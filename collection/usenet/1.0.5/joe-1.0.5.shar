#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 11/21/1992 14:33 UTC by jhallen@world
# Source directory /tmp/j/joe
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   5471 -rw------- INFO
#   5257 -rw------- README
#  24715 -rw------- b.c
#  10590 -rw------- b.h
#  12881 -rw------- blocks.c
#   2144 -rw------- blocks.h
#  13764 -rw------- bw.c
#   1252 -rw------- bw.h
#   1152 -rw------- config.h
#   1273 -rw------- config16.h
#   1152 -rw------- config32.h
#   1391 -rw------- config86.h
#  12488 -rw------- copying
#  32824 -rw------- edfuncs.c
#   1933 -rw------- edfuncs.h
#   8056 -rw------- heap.c
#   3883 -rw------- heap.h
#   4291 -rw------- help.c
#   1306 -rw------- help.h
#  19130 -rw------- joerc
#  11368 -rw------- kbd.c
#   2999 -rw------- kbd.h
#   2755 -rw------- macro.c
#   1344 -rw------- macro.h
#  10617 -rw------- main.c
#   1140 -rw------- main.h
#   1179 -rw------- makefile
#   2874 -rw------- menu.c
#   1318 -rw------- menu.h
#   1505 -rw------- msdir.c
#   1513 -rw------- olddir.c
#   2984 -rw------- pathfunc.c
#   2548 -rw------- pathfunc.h
#   7010 -rw------- pattern.c
#    841 -rw------- pattern.h
#   2503 -rw------- poshist.c
#    908 -rw------- poshist.h
#   4996 -rw------- pw.c
#   1442 -rw------- pw.h
#    846 -rw------- queue.c
#   3442 -rw------- queue.h
#  12354 -rw------- random.c
#    134 -rw------- random.h
#   1259 -rw------- reg.c
#   8187 -rw------- regex.c
#    879 -rw------- regex.h
#  26464 -rw------- scrn.c
#   7538 -rw------- scrn.h
#   6687 -rw------- tab.c
#   1173 -rw------- tab.h
#   4577 -rw------- termcap
#  10843 -rw------- termcap.c
#   6116 -rw------- termcap.h
#   1592 -rw------- termidx.c
#   2705 -rw------- terminfo.c
#   1341 -rw------- todojoe
#   2733 -rw------- toomany.c
#   1322 -rw------- toomany.h
#   5951 -rw------- tty.h
#   5407 -rw------- ttybsd.c
#   4717 -rw------- ttyhpux.c
#   1705 -rw------- ttymsdos.c
#   5008 -rw------- ttyposix.c
#   4269 -rw------- ttysv.c
#   4223 -rw------- ttyxenix.c
#   6362 -rw------- tw.c
#   1265 -rw------- tw.h
#   5709 -rw------- undo.c
#   1901 -rw------- undo.h
#   6830 -rw------- va.c
#  11674 -rw------- va.h
#  11446 -rw------- vfile.c
#   9358 -rw------- vfile.h
#  10956 -rw------- vs.c
#  13819 -rw------- vs.h
#  13930 -rw------- w.c
#   5765 -rw------- w.h
#   1902 -rw------- zstr.c
#   1044 -rw------- zstr.h
#  19130 -rw------- .joerc
#
# ============= INFO ==============
if test -f 'INFO' -a X"$1" != X"-c"; then
	echo 'x - skipping INFO (File already exists)'
else
echo 'x - extracting INFO (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'INFO' &&
X                           Joe's Own Editor 1.0.5
X
X
Get it by anonymous ftp
from: 'world.std.com', file '/src/editors/joe1.0.5.tar.Z'
X
If you have questions, problems or suggestions,
send email to: 'jhallen@world.std.com'
X
X
X	JOE is a sane ASCII text screen editor for UNIX.  It is designed to 
make use of the power and versitility of UNIX, but also to be easy to use.  
It has the feel of most IBM PC editors.  The key sequences are remeniscent 
of WordStar and TURBO-PASCAL.  It also has the features UNIX user's should 
expect: makes full use of termcap/terminfo, is designed to work well over 
slow networks and low baud rate modems, designed to reduce installation 
headaches, and has the best features of vi.
X
X	JOE is most useful for editing unformatted text, such as USENET news 
articles and for editing block-structured languages such as C and PASCAL.  
JOE is ideal for new or casual users but is also is also a powerful enough 
to please experienced users.
X
Features:
X
X	Full termcap/terminfo support.  Will work on any terminal except for
overstrike terminals.  A new termcap library is supplied which can use an 
index file to make it faster then terminfo.  A number of terminfo extensions 
are supported and the GNU extensions to the termcap language are also 
supported.  JOE is not picky about the completeness of the termcap entries, 
it knows what the defaults are.
X
X	Non-nonsense installation.  JOE has both ^H and DEL mapped to 
backspace and ^Q and ^S are not used.  JOE compiles to 120-190K on most 
systems.
X
X	Powerful optimal screen update.  Uses scrolling regions the way they 
are supposed to be used (I.E., without building insert and delete line with 
them) and uses a powerful line shifting (insert/delete character) algorithm 
which works if text goes past the ends of lines.  Has defered screen update 
to handle typeahead.
X
X	VI-style unix integration.  You can filter a highlighted block 
through a UNIX command.  Also, each place in joe which accepts a file name 
(including the command line) will also accept: 
X
X		!command		to pipe into or out of a command
X		>>filename		to append to a file
X		filename,start,size	to edit a portion of a file/device
X		-			to use stdin or stdout
X
X	Also, filenames on the command line may be preceeded by +nnn to 
start editing at a specified line.
X
X	Orthoganality.  Each prompt is actually a normal edit buffer and a 
copy of a history buffer.  You can use all of the normal edit commands to 
create file names and search strings.  You can use the up arrow key (or 
search backwards and any other appropriate edit command) to go back through 
the history of previous responses.  
X
X	Powerful buffering system.  JOE uses a doubly linked list of gap 
buffers which can spill into /tmp directory files.  You can edit file of any 
size up to the amount of free disk space and there are no line-length 
restrictions.  Since the buffering system is block-based, JOE will incur 
only a minimum of swapping on heavily loaded systems.
X
X	TAB-completion and file selection menus.  If you hit tab in a file 
name prompt, the name is either completed or a menu of possible matches 
appears.
X
X	Nice help system.  When you ask for help, you get a menu of help 
screens to shoose from (all definable in an initialization file).   Once a 
help screen is selected, the help remains on while you continue to use the 
editor.  Here is the first help screen:
X
CURSOR           GO TO            BLOCK      DELETE   MISC         EXIT
^B left ^F right ^U  prev. screen ^KB begin  ^D char. ^KJ reformat ^KX save
^P up   ^N down  ^V  next screen  ^KK end    ^Y line  ^TT overtype ^C  abort
^Z previous word ^A  beg. of line ^KM move   ^W >word `   Ctrl-    ^KZ shell
^X next word     ^E  end of line  ^KC copy   ^O word< ^   Meta-    FILE
SEARCH           ^KU top of file  ^KW file   ^J >line ^R  retype   ^KE new
^KF find text    ^KV end of file  ^KY delete ^_ undo  ^@  insert   ^KR insert
^L  find next    ^KL to line No.  ^K/ filter ^^ redo               ^KD save
X
X	Powerful set of editing commands.  Including:
X
X		- search and replace system, including powerful regular 
X		  expressions (including matching of balanced C expressions).
X
X		- tag search
X
X		- paragraph format
X
X		- undo and redo
X
X		- position history allows you to get back to previous
X		  editing contexts and allows you to quickly flip between
X		  editing contexts
X
X		- multiple keyboard macros
X
X		- multiple windows
X
X		- block move/copy/delete/filter
X
X		- rectangle mode
X
X		- overtype/insert modes
X
X		- indent/unindent
X
X		- goto matching ( [ {
X
X		- auto-indent mode
X
X	Plus many options can be set:
X
X		- row and column number can be shown on status line
X
X		- can have EMACS-style cursor recentering on scrolls
X
X		- characters between 160-254 can be shown as-is for
X		  scandinavian characters
X
X		- Final newline can be forced on end of file
X
X		- Can start with a help screen on
X
X		- No. of PgUp/PgDn lines to keep can be specified
X
X		- Left/Right margin settings
X
X		- Tab width
X
X		- Indentation step and character
X
X	JOE will soon have:
X
X		Hex dump edit mode
X
X		Fixed record length edit mode
X
X		Shell windows and background/demand file-loading
X
/*  jhallen@world.std.com */     /* Amazing */            /* Joseph H. Allen */
int a[1817];main(z,p,q,r){for(p=80;q+p-80;p-=2*a[p])for(z=9;z--;)q=3&(r=time(0)
+r*57)/7,q=q?q-1?q-2?1-p%79?-1:0:p%79-77?1:0:p<1659?79:0:p>158?-79:0,q?!a[p+q*2
]?a[p+=a[p+=q]=q]=q:0:0;for(;q++-1817;)printf(q%79?"%c":"%c\n"," #"[!a[q-1]]);}
SHAR_EOF
chmod 0600 INFO ||
echo 'restore of INFO failed'
Wc_c="`wc -c < 'INFO'`"
test 5471 -eq "$Wc_c" ||
	echo 'INFO: original size 5471, current size' "$Wc_c"
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
else
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
This is Joe's Own Editor.  See the INFO file if you don't know what this is.
X
Installation proceedure
=-=-=-=-=-=-=-=-=-=-=-=
X
X	Decide on the name of the global keymap file if you don't want it
X	to be '/usr/local/lib/joerc' and modify the 'JOERC=' in the
X	'makefile'.  If you're a mere user, copy the joerc file into
X	$HOME/.joerc
X
X	Type 'make' followed by one of the following system names:
X
X		xenix		for xenix 386 systems
X
X		posix		for posix conformant systems (use this for
X				linux)
X
X		bsd		for BSD UNIX
X
X		sv		for old system V UNIX
X
X		hpux		for HPUX systems
X
X	Then type 'make install' to install joe in
X	/usr/local/bin and /usr/local/lib
X
X	Type 'make clean' eliminate the .o files
X
X	Copy termcap to .termcap in your home directory if you want to
X	use it instead of /etc/termcap (see below).
X
X	Set the baud rate properly (see below).
X
** SCO UNIX users **
X
Use the 'make sv', but first edit 'ttysv.c' and add these lines:
X	#include <sys/types.h>
X	#include <sys/stream.h>
X	#include <sys/ptem.h>
X	#undef SIGCONT
X
You may also wish to use the terminfo database.  See below.
X
USEAGE:	joe filenames
X
X	Optionally preceed each filename with +nnn to start at specified 
line number.  
X
** IMPORTANT **
X
The baud rate must be correctly set or either typeahead will not interrupt 
the screen update and scrolling wont be used or there will be annoying 
delays in the screen update.  If you can't set the baud rate correctly with 
'stty', give a numeric value in the environment variable 'BAUD'.  
X
The baud rate '38400' or 'extb' means infinite to joe.  Use it for X windows
and hardware console ttys.  No delays will be generated and scrolling will
not be used.
X
Use the LINES and COLUMNS environment variables if you need the terminal
size to be different than whatever the termcap entry or stty says.
X
Since most people use terminal emulators, JOE does not send out pad 
characters.  If you're using a real terminal and the padding matters, set 
the environment variable DOPADDING.
X
A termcap file is included with JOE.  You might consider updating your own 
termcap file with the entries in it, particularly if you use ANSI/VT100ish 
terminals.  JOE understands some capabilities which are not usually supplied 
in normal termcap (see below).
X
X                                 VARIATIONS
X                                 =-=-=-=-=-
X
Termcap/Terminfo
=-=-=-=-=-=-=-=-
X
X	JOE prefers to use the termcap terminal capability database.  You
have if the file '/etc/termcap' exists.  If it doesn't you can use the
'termcap' file supplied with joe by copying it to /etc.
X
X	Termcap is better than terminfo because it is a more open standard. 
Programs can directly access the termcap database and future versions of
terminfo may require programs to use curses.  The only argument in
terminfo's favour is that it is faster than termcap.  To fix this problem,
JOE will use a termcap index file if it exists and if it is up to date.
X
X	This is the proceedure to make the termcap index file:
X
X		make termidx
X		./termidx </etc/termcap >/etc/termcap.idx
X
X	The /etc/termcap.idx is a text file which you can look at if you're
curious.
X
X	JOE supports the GNU extensions to the termcap language and also
understands several new capabilities:
X
X		AL DL IC DC RI LE UP DO SF SR
X
X			Versions of the standard capabilities which accept
X			an argument.  For example, RI with and argument of
X			7 should move the cursor 7 positions to the right.
X
X		rr
X
X			Set this flag if the cursor is restricted to move
X			only within the scrolling regions.  This is an optional
X			mode on vt220s and several clones assume that this
X			mode is always on.
X
X		cb
X
X			Like the 'cv' capability, but the cursor goes to the
X			beginning of the specified line.  Like 'ESC [ n H' in
X			ansi/vt100.
X
X	But if you really must use the terminfo database, change the
'termcap.o' file in the OBJS list in the makefile to 'terminfo.o'.  You'll 
also have to add '-ltinfo', '-lterminfo' or '-lcurses' to the appropriate link
line (lines beginning with $(CC)) in the make file.
X
VOID trouble
=-=-=-=-=-=-
X
X	If you're using an old C compiler which doesn't like the 'void'
type, uncomment the '#define void int' line from the config.h file.
X
No diropen library
=-=-=-=-=-=-=-=-=-
X
X	Add 'olddir.o' to the object file list in the makefile.
X
16-bit systems / MS-DOS systems
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
X
X	The 16-bit segmented system support is not quite finished yet.  If
you really want to try, copy 'config86.h' to config.h and try compiling with
ttymsdos.h or ttyxenix.h for Xenix 86/286 systems.  Use large model.
X
X	I still have to make the UNDO system use edit buffers (which use a
linked list of small blocks) instead of large malloc blocks to store the
records.  
X
X	Also for MS-DOS you have to go through ansi/nansi/zansi.sys.  There
also needs to be an \etc\termcap file and a \tmp directory.  Soon I'll make
a direct screen access version.  Also there's a 'msdir.c' module for making
the turbo-C directory access functions look like unix opendir functions. 
You'll probably have to make even more changes (like no password file
support) to get it to work.
X
X	If someone sends me information about tty drivers on QNX or
coherent, I'll be happy to try to make JOE work for them (also, do they
support large model?)
SHAR_EOF
chmod 0600 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 5257 -eq "$Wc_c" ||
	echo 'README: original size 5257, current size' "$Wc_c"
fi
# ============= b.c ==============
if test -f 'b.c' -a X"$1" != X"-c"; then
	echo 'x - skipping b.c (File already exists)'
else
echo 'x - extracting b.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'b.c' &&
/* Buffer management
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <pwd.h>
#include <errno.h>
#include "config.h"
#include "heap.h"
#include "blocks.h"
#include "w.h"
#include "tty.h"
#include "scrn.h"
#include "undo.h"
#include "vs.h"
#include "zstr.h"
#include "main.h"
#include "bw.h"
#include "b.h"
X
extern int errno;
int force=0;
X
char buffer[1024];
X
/********************/
/* Buffer GAP stuff */
/********************/
X
/* Get size of gap (amount of free space) */
X
#define GGAPSZ(hdr) ((hdr)->ehole-(hdr)->hole)
X
/* Get number of characters in gap buffer */
X
#define GSIZE(hdr) (SEGSIZ-GGAPSZ(hdr))
X
/* Set position of gap */
X
static void gstgap(hdr,ptr,ofst)
H *hdr;
char *ptr;
int ofst;
{
if(ofst>hdr->hole)
X mfwrd(ptr+hdr->hole,ptr+hdr->ehole,ofst-hdr->hole), vchanged(ptr);
else if(ofst<hdr->hole)
X mbkwd(ptr+hdr->ehole-(hdr->hole-ofst),ptr+ofst,hdr->hole-ofst), vchanged(ptr);
hdr->ehole=ofst+hdr->ehole-hdr->hole;
hdr->hole=ofst;
}
X
/* Insert a block */
X
static void ginsm(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
{
if(ofst!=hdr->hole) gstgap(hdr,ptr,ofst);
mcpy(ptr+hdr->hole,blk,size);
hdr->hole+=size;
vchanged(ptr);
}
X
/* Delete characters */
X
static void gdel(hdr,ptr,ofst,size)
H *hdr;
char *ptr;
int ofst;
int size;
{
if(ofst!=hdr->hole) gstgap(hdr,ptr,ofst);
hdr->ehole+=size;
}
X
/* Read block */
X
static void grmem(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
{
if(ofst<hdr->hole)
X if(size>hdr->hole-ofst)
X  mcpy(blk,ptr+ofst,hdr->hole-ofst),
X  mcpy(blk+hdr->hole-ofst,ptr+hdr->ehole,size-(hdr->hole-ofst));
X else mcpy(blk,ptr+ofst,size);
else mcpy(blk,ptr+ofst+hdr->ehole-hdr->hole,size);
}
X
/**************************************/
/* Header and text segment allocation */
/**************************************/
X
static long salloc(b)
B *b;
{
if(b->fretxt)
X {
X long addr=b->fretxt;
X long *adr=(long *)vlock(b->text,addr);
X b->fretxt= *adr;
X vunlock(adr);
X return addr;
X }
else return valloc(b->text,(long)SEGSIZ);
}
X
static H frhdrs={{&frhdrs,&frhdrs}};
X
static H *halloc()
{
if(qempty(H,link,&frhdrs))
X {
X H *h;
X int x;
X h=(H *)malloc(sizeof(H)*64);
X for(x=0;x!=64;++x) enquef(H,link,&frhdrs,h+x);
X }
return deque(H,link,frhdrs.link.next);
}
X
static void sfree(b,addr)
B *b;
long addr;
{
long *adr=(long *)vlock(b->text,addr);
*adr=b->fretxt;
vchanged(adr); vunlock(adr);
b->fretxt=addr;
}
X
/**********************/
/* Pointer allocation */
/**********************/
X
static P frptrs={{&frptrs,&frptrs}};
X
static P *palloc()
{
if(qempty(P,link,&frptrs))
X {
X P *h;
X int x;
X h=(P *)malloc(sizeof(P)*64);
X for(x=0;x!=64;++x) enquef(P,link,&frptrs,h+x);
X }
return deque(P,link,frptrs.link.next);
}
X
static void pfree(p)
P *p;
{
enquef(P,link,&frptrs,p);
}
X
/****************************/
/* Buffer creation/deletion */
/****************************/
X
/* Doubly linked list of buffers */
X
static B bufs={{&bufs,&bufs}};
int tabwidth=8;
X
B *bmk()
{
B *new=(B *)malloc(sizeof(B));
new->tab=tabwidth;
new->backup=1;
new->chnged=0;
new->count=1;
new->name=0;
new->fretxt=0;
new->bof=palloc();
izque(P,link,new->bof);
new->text=vtmp();
new->bof->b=new;
new->bof->owner=0;
new->bof->ofst=0;
new->bof->byte=0;
new->bof->line=0;
new->bof->col=0;
new->bof->xcol=0;
new->bof->lbyte=0;
new->bof->hdr=halloc();
new->bof->hdr->hole=0;
new->bof->hdr->ehole=SEGSIZ;
izque(H,link,new->bof->hdr);
new->bof->hdr->seg=salloc(new);
new->bof->ptr=vlock(new->text,new->bof->hdr->seg);
new->eof=pdup(new->bof);
undomk(new);
enquef(B,link,&bufs,new);
return new;
}
X
/* Find loaded file */
X
B *bfind(name)
char *name;
{
B *b;
for(b=bufs.link.next;b!=&bufs;b=b->link.next)
X if(b->name && !zcmp(name,b->name))
X  {
X  ++b->count;
X  return b;
X  }
return 0;
}
X
void brm(b)
B *b;
{
if(!--b->count)
X {
X undorm(b);
X splicef(H,link,&frhdrs,b->bof->hdr);
X while(!qempty(P,link,b->bof)) prm(b->bof->link.next);
X prm(b->bof);
X if(b->name) free(b->name);
X vclose(b->text);
X free(deque(B,link,b));
X }
}
X
/**********************/
/* Pointer management */
/**********************/
X
P *pset(n,p)
P *n, *p;
{
n->b=p->b;
n->ofst=p->ofst;
n->hdr=p->hdr;
if(n->ptr) vunlock(n->ptr); n->ptr=p->ptr; vupcount(n->ptr);
n->byte=p->byte;
n->line=p->line;
n->col=p->col;
n->xcol=p->xcol;
n->lbyte=p->lbyte;
return n;
}
X
P *pdup(p)
P *p;
{
P *n=palloc();
n->ptr=0;
n->owner=0;
enquef(P,link,p,n);
return pset(n,p);
}
X
P *pdupown(p,o)
P *p;
P **o;
{
P *n=palloc();
n->ptr=0;
n->owner=o;
enquef(P,link,p,n);
pset(n,p);
if(*o) prm(*o);
*o=n;
return n;
}
X
P *pbof(p)
P *p;
{
return pset(p,p->b->bof);
}
X
P *peof(p)
P *p;
{
return pset(p,p->b->eof);
}
X
void prm(p)
P *p;
{
if(!p) return;
if(p->owner) *p->owner=0;
vunlock(p->ptr);
pfree(deque(P,link,p));
}
X
int pisbof(p)
P *p;
{
return p->hdr==p->b->bof->hdr && !p->ofst;
}
X
int piseof(p)
P *p;
{
return p->hdr==p->b->bof->hdr->link.prev;
}
X
int piseol(p)
P *p;
{
if(p->hdr==p->b->bof->hdr->link.prev) return 1;
if(p->ofst>=p->hdr->hole)
X { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') return 1; }
else if(p->ptr[p->ofst]=='\n') return 1;
return 0;
}
X
int pisbol(p)
P *p;
{
char c;
if(p->hdr==p->b->bof->hdr && !p->ofst) return 1;
c=prgetcn(p); pfwrdn(p,(long)1);
return c=='\n';
}
X
int pisbow(p)
P *p;
{
P *q=pdup(p);
int c=brc(p);
int d=prgetcn(q);
prm(q);
if((c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9') &&
X !(d>='a' && d<='z' || d>='A' && d<='Z' || d>='0' && d<='9')) return 1;
return 0;
}
X
int piseow(p)
P *p;
{
P *q=pdup(p);
int d=brc(q);
int c=prgetcn(q);
prm(q);
if((c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9') &&
X !(d>='a' && d<='z' || d>='A' && d<='Z' || d>='0' && d<='9')) return 1;
return 0;
}
X
int pnext(p)
P *p;
{
if(p->hdr==p->b->bof->hdr->link.prev) return 0;
p->hdr=p->hdr->link.next; p->ofst=0;
vunlock(p->ptr); p->ptr=vlock(p->b->text,p->hdr->seg);
return GSIZE(p->hdr)!=0;
}
X
int pprev(p)
P *p;
{
if(p->hdr==p->b->bof->hdr) return 0;
p->hdr=p->hdr->link.prev;
p->ofst=GSIZE(p->hdr);
vunlock(p->ptr); p->ptr=vlock(p->b->text,p->hdr->seg);
return p->ofst;
}
X
int pgetcn(p)
P *p;
{
unsigned char c;
if(p->ofst==GSIZE(p->hdr)) return MAXINT;
if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
else c=p->ptr[p->ofst];
if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
return c;
}
X
int pgetc(p)
P *p;
{
unsigned char c;
if(p->ofst==GSIZE(p->hdr)) return MAXINT;
if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
else c=p->ptr[p->ofst];
if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
++p->byte;
if(c=='\n') ++p->line, p->col=0, p->lbyte=0;
else
X {
X ++p->lbyte;
X if(c=='\t') p->col+=p->b->tab-p->col%p->b->tab;
X else ++p->col;
X }
return c;
}
X
P *pfwrdn(p,n)
P *p;
long n;
{
while(n>=GSIZE(p->hdr)-p->ofst)
X {
X int adj=GSIZE(p->hdr)-p->ofst;
X if(!adj) break;
X n-=adj;
X pnext(p);
X }
if(n>GSIZE(p->hdr)-p->ofst) return 0;
p->ofst+=n;
return p;
}
X
P *pfwrd(p,n)
P *p;
long n;
{
int c;
while(n--) if(pgetc(p)== MAXINT) return 0;
return p;
}
X
int prgetcn(p)
P *p;
{
unsigned char c;
if(!p->ofst) if(!pprev(p)) return MAXINT;
--p->ofst;
if(p->ofst>=p->hdr->hole)
X c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
else c=p->ptr[p->ofst];
return c;
}
X
int prgetc(p)
P *p;
{
unsigned char c;
if(!p->ofst) if(!pprev(p)) return MAXINT;
--p->ofst;
if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
else c=p->ptr[p->ofst];
--p->byte;
if(c=='\n')
X {
X --p->line;
X pfcol(p);
X }
else if(c=='\t') pfcol(p);
else
X {
X --p->lbyte;
X --p->col;
X }
return c;
}
X
P *pbkwdn(p,n)
P *p;
long n;
{
while(n>p->ofst)
X {
X n-=p->ofst;
X if(!pprev(p)) break;
X }
if(n>p->ofst) return 0;
p->ofst-=n;
return p;
}
X
P *pbkwdf(p,n)
P *p;
long n;
{
while(n--)
X {
X if(!p->ofst) if(!pprev(p)) return 0;
X --p->ofst;
X --p->byte;
X if(p->ofst>=p->hdr->hole)
X  {
X  if('\n'==p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole])
X  --p->line;
X  }
X else if('\n'==p->ptr[p->ofst]) --p->line;
X }
return p;
}
X
P *pfcol(p)
P *p;
{
H *hdr=p->hdr;
int ofst=p->ofst;
pboln(p);
while(p->ofst!=ofst || p->hdr!=hdr) pgetc(p);
return p;
}
X
P *pbkwd(p,n)
P *p;
long n;
{
P *y=pbkwdf(p,n);
pfcol(p);
return y;
}
X
P *pbol(p)
P *p;
{
if(p->lbyte) pbkwdn(p,p->lbyte);
p->byte-=p->lbyte; p->lbyte=0; p->col=0;
return p;
}
X
P *pboln(p)
P *p;
{
if(pprevl(p)) pgetc(p);
p->col=0; p->lbyte=0;
return p;
}
X
P *peol(p)
P *p;
{
while(p->hdr!=p->b->bof->hdr->link.prev)
X {
X unsigned char c;
X if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
X else c=p->ptr[p->ofst];
X if(c=='\n') break;
X else
X  {
X  ++p->byte;
X  ++p->ofst;
X  ++p->lbyte;
X  if(c=='\t') p->col+=p->b->tab-p->col%p->b->tab;
X  else ++p->col;
X  if(p->ofst==GSIZE(p->hdr)) pnext(p); 
X  }
X }
return p;
}
X
P *pnextl(p)
P *p;
{
char c;
do
X {
X if(p->ofst==GSIZE(p->hdr)) if(!pnext(p)) return 0;
X if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
X else c=p->ptr[p->ofst];
X ++p->byte; ++p->ofst;
X }
X while(c!='\n');
++p->line;
p->col=0; p->lbyte=0;
if(p->ofst==GSIZE(p->hdr)) pnext(p);
return p;
}
X
P *pprevl(p)
P *p;
{
char c;
do
X {
X if(!p->ofst) if(!pprev(p)) return 0;
X --p->ofst; --p->byte;
X if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
X else c=p->ptr[p->ofst];
X }
X while(c!='\n');
--p->line;
return p;
}
X
P *pline(p,line)
P *p;
long line;
{
if(line>p->b->eof->line) { pset(p,p->b->eof); return p; }
if(line<Iabs(p->line-line)) pset(p,p->b->bof);
if(Iabs(p->b->eof->line-line)<Iabs(p->line-line)) pset(p,p->b->eof);
if(p->line==line) { pbol(p); return p; }
while(line>p->line) pnextl(p);
if(line<p->line)
X {
X while(line<p->line) pprevl(p);
X pboln(p);
X }
p->lbyte=0; p->col=0;
return p;
}
X
P *pcol(p,goalcol)
P *p;
long goalcol;
{
if(p->lbyte) pbol(p);
do
X {
X unsigned char c;
X int wid;
X if(p->ofst==GSIZE(p->hdr)) break;
X if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
X else c=p->ptr[p->ofst];
X if(c=='\n') break;
X if(c=='\t') wid=p->b->tab-p->col%p->b->tab;
X else wid=1;
X if(p->col+wid>goalcol) break;
X if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
X ++p->byte; ++p->lbyte; p->col+=wid;
X } while(p->col!=goalcol);
return p;
}
X
P *pfindrn(p,s,len)
P *p;
char *s;
{
P *q=pdup(p);
char *os;
int olen;
if(!len) return p;
q=pdup(p);
do
X {
X pset(q,p);
X os=s; olen=len;
X while(olen--) if(*os++!=pgetc(q)) break;
X if(olen== -1)
X  {
X  prm(q);
X  return p;
X  }
X } while(pbkwdf(p,1L));
prm(q);
return 0;
}
X
P *pfindrni(p,s,len)
P *p;
char *s;
{
P *q=pdup(p);
char *os;
int olen;
if(!len) return p;
q=pdup(p);
do
X {
X pset(q,p);
X os=s; olen=len;
X while(olen--) if(toup(*os++)!=toup(pgetc(q))) break;
X if(olen== -1)
X  {
X  prm(q);
X  return p;
X  }
X } while(pbkwdf(p,1L));
prm(q);
return 0;
}
X
P *pfindfn(p,s,len)
P *p;
char *s;
{
P *q=pdup(p);
char *os;
int olen;
int c;
if(!len) return p;
q=pdup(p);
while( (c=pgetc(p)) != MAXINT )
X if(c==s[0])
X  {
X  pset(q,p);
X  os=s+1; olen=len-1;
X  while(olen--) if(*os++!=pgetc(q)) break;
X  if(olen== -1)
X   {
X   prm(q);
X   prgetc(p);
X   return p;
X   }
X  }
prm(q);
return 0;
}
X
P *pfindfni(p,s,len)
P *p;
char *s;
{
P *q=pdup(p);
char *os;
int olen;
int c;
if(!len) return p;
q=pdup(p);
while( (c=pgetc(p)) != MAXINT )
X if(toup(c)==toup(s[0]))
X  {
X  pset(q,p);
X  os=s+1; olen=len-1;
X  while(olen--) if(toup(*os++)!=toup(pgetc(q))) break;
X  if(olen== -1)
X   {
X   prm(q);
X   prgetc(p);
X   return p;
X   }
X  }
prm(q);
return 0;
}
X
/******************************/
/* Getting data from a buffer */
/******************************/
X
int brc(p)
P *p;
{
if(p->hdr==p->b->bof->hdr->link.prev) return MAXINT;
if(p->ofst>=p->hdr->hole) return p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
else return p->ptr[p->ofst];
}
X
char *brmem(p,blk,size)
P *p;
char *blk;
int size;
{
char *bk=blk;
P *np;
int amnt;
np=pdup(p);
while(size>(amnt=GSIZE(np->hdr)-np->ofst))
X {
X grmem(np->hdr,np->ptr,np->ofst,bk,amnt);
X bk+=amnt;
X size-=amnt;
X if(!pnext(np)) break;
X }
if(size<(amnt=GSIZE(np->hdr)-np->ofst)) amnt=size;
if(amnt) grmem(np->hdr,np->ptr,np->ofst,bk,amnt);
prm(np);
return blk;
}
X
char *brs(p,size)
P *p;
int size;
{
char *s=(char *)malloc(size+1);
s[size]=0;
return brmem(p,s,size);
}
X
char *brvs(p,size)
P *p;
int size;
{
char *s=vstrunc(NULL,size);
return brmem(p,s,size);
}
X
int bsavefd(p,fd,size)
P *p;
long size;
{
P *np=pdup(p);
int amnt;
while(size>(amnt=GSIZE(np->hdr)-np->ofst))
X {
X if(np->ofst<np->hdr->hole)
X  {
X  if(write(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0) return -5;
X  if(write(fd,np->ptr+np->hdr->ehole,SEGSIZ-np->hdr->ehole)<0) return -5;
X  }
X else if(write(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),amnt)<0) return -5;
X size-=amnt;
X if(!pnext(np)) break;
X }
if(size<(amnt=GSIZE(np->hdr)-np->ofst)) amnt=size;
if(amnt)
X if(np->ofst<np->hdr->hole)
X  if(amnt>np->hdr->hole-np->ofst)
X   {
X   if(write(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0) return -5;
X   if(write(fd,np->ptr+np->hdr->ehole,amnt-np->hdr->hole+np->ofst)<0) return -5;
X   }
X  else
X   {
X   if(write(fd,np->ptr+np->ofst,amnt)<0) return -5;
X   }
X else if(write(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),amnt)<0) return -5;
prm(np);
return 0; /* Check status returned by fwrite */
}
X
char *parsens(s,skip,amnt)
char *s;
long *skip, *amnt;
{
char *n=vsncpy(NULL,0,sz(s));
int x,y;
*skip=0;
*amnt= MAXLONG;
for(x=sLEN(n)-1;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
if(n[x]==',')
X {
X int c;
X n[x]=0;
X if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
X else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
X else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
X else sscanf(n+x+1,"%d",skip);
X for(--x;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
X if(n[x]==',')
X  {
X  n[x]=0;
X  *amnt= *skip;
X  if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
X  else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
X  else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
X  else sscanf(n+x+1,"%d",skip);
X  }
X }
if(n[0]=='~')
X {
X for(x=1;n[x] && n[x]!='/';++x);
X if(n[x]=='/')
X  if(x==1)
X   {
X   char *z;
X   s=getenv("HOME");
X   z=vsncpy(NULL,0,sz(s));
X   z=vsncpy(z,sLEN(z),sz(n+x));
X   vsrm(n);
X   n=z;
X   }
X  else
X   {
X   struct passwd *passwd;
X   n[x]=0;
X   passwd=getpwnam(n+1);
X   n[x]='/';
X   if(passwd)
X    {
X    char *z=vsncpy(NULL,0,sz(passwd->pw_dir));
X    z=vsncpy(z,sLEN(z),sz(n+x));
X    vsrm(n);
X    n=z;
X    }
X   }
X }
return n;
}
X
int bsave(p,s,size)
P *p;
char *s;
long size;
{
FILE *f;
int flg;
long skip,amnt;
s=parsens(s,&skip,&amnt);
if(amnt<size) size=amnt;
if(s[0]=='!')
X {
X nescape(maint->t);
X ttclsn();
X f=popen(s+1,"w");
X }
else if(s[0]=='>' && s[1]=='>') f=fopen(s+2,"a");
else if(!zcmp(s,"-"))
X {
X nescape(maint->t);
X ttclsn();
X f=stdout;
X }
else
X if(skip || amnt!=MAXLONG) f=fopen(s,"r+");
X else f=fopen(s,"w");
if(!f)
X {
X if(s[0]=='!') ttopnn(), nreturn(maint->t);
X return -4;
X }
fflush(f);
X
if(skip && lseek(fileno(f),skip,0)<0) { flg= -3; goto err; }
X
flg=bsavefd(p,fileno(f),size);
if(force && size && !skip && amnt==MAXINT)
X {
X P *q=pdup(p);
X char nl='\n';
X pfwrdn(p,size-1);
X if(brc(p)!='\n')
X  if(write(fileno(f),&nl,1)<0) flg= -5;
X }
err:;
if(s[0]=='!') pclose(f);
else if(zcmp(s,"-")) fclose(f);
else fflush(f);
if(s[0]=='!' || !zcmp(s,"-")) ttopnn(), nreturn(maint->t);
return flg;
}
X
/*******************************/
/* Deleting data from a buffer */
/*******************************/
X
static void fixup(p,amnt,nlines,hdr,hdramnt)
P *p;
long amnt;
long nlines;
H *hdr;
int hdramnt;
{
P *pp;
int flg;
if(!p->lbyte) flg=0;
else flg=1;
scrdel(p->b,p->line,nlines,flg);
for(pp=p->link.next;pp!=p;pp=pp->link.next)
X if(pp->byte>=p->byte)
X  if(pp->byte<=p->byte+amnt) pset(pp,p);
X  else
X   {
X   if(pp->hdr==hdr) pp->ofst-=hdramnt;
X   if(pp->line==p->line+nlines) pp->col=~(long)0;
X   pp->byte-=amnt;
X   pp->line-=nlines;
X   }
for(pp=p->link.next;pp!=p;pp=pp->link.next)
X if(pp->col==~(long)0) pfcol(pp);
p->b->chnged=1;
}
X
static void frchn(b,h)
B *b;
H *h;
{
H *a;
a=h; do
X sfree(b,a->seg),
X a=a->link.next;
X while(a!=h);
splicef(H,link,&frhdrs,h);
}
X
P *bdel(from,to)
P *from, *to;
{
long nlines=to->line-from->line;/* No. EOLs to delete */
long amnt=to->byte-from->byte;	/* No. bytes to delete */
int toamnt;			/* Amount delete from segment in 'to' */
if(from->byte==to->byte) return from;
undodel(from,amnt);
if(from->hdr==to->hdr)
X {
X gdel(from->hdr,from->ptr,from->ofst,(int)amnt);
X toamnt=amnt;
X }
else
X {
X H *a;
X toamnt=to->ofst;
X /* Delete beginning of to */
X gstgap(to->hdr,to->ptr,to->ofst);
X to->hdr->hole=0;
X
X /* Delete end of from */
X if(from->ofst)
X  {
X  a=from->hdr;
X  gstgap(from->hdr,from->ptr,from->ofst);
X  from->hdr->ehole=SEGSIZ;
X  }
X else a=from->hdr->link.prev;
X
X /* From now points to header/segment of to */
X from->hdr=to->hdr;
X vunlock(from->ptr); from->ptr=to->ptr; vupcount(to->ptr);
X from->ofst=0;
X
X /* Delete headers/segments between a and to->hdr */
X if(a->link.next!=to->hdr)
X  frchn(to->b,snip(H,link,a->link.next,to->hdr->link.prev));
X }
X
fixup(from,amnt,nlines,to->hdr,toamnt);
return from;
}
X
/********************************/
/* Inserting data into a buffer */
/********************************/
X
/* Split a block at p's ofst */
/* p is placed in the new block such that it points to the same text but with
X * p->ofst==0
X */
X
static void bsplit(p)
P *p;
{
if(p->ofst)
X {
X H *hdr;
X char *ptr;
X P *pp;
X
X hdr=halloc();
X hdr->seg=salloc(p->b);
X ptr=vlock(p->b->text,hdr->seg);
X
X gstgap(p->hdr,p->ptr,p->ofst);
X mcpy(ptr,p->ptr+p->hdr->ehole,SEGSIZ-p->hdr->ehole);
X vchanged(ptr);
X hdr->hole=SEGSIZ-p->hdr->ehole;
X hdr->ehole=SEGSIZ;
X p->hdr->ehole=SEGSIZ;
X
X enquef(H,link,p->hdr,hdr);
X 
X vunlock(p->ptr);
X
X for(pp=p->link.next;pp!=p;pp=pp->link.next)
X  if(pp->hdr==p->hdr && pp->ofst>=p->ofst)
X   {
X   pp->hdr=hdr;
X   vunlock(pp->ptr); pp->ptr=ptr; vupcount(ptr);
X   pp->ofst-=p->ofst;
X   }
X
X p->ptr=ptr;
X p->hdr=hdr;
X p->ofst=0;
X }
}
X
static void inschn(p,a)
P *p;
H *a;
{
bsplit(p);
p->hdr=spliceb(H,link,p->hdr,a);
vunlock(p->ptr); p->ptr=vlock(p->b->text,a->seg);
}
X
static H *bldchn(b,blk,size)
B *b;
char *blk;
int size;
{
H anchor, *l;
izque(H,link,&anchor);
do
X {
X char *ptr;
X int amnt;
X ptr=vlock(b->text,(l=halloc())->seg=salloc(b));
X if(size>SEGSIZ) amnt=SEGSIZ;
X else amnt=size;
X mcpy(ptr,blk,amnt);
X vchanged(ptr); vunlock(ptr);
X l->hole=amnt; l->ehole=SEGSIZ;
X enqueb(H,link,&anchor,l);
X blk+=amnt; size-=amnt;
X }
X while(size);
l=anchor.link.next;
deque(H,link,&anchor);
return l;
}
X
static void fixup1(p,amnt,nlines,hdr,hdramnt)
P *p;
long amnt;
long nlines;
H *hdr;
int hdramnt;
{
P *pp;
int flg;
if(!p->lbyte) flg=0;
else flg=1;
scrins(p->b,p->line,nlines,flg);
for(pp=p->link.next;pp!=p;pp=pp->link.next)
X if(pp->byte==p->byte && pp!=p->b->eof) pset(pp,p);
X else if(pp->byte>p->byte || pp==p->b->eof)
X  {
X  pp->byte+=amnt;
X  if(pp->line==p->line) pp->col=~(long)0;
X  pp->line+=nlines;
X  if(pp->hdr==hdr) pp->ofst+=hdramnt;
X  }
for(pp=p->link.next;pp!=p;pp=pp->link.next) if(pp->col==~(long)0) pfcol(pp);
undoins(p,amnt);
p->b->chnged=1;
}
X
P *binsm(p,blk,amnt)
P *p;
char *blk;
int amnt;
{
long nlines=mcnt(blk,'\n',amnt);
H *h=0;
int hdramnt;
if(p->hdr!=p->b->eof->hdr && amnt<=GGAPSZ(p->hdr))
X {
X h=p->hdr;
X hdramnt=amnt;
X ginsm(p->hdr,p->ptr,p->ofst,blk,amnt);
X }
else if(p->hdr==p->b->eof->hdr &&
X        p->b->bof->hdr != p->b->eof->hdr &&
X        amnt<=GGAPSZ(p->hdr->link.prev))
X {
X pprev(p); 
X ginsm(p->hdr,p->ptr,p->ofst,blk,amnt);
X }
else
X {
X H *a=bldchn(p->b,blk,amnt);
X inschn(p,a);
X }
fixup1(p,(long)amnt,nlines,h,hdramnt);
return p;
}
X
P *binsc(p,c)
P *p;
char c;
{
return binsm(p,&c,1);
}
X
P *binss(p,s)
P *p;
char *s;
{
return binsm(p,s,zlen(s));
}
X
P *binsb(p,from,to)
P *p, *from, *to;
{
P *dp=pdup(p);
P *sp=pdup(from);
int amnt;
if(p->b==from->b && p->byte>=from->byte && p->byte<to->byte)
X {
X P *mid=pdup(dp);
X while(mid->byte-sp->byte>=1024)
X  {
X  brmem(sp,buffer,1024);
X  binsm(dp,buffer,1024);
X  pfwrdn(sp,(long)1024), sp->byte+=1024;
X  pfwrdn(dp,(long)1024), dp->byte+=1024;
X  }
X if(amnt=mid->byte-sp->byte)
X  {
X  brmem(sp,buffer,amnt);
X  binsm(dp,buffer,amnt);
X  pfwrdn(sp,(long)amnt), sp->byte+=amnt;
X  pfwrdn(dp,(long)amnt), dp->byte+=amnt;
X  }
X prm(mid);
X pset(sp,dp);
X pset(dp,to);
X }
while(to->byte-sp->byte>=1024)
X {
X brmem(sp,buffer,1024);
X binsm(dp,buffer,1024);
X pfwrdn(sp,(long)1024), sp->byte+=1024;
X pfwrdn(dp,(long)1024), dp->byte+=1024;
X }
if(amnt=to->byte-sp->byte)
X {
X brmem(sp,buffer,amnt);
X binsm(dp,buffer,amnt);
X }
prm(dp);
prm(sp);
return p;
}
X
static int bkread(fi,buff,size)
char *buff;
int size;
{
int a,b;
if(!size) return -1;
for(a=b=0;(a<size) && ((b=read(fi,buff+a,size-a))>0);a+=b);
return (b<0) ? -1 : a;
}
X
static H *rdchn(b,fi,linesp,totala,max)
B *b;
long *linesp;
long *totala;
long *max;
{
H anchor, *l;
long lines=0, total=0;
char *ptr;
int amnt;
long vseg;
char *seg;
izque(H,link,&anchor);
while((amnt=bkread(fi,seg=vlock(b->text,vseg=salloc(b)),*max>=SEGSIZ?SEGSIZ:(int)*max))>0)
X {
X total+=amnt;
X *max-=amnt;
X lines+=mcnt(seg,'\n',amnt);
X vchanged(seg); vunlock(seg);
X l=halloc();
X l->seg=vseg;
X l->hole=amnt;
X l->ehole=SEGSIZ;
X enqueb(H,link,&anchor,l);
X }
sfree(b,vseg);
vunlock(seg);
if(amnt<0) return 0;
*linesp=lines;
*totala=total;
l=anchor.link.next;
deque(H,link,&anchor);
return l;
}
X
int binsfd(p,fd,max)
P *p;
long max;
{
long nlines;
long amnt;
int flg;
H *a;
if(a=rdchn(p->b,fd,&nlines,&amnt,&max))
X {
X if(amnt)
X  {
X  inschn(p,a);
X  fixup1(p,amnt,nlines,NULL,0);
X  }
X return 0;
X }
return -2;
}
X
int binsf(p,s)
P *p;
char *s;
{
FILE *fi;
int flg;
long skip,amnt;
s=parsens(s,&skip,&amnt);
if(s[0]=='!')
X {
X nescape(maint->t);
X ttclsn();
X fi=popen(s+1,"r");
X }
else if(!zcmp(s,"-")) fi=stdin;
else fi=fopen(s,"r");
if(!fi)
X {
X if(s[0]=='!') ttopnn(), nreturn(maint->t);
X if(errno==ENOENT) return -1;
X else return -4;
X }
if(skip)
X {
X if(lseek(fileno(fi),skip,0)<0)
X  {
X  int r;
X  while(skip>1024)
X   {
X   r=read(fileno(fi),buffer,1024);
X   if(r!= -1) skip-=r;
X   else { flg= -3; goto err; }
X   }
X  while(skip)
X   {
X   r=read(fileno(fi),buffer,(int)skip);
X   if(r!= -1) skip-=r;
X   else { flg= -3; goto err; }
X   }
X  }
X }
flg=binsfd(p,fileno(fi),amnt);
err:;
if(s[0]=='!') pclose(fi);
else if(zcmp(s,"-")) fclose(fi);
if(s[0]=='!') ttopnn(), nreturn(maint->t);
vsrm(s);
return flg;
}
X
int bload(b,s)
B *b;
char *s;
{
int rtval;
long skip,amnt;
inundo=1;
rtval=binsf(b->bof,s);
inundo=0;
b->name=zdup(s);
if(rtval)
X {
X b->backup=1;
X b->chnged=0;
X return rtval;
X }
b->chnged=0;
b->backup=0;
s=parsens(s,&skip,&amnt);
if(!zcmp(s,"-")) b->backup=1, b->chnged=1;
else if(s[0]=='!') b->backup=1;
else if(skip || amnt!=MAXLONG) b->backup=1;
vsrm(s);
return rtval;
}
X
/* View chain */
X
void check(b)
B *b;
{
H *h;
for(h=b->bof->hdr->link.next;h!=b->bof->hdr;h=h->link.next)
X {
X printf("\r%8.8X: prev=%X next=%X seq=%lX hole=%d ehole=%d\r\n",
X        h,h->link.prev,h->link.next,h->seg,h->hole,h->ehole);
X }
printf("\r%8.8X: prev=%X next=%X seq=%lX hole=%d ehole=%d\r\n",
X       h,h->link.prev,h->link.next,h->seg,h->hole,h->ehole);
}
X
/* View pointers */
X
void checkp(b)
B *b;
{
P *p;
printf("\rPointers\r\n");
X 
for(p=b->bof->link.next;p!=b->bof;p=p->link.next)
X {
X if(p==b->bof) printf("\rBof: ");
X else if(p==b->eof) printf("\rEof: ");
X else printf("\r");
X  printf("Byte=%ld Hdr=%X Ofst=%d Line=%ld Col=%ld Lbyte=%ld\r\n",
X	 p->byte,p->hdr,p->ofst,p->line,p->col,p->lbyte);
X }
if(p==b->bof) printf("\rBof: ");
else if(p==b->eof) printf("\rEof: ");
else printf("\r");
printf("Byte=%ld Hdr=%X Ofst=%d Line=%ld Col=%ld Lbyte=%ld\r\n",p->byte,p->hdr,p->ofst,p->line,p->col,p->lbyte);
}
X
/* Refigure column numbers */
X
void refigure()
{
B *b;
P *p;
for(b=bufs.link.next;b!=&bufs;b=b->link.next)
X {
X p=b->bof; do
X  pfcol(p), p->xcol=p->col;
X  while(p=p->link.next, p!=b->bof);
X }
}
X
/* Save edit buffers when editor dies */
X
void ttsig(sig)
{
long tim=time(0);
B *b;
FILE *f=fopen("DEADJOE","a");
fprintf(f,"\n*** Modified files in JOE when it aborted on %s",ctime(&tim));
if(sig) fprintf(f,"*** JOE was aborted by signal %d\n",sig);
else fprintf(f,"*** JOE was aborted because the terminal closed\n");
fflush(f);
for(b=bufs.link.next;b!=&bufs;b=b->link.next)
X if(b->chnged)
X  {
X  if(b->name) fprintf(f,"\n*** File \'%s\'\n",b->name);
X  else fprintf(f,"\n*** File \'(Unnamed)\'\n",b->name);
X   fflush(f);
X  bsavefd(b->bof,fileno(f),b->eof->byte);
X  }
_exit(1);
}
SHAR_EOF
chmod 0600 b.c ||
echo 'restore of b.c failed'
Wc_c="`wc -c < 'b.c'`"
test 24715 -eq "$Wc_c" ||
	echo 'b.c: original size 24715, current size' "$Wc_c"
fi
# ============= b.h ==============
if test -f 'b.h' -a X"$1" != X"-c"; then
	echo 'x - skipping b.h (File already exists)'
else
echo 'x - extracting b.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'b.h' &&
/* Buffer management
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
X
#ifndef _Ib
#define _Ib 1
X
#include "config.h"
#include "queue.h"
#include "vfile.h"
#include "undo.h"
X
typedef struct header H;
typedef struct point P;
typedef struct buffer B;
X
#define HDRSIZ 16		/* Text segment header size */
#define SEGSIZ 1024		/* Text segment size */
X
/* A text segment header */
X
struct header
X {
X LINK(H) link;			/* Doubly-linked list of headers */
X long seg;			/* Virtual address of text segment */
X unsigned short hole;		/* Offset to hole */
X unsigned short ehole;		/* Offset to text following hole */
X };
X
/* A buffer */
X
extern int force;
extern char *stdio;		/* If file name is set to this, use stdio */
X
struct buffer
X {
X LINK(B) link;			/* Doubly-linked list of buffers */
X VFILE *text;			/* Software virtual memory for this buffer */
X long fretxt;			/* Linked list of free text */
X P *bof;			/* Address of BOF pointer */
X P *eof;			/* Address of EOF pointer */
X char *name;			/* File name/0 for unnamed/stdio */
X int count;			/* Reference count */
X int chnged;			/* Set if changed since last save */
X int backup;			/* Set if backup file needn't be written */
X UNDO *undo;			/* Undo storage */
X int tab;			/* Tab width */
X };
X
/* A pointer */
X
struct point
X {
X LINK(P) link;			/* Doubly-linked list of pointers */
X
X /* Physical section of pointer
X  * These must be absolutely correct for the pointer to actually be pointing
X  * anywhere */
X B *b;				/* Buffer this pointer is in */
X int ofst;			/* Byte offset into current segment */
X char *ptr;			/* Address of current segment */
X H *hdr;			/* Address of segment's header */
X
X /* Logical section
X  * These give more information about the pointer's location.  Sometimes
X  * one or more of these may not be correctly updated */
X long byte;			/* Byte offset from beginning of file */
X long line;			/* Line number */
X long col;			/* Column number */
X long xcol;			/* Extended column number */
X long lbyte;			/* Byte number */
X 
X P **owner;			/* Owner of this pointer */
X };
X
/*******************************/
/* Buffer management functions */
/*******************************/
X
/* B *bmk(void);
X * Create a new empty buffer.
X * The following variables get these initializations:
X *     name            NULL
X *     reference count 1
X *     backup flag     1
X *     changed flag    0
X */
B *bmk();
X
/* B *bfind(char *name);
X * Find file.  Returns with buffer of already loaded file or 0.  If the
X * file is found, the buffer's reference count is incremented.
X */
B *bfind();
X
/* void brm(B *b);
X * Decrement a buffer's reference count.  If it reaches zero, eliminate the
X * buffer.
X */
void brm();
X
/********************************/
/* Pointer management functions */
/********************************/
X
/* P *pdup(P *p);
X * Duplicate a pointer.  The new pointer's owner is set to NULL.
X */
P *pdup();
X
/* P *pdupown(P *p,P **o);
X * Duplicate pointer and set ownership of pointer
X */
P *pdupown();
X
/* P *pset(P *p,P *n);
X * Force a pointer p to point to the same place as another pointer n.
X * Caution: this assumes that the original pointer p is pointing to a
X * valid locked text segment.  If it doesn't, you must clear p->ptr
X * before calling this function.
X */
P *pset();
X
/* P *peof(P *p);
X * Force a pointer to point to the end of file
X */
P *peof();
X
/* P *pbof(P *p);
X * Force a pointer to point to the beginning of file
X */
P *pbof();
X
/* void prm(P *p);
X * Remove a pointer.  Clears the pointer's owner address.
X */
void prm();
X
/* int pisbof(P *p);
X * Return true if pointer is at beginning of file
X * This can be used on pointers with incorrect logical sections
X */
int pisbof();
X
/* int piseof(P *p);
X * Return true if pointer is at end of file
X * Ok to use if the pointer's logical section is incorrect or if the buffer's
X * end of file pointer is incorrect.
X */
int piseof();
X
/* int pisbol(P *p);
X * Return true if pointer is at beginning of line.
X * Ok to use if the pointer's logical section is incorrect.
X */
int pisbol();
X
/* int piseol(P *p);
X * Return true if pointer is at end of line
X * This can be used if the pointer's logical section is incorrect.  It can
X * also be used if the buffer's end of file pointer is incorrect.
X */
int piseol();
X
/* int pisbow(P *p);
X * Return true if pointer is at beginning of a word
X */
int pisbow();
X
/* int piseow(P *p);
X * Return true if pointer is at end of word
X */
int piseow();
X
/* int pnext(P *p);
X * Advance pointer to beginning of next segment.  Only updates physical part
X * of pointer.  Returns false if the pointer was at or reached end of buffer.
X */
int pnext();
X
/* int pprev(P *p);
X * Set pointer to after end of previous segment.  Only updates physical part of
X * pointer.  Returns false if pointer was at or reached beginning of buffer.
X * Warning: this function sets the pointer to an invalid place.  Only use this
X * if p->ofst will be subsequently decremented before any characters are read.
X */
int pprev();
X
/* int pgetcn(P *p);
X * Get character at pointer and advance pointer.  Only updates physical
X * section of pointer.  Workds ok if buffer's end of file pointer is
X * incorrect.  Returns -1 if pointer was at end of buffer.
X */
int pgetcn();
X
/* int pgetc(P *p);
X * Get character at pointer and advance pointer.  Returns -1 if pointer
X * was at end of file.  Works ok if buffer's end of file pointer is incorrect.
X */
int pgetc();
X
/* P *pfwrdn(P *p,long n);
X * Advance pointer by n characters.  Only the physical section of the pointer
X * is updated.  Works ok if buffer's end of buffer pointer is incorrect.
X */
P *pfwrdn();
X
/* P *pfwrd(P *p,long n);
X * Advance pointer by n characters.  If the pointer goes past the end of the
X * buffer, the pointer is set to the end of the buffer and 0 is returned
X * instead of the pointer.
X */
P *pfwrd();
X
/* int prgetcn(P *p);
X * Move pointer back one and return character that position.  Returns -1
X * if pointer was at beginning of file.  Only updates physical part of
X * pointer.
X */
int prgetcn();
X
/* int prgetc(P *p);
X * Move pointer back one and return character at that position.  Returns -1
X * if pointer was at beginning of file.
X */
int prgetc();
X
/* P *pbkwdn(P *p,long n);
X * Move pointer back n characters.  Returns 0 on attempt to go before
X * beginning of buffer.  Only updates physical section of pointer.
X */
P *pbkwdn();
X
/* P *pbkwdf(P *p,long n);
X * Move pointer back n characters.  Returns 0 on attempt to go before
X * beginning of buffer.  Only updates line number part of logical section
X * of pointer.
X */
P *pbkwdf();
X
/* P *pfcol(P *p);
X * Determine and set column number of line byte number parts of logical
X * section of p.  Works ok if end of file pointer is incorrect.
X */
P *pfcol();
X
/* P *pbkwd(P *p,long n);
X * Move pointer back n characters.  Returns 0 if attempt to move before
X * beginning of buffer.
X */
P *pbkwd();
X
/* P *pbol(P *p);
X * Set pointer to beginning of line.  'lbyte' of logical part of pointer
X * must be correct.
X */
P *pbol();
X
/* P *pboln(P *p);
X * Set pointer to beginning of line.  Works ok if logical part of pointer
X * is not correct.
X */
P *pboln();
X
/* P *peol(P *p);
X * Set pointer to end of line.  Works ok if end of buffer pointer is
X * incorrect.
X */
P *peol();
X
/* P *pnextl(P *p);
X * Set pointer to beginning of next line or end of last line.  Returns 0
X * for end of last line.  Column number section of logical part of pointer
X * is not set.
X */
P *pnextl();
X
/* P *pprevl(P *p);
X * Set pointer to end of previous line or beginning of first line.  Returns
X * 0 if we got to the beginning part of the first line.  Column number
X * section of logicl part of pointer is not set.
X */
P *pprevl();
X
/* P *pline(P *p,long line);
X * Goto beginning of given line number.  Line number part of logical section
X * of pointer (and eof pointer) must be correct.
X */
P *pline();
X
/* P *pcol(P *p,long col);
X * Goto given column number.  The original column number (and lbyte) need
X * not be correct.
X */
P *pcol();
X
/* P *pfindrn(P *p,char *s,int len);
X * Search reverse for string
X */
P *pfindrn();
X
/* P *pfindrni(P *p,char *s,int len);
X * Search reverse for string case insensitive
X */
P *pfindrni();
X
/* P *pfindfn(P *p,char *s,int len);
X * Find first occurance of string s/len beginning at p.  If found, returns
X * p pointing to beginning of string.  If not found, returns 0.
X */
P *pfindfn();
X
/* P *pfindfni(P *p,char *s,int len);
X * Case insensitive version of above
X */
P *pfindfni();
X
/* int brc(P *p);
X * Read character at a pointer or return -1 if pointer was at end of the buffer
X */
int brc();
X
/* char *brmem(P *p,char *blk,int size);
X * Read characters into a memory block
X */
char *brmem();
X
/* char *brs(P *p,int size);
X * Read a zero terminated string into an malloc block and return the malloc
X * block
X */
char *brs();
X
/* char *brvs(P *p,int size);
X * Read a variable length string
X */
char *brvs();
X
/* char *parsens(char *s,long skip,long amnt);
X * Parse file name.
X */
char *parsens();
X
/* int bsavefd(P *p,int fd,long size);
X * Write 'size' bytes beginning at 'p' to 'fd'.
X */
int bsavefd();
X
/* int bsave(P *p,char *name,long size);
X * Save characters into a file
X */
int bsave();
X
/* P *bdel(P *from,P *to);
X * Delete characters from a buffer
X */
X
P *bdel();
X
/* P *binsc(P *p,char c);
X * Insert a character into a buffer
X */
P *binsc();
X
/* P *binsm(P *p,char *blk,int size);
X * Insert a memory block into a buffer
X */
P *binsm();
X
/* P *binss(P *p,char *s);
X * Insert zero terminated string into a buffer
X */
P *binss();
X
/* P *binsb(P *p,P *from,P *to);
X * Insert characters from another buffer
X */
P *binsb();
X
/* int binsfd(P *p,int fd,long max);
X * Insert a file into a buffer.  No more than 'max' bytes are loaded from
X * the file.
X */
int binsfd();
X
/* int binsf(P *p,char *name);
X * Insert a file into a buffer
X */
int binsf();
X
/* int bload(B *b,char *s);
X * Load a file into a buffer
X */
int bload();
X
void refigure();
X
#endif
SHAR_EOF
chmod 0600 b.h ||
echo 'restore of b.h failed'
Wc_c="`wc -c < 'b.h'`"
test 10590 -eq "$Wc_c" ||
	echo 'b.h: original size 10590, current size' "$Wc_c"
fi
# ============= blocks.c ==============
if test -f 'blocks.c' -a X"$1" != X"-c"; then
	echo 'x - skipping blocks.c (File already exists)'
else
echo 'x - extracting blocks.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'blocks.c' &&
/* Fast block move/copy subroutines
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
X
/* Take a look at the configuration information in types.h */
/* This module requires that AUTOINC, ALIGNED, ISIZ, SHFT and BITS be defined
X * correctly
X */
#include "blocks.h"
X
/* Set 'sz' 'int's beginning at 'd' to the value 'c' */
/* Returns address of block.  Does nothing if 'sz' equals zero */
X
int *msetI(d,c,sz)
register int *d, c;
register int sz;
{
int *orgd=d;
while(sz>=16)
X {
#ifdef AUTOINC
X *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c;
X *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c;
#else
X d[0]=c; d[1]=c; d[2]=c; d[3]=c; d[4]=c; d[5]=c; d[6]=c; d[7]=c;
X d[8]=c; d[9]=c; d[10]=c; d[11]=c; d[12]=c; d[13]=c; d[14]=c; d[15]=c;
X d+=16;
#endif
X sz-=16;
X }
switch(sz)
X {
#ifdef AUTOINC
case 15: *d++=c;
case 14: *d++=c;
case 13: *d++=c;
case 12: *d++=c;
case 11: *d++=c;
case 10: *d++=c;
case 9: *d++=c;
case 8: *d++=c;
case 7: *d++=c;
case 6: *d++=c;
case 5: *d++=c;
case 4: *d++=c;
case 3: *d++=c;
case 2: *d++=c;
case 1: *d++=c;
#else
case 15: d[14]=c;
case 14: d[13]=c;
case 13: d[12]=c;
case 12: d[11]=c;
case 11: d[10]=c;
case 10: d[9]=c;
case 9: d[8]=c;
case 8: d[7]=c;
case 7: d[6]=c;
case 6: d[5]=c;
case 5: d[4]=c;
case 4: d[3]=c;
case 3: d[2]=c;
case 2: d[1]=c;
case 1: d[0]=c;
#endif
case 0:;
X }
return orgd;
}
X
/* Set 'sz' 'char's beginning at 'd' to the value 'c' */
/* Returns address of block.  Does nothing if 'sz' equals zero */
X
char *mset(d,c,sz)
register char *d, c;
register int sz;
{
char *orgd=d;
if(sz<16)
X switch(sz)
X  {
#ifdef AUTOINC
X  case 15: *d++=c;
X  case 14: *d++=c;
X  case 13: *d++=c;
X  case 12: *d++=c;
X  case 11: *d++=c;
X  case 10: *d++=c;
X  case 9: *d++=c;
X  case 8: *d++=c;
X  case 7: *d++=c;
X  case 6: *d++=c;
X  case 5: *d++=c;
X  case 4: *d++=c;
X  case 3: *d++=c;
X  case 2: *d++=c;
X  case 1: *d++=c;
#else
X  case 15: d[14]=c;
X  case 14: d[13]=c;
X  case 13: d[12]=c;
X  case 12: d[11]=c;
X  case 11: d[10]=c;
X  case 10: d[9]=c;
X  case 9: d[8]=c;
X  case 8: d[7]=c;
X  case 7: d[6]=c;
X  case 6: d[5]=c;
X  case 5: d[4]=c;
X  case 4: d[3]=c;
X  case 3: d[2]=c;
X  case 2: d[1]=c;
X  case 1: d[0]=c;
#endif
X  case 0:;
X  }
else
X {
X int z=ISIZ-((int)d&(ISIZ-1));
X if(z!=ISIZ)
X  switch(z)
X   {
#ifdef AUTOINC
X  case 7: *d++=c;
X  case 6: *d++=c;
X  case 5: *d++=c;
X  case 4: *d++=c;
X  case 3: *d++=c;
X  case 2: *d++=c;
X  case 1: *d++=c;
X  case 0:;
#else
X  case 7: d[6]=c;
X  case 6: d[5]=c;
X  case 5: d[4]=c;
X  case 4: d[3]=c;
X  case 3: d[2]=c;
X  case 2: d[1]=c;
X  case 1: d[0]=c;
X  case 0:;
X          d+=z;
#endif
X   sz-=z;
X   }
X msetI(d,
#if ISIZ>=8
X (c<<(BITS*7))+(c<<(BITS*6))+(c<<(BITS*5))+(c<<(BITS*4))+
#endif
#if ISIZ>=4
X (c<<(BITS*3))+(c<<(BITS*2))+
#endif
#if ISIZ>=2
X (c<<BITS)+
#endif
X c,sz>>SHFT);
X d+=sz&~(ISIZ-1);
X switch(sz&(ISIZ-1))
X  {
#ifdef AUTOINC
X case 7: *d++=c;
X case 6: *d++=c;
X case 5: *d++=c;
X case 4: *d++=c;
X case 3: *d++=c;
X case 2: *d++=c;
X case 1: *d++=c;
#else
X case 7: d[6]=c;
X case 6: d[5]=c;
X case 5: d[4]=c;
X case 4: d[3]=c;
X case 3: d[2]=c;
X case 2: d[1]=c;
X case 1: d[0]=c;
#endif
X case 0:;
X  }
X }
return orgd;
}
X
/* Copy a block of integers */
/* Copy from highest address to lowest */
X
static int *mbkwdI(d,s,sz)
register int *d, *s;
register int sz;
{
if(d==s) return d;
d+=sz; s+=sz;
while(sz>=16)
X {
#ifdef AUTOINC
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; 
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; 
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
#else
X d-=16; s-=16;
X d[15]=s[15]; d[14]=s[14]; d[13]=s[13]; d[12]=s[12]; d[11]=s[11]; d[10]=s[10];
X d[9]=s[9]; d[8]=s[8]; d[7]=s[7]; d[6]=s[6]; d[5]=s[5]; d[4]=s[4]; d[3]=s[3];
X d[2]=s[2]; d[1]=s[1]; d[0]=s[0];
#endif
X sz-=16;
X }
#ifndef AUTOINC
X d-=sz; s-=sz;
#endif
switch(sz)
X {
#ifdef AUTOINC
X case 15: *--d= *--s;
X case 14: *--d= *--s;
X case 13: *--d= *--s;
X case 12: *--d= *--s;
X case 11: *--d= *--s;
X case 10: *--d= *--s;
X case 9: *--d= *--s;
X case 8: *--d= *--s;
X case 7: *--d= *--s;
X case 6: *--d= *--s;
X case 5: *--d= *--s;
X case 4: *--d= *--s;
X case 3: *--d= *--s;
X case 2: *--d= *--s;
X case 1: *--d= *--s;
#else
X case 15: d[14]=s[14];
X case 14: d[13]=s[13];
X case 13: d[12]=s[12];
X case 12: d[11]=s[11];
X case 11: d[10]=s[10];
X case 10: d[9]=s[9];
X case 9: d[8]=s[8];
X case 8: d[7]=s[7];
X case 7: d[6]=s[6];
X case 6: d[5]=s[5];
X case 5: d[4]=s[4];
X case 4: d[3]=s[3];
X case 3: d[2]=s[2];
X case 2: d[1]=s[1];
X case 1: d[0]=s[0];
#endif
X case 0:;
X }
return d;
}
X
/* Copy a block of 'int's.  Copy from lowest address to highest */
X
static int *mfwrdI(d,s,sz)
register int *d, *s;
register int sz;
{
int *od=d;
if(s==d) return d;
while(sz>=16)
X {
#ifdef AUTOINC
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
#else
X d[0]=s[0]; d[1]=s[1]; d[2]=s[2]; d[3]=s[3]; d[4]=s[4]; d[5]=s[5]; d[6]=s[6];
X d[7]=s[7]; d[8]=s[8]; d[9]=s[9]; d[10]=s[10]; d[11]=s[11]; d[12]=s[12];
X d[13]=s[13]; d[14]=s[14]; d[15]=s[15];
X s+=16; d+=16;
#endif
X sz-=16;
X }
#ifndef AUTOINC
s-=15-sz; d-=15-sz;
#endif
switch(sz)
X {
#ifdef AUTOINC
X case 15: *d++= *s++;
X case 14: *d++= *s++;
X case 13: *d++= *s++;
X case 12: *d++= *s++;
X case 11: *d++= *s++;
X case 10: *d++= *s++;
X case 9: *d++= *s++;
X case 8: *d++= *s++;
X case 7: *d++= *s++;
X case 6: *d++= *s++;
X case 5: *d++= *s++;
X case 4: *d++= *s++;
X case 3: *d++= *s++;
X case 2: *d++= *s++;
X case 1: *d++= *s++;
#else
X case 15: d[0]=s[0];
X case 14: d[1]=s[1];
X case 13: d[2]=s[2];
X case 12: d[3]=s[3];
X case 11: d[4]=s[4];
X case 10: d[5]=s[5];
X case 9: d[6]=s[6];
X case 8: d[7]=s[7];
X case 7: d[8]=s[8];
X case 6: d[9]=s[9];
X case 5: d[10]=s[10];
X case 4: d[11]=s[11];
X case 3: d[12]=s[12];
X case 2: d[13]=s[13];
X case 1: d[14]=s[14];
#endif
X case 0:;
X }
return od;
}
X
/* Copy the block of 'sz' bytes beginning at 's' to 'd'.  If 'sz' is zero or
X * if 's'=='d', nothing happens.  The bytes at the highest address ('s'+'sz'-1)
X * are copied before the ones at the lowest ('s') are.
X */ 
X
char *mbkwd(d,s,sz)
register char *d, *s;
register int sz;
{
if(s==d) return d;
s+=sz; d+=sz;
#ifdef ALIGNED
if( sz>=16 )
#else
if( ((int)s&(ISIZ-1))==((int)d&(ISIZ-1)) && sz>=16)
#endif
X {
X int z=((int)s&(ISIZ-1));
#ifndef AUTOINC
X s-=z; d-=z;
#endif
X switch(z)
X  {
#ifdef AUTOINC
X  case 7: *--d= *--s;
X  case 6: *--d= *--s;
X  case 5: *--d= *--s;
X  case 4: *--d= *--s;
X  case 3: *--d= *--s;
X  case 2: *--d= *--s;
X  case 1: *--d= *--s;
#else
X  case 7: d[6]=s[6];
X  case 6: d[5]=s[5];
X  case 5: d[4]=s[4];
X  case 4: d[3]=s[3];
X  case 3: d[2]=s[2];
X  case 2: d[1]=s[1];
X  case 1: d[0]=s[0];
#endif
X  case 0:;
X  }
X sz-=z;
X mbkwdI(d-(sz&~(ISIZ-1)),s-(sz&~(ISIZ-1)),sz>>SHFT);
#ifndef AUTOINC
X d-=sz; s-=sz;
#else
X d-=(sz&~(ISIZ-1)); s-=(sz&~(ISIZ-1));
#endif
X switch(sz&(ISIZ-1))
X  {
#ifdef AUTOINC
X  case 7: *--d= *--s;
X  case 6: *--d= *--s;
X  case 5: *--d= *--s;
X  case 4: *--d= *--s;
X  case 3: *--d= *--s;
X  case 2: *--d= *--s;
X  case 1: *--d= *--s;
#else
X  case 7: d[6]=s[6];
X  case 6: d[5]=s[5];
X  case 5: d[4]=s[4];
X  case 4: d[3]=s[3];
X  case 3: d[2]=s[2];
X  case 2: d[1]=s[1];
X  case 1: d[0]=s[0];
#endif
X  case 0:;
X  }
X }
else
X {
X while(sz>=16)
X  {
#ifdef AUTOINC
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
X *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
#else
X  d-=16; s-=16;
X  d[15]=s[15]; d[14]=s[14]; d[13]=s[13]; d[12]=s[12]; d[11]=s[11]; d[10]=s[10];
X  d[9]=s[9]; d[8]=s[8]; d[7]=s[7]; d[6]=s[6]; d[5]=s[5]; d[4]=s[4]; d[3]=s[3];
X  d[2]=s[2]; d[1]=s[1]; d[0]=s[0];
#endif
X  sz-=16;
X  }
#ifndef AUTOINC
X d-=sz; s-=sz;
#endif
X switch(sz)
X  {
#ifdef AUTOINC
X  case 15: *--d= *--s;
X  case 14: *--d= *--s;
X  case 13: *--d= *--s;
X  case 12: *--d= *--s;
X  case 11: *--d= *--s;
X  case 10: *--d= *--s;
X  case 9: *--d= *--s;
X  case 8: *--d= *--s;
X  case 7: *--d= *--s;
X  case 6: *--d= *--s;
X  case 5: *--d= *--s;
X  case 4: *--d= *--s;
X  case 3: *--d= *--s;
X  case 2: *--d= *--s;
X  case 1: *--d= *--s;
#else
X  case 15: d[14]=s[14];
X  case 14: d[13]=s[13];
X  case 13: d[12]=s[12];
X  case 12: d[11]=s[11];
X  case 11: d[10]=s[10];
X  case 10: d[9]=s[9];
X  case 9: d[8]=s[8];
X  case 8: d[7]=s[7];
X  case 7: d[6]=s[6];
X  case 6: d[5]=s[5];
X  case 5: d[4]=s[4];
X  case 4: d[3]=s[3];
X  case 3: d[2]=s[2];
X  case 2: d[1]=s[1];
X  case 1: d[0]=s[0];
#endif
X  case 0:;
X  }
X }
return d;
}
X
char *mmove(d,s,sz)
char *d, *s;
int sz;
{
if(d>s) mbkwd(d,s,sz);
else mfwrd(d,s,sz);
}
X
/* Copy the block of 'sz' bytes beginning at 's' to 'd'.  If 'sz' is zero or
X * if 's'=='d', nothing happens.  The bytes at the lowest address ('s')
X * are copied before the ones at the highest ('s'+'sz'-1) are.
X */ 
X
char *mfwrd(d,s,sz)
register char *d, *s;
register int sz;
{
char *od=d;
if(d==s) return d;
#ifdef ALIGNED
if(sz>=16)
#else
if( ((int)d&(ISIZ-1))==((int)s&(ISIZ-1)) && sz>=16 )
#endif
X {
X int z=((int)s&(ISIZ-1));
X if(z)
X  {
#ifndef AUTOINC
X  s-=z; d-=z;
X  switch(ISIZ-z)
X   {
#if ISIZ==8
X   case 7: d[1]=s[1];
X   case 6: d[2]=s[2];
X   case 5: d[3]=s[3];
X   case 4: d[4]=s[4];
X   case 3: d[5]=s[5];
X   case 2: d[6]=s[6];
X   case 1: d[7]=s[7];
X   case 0:;
#else
#if ISIZ==4
X   case 3: d[1]=s[1];
X   case 2: d[2]=s[2];
X   case 1: d[3]=s[3];
X   case 0:;
#else
#if ISIZ==2
X   case 1: d[1]=s[1];
X   case 0:;
#endif
#endif
#endif
X   }
X  s+=ISIZ; d+=ISIZ;
#else
X  switch(ISIZ-z)
X   {
X   case 7: *d++= *s++;
X   case 6: *d++= *s++;
X   case 5: *d++= *s++;
X   case 4: *d++= *s++;
X   case 3: *d++= *s++;
X   case 2: *d++= *s++;
X   case 1: *d++= *s++;
X   case 0:;
X   }
#endif
X  sz-=ISIZ-z;
X  }
X mfwrdI(d,s,sz>>SHFT);
#ifdef AUTOINC
X s+=(sz&~(ISIZ-1)); d+=(sz&~(ISIZ-1));
X switch(sz&(ISIZ-1))
X  {
X  case 7: *d++= *s++;
X  case 6: *d++= *s++;
X  case 5: *d++= *s++;
X  case 4: *d++= *s++;
X  case 3: *d++= *s++;
X  case 2: *d++= *s++;
X  case 1: *d++= *s++;
X  case 0:;
X  }
#else
X s+=sz-(ISIZ-1); d+=sz-(ISIZ-1);
X switch(sz&(ISIZ-1))
X  {
#if ISIZ==8
X case 7: d[0]=s[0];
X case 6: d[1]=s[1];
X case 5: d[2]=s[2];
X case 4: d[3]=s[3];
X case 3: d[4]=s[4];
X case 2: d[5]=s[5];
X case 1: d[6]=s[6];
X case 0:;
#else
#if ISIZ==4
X  case 3: d[0]=s[0];
X  case 2: d[1]=s[1];
X  case 1: d[2]=s[2];
X  case 0:;
#else
#if ISIZ==2
X  case 1: d[0]=s[0];
X  case 0:;
#endif
#endif
#endif
X  }
#endif
X }
else
X {
X while(sz>=16)
X  {
#ifdef AUTOINC
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
X *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
#else
X  d[0]=s[0]; d[1]=s[1]; d[2]=s[2]; d[3]=s[3]; d[4]=s[4]; d[5]=s[5]; d[6]=s[6];
X  d[7]=s[7]; d[8]=s[8]; d[9]=s[9]; d[10]=s[10]; d[11]=s[11]; d[12]=s[12];
X  d[13]=s[13]; d[14]=s[14]; d[15]=s[15];
X  s+=16; d+=16;
#endif
X  sz-=16;
X  }
#ifndef AUTOINC
X s-=15-sz; d-=15-sz;
#endif
X switch(sz)
X  {
#ifdef AUTOINC
X case 15: *d++= *s++;
X case 14: *d++= *s++;
X case 13: *d++= *s++;
X case 12: *d++= *s++;
X case 11: *d++= *s++;
X case 10: *d++= *s++;
X case 9: *d++= *s++;
X case 8: *d++= *s++;
X case 7: *d++= *s++;
X case 6: *d++= *s++;
X case 5: *d++= *s++;
X case 4: *d++= *s++;
X case 3: *d++= *s++;
X case 2: *d++= *s++;
X case 1: *d++= *s++;
X case 0:;
#else
X  case 15: d[0]=s[0];
X  case 14: d[1]=s[1];
X  case 13: d[2]=s[2];
X  case 12: d[3]=s[3];
X  case 11: d[4]=s[4];
X  case 10: d[5]=s[5];
X  case 9: d[6]=s[6];
X  case 8: d[7]=s[7];
X  case 7: d[8]=s[8];
X  case 6: d[9]=s[9];
X  case 5: d[10]=s[10];
X  case 4: d[11]=s[11];
X  case 3: d[12]=s[12];
X  case 2: d[13]=s[13];
X  case 1: d[14]=s[14];
X  case 0:;
#endif
X  }
X }
return od;
}
X
/* Utility to count number of lines within a segment */
X
int mcnt(blk,c,size)
char *blk,c;
int size;
{
int nlines=0;
while(size>=16)
X {
X if(blk[0]==c) ++nlines;
X if(blk[1]==c) ++nlines;
X if(blk[2]==c) ++nlines;
X if(blk[3]==c) ++nlines;
X if(blk[4]==c) ++nlines;
X if(blk[5]==c) ++nlines;
X if(blk[6]==c) ++nlines;
X if(blk[7]==c) ++nlines;
X if(blk[8]==c) ++nlines;
X if(blk[9]==c) ++nlines;
X if(blk[10]==c) ++nlines;
X if(blk[11]==c) ++nlines;
X if(blk[12]==c) ++nlines;
X if(blk[13]==c) ++nlines;
X if(blk[14]==c) ++nlines;
X if(blk[15]==c) ++nlines;
X blk+=16; size-=16;
X }
while(size--) if(*blk++=='\n') ++nlines;
return nlines;
}
SHAR_EOF
chmod 0600 blocks.c ||
echo 'restore of blocks.c failed'
Wc_c="`wc -c < 'blocks.c'`"
test 12881 -eq "$Wc_c" ||
	echo 'blocks.c: original size 12881, current size' "$Wc_c"
fi
# ============= blocks.h ==============
if test -f 'blocks.h' -a X"$1" != X"-c"; then
	echo 'x - skipping blocks.h (File already exists)'
else
echo 'x - extracting blocks.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'blocks.h' &&
/* Fast block move/copy subroutines
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
X
#ifndef _Iblocks
#define _Iblocks 1
X
#include "config.h"
X
/* Warning: Don't use mfwrd or mbkwd for filling an area.  Use them only
X * for copying, inserting or deleting.  Since they copy ints at a time, they
X * will not work for filling.
X */
X
/* char *mfwrd(char *d,char *s,int sz); Copy 'sz' bytes from 's' to 'd'.
X   The copy occures in the forward direction (use for deletes)
X   Nothing happens if 'd'=='s' or 'sz'==0
X   Returns original value of 'd'
X */
char *mfwrd();
X
/* char *mbkwd(char *d,char *s,int sz); Copy 'sz' bytes from 's' to 'd'.
X   The copy occures in the backward direction (use for inserts)
X   Nothing happens if 'd'=='s' or 'sz'==0
X   Returns original value of 'd'
X */
char *mbkwd();
X
/* char *mmove(char *d,char *s,int sz); Copy 'sz' bytes from 's' to 'd'.  Chooses
X * either mbkwd or mfwrd to do this such that the data won't get clobbered.
X */
char *mmove();
X
/* Use this for non-overlapping copies */
#define mcpy mbkwd
X
/* char *mset(char *d,char c,int sz); Set 'sz' bytes at 'd' to 'c'.
X * If 'sz'==0 nothing happens
X * Return original value of 'd'
X */
char *mset();
X
/* int *msetI(int *d,int c,int sz); Set 'sz' ints at 'd' to 'c'.
X * If 'sz'==0 nothing happens
X * Returns orininal value of 'd'
X */
X
int *msetI();
X
/* int mcnt(char *blk,char c,int size);
X *
X * Count number of occurances a character appears in a block
X */
int mcnt();
X
#endif
SHAR_EOF
chmod 0600 blocks.h ||
echo 'restore of blocks.h failed'
Wc_c="`wc -c < 'blocks.h'`"
test 2144 -eq "$Wc_c" ||
	echo 'blocks.h: original size 2144, current size' "$Wc_c"
fi
# ============= bw.c ==============
if test -f 'bw.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bw.c (File already exists)'
else
echo 'x - extracting bw.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bw.c' &&
/* Edit buffer window generation
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "tty.h"
#include "vfile.h"
#include "toomany.h"
#include "termcap.h"
#include "kbd.h"
#include "b.h"
#include "scrn.h"
#include "w.h"
#include "bw.h"
X
/* Display modes */
int dspasis=0;
extern int square;
X
P *getto(p,cur,top,line)
P *p,*cur,*top;
long line;
{
long dist=MAXLONG;
long d;
P *best;
if(!p)
X {
X if(d=(line-cur->line>=0?line-cur->line:cur->line-line), d<dist)
X  dist=d, best=cur;
X if(d=(line-top->line>=0?line-top->line:top->line-line), d<dist)
X  dist=d, best=top;
X p=pdup(best);
X pbol(p);
X }
while(line>p->line) if(!pnextl(p)) break;
if(line<p->line)
X {
X while(line<p->line) pprevl(p);
X pboln(p);
X }
return p;
}
X
/* Scroll window to follow cursor */
X
int mid=0;
X
void bwfllw(w)
BW *w;
{
P *newtop;
if(w->cursor->line<w->top->line)
X {
X newtop=pdup(w->cursor);
X pbol(newtop);
X if(mid)
X  if(newtop->line>=w->h/2) pline(newtop,newtop->line-w->h/2);
X  else pset(newtop,newtop->b->bof);
X if(w->top->line-newtop->line<w->h)
X  {
X  nscrldn(w->t->t,w->y,w->y+w->h,(int)(w->top->line-newtop->line));
X  scrldn(w->t->t->updtab,w->y,w->y+w->h,(int)(w->top->line-newtop->line));
X  }
X else msetI(w->t->t->updtab+w->y,1,w->h);
X pset(w->top,newtop);
X prm(newtop);
X }
else if(w->cursor->line>=w->top->line+w->h)
X {
X newtop=pdup(w->top);
X if(mid) newtop=getto(NULL,w->cursor,w->top,w->cursor->line-w->h/2);
X else newtop=getto(NULL,w->cursor,w->top,w->cursor->line-(w->h-1));
X if(newtop->line-w->top->line<w->h)
X  {
X  nscrlup(w->t->t,
X            w->y,
X            w->y+w->h,
X            (int)(newtop->line-w->top->line));
X  scrlup(w->t->t->updtab,w->y,w->y+w->h,(int)(newtop->line-w->top->line));
X  }
X else msetI(w->t->t->updtab+w->y,1,w->h);
X pset(w->top,newtop);
X prm(newtop);
X }
X
/* Adjust column */
if(w->cursor->xcol<w->offset)
X {
X w->offset=w->cursor->xcol;
X msetI(w->t->t->updtab+w->y,1,w->h);
X }
else if(w->cursor->xcol>=w->offset+w->w)
X {
X w->offset=w->cursor->xcol-(w->w-1);
X msetI(w->t->t->updtab+w->y,1,w->h);
X }
}
X
/* Scroll a buffer window after an insert occured.  'flg' is set to 1 if
X * the first line was split
X */
X
void bwins(w,l,n,flg)
BW *w;
long l,n;
int flg;
{
if(l+flg+n<w->top->line+w->h && l+flg>=w->top->line && l+flg<=w->b->eof->line)
X {
X int y;
X if(flg) w->t->t->sary[w->y+l-w->top->line]=w->t->t->li;
X nscrldn(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
X scrldn(w->t->t->updtab,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
X }
if(l<w->top->line+w->h && l>=w->top->line)
X if(n>=w->h-(l-w->top->line))
X  msetI(w->t->t->updtab+w->y+l-w->top->line,1,w->h-(int)(l-w->top->line));
X else
X  msetI(w->t->t->updtab+w->y+l-w->top->line,1,(int)n+1);
}
X
/* Scroll current windows after a delete */
X
void bwdel(w,l,n,flg)
BW *w;
long l,n;
int flg;
{
if(l<w->top->line+w->h && l>=w->top->line)
X w->t->t->updtab[w->y+l-w->top->line]=1;
if(l+n<w->top->line+w->h && l+n>=w->top->line)
X w->t->t->updtab[w->y+l+n-w->top->line]=1;
X
if(l<w->top->line+w->h &&
X   (l+n>=w->top->line+w->h || l+n==w->b->eof->line))
X if(l>=w->top->line)
X  scrlup(w->t->t->updtab,w->y+l-w->top->line,w->y+w->h,
X         w->y+w->h-(w->y+l-w->top->line));
X else
X  scrlup(w->t->t->updtab,w->y,w->y+w->h,w->h);
else if(l+n<w->top->line+w->h &&
X        l+n>w->top->line &&
X        l+n<w->b->eof->line)
X if(l+flg>=w->top->line)
X  {
X  nscrlup(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
X  scrlup(w->t->t->updtab,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
X  }
X else
X  {
X  nscrlup(w->t->t,w->y,w->y+w->h,(int)(l+n-w->top->line));
X  scrlup(w->t->t->updtab,w->y,w->y+w->h,(int)(l+n-w->top->line));
X  }
}
X
/* Update a single line */
X
static int lgen(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta;
unsigned char bc;
X
/* Initialize bp and amnt from p */
if(p->ofst>=p->hdr->hole)
X {
X bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
X amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
X }
else
X {
X bp=p->ptr+p->ofst;
X amnt=p->hdr->hole-p->ofst;
X }
X
if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
X {
X bc= *bp++;
X if(square)
X  {
X  if(col>=from && col<to) c=INVERSE;
X  else c=0;
X  }
X else
X  {
X  if(byte>=from && byte<to) c=INVERSE;
X  else c=0;
X  }
X ++byte;
X if(bc=='\t')
X  {
X  ta=p->b->tab-col%p->b->tab;
X  if(ta+col>scr)
X   {
X   ta-=scr-col;
X   goto dota;
X   }
X  if((col+=ta)==scr) { --amnt; goto loop; }
X  }
X else if(bc=='\n') goto eobl;
X else if(++col==scr) { --amnt; goto loop; }
X }
X while(--amnt);
if(bp==p->ptr+SEGSIZ)
X {
X if(pnext(p))
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole;
X  goto lp;
X  }
X else
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole+1;
X  }
X }
else
X {
X bp=p->ptr+p->hdr->ehole;
X amnt=SEGSIZ-p->hdr->ehole;
X goto lp;
X }
goto eof;
X
loop:		/* Display next character */
if(amnt) do
X {
X bc= *bp++;
X if(square)
X  if(col+x>=from && col+x<to) c=INVERSE;
X  else c=0;
X else
X  if(byte>=from && byte<to) c=INVERSE;
X  else c=0;
X ++byte;
X if(bc=='\t')
X  {
X  ta=p->b->tab-((x+scr)%p->b->tab);
X  dota:
X  do
X   {
X   if(screen[x]!=' '+c)
X    {
X    screen[x]=' '+c;
X    if(t->ins) clrins(t);
X    if(t->x!=x || t->y!=y) cpos(t,x,y);
X    if(c!=t->attrib) attr(t,c);
X    ttputc(' '); ++t->x;
X    if(have) goto bye;
X    }
X   if(++x==w) goto eosl;
X   }
X   while(--ta);
X  }
X else if(bc=='\n') goto eobl;
X else
X  {
X  if(!dspasis || bc<160 || bc>254)
X   {
X   if(bc&128) c^=INVERSE, bc&=127;
X   if(bc==127) c|=UNDERLINE, bc='?';
X   else if(bc<32) c|=UNDERLINE, bc+='@';
X   }
X  if(t->hz && bc=='~') bc='\\';
X  if(screen[x]!=c+bc)
X   {
X   screen[x]=c+bc;
X   if(t->ins) clrins(t);
X   if(t->x!=x || t->y!=y) cpos(t,x,y);
X   if(c!=t->attrib) attr(t,c);
X   ttputc(bc); ++t->x;
X   if(have) goto bye;
X   }
X  if(++x==w) goto eosl;
X  }
X }
X while(--amnt);
if(bp==p->ptr+SEGSIZ)
X {
X if(pnext(p))
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole;
X  goto loop;
X  }
X else
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole+1;
X  }
X }
else
X {
X bp=p->ptr+p->hdr->ehole;
X amnt=SEGSIZ-p->hdr->ehole;
X goto loop;
X }
goto eof;
X
eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
if(x!=w) done=eraeol(t,x,y);
else done=0;
X
/* Set p to bp/amnt */
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;
X
eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
}
X
/* Generate line into an array */
X
static int lgena(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta;
unsigned char bc;
X
/* Initialize bp and amnt from p */
if(p->ofst>=p->hdr->hole)
X {
X bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
X amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
X }
else
X {
X bp=p->ptr+p->ofst;
X amnt=p->hdr->hole-p->ofst;
X }
X
if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
X {
X bc= *bp++;
X if(square)
X  {
X  if(col>=from && col<to) c=INVERSE;
X  else c=0;
X  }
X else
X  {
X  if(byte>=from && byte<to) c=INVERSE;
X  else c=0;
X  }
X ++byte;
X if(bc=='\t')
X  {
X  ta=p->b->tab-col%p->b->tab;
X  if(ta+col>scr)
X   {
X   ta-=scr-col;
X   goto dota;
X   }
X  if((col+=ta)==scr) { --amnt; goto loop; }
X  }
X else if(bc=='\n') goto eobl;
X else if(++col==scr) { --amnt; goto loop; }
X }
X while(--amnt);
if(bp==p->ptr+SEGSIZ)
X {
X if(pnext(p))
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole;
X  goto lp;
X  }
X else
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole+1;
X  }
X }
else
X {
X bp=p->ptr+p->hdr->ehole;
X amnt=SEGSIZ-p->hdr->ehole;
X goto lp;
X }
goto eobl;
X
loop:		/* Display next character */
if(amnt) do
X {
X bc= *bp++;
X if(square)
X  if(col+x>=from && col+x<to) c=INVERSE;
X  else c=0;
X else
X  if(byte>=from && byte<to) c=INVERSE;
X  else c=0;
X ++byte;
X if(bc=='\t')
X  {
X  ta=p->b->tab-((x+scr)%p->b->tab);
X  dota:
X  do
X   {
X   screen[x]=' '+c;
X   if(++x==w) goto eosl;
X   }
X   while(--ta);
X  }
X else if(bc=='\n') goto eobl;
X else
X  {
X  if(!dspasis || bc<160 || bc>254)
X   {
X   if(bc&128) c^=INVERSE, bc&=127;
X   if(bc==127) c|=UNDERLINE, bc='?';
X   else if(bc<32) c|=UNDERLINE, bc+='@';
X   }
X  screen[x]=c+bc;
X  if(++x==w) goto eosl;
X  }
X }
X while(--amnt);
if(bp==p->ptr+SEGSIZ)
X {
X if(pnext(p))
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole;
X  goto loop;
X  }
X else
X  {
X  bp=p->ptr;
X  amnt=p->hdr->hole+1;
X  }
X }
else
X {
X bp=p->ptr+p->hdr->ehole;
X amnt=SEGSIZ-p->hdr->ehole;
X goto loop;
X }
goto eof;
eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
while(x!=w) screen[x++]=' ';
done=0;
X
/* Set p to bp/amnt */
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;
X
eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
}
X
void bwgen(w)
BW *w;
{
int *screen;
P *p=0;
P *q=pdup(w->cursor);
int bot=w->h+w->y;
int y;
int dosquare=0;
long from,to;
from=to=0;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   w->t->markb->b==w->b)
X if(square) from=w->t->markb->col, to=w->t->markk->col, dosquare=1;
X else from=w->t->markb->byte, to=w->t->markk->byte;
X
y=w->cursor->line-w->top->line+w->y;
for(screen=w->t->t->scrn+y*w->t->w;y!=bot; ++y, screen+=w->t->w)
X {
X if(have) break;
X if(w->t->t->updtab[y])
X  {
X  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
X  if(w->t->t->insdel && !w->x)
X   {
X   pset(q,p);
X   if(dosquare)
X    if(w->top->line+y-w->y>=w->t->markb->line &&
X       w->top->line+y-w->y<=w->t->markk->line)
X     lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,from,to);
X    else
X     lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
X   else
X    lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,from,to);
X   magic(w->t->t,y,screen,w->t->t->compose,
X         (int)(w->cursor->xcol-w->offset+w->x));
X   }
X  if(dosquare)
X   if(w->top->line+y-w->y>=w->t->markb->line &&
X      w->top->line+y-w->y<=w->t->markk->line)
X    w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                            from,to);
X   else
X    w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                            0L,0L);
X  else
X   w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                           from,to);
X  }
X }
X 
y=w->y;
for(screen=w->t->t->scrn+w->y*w->t->w; y!=w->y+w->cursor->line-w->top->line;
X    ++y, screen+=w->t->w)
X {
X if(have) break;
X if(w->t->t->updtab[y])
X  {
X  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
X  if(w->t->t->insdel && !w->x)
X   {
X   pset(q,p);
X   if(dosquare)
X    if(w->top->line+y-w->y>=w->t->markb->line &&
X       w->top->line+y-w->y<=w->t->markk->line)
X     lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,from,to);
X    else
X     lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
X   else
X    lgena(w->t->t,y,w->t->t->compose,w->x,w->x+w->w,q,w->offset,from,to);
X   magic(w->t->t,y,screen,w->t->t->compose,
X         (int)(w->cursor->xcol-w->offset+w->x));
X   }
X  if(dosquare)
X   if(w->top->line+y-w->y>=w->t->markb->line &&
X      w->top->line+y-w->y<=w->t->markk->line)
X    w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                            from,to);
X   else
X    w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                            0L,0L);
X  else
X   w->t->t->updtab[y]=lgen(w->t->t,y,screen,w->x,w->x+w->w,p,w->offset,
X                           from,to);
X  }
X }
prm(q);
if(p) prm(p);
}
X
void bwmove(w,x,y)
BW *w;
int x,y;
{
w->x=x;
w->y=y;
}
X
void bwresz(w,wi,he)
BW *w;
int wi, he;
{
if(he>w->h && w->y!= -1) msetI(w->t->t->updtab+w->y+w->h,1,he-w->h);
w->w=wi;
w->h=he;
}
X
BW *bwmk(t,b,x,y,wi,h)
SCREEN *t;
B *b;
int x,y,wi,h;
{
BW *w=(BW *)malloc(sizeof(BW));
w->b=b;
w->x=x;
w->y=y;
w->w=wi;
w->h=h;
X
w->lmargin=0;
w->rmargin=76;
w->autoindent=0;
w->wordwrap=0;
w->overtype=0;
w->indentc=' ';
w->istep=1;
X
w->top=pdup(b->bof);
w->cursor=pdup(w->top);
w->t=t; 
w->object=NULL;
w->offset=0;
return w;
}
X
void bwrm(w)
BW *w;
{
prm(w->top);
prm(w->cursor);
brm(w->b);
free(w);
}
X
void ustat(w)
W *w;
{
BW *bw=(BW *)w->object;
static char buf[80];
unsigned c=brc(bw->cursor);
if(c==MAXINT)
X sprintf(buf,"** ROW=%ld COL=%ld BYTE=%ld/0x%X **",
X         bw->cursor->line+1,bw->cursor->col+1,bw->cursor->byte,
X         bw->cursor->byte,bw->b->eof->line+1,bw->b->eof->byte+1);
else
X sprintf(buf,"** ROW=%ld COL=%ld BYTE=%ld/0x%X CHAR=%d/0%o/0x%X **",
X         bw->cursor->line+1,bw->cursor->col+1,bw->cursor->byte,
X         bw->cursor->byte,c,c,c);
msgnw(w,buf);
}
SHAR_EOF
chmod 0600 bw.c ||
echo 'restore of bw.c failed'
Wc_c="`wc -c < 'bw.c'`"
test 13764 -eq "$Wc_c" ||
	echo 'bw.c: original size 13764, current size' "$Wc_c"
fi
# ============= bw.h ==============
if test -f 'bw.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bw.h (File already exists)'
else
echo 'x - extracting bw.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bw.h' &&
/* Edit buffer window generation
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ibw
#define _Ibw 1
X
#include "config.h"
#include "b.h"
#include "w.h"
X
extern int dspasis;
X
typedef struct bw BW;
X
struct bw
X {
X B *b;
X P *top;
X P *cursor;
X long offset;
X SCREEN *t;
X int h,w,x,y;
X 
X long lmargin;
X long rmargin;
X int autoindent;
X int wordwrap;
X int overtype;
X long istep;
X int indentc;
X 
X void *object;
X };
X
extern int mid;
void bwfllw();
void bwins();
void bwdel();
void bwgen();
BW *bwmk();
void bwmove();
void bwresz();
void bwrm();
void ustat();
X
#endif
SHAR_EOF
chmod 0600 bw.h ||
echo 'restore of bw.h failed'
Wc_c="`wc -c < 'bw.h'`"
test 1252 -eq "$Wc_c" ||
	echo 'bw.h: original size 1252, current size' "$Wc_c"
fi
# ============= config.h ==============
if test -f 'config.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config.h (File already exists)'
else
echo 'x - extracting config.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config.h' &&
/* Configuration file for 32-bit systems */
X
#ifndef _Iconfig
#define _Iconfig 1
X
/* Integer size quantities
X * MAXINT Maximum signed integer
X * ISIZ   Number of chars in an int
X * SHFT   LOG2 of ISIZ
X */
X
#define MAXINT 0x7FFFFFFF
#define ISIZ 4
#define SHFT 2
X
/* Support for segmented systems
X * physical(addr)   Return a linear address given a pointer
X * normalize(addr)  Normalize a pointer so that the offset part is minimized
X */
X
#define physical(a) ((long)(a))
#define normalize(a) (a)
X
#define BITS 8			/* Number of bits in a char */
#define MAXLONG 0x7FFFFFFF
X
/* Uncomment the following line if your compiler has trouble with void */
/* #define void int */
X
#ifndef NULL
#define NULL ((void *)0)
#endif
X
/* These are for optimizing blocks.c */
/* #define AUTOINC */	/* Define this if CPU can autoincrement faster than
X			   it can do [reg+offset] addressing */
/* #define ALIGNED */	/* Define this if CPU can access unaligned ints */
X			/* (tries to align ints even if defined) */
X
/* System calls we use */
char *getenv();
long time();
/*
int chdir();
int creat();
int open();
int close();
int read();
int write();
int lseek();
*/
X
#endif
SHAR_EOF
chmod 0600 config.h ||
echo 'restore of config.h failed'
Wc_c="`wc -c < 'config.h'`"
test 1152 -eq "$Wc_c" ||
	echo 'config.h: original size 1152, current size' "$Wc_c"
fi
# ============= config16.h ==============
if test -f 'config16.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config16.h (File already exists)'
else
echo 'x - extracting config16.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config16.h' &&
/* Configuration file for 16-bit systems */
X
#ifndef _Iconfig
#define _Iconfig 1
X
/* Integer size quantities
X * MAXINT Maximum signed integer
X * ISIZ   Number of chars in an int
X * SHFT   LOG2 of ISIZ
X */
X
#define MAXINT 0x7FFF
#define ISIZ 2
#define SHFT 1
X
/* Support for segmented systems
X * physical(addr)   Return a linear address given a pointer
X * normalize(addr)  Normalize a pointer so that the offset part is minimized
X */
X
#define physical(a) ((long)(a))
#define normalize(a) (a)
X
#define BITS 8			/* Number of bits in a char */
#define MAXLONG 0x7FFFFFFF
X
/* Uncomment the following line if your compiler has trouble with void */
/* #define void int */
X
/* NULL should only be used for data-pointers, not function pointers,
X * (because of medium model MSDOS)
X */
#ifndef NULL
#define NULL ((void *)0)
#endif
X
/* These are for optimizing blocks.c */
/* #define AUTOINC */	/* Define this if CPU can autoincrement faster than
X			   it can do [reg+offset] addressing */
/* #define ALIGNED */	/* Define this if CPU can access unaligned ints */
X			/* (tries to align ints even if defined) */
X
/* System calls we use */
char *getenv();
char *getcwd();
long time();
/*
int chdir();
int creat();
int open();
int close();
int read();
int write();
int lseek();
*/
X
#endif
SHAR_EOF
chmod 0600 config16.h ||
echo 'restore of config16.h failed'
Wc_c="`wc -c < 'config16.h'`"
test 1273 -eq "$Wc_c" ||
	echo 'config16.h: original size 1273, current size' "$Wc_c"
fi
# ============= config32.h ==============
if test -f 'config32.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config32.h (File already exists)'
else
echo 'x - extracting config32.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config32.h' &&
/* Configuration file for 32-bit systems */
X
#ifndef _Iconfig
#define _Iconfig 1
X
/* Integer size quantities
X * MAXINT Maximum signed integer
X * ISIZ   Number of chars in an int
X * SHFT   LOG2 of ISIZ
X */
X
#define MAXINT 0x7FFFFFFF
#define ISIZ 4
#define SHFT 2
X
/* Support for segmented systems
X * physical(addr)   Return a linear address given a pointer
X * normalize(addr)  Normalize a pointer so that the offset part is minimized
X */
X
#define physical(a) ((long)(a))
#define normalize(a) (a)
X
#define BITS 8			/* Number of bits in a char */
#define MAXLONG 0x7FFFFFFF
X
/* Uncomment the following line if your compiler has trouble with void */
/* #define void int */
X
#ifndef NULL
#define NULL ((void *)0)
#endif
X
/* These are for optimizing blocks.c */
/* #define AUTOINC */	/* Define this if CPU can autoincrement faster than
X			   it can do [reg+offset] addressing */
/* #define ALIGNED */	/* Define this if CPU can access unaligned ints */
X			/* (tries to align ints even if defined) */
X
/* System calls we use */
char *getenv();
long time();
/*
int chdir();
int creat();
int open();
int close();
int read();
int write();
int lseek();
*/
X
#endif
SHAR_EOF
chmod 0600 config32.h ||
echo 'restore of config32.h failed'
Wc_c="`wc -c < 'config32.h'`"
test 1152 -eq "$Wc_c" ||
	echo 'config32.h: original size 1152, current size' "$Wc_c"
fi
# ============= config86.h ==============
if test -f 'config86.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config86.h (File already exists)'
else
echo 'x - extracting config86.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config86.h' &&
/* Configuration file for 8086 segmented systems */
X
#ifndef _Iconfig
#define _Iconfig 1
X
/* Integer size quantities
X * MAXINT Maximum signed integer
X * ISIZ   Number of chars in an int
X * SHFT   LOG2 of ISIZ
X */
X
#define MAXINT 0x7FFF
#define ISIZ 2
#define SHFT 1
X
/* Support for segmented systems
X * physical(addr)   Return a linear address given a pointer
X * normalize(addr)  Normalize a pointer so that the offset part is minimized
X */
X
#define physical(a) (((long)(a)&0xFFFF)+(((unsigned long)(a)&0xFFFF0000)>>12))
#define normalize(a) \
X ((void *)(((long)(a)&0xFFFF000F)+(((long)(a)&0x0000FFF0)<<12)))
X
#define BITS 8			/* Number of bits in a char */
#define MAXLONG 0x7FFFFFFF
X
/* Uncomment the following line if your compiler has trouble with void */
/* #define void int */
X
/* NULL should only be used for data-pointers, not function pointers,
X * (because of medium model MSDOS)
X */
#ifndef NULL
#define NULL ((void *)0)
#endif
X
/* These are for optimizing blocks.c */
/* #define AUTOINC */	/* Define this if CPU can autoincrement faster than
X			   it can do [reg+offset] addressing */
/* #define ALIGNED */	/* Define this if CPU can access unaligned ints */
X			/* (tries to align ints even if defined) */
X
/* System calls we use */
char *getenv();
char *getcwd();
long time();
/*
int chdir();
int creat();
int open();
int close();
int read();
int write();
int lseek();
*/
X
#endif
SHAR_EOF
chmod 0600 config86.h ||
echo 'restore of config86.h failed'
Wc_c="`wc -c < 'config86.h'`"
test 1391 -eq "$Wc_c" ||
	echo 'config86.h: original size 1391, current size' "$Wc_c"
fi
# ============= copying ==============
if test -f 'copying' -a X"$1" != X"-c"; then
	echo 'x - skipping copying (File already exists)'
else
echo 'x - extracting copying (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'copying' &&
X
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.
You can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
X
X  The precise terms and conditions for copying, distribution and
modification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
contains a notice placed by the copyright holder saying it may be
distributed under the terms of this General Public License.  The
"Program", below, refers to any such program or work, and a "work based
on the Program" means either the Program or any work containing the
Program or a portion of it, either verbatim or with modifications.  Each
licensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
code as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
General Public License and to the absence of any warranty; and give any
other recipients of the Program a copy of this General Public License
along with the Program.  You may charge a fee for the physical act of
transferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
it, and copy and distribute such modifications under the terms of Paragraph
1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
Mere aggregation of another independent work with the Program (or its
derivative) on a volume of a storage or distribution medium does not bring
the other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
it, under Paragraph 2) in object code or executable form under the terms of
Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
Source code for a work means the preferred form of the work for making
modifications to it.  For an executable file, complete source code means
all the source code for all modules it contains; but, as a special
exception, it need not include source code for modules which are standard
libraries that accompany the operating system on which the executable
file runs, or for standard header files or definitions files that
accompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
Program except as expressly provided under this General Public License.
Any attempt otherwise to copy, modify, sublicense, distribute or transfer
the Program is void, and will automatically terminate your rights to use
the Program under this License.  However, parties who have received
copies, or rights to use copies, from you under this General Public
License will not have their licenses terminated so long as such parties
remain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
on the Program) you indicate your acceptance of this license to do so,
and all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the original
licensor to copy, distribute or modify the Program subject to these
terms and conditions.  You may not impose any further restrictions on the
recipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
X
Each version is given a distinguishing version number.  If the Program
specifies a version number of the license which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
the license, you may choose any version ever published by the Free Software
Foundation.
X
X  8. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.
X
X  To do so, attach the following notices to the program.  It is safest to
attach them to the start of each source file to most effectively convey
the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Also add information on how to contact you by electronic and paper mail.
X
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19xx name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.
X
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  program `Gnomovision' (a program to direct compilers to make passes
X  at assemblers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
That's all there is to it!
SHAR_EOF
chmod 0600 copying ||
echo 'restore of copying failed'
Wc_c="`wc -c < 'copying'`"
test 12488 -eq "$Wc_c" ||
	echo 'copying: original size 12488, current size' "$Wc_c"
fi
# ============= edfuncs.c ==============
if test -f 'edfuncs.c' -a X"$1" != X"-c"; then
	echo 'x - skipping edfuncs.c (File already exists)'
else
echo 'x - extracting edfuncs.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'edfuncs.c' &&
/* User edit functions
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include "config.h"
#include "tty.h"
#include "b.h"
#include "w.h"
#include "termcap.h"
#include "vfile.h"
#include "toomany.h"
#include "scrn.h"
#include "vs.h"
#include "bw.h"
#include "pw.h"
#include "tw.h"
#include "zstr.h"
#include "main.h"
#include "edfuncs.h"
X
int square=0;		/* Rectangle mode */
X
B *filehist=0;
B *filthist=0;
B *linehist=0;
B *taghist=0;
X
char *msgs[]=
{
"Error writing file",
"Error opening file",
"Error seeking file",
"Error reading file",
"New File"
};
X
/****************/
/* Window stuff */
/****************/
X
void uprevw(w)
W *w;
{
wprev(w->t);
}
X
void unextw(w)
W *w;
{
wnext(w->t);
}
X
void ugroww(w)
W *w;
{
wgrow(w);
}
X
void ushrnk(w)
W *w;
{
wshrink(w);
}
X
void uexpld(w)
W *w;
{
if(w->t->h-w->t->wind==getgrouph(w)) wshowall(w->t);
else wshowone(w);
}
X
/******************************/
/* Rectangle mode subroutines */
/******************************/
X
void pfill(p,to,usetabs)
P *p;
long to;
{
if(usetabs)
X while(p->col<to)
X  if(p->col+p->b->tab-p->col%p->b->tab<=to) binsc(p,'\t'), pgetc(p);
X  else binsc(p,' '), pgetc(p);
else while(p->col<to) binsc(p,' '), pgetc(p);
}
X
/* Insert rectangle into buffer
X * returns width of inserted matter
X */
X
long pinsrect(cur,tmp)
P *cur;
B *tmp;
{
P *p=pdup(cur);
P *q=pdup(tmp->bof);
P *r=pdup(q);
int usetabs=0;
long width=0;
do
X {
X long wid=cur->col;
X while(!piseol(q))
X  if(pgetc(q)=='\t') wid+=cur->b->tab-wid%cur->b->tab, usetabs=1;
X  else ++wid;
X if(wid-cur->col>width) width=wid-cur->col;
X } while(pgetc(q)!=MAXINT);
if(width)
X {
X pset(q,tmp->bof);
X while(pset(r,q), peol(q), (q->line!=tmp->eof->line || q->col))
X  {
X  pcol(p,cur->col);
X  if(p->col<cur->col) pfill(p,cur->col,usetabs);
X  binsb(p,r,q); pfwrd(p,q->byte-r->byte);
X  if(p->col<cur->col+width) pfill(p,cur->col+width,usetabs);
X  if(!pnextl(p)) binsc(p,'\n'), pgetc(p);
X  if(pgetc(q)==MAXINT) break;
X  }
X }
prm(p); prm(q); prm(r);
return width;
}
X
/* Overwrite version of above */
X
long povrrect(cur,tmp)
P *cur;
B *tmp;
{
P *p=pdup(cur);
P *q=pdup(tmp->bof);
P *r=pdup(q);
P *z=pdup(cur);
int usetabs=0;
long width=0;
long curcol=cur->col;
do
X {
X long wid=curcol;
X while(!piseol(q))
X  if(pgetc(q)=='\t') wid+=cur->b->tab-wid%cur->b->tab, usetabs=1;
X  else ++wid;
X if(wid-curcol>width) width=wid-curcol;
X } while(pgetc(q)!=MAXINT);
if(width)
X {
X pset(q,tmp->bof);
X while(pset(r,q), peol(q), (q->line!=tmp->eof->line || q->col))
X  {
X  pcol(p,curcol);
X  if(p->col<curcol) pfill(p,curcol,usetabs);
X  pset(z,p); pcol(z,curcol+width); bdel(p,z);
X  binsb(p,r,q); pfwrd(p,q->byte-r->byte);
X  if(p->col<curcol+width) pfill(p,curcol+width,usetabs);
X  if(!pnextl(p)) binsc(p,'\n'), pgetc(p);
X  if(pgetc(q)==MAXINT) break;
X  }
X }
prm(p); prm(q); prm(r); prm(z);
return width;
}
X
/* Extract rectangle into a buffer */
X
B *pextrect(up,down,left,right)
P *up, *down;
long left,right;
{
P *p=pdup(up);
P *q=pdup(p);
B *tmp=bmk();
P *z=pdup(tmp->eof);
pbol(p);
do
X {
X pcol(p,left);
X pset(q,p);
X pcol(q,right);
X pset(z,tmp->eof); binsb(z,p,q);
X pset(z,tmp->eof); binsc(z,'\n');
X } while(pnextl(p) && p->line<=down->line);
prm(p); prm(q); prm(z);
return tmp;
}
X
/* Delete rectangle.  Returns true if tabs were used */
X
int pdelrect(up,down,left,right,overtype)
P *up, *down;
long left,right;
{
P *p=pdup(up);
P *q=pdup(p);
int usetabs=0;
if(overtype)
X {
X int c;
X pbol(p);
X do
X  {
X  pcol(p,left);
X  pset(q,p);
X  pcol(q,right);
X  while(p->byte<q->byte) if(pgetc(p)=='\t') { usetabs=1; break; }
X  if(usetabs) break;
X  } while(pnextl(p) && p->line<=down->line);
X pset(p,up);
X }
pbol(p);
do
X {
X pcol(p,left);
X pset(q,p);
X pcol(q,right);
X bdel(p,q);
X if(overtype) pfill(p,right,usetabs);
X } while(pnextl(p) && p->line<=down->line);
prm(p); prm(q);
return usetabs;
}
X
/***************/
/* Block stuff */
/***************/
X
void umarkb(w)
W *w;
{
BW *bw=(BW *)w->object;
pdupown(bw->cursor,&w->t->markb);
updall();
}
X
void umarkk(w)
W *w;
{
BW *bw=(BW *)w->object;
pdupown(bw->cursor,&w->t->markk);
updall();
}
X
void ublkdel(w)
W *w;
{
BW *bw=(BW *)w->object;
if(w->t->markb && w->t->markk &&
X   w->t->markb->b==w->t->markk->b &&
X   w->t->markk->byte>w->t->markb->byte &&
X   (!square || w->t->markb->col<w->t->markk->col))
X if(square)
X  {
X  pdelrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col,
X           bw->overtype);
X  return;
X  }
X else
X  {
X  bdel(w->t->markb,w->t->markk);
X  prm(w->t->markb);
X  prm(w->t->markk);
X  return;
X  }
msgnw(w,"No block");
}
X
void ublkmove(w)
W *w;
{
BW *bw=(BW *)w->object;
long size;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   (size=w->t->markk->byte-w->t->markb->byte)>0 &&
X   (!square || w->t->markb->col<w->t->markk->col))
X if(square)
X  {
X  long height=w->t->markk->line-w->t->markb->line;
X  long width;
X  long ocol=bw->cursor->col;
X  B *tmp=pextrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col);
X  pdelrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col,
X           bw->overtype);
X  if(bw->overtype)
X   {
X   while(bw->cursor->col<ocol)
X    if(brc(bw->cursor)==' ') pgetc(bw->cursor);
X    else if(bw->cursor->col+bw->b->tab-bw->cursor->col%bw->b->tab<=
X            bw->cursor->col) pgetc(bw->cursor);
X    else binsc(bw->cursor,' '), pgetc(bw->cursor);
X   width=povrrect(bw->cursor,tmp);
X   }
X  else width=pinsrect(bw->cursor,tmp);
X  brm(tmp);
X  while(bw->cursor->col<ocol) pgetc(bw->cursor);
X  umarkb(w);
X  umarkk(w);
X  pline(w->t->markk,w->t->markk->line+height);
X  pcol(w->t->markk,w->t->markb->col+width);
X  return;
X  }
X else if(bw->cursor->b!=w->t->markk->b ||
X         bw->cursor->byte>w->t->markk->byte ||
X         bw->cursor->byte<w->t->markb->byte)
X  {
X  binsb(bw->cursor,w->t->markb,w->t->markk);
X  ublkdel(w);
X  umarkb(w);
X  umarkk(w);
X  pfwrd(w->t->markk,size);
X  updall();
X  return;
X  }
msgnw(w,"No block");
}
X
void ublkcpy(w)
W *w;
{
BW *bw=(BW *)w->object;
long size;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   (size=w->t->markk->byte-w->t->markb->byte)>0 &&
X   (!square || w->t->markb->col < w->t->markk->col))
X if(square)
X  {
X  B *tmp=pextrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col);
X  long width;
X  long height;
X  if(bw->overtype) width=povrrect(bw->cursor,tmp);
X  else width=pinsrect(bw->cursor,tmp);
X  height=w->t->markk->line-w->t->markb->line;
X  brm(tmp);
X  umarkb(w);
X  umarkk(w);
X  pline(w->t->markk,w->t->markk->line+height);
X  pcol(w->t->markk,w->t->markb->col+width);
X  return;
X  }
X else
X  {
X  binsb(bw->cursor,w->t->markb,w->t->markk);
X  umarkb(w);
X  umarkk(w);
X  pfwrd(w->t->markk,size);
X  updall();
X  return;
X  }
msgnw(w,"No block");
}
X
void ushell(w)
W *w;
{
nescape(w->t->t);
ttsusp();
nreturn(w->t->t);
}
X
void dowrite(w,s)
W *w;
char *s;
{
long size;
int fl;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   (size=w->t->markk->byte-w->t->markb->byte)>0 &&
X   (!square || w->t->markk->col>w->t->markb->col))
X {
X if(square)
X  {
X  B *tmp=pextrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col);
X  if(fl=bsave(tmp->bof,s,tmp->eof->byte)) msgnw(w,msgs[5+fl]);
X  brm(tmp);
X  }
X else if(fl=bsave(w->t->markb,s,size)) msgnw(w,msgs[5+fl]);
X }
else msgnw(w,"No block");
vsrm(s);
}
X
void ublksave(w)
W *w;
{
BW *bw=(BW *)w->object;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   (w->t->markk->byte-w->t->markb->byte)>0 &&
X   (!square || w->t->markk->col>w->t->markb->col))
X {
X wmkfpw(w,"Name of file to write (^C to abort): ",&filehist,dowrite,"Names");
X return;
X }
msgnw(w,"No block");
}
X
long pindent();
X
void setindent(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p, *q;
long indent;
if(pblank(bw->cursor)) return;
X
p=pdup(bw->cursor);
q=pdup(p);
indent=pindent(p);
X
do
X if(!pprevl(p)) goto done;
X else pboln(p);
X while(pindent(p)>=indent && !pblank(p));
pnextl(p);
done:
pboln(p);
if(w->t->markb) prm(w->t->markb);
w->t->markb=p; p->owner=&w->t->markb;
X
do
X if(!pnextl(q)) break;
X while(pindent(q)>=indent && !pblank(q));
pfcol(q);
X
if(w->t->markk) prm(w->t->markk);
w->t->markk=q; q->owner=&w->t->markk;
X
updall();
}
X
void urindent(w)
W *w;
{
BW *bw=(BW *)w->object;
if(square)
X {
X if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X    w->t->markb->byte<=w->t->markk->byte && w->t->markb->col<=w->t->markk->col)
X  {
X  P *p=pdup(w->t->markb);
X  do
X   {
X   pcol(p,w->t->markb->col);
X   pfill(p,w->t->markb->col+bw->istep,bw->indentc=='\t'?1:0);
X   } while(pnextl(p) && p->line<=w->t->markk->line);
X  prm(p);
X  }
X return;
X }
if(!w->t->markb || !w->t->markk || w->t->markb->b!=w->t->markk->b ||
X   bw->cursor->byte<w->t->markb->byte || bw->cursor->byte>w->t->markk->byte)
X {
X setindent(w);
X }
else
X {
X P *p=pdup(w->t->markb);
X while(p->byte<w->t->markk->byte)
X  {
X  pbol(p);
X  while(p->col<bw->istep) binsc(p,bw->indentc), pgetc(p);
X  pnextl(p);
X  }
X prm(p);
X }
}
X
void ulindent(w)
W *w;
{
BW *bw=(BW *)w->object;
if(square)
X {
X if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X    w->t->markb->byte<=w->t->markk->byte && w->t->markb->col<=w->t->markk->col)
X  {
X  P *p=pdup(w->t->markb);
X  P *q=pdup(p);
X  do
X   {
X   pcol(p,w->t->markb->col);
X   while(p->col<w->t->markb->col+bw->istep)
X    {
X    int c=pgetc(p);
X    if(c!=' ' && c!='\t' && c!=bw->indentc)
X     {
X     prm(p);
X     prm(q);
X     return;
X     }
X    }
X   } while(pnextl(p) && p->line<=w->t->markk->line);
X  pset(p,w->t->markb);
X  do
X   {
X   pcol(p,w->t->markb->col);
X   pset(q,p);
X   pcol(q,w->t->markb->col+bw->istep);
X   bdel(p,q);
X   } while(pnextl(p) && p->line<=w->t->markk->line);
X  prm(p); prm(q);
X  }
X return;
X }
if(!w->t->markb || !w->t->markk || w->t->markb->b!=w->t->markk->b ||
X   bw->cursor->byte<w->t->markb->byte || bw->cursor->byte>w->t->markk->byte)
X {
X setindent(w);
X }
else
X {
X P *p=pdup(w->t->markb);
X P *q=pdup(p);
X pbol(p);
X while(p->byte<w->t->markk->byte)
X  {
X  if(pindent(p)<bw->istep) { prm(p); return; }
X  pnextl(p);
X  }
X pset(p,w->t->markb);
X pbol(p);
X while(p->byte<w->t->markk->byte)
X  {
X  pset(q,p);
X  while(q->col<bw->istep) pgetc(q);
X  bdel(p,q);
X  pnextl(p);
X  }
X prm(p); prm(q);
X }
}
X
static void dofilt(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
int fr[2];
int fw[2];
char c;
X
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   w->t->markk->byte>w->t->markb->byte &&
X   (!square || w->t->markk->col>w->t->markb->col)) goto go;
msgnw(w,"No block");
return;
X
go:
X
pipe(fr);
pipe(fw);
nescape(w->t->t);
ttclsn();
if(!fork())
X {
X signrm();
X close(0);
X close(1);
X dup(fw[0]);
X dup(fr[1]);
X close(fw[0]);
X close(fr[1]);
X close(fw[1]);
X close(fr[0]);
X execl("/bin/sh","/bin/sh","-c",s,NULL);
X _exit(0);
X }
close(fr[1]);
close(fw[0]);
if(fork())
X {
X long szz;
X close(fw[1]);
X if(square)
X  {
X  B *tmp=bmk();
X  long width;
X  long height;
X  pdelrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col,
X           bw->overtype);
X  binsfd(tmp->bof,fr[0],MAXLONG);
X  if(bw->overtype) width=povrrect(w->t->markb,tmp);
X  else width=pinsrect(w->t->markb,tmp);
X  if(tmp->eof->col || !tmp->eof->line) height=tmp->eof->line;
X  else height=tmp->eof->line-1;
X  pdupown(w->t->markb,&w->t->markk);
X  pline(w->t->markk,w->t->markk->line+height);
X  pcol(w->t->markk,w->t->markb->col+width);
X  brm(tmp);
X  updall();
X  }
X else
X  {
X  bdel(w->t->markb,w->t->markk);
X  szz=w->t->markk->b->eof->byte;
X  binsfd(w->t->markk,fr[0],MAXLONG);
X  pfwrd(w->t->markk,w->t->markk->b->eof->byte-szz);
X  }
X close(fr[0]);
X wait(0);
X wait(0);
X }
else
X {
X if(square)
X  {
X  B *tmp=pextrect(w->t->markb,w->t->markk,w->t->markb->col,w->t->markk->col);
X  bsavefd(tmp->bof,fw[1],tmp->eof->byte);
X  }
X else bsavefd(w->t->markb,fw[1],w->t->markk->byte-w->t->markb->byte);
X close(fw[1]);
X _exit(0);
X }
vsrm(s);
ttopnn();
nreturn(w->t->t);
bw->cursor->xcol=bw->cursor->col;
}
X
void ufilt(w)
W *w;
{
BW *bw=(BW *)w->object;
if(w->t->markb && w->t->markk && w->t->markb->b==w->t->markk->b &&
X   (w->t->markk->byte-w->t->markb->byte)>0)
X {
X wmkpw(w,"Command to filter block through (^C to abort): ",
X       &filthist,dofilt,NULL);
X return;
X }
msgnw(w,"No block");
}
X
/****************************/
/* File loading and storing */
/****************************/
X
static int backup(w)
W *w;
{
BW *bw=(BW *)w->object;
if(!bw->b->backup)
X {
X char *s=0;
X /* Create command string */
X s=vsncpy(s,0,sc("/bin/cp "));
X s=vsncpy(s,sLEN(s),sz(bw->b->name));
X s=vsadd(s,' ');
X s=vsncpy(s,sLEN(s),sz(bw->b->name));
X s=vsncpy(s,sLEN(s),sc("~ 2>/dev/null"));
X
X if(system(s))
X  {
X  msgnw(w,"Couldn't make backup file... file not saved");
X  vsrm(s);
X  return 1;
X  }
X else
X  {
X  bw->b->backup=1;
X  vsrm(s);
X  return 0;
X  }
X }
else return 0;
}
X
static int dosave(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
FILE *f;
int fl;
if(backup(w)) { vsrm(s); return 1; }
if(fl=bsave(bw->b->bof,s,bw->b->eof->byte))
X {
X msgnw(w,msgs[fl+5]);
X vsrm(s);
X return 1;
X }
else
X {
X if(!bw->b->name) bw->b->name=zdup(s);
X if(!zcmp(bw->b->name,s)) bw->b->chnged=0;
X vsrm(s);
X return 0;
X }
}
X
void usave(w)
W *w;
{
BW *bw=(BW *)w->object;
W *pw=wmkfpw(w,"Name of file to save (^C to abort): ",&filehist,dosave,"Names");
if(pw && bw->b->name)
X {
X BW *pbw=(BW *)pw->object;
X binss(pbw->cursor,bw->b->name);
X pset(pbw->cursor,pbw->b->eof); pbw->cursor->xcol=pbw->cursor->col;
X }
}
X
static void doedit(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
void *object=bw->object;
B *b=bfind(s);
if(!b)
X {
X b=bmk();
X if(!zlen(s))
X  msgnwt(w,"New file ");
X else
X  {
X  int fl;
X  if(fl=bload(b,s)) msgnwt(w,msgs[fl+5]);
X  }
X }
bwrm(bw);
w->object=(void *)(bw=bwmk(w->t,b,w->x,w->y+1,w->w,w->h-1));
wredraw(w);
setoptions(bw,s);
bw->object=object;
vsrm(s);
}
X
void uedit(w)
W *w;
{
BW *bw=(BW *)w->object;
if(bw->b->count==1 && bw->b->chnged)
X {
X int c=query(w,"Do you really want to throw away this file (y,n)? ");
X if(c!='y' && c!='Y') return;
X }
wmkfpw(w,"Name of file to edit (^C to abort): ",&filehist,doedit,"Names");
}
X
static void doinsf(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
int fl;
if(square)
X {
X B *tmp=bmk();
X if(fl=binsf(tmp->bof,s)) msgnw(w,msgs[fl+5]);
X else
X  if(bw->overtype) povrrect(bw->cursor,tmp);
X  else pinsrect(bw->cursor,tmp);
X brm(tmp);
X }
else
X if(fl=binsf(bw->cursor,s)) msgnw(w,msgs[fl+5]);
vsrm(s);
bw->cursor->xcol=bw->cursor->col;
}
X
void uinsf(w)
W *w;
{
BW *bw=(BW *)w->object;
wmkfpw(w,"Name of file to insert (^C to abort): ",&filehist,doinsf,"Names");
}
X
extern char *exmsg;
X
static void doex(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
bw->b->name=zdup(s); 
if(dosave(w,s)) { free(bw->b->name); bw->b->name=0; return; }
exmsg=vsncpy(NULL,0,sc("File "));
exmsg=vsncpy(exmsg,sLEN(exmsg),sz(bw->b->name));
exmsg=vsncpy(exmsg,sLEN(exmsg),sc(" saved."));
bw->b->chnged=0;
wabort(w);
}
X
void uexsve(w)
W *w;
{
BW *bw=(BW *)w->object;
if(!bw->b->chnged)
X {
X exmsg=vsncpy(NULL,0,sc("File "));
X exmsg=vsncpy(exmsg,sLEN(exmsg),sz(bw->b->name));
X exmsg=vsncpy(exmsg,sLEN(exmsg),sc(" not changed so no updated needed."));
X wabort(w);
X return;
X }
if(bw->b->name)
X {
X if(dosave(w,vsncpy(NULL,0,sz(bw->b->name)))) return;
X exmsg=vsncpy(NULL,0,sc("File "));
X exmsg=vsncpy(exmsg,sLEN(exmsg),sz(bw->b->name));
X exmsg=vsncpy(exmsg,sLEN(exmsg),sc(" saved."));
X bw->b->chnged=0;
X wabort(w);
X } 
else wmkfpw(w,"Name of file to save (^C to abort): ",&filehist,doex,"Names");
}
X
/*************/
/* Goto line */
/*************/
X
static void doline(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
long num=0;
sscanf(s,"%ld",&num);
if(num>=1) pline(bw->cursor,num-1), bw->cursor->xcol=bw->cursor->col;
else msgnw(w,"Invalid line number");
vsrm(s);
}
X
void uline(w)
W *w;
{
wmkpw(w,"Goto line (^C to abort): ",&linehist,doline,NULL);
}
X
/************************/
/* Basic edit functions */
/************************/
X
void uquote(w)
W *w;
{
BW *bw=(BW *)w->object;
int c=queryn(w,"Ctrl-");
if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
if(c=='?') c=127;
utype(w,c);
}
X
void uquote8(w)
W *w;
{
BW *bw=(BW *)w->object;
int c=queryn(w,"Meta-");
if(c=='`')
X {
X c=queryn(w,"Meta-Ctrl-");
X if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
X if(c=='?') c=127;
X }
c|=128;
utype(w,c);
}
X
void uretyp(w)
W *w;
{
BW *bw=(BW *)w->object;
nredraw(w->t->t);
}
X
P *pboi(p)
P *p;
{
pbol(p);
while(cwhite(brc(p))) pgetc(p);
return p;
}
X
int pisedge(p)
P *p;
{
P *q;
int c;
if(pisbol(p)) return 1;
if(piseol(p)) return 1;
q=pdup(p);
pboi(q);
if(q->byte==p->byte) goto yes;
if(cwhite(c=brc(p)))
X {
X pset(q,p); if(cwhite(prgetc(q))) goto no;
X if(c=='\t') goto yes;
X pset(q,p); pgetc(q);
X if(pgetc(q)==' ') goto yes;
X goto no;
X }
else
X {
X pset(q,p); c=prgetc(q);
X if(c=='\t') goto yes;
X if(c!=' ') goto no;
X if(prgetc(q)==' ') goto yes;
X goto no;
X }
X
yes: prm(q); return 1;
no:  prm(q); return 0;
}
X
void upedge(w)
W *w;
{
BW *bw=(BW *)w->object;
prgetc(bw->cursor);
while(!pisedge(bw->cursor)) prgetc(bw->cursor);
}
X
void unedge(w)
W *w;
{
BW *bw=(BW *)w->object;
pgetc(bw->cursor);
while(!pisedge(bw->cursor)) pgetc(bw->cursor);
}
X
void ubol(w)
W *w;
{
BW *bw=(BW *)w->object;
pbol(bw->cursor);
}
X
void ueol(w)
W *w;
{
BW *bw=(BW *)w->object;
peol(bw->cursor);
}
X
void ubof(w)
W *w;
{
BW *bw=(BW *)w->object;
pbof(bw->cursor);
}
X
void ueof(w)
W *w;
{
BW *bw=(BW *)w->object;
peof(bw->cursor);
}
X
void ultarw(w)
W *w;
{
BW *bw=(BW *)w->object;
prgetc(bw->cursor);
}
X
X
void urtarw(w)
W *w;
{
BW *bw=(BW *)w->object;
pgetc(bw->cursor);
}
X
void uprvwrd(w)
W *w;
{
BW *bw=(BW *)w->object;
int c, d;
X
/* Move to end of previous word or edge */
lp:
d=' ';
while(c=prgetc(bw->cursor),
X      c!= MAXINT && !cword(c) && (!cwhitel(c) || cwhitel(d)))
X d=c; 
if(c==' ')
X {
X d=prgetc(bw->cursor); if(d!=MAXINT) pgetc(bw->cursor);
X if(!cwhitel(d)) { pgetc(bw->cursor); goto lp; }
X }
if(c!= MAXINT) pgetc(bw->cursor);
X
X
/* Move to beginning of current word */
while(cword(c=prgetc(bw->cursor)));
if(c!= MAXINT) pgetc(bw->cursor);
}
X
void unxtwrd(w)
W *w;
{
BW *bw=(BW *)w->object;
int c, d;
/* Move to start of next word or edge */
lp:
d=' ';
while(c=brc(bw->cursor),
X      c!= MAXINT && !cword(c) && (!cwhitel(c) || cwhitel(d)))
X d=pgetc(bw->cursor);
if(c==' ')
X {
X pgetc(bw->cursor); d=brc(bw->cursor); prgetc(bw->cursor);
X if(!cwhitel(d)) goto lp;
X }
X
/* Move to end of current word */
while(c=brc(bw->cursor), cword(c)) pgetc(bw->cursor);
}
X
void utomatch(w)
W *w;
{
BW *bw=(BW *)w->object;
int c, f, dir, cnt, d;
P *p;
c=brc(bw->cursor);
f= MAXINT; dir=1;
if(c=='(') f=')';
if(c=='[') f=']';
if(c=='{') f='}';
if(c=='`') f='\'';
if(c=='<') f='>';
if(c==')') f='(', dir= -1;
if(c==']') f='[', dir= -1;
if(c=='}') f='{', dir= -1;
if(c=='\'') f='`', dir= -1;
if(c=='>') f='<', dir= -1;
if(f== MAXINT) return;
if(dir==1)
X {
X p=pdup(bw->cursor);
X cnt=0;
X pgetc(p);
X while(d=pgetc(p), d!= MAXINT)
X  if(d==c) ++cnt;
X  else if(d==f) if(!cnt--) break;
X if(d!= MAXINT)
X  {
X  prgetc(p);
X  pset(bw->cursor,p);
X  }
X prm(p);
X }
else
X {
X p=pdup(bw->cursor);
X cnt=0;
X while(d=prgetc(p), d!= MAXINT)
X  if(d==c) ++cnt;
X  else if(d==f) if(!cnt--) break;
X if(d!= MAXINT) pset(bw->cursor,p);
X prm(p);
X }
}
X
void uuparw(w)
W *w;
{
BW *bw=(BW *)w->object;
long col=bw->cursor->xcol;
pprevl(bw->cursor);
pboln(bw->cursor);
pcol(bw->cursor,bw->cursor->xcol=col);
}
X
void udnarw(w)
W *w;
{
BW *bw=(BW *)w->object;
long col=bw->cursor->xcol;
if(!pnextl(bw->cursor)) pboln(bw->cursor);
pcol(bw->cursor,bw->cursor->xcol=col);
}
X
void scrup(w,n,flg)
W *w;
{
BW *bw=(BW *)w->object;
int scrollamnt=0;
int cursoramnt=0;
int x;
long col=bw->cursor->xcol;
if(bw->top->line>=n) scrollamnt=cursoramnt=n;
else if(bw->top->line) scrollamnt=cursoramnt=bw->top->line;
else
X if(flg) cursoramnt=bw->cursor->line;
X else if(bw->cursor->line>=n) cursoramnt=n;
X
for(x=0;x!=scrollamnt;++x) pprevl(bw->top);
pboln(bw->top);
for(x=0;x!=cursoramnt;++x) pprevl(bw->cursor);
pboln(bw->cursor); pcol(bw->cursor,bw->cursor->xcol=col);
if(scrollamnt && scrollamnt<bw->h)
X {
X nscrldn(w->t->t,bw->y,bw->y+bw->h,scrollamnt);
X scrldn(w->t->t->updtab,bw->y,bw->y+bw->h,scrollamnt);
X }
else if(scrollamnt)
X {
X scrldn(w->t->t->updtab,bw->y,bw->y+bw->h,bw->h);
X }
}
X
void scrdn(w,n,flg)
W *w;
{
BW *bw=(BW *)w->object;
int scrollamnt=0;
int cursoramnt=0;
int x;
long col=bw->cursor->xcol;
X
if(bw->top->b->eof->line<bw->top->line+bw->h)
X {
X cursoramnt=bw->top->b->eof->line-bw->cursor->line;
X if(!flg && cursoramnt>n) cursoramnt=n;
X }
else if(bw->top->b->eof->line-(bw->top->line+bw->h)>=n)
X cursoramnt=scrollamnt=n;
else
X cursoramnt=scrollamnt=bw->top->b->eof->line-(bw->top->line+bw->h)+1;
X
for(x=0;x!=scrollamnt;++x) pnextl(bw->top);
for(x=0;x!=cursoramnt;++x) pnextl(bw->cursor);
pcol(bw->cursor,bw->cursor->xcol=col);
if(scrollamnt && scrollamnt<bw->h)
X {
X int x;
X nscrlup(w->t->t,bw->y,bw->y+bw->h,scrollamnt);
X scrlup(w->t->t->updtab,bw->y,bw->y+bw->h,scrollamnt);
X }
else if(scrollamnt) scrlup(w->t->t->updtab,bw->y,bw->y+bw->h,bw->h);
}
X
int pgamnt= -1;
X
void upgup(w)
W *w;
{
BW *bw=(BW *)w->object;
if(pgamnt== -1) scrup(w,bw->h/2+(bw->h&1),1);
else if(pgamnt<bw->h) scrup(w,bw->h-pgamnt,1);
else scrup(w,1,1);
}
X
void upgdn(w)
W *w;
{
BW *bw=(BW *)w->object;
if(pgamnt== -1) scrdn(w,bw->h/2+(bw->h&1),1);
else if(pgamnt<bw->h) scrdn(w,bw->h-pgamnt,1);
else scrdn(w,1,1);
}
X
void uupslide(w)
W *w;
{
scrup(w,1,0);
}
X
void udnslide(w)
W *w;
{
scrdn(w,1,0);
}
X
void udelch(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
p=pdup(bw->cursor);
pgetc(p);
bdel(bw->cursor,p);
prm(p);
}
X
void ubacks(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
int c;
if(bw->overtype && !pisbol(bw->cursor) && !piseol(bw->cursor))
X {
X if((c=prgetc(bw->cursor))!='\t') return;
X else if(c!=MAXINT) pgetc(bw->cursor);
X }
p=pdup(bw->cursor);
if((c=prgetc(bw->cursor))!= MAXINT) bdel(bw->cursor,p);
prm(p);
}
X
void udelw(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
int c;
p=pdup(bw->cursor);
c=brc(p);
if(cword(c))
X while(c=brc(p), cword(c)) pgetc(p);
else if(cwhitel(c))
X while(c=brc(p), cwhitel(c)) pgetc(p);
else pgetc(p);
bdel(bw->cursor,p);
prm(p);
}
X
void ubackw(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
int c;
p=pdup(bw->cursor);
c=prgetc(bw->cursor);
if(cword(c))
X {
X while(c=prgetc(bw->cursor), cword(c));
X if(c!= MAXINT) pgetc(bw->cursor);
X }
else if(cwhitel(c))
X {
X while(c=prgetc(bw->cursor), cwhitel(c));
X if(c!= MAXINT) pgetc(bw->cursor);
X }
bdel(bw->cursor,p);
prm(p);
}
X
void udelel(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
p=pdup(bw->cursor);
peol(p);
if(bw->cursor->byte==p->byte)
X {
X prm(p);
X udelch(w);
X }
else
X {
X bdel(bw->cursor,p);
X prm(p);
X }
}
X
void udelbl(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
p=pdup(bw->cursor);
pbol(p);
bdel(p,bw->cursor);
prm(p);
}
X
void udelln(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
pbol(bw->cursor);
p=pdup(bw->cursor);
pnextl(p);
bdel(bw->cursor,p);
prm(p);
}
X
void ucenter(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p=bw->cursor, *q;
long endcol, begcol, x;
int c;
X
peol(p);
while(!pisbol(p) && cwhite(c=prgetc(p)));
if(pisbol(p)) return;
pgetc(p); endcol=p->col;
X
pbol(p);
while(!piseol(p) && cwhite(c=pgetc(p)));
if(piseol(p)) return;
prgetc(p); begcol=p->col;
X
if(endcol-begcol>bw->rmargin+bw->lmargin) return;
X
q=pdup(p); pbol(q); bdel(q,p); prm(q);
X
for(x=0;x!=(bw->lmargin+bw->rmargin)/2-(endcol-begcol)/2;++x) binsc(p,' ');
X
if(!pnextl(p))
X {
X binsc(p,'\n');
X pgetc(p);
X }
}
X
/* Paragraph stuff */
X
/* Determine if line pointer is on is blank */
X
int pblank(p)
P *p;
{
P *q=pdup(p);
int rtval;
pbol(q);
while(cwhite(brc(q))) pgetc(q);
rtval=piseol(q);
prm(q);
return rtval;
}
X
/* Determine indentation level of line pointer is on */
X
long pindent(p)
P *p;
{
P *q=pdup(p);
long col;
pbol(q);
while(cwhite(brc(q))) pgetc(q);
col=q->col;
prm(q);
return col;
}
X
/* Move pointer to beginning of paragraph */
X
P *pbop(p)
P *p;
{
long indent;
pbol(p);
indent=pindent(p);
while(!pisbof(p))
X {
X long ind;
X pprevl(p); pboln(p);
X ind=pindent(p);
X if(pblank(p) || ind<indent)
X  {
X  pnextl(p);
X  break;
X  }
X if(ind>indent) break;
X }
return p;
}
X
/* Move pointer to end of paragraph */
X
P *peop(p)
P *p;
{
long indent;
pbol(p);
indent=pindent(p);
while(!piseof(p))
X {
X long ind;
X pnextl(p);
X ind=pindent(p);
X if(ind>indent || pblank(p)) break;
X if(ind<indent) indent=ind;
X }
if(piseof(p))  peol(p);
return p;
}
X
/* Wrap word */
X
void wrapword(p,indent)
P *p;
long indent;
{
int c;
long to=p->byte;
while(!pisbol(p) && !cwhite(c=prgetc(p)));
if(!pisbol(p))
X {
X pgetc(p);
X binsc(p,'\n'), ++to;
X pgetc(p);
X if(indent) while(indent--) binsc(p,' '), ++to;
X }
pfwrd(p,to-p->byte);
}
X
/* Reformat paragraph */
X
void uformat(w)
W *w;
{
BW *bw=(BW *)w->object;
long indent;
char *buf, *b;
int len;
long curoff;
int c;
P *p, *q;
p=pdup(bw->cursor); pbol(p);
X
if(pblank(p))
X {
X prm(p);
X return;
X }
X
pbop(p);
curoff=bw->cursor->byte-p->byte;
peop(bw->cursor);
X
if(bw->cursor->lbyte) binsc(bw->cursor,'\n'), pgetc(bw->cursor);
if(piseof(bw->cursor)) binsc(bw->cursor,'\n');
X
indent=pindent(p);
q=pdup(p); pnextl(q);
if(q->line!=bw->cursor->line) indent=pindent(q);
prm(q);
if(bw->lmargin>indent) indent=bw->lmargin;
X
buf=(char *)malloc(len=(bw->cursor->byte-p->byte));
brmem(p,buf,len);
bdel(p,bw->cursor);
prm(p);
X
/* text is in buffer.  insert it at cursor */
X
/* Do first line */
b=buf;
p=pdup(bw->cursor);
X
while(len--)
X {
X if(b-buf==curoff) pset(bw->cursor,p);
X c= *b++;
X if(c=='\n') { ++len; --b; break; }
X if(cwhite(c))
X  {
X  char *r=b;
X  int rlen=len;
X  int z;
X  while(rlen--)
X   {
X   z=*r++;
X   if(z=='\n') break;
X   if(!cwhite(z)) goto ok;
X   }
X  ++len; --b; break;
X  ok:;
X  }
X binsc(p,c); pgetc(p);
X if(p->col>bw->rmargin && !cwhite(c))
X  {
X  wrapword(p,indent);
X  break;
X  }
X }
X
while(len>0)
X if(cwhitel(*b))
X  {
X  if(b[-1]=='.' || b[-1]=='?' || b[-1]=='!') binsc(p,' '), pgetc(p);
X  binsc(p,' '); pgetc(p);
X  while(len && cwhitel(*b))
X   {
X   if(b-buf==curoff) pset(bw->cursor,p);
X   ++b, --len;
X   }
X  }
X else
X  {
X  if(b-buf==curoff) pset(bw->cursor,p);
X  binsc(p,*b++); --len; pgetc(p);
X  if(p->col>bw->rmargin) wrapword(p,indent);
X  }
X
binsc(p,'\n');
prm(p);
free(buf);
}
X
void uinsc(w)
W *w;
{
BW *bw=(BW *)w->object;
binsc(bw->cursor,' ');
}
X
void utype(w,c)
W *w;
int c;
{
BW *bw=(BW *)w->object;
P *p;
if(pblank(bw->cursor))
X while(bw->cursor->col<bw->lmargin) binsc(bw->cursor,' '), pgetc(bw->cursor);
binsc(bw->cursor,c);
pgetc(bw->cursor);
if(bw->wordwrap && bw->cursor->col>bw->rmargin && !cwhite(c))
X wrapword(bw->cursor,bw->lmargin);
else if(bw->overtype && !piseol(bw->cursor) && c!='\t') udelch(w);
}
X
void urtn(w)
W *w;
{
BW *bw=(BW *)w->object;
P *p;
int c;
p=pdup(bw->cursor);
binsc(bw->cursor,'\n');
pgetc(bw->cursor);
if(bw->autoindent)
X {
X pbol(p);
X while(cwhite(c=pgetc(p))) binsc(bw->cursor,c), pgetc(bw->cursor);
X }
prm(p);
}
X
void uopen(w)
W *w;
{
BW *bw=(BW *)w->object;
P *q=pdup(bw->cursor);
urtn(w);
pset(bw->cursor,q);
prm(q);
}
X
void dotag(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
char buf[512];
FILE *f;
void *object=bw->object;
f=fopen("tags","r");
while(fgets(buf,512,f))
X {
X int x, y, c;
X for(x=0;buf[x] && buf[x]!=' ' && buf[x]!='\t';++x);
X c=buf[x]; buf[x]=0;
X if(!zcmp(s,buf))
X  {
X  buf[x]=c;
X  while(buf[x]==' ' || buf[x]=='\t') ++x;
X  for(y=x;buf[y] && buf[y]!=' ' && buf[y]!='\t' && buf[y]!='\n';++y);
X  if(x!=y)
X   {
X   B *b;
X   c=buf[y]; buf[y]=0;
X   b=bfind(buf+x);
X   if(!b)
X    {
X    int fl;
X    b=bmk();
X    if(fl=bload(b,buf+x))
X     { msgnwt(w,msgs[fl+5]); brm(b); vsrm(s); fclose(f); return; }
X    }
X   bwrm(bw);
X   w->object=(void *)(bw=bwmk(w->t,b,w->x,w->y+1,w->w,w->h-1));
X   wredraw(w);
X   setoptions(bw,buf+x);
X   bw->object=object;
X   
X   buf[y]=c;
X   while(buf[y]==' ' || buf[y]=='\t') ++y;
X   for(x=y;buf[x] && buf[x]!='\n';++x);
X   buf[x]=0;
X   if(x!=y)
X    {
X    long line=0;
X    if(buf[y]>='0' && buf[y]<='9')
X     {
X     sscanf(buf+y,"%ld",&line);
X     if(line>=1) pline(bw->cursor,line-1), bw->cursor->xcol=bw->cursor->col;
X     else msgnw(w,"Invalid line number");
X     }
X    else
X     {
X     if(buf[y]=='/' || buf[y]=='?')
X      {
X      ++y;
X      if(buf[y]=='^') buf[--y]='\\';
X      }
X     if(buf[x-1]=='/' || buf[x-1]=='?')
X      {
X      --x;
X      buf[x]=0;
X      if(buf[x-1]=='$')
X       {
X       buf[x-1]='\\';
X       buf[x]='$';
X       ++x;
X       buf[x]=0;
X       }
X      }
X     if(x!=y)
X      {
X      w->t->pattern=vsncpy(NULL,0,sz(buf+y));
X      w->t->options=0;
X      w->t->repeat= -1;
X      pfnext(w);
X      }
X     }
X    }
X   vsrm(s);
X   fclose(f);
X   return;
X   }
X  }
X }
msgnw(w,"Not found");
vsrm(s);
fclose(f);
}
X
void utag(w)
W *w;
{
BW *bw=(BW *)w->object;
W *pw;
if(bw->b->count==1 && bw->b->chnged)
X {
X int c=query(w,"Do you really want to throw away this file (y,n)? ");
X if(c!='y' && c!='Y') return;
X }
pw=wmkfpw(w,"Tag string to find (^C to abort): ",&taghist,dotag,NULL);
if(pw && cword(brc(bw->cursor)))
X {
X BW *pbw=(BW *)pw->object;
X P *p=pdup(bw->cursor);
X P *q=pdup(p);
X int c;
X while(cword(c=prgetc(p))); if(c!=MAXINT) pgetc(p);
X pset(q,p); while(cword(c=pgetc(q))); if(c!=MAXINT) prgetc(q);
X binsb(pbw->cursor,p,q);
X pset(pbw->cursor,pbw->b->eof); pbw->cursor->xcol=pbw->cursor->col;
X prm(p); prm(q);
X }
}
X
/* Mode commands */
X
void uisquare(w)
W *w;
{
square= !square;
if(square) msgnw(w,"Rectangle mode selected.  Effects block commands & Insert file");
else msgnw(w,"Normal text-stream mode selected");
updall();
}
X
void uiindent(w)
W *w;
{
BW *bw=(BW *)w->object;
bw->autoindent= !bw->autoindent;
if(bw->autoindent) msgnw(w,"Autoindent enabled");
else msgnw(w,"Autoindent disabled");
}
X
void uiwrap(w)
W *w;
{
BW *bw=(BW *)w->object;
bw->wordwrap= !bw->wordwrap;
if(bw->wordwrap) msgnw(w,"Word wrap enabled");
else msgnw(w,"Word wrap disabled");
}
X
void uitype(w)
W *w;
{
BW *bw=(BW *)w->object;
bw->overtype= !bw->overtype;
if(bw->overtype==0) msgnw(w,"Insert mode");
else msgnw(w,"Overtype mode");
}
X
void uimid(w)
W *w;
{
mid= !mid;
if(mid) msgnw(w,"Cursor will be recentered after a scroll");
else msgnw(w,"Cursor will not be recentered after a scroll");
}
X
void uiforce(w)
W *w;
{
force= !force;
if(force) msgnw(w,"Last line forced to have LF when file saved");
else msgnw(w,"Last line not forced to have LF");
}
X
void uiasis(w)
W *w;
{
dspasis= !dspasis;
if(dspasis) msgnw(w,"Characters above 127 displayed as-is");
else msgnw(w,"Characters above 127 remapped");
refigure();
updall();
}
X
void uistacol(w)
W *w;
{
stacol= !stacol;
}
X
void uistarow(w)
W *w;
{
starow= !starow;
}
X
static void dolmar(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
long v=bw->lmargin;
sscanf(s,"%ld",&v);
vsrm(s);
bw->lmargin=v;
}
X
void uilmargin(w)
W *w;
{
BW *bw=(BW *)w->object;
char buf[80];
sprintf(buf,"Left margin %ld (^C to abort): ",bw->lmargin);
wmkpw(w,buf,NULL,dolmar,NULL);
}
X
static void docindent(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
int v=bw->indentc;
sscanf(s,"%d",&v);
vsrm(s);
bw->indentc=v;
}
X
void uicindent(w)
W *w;
{
BW *bw=(BW *)w->object;
char buf[80];
sprintf(buf,"Indent char %d (SPACE=32, TAB=9, ^C to abort): ",
X        bw->indentc);
wmkpw(w,buf,NULL,docindent,NULL);
}
X
static void doistep(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
long v=bw->istep;
sscanf(s,"%ld",&v);
vsrm(s);
bw->istep=v;
}
X
void uiistep(w)
W *w;
{
BW *bw=(BW *)w->object;
char buf[80];
sprintf(buf,"Indent step %ld (^C to abort): ",bw->istep);
wmkpw(w,buf,NULL,doistep,NULL);
}
X
static void dormar(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
long v=bw->rmargin;
sscanf(s,"%ld",&v);
vsrm(s);
bw->rmargin=v;
}
X
void uirmargin(w)
W *w;
{
BW *bw=(BW *)w->object;
char buf[80];
sprintf(buf,"Right margin %ld (^C to abort): ",bw->rmargin);
wmkpw(w,buf,NULL,dormar,NULL);
}
X
static void dotab(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
int v=bw->b->tab;
sscanf(s,"%ld",&v);
if(v<0 || v>256) v=8;
vsrm(s);
bw->b->tab=v;
refigure();
updall();
}
X
void uitab(w)
W *w;
{
BW *bw=(BW *)w->object;
char buf[80];
sprintf(buf,"Tab width %d (^C to abort): ",bw->b->tab);
wmkpw(w,buf,NULL,dotab,NULL);
}
X
static void dopgamnt(w,s)
W *w;
char *s;
{
BW *bw=(BW *)w->object;
long v=pgamnt;
sscanf(s,"%ld",&v);
vsrm(s);
if(v<-1) v= -1;
pgamnt=v;
}
X
void uipgamnt(w)
W *w;
{
char buf[80];
sprintf(buf,"Lines to keep for pgup/pgdn or -1 for 1/2 (%ld): ",pgamnt);
wmkpw(w,buf,NULL,dopgamnt,NULL);
}
X
/* Argument setting */
X
void uarg(w,c)
W *w;
{
char buf[80];
if(c>='1' && c<='9') w->t->arg=(c&0xF);
else w->t->arg=0;
sprintf(buf,"%d",w->t->arg); msgnw(w,buf);
while(c=edgetc(), c>='0' && c<='9')
X {
X w->t->arg=w->t->arg*10+(c&0xf);
X sprintf(buf,"%d",w->t->arg); msgnw(w,buf);
X }
if(c==3) w->t->arg=0;
else eungetc(c);
}
SHAR_EOF
chmod 0600 edfuncs.c ||
echo 'restore of edfuncs.c failed'
Wc_c="`wc -c < 'edfuncs.c'`"
test 32824 -eq "$Wc_c" ||
	echo 'edfuncs.c: original size 32824, current size' "$Wc_c"
fi
# ============= edfuncs.h ==============
if test -f 'edfuncs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping edfuncs.h (File already exists)'
else
echo 'x - extracting edfuncs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'edfuncs.h' &&
/* User edit functions
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iedfncs
#define _Iedfncs 1
X
#include "config.h"
X
extern char *msgs[];
X
void umarkb();
void umarkk();
void ublkdel();
void ublkcpy();
void ublkmove();
void ublksave();
X
void ufilt();
void ulindent();
void urindent();
X
void uarg();
X
void ugroww();
void ushrnk();
void unextw();
void uprevw();
void uexpld();
X
void ushell();
X
void uretyp();
X
void uexsve();
void usave();
void uedit();
void uinsf();
X
void ubof();
void ueof();
X
void ubol();
void ueol();
void upedge();
void unedge();
X
void ultarw();
void urtarw();
X
void uprvwrd();
void unxtwrd();
X
void uuparw();
void udnarw();
X
void upgup();
void upgdn();
void uupslide();
void udnslide();
X
void uline();
X
void utomatch();
X
void uopen();
void uinsc();
X
void udelch();
void ubacks();
X
void udelw();
void ubackw();
X
void udelel();
void udelbl();
void udelln();
X
void uquote();
void uquote8();
void urtn();
void utype();
X
void ucenter();
void uformat();
X
void uirmargin();
void uilmargin();
void uitype();
void uiwrap();
void uiindent();
void uipgamnt();
void uimid();
void uiforce();
void uiasis();
void uistarow();
void uistacol();
void uitab();
void uisquare();
void uiistep();
void uicindent();
void utag();
X
#endif
SHAR_EOF
chmod 0600 edfuncs.h ||
echo 'restore of edfuncs.h failed'
Wc_c="`wc -c < 'edfuncs.h'`"
test 1933 -eq "$Wc_c" ||
	echo 'edfuncs.h: original size 1933, current size' "$Wc_c"
fi
# ============= heap.c ==============
if test -f 'heap.c' -a X"$1" != X"-c"; then
	echo 'x - skipping heap.c (File already exists)'
else
echo 'x - extracting heap.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'heap.c' &&
/* Fast space-efficient heap manager
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "blocks.h"
#include "random.h"
#include "heap.h"
X
#define MAXSIZE (MAXINT-16)
X
/* A free block of memory */
X
typedef struct freeblck FREE;
struct freeblck
X {
X int size;		/* Includes self, +1 for allocated blocks */
X 			/* Equals '1' for end of heap or segment */
X FREE *next;		/* Data part of allocated blocks begins here */
X FREE *prev;
X };
X
static int reent=0;	/* Set if freeit is reentering itself */
void *sbrk();		/* Operating system memory allocator */
void (*mtrap)()=0;	/* Memory overflow handler */
static trapflag=0;	/* Set while handling an overflow condition */
X
static char *heapend=0;	/* Top of heap */
X
/* A skiplist entry */
X
struct skipnode
X {
X int key;
X int nptrs;
X FREE *value;
X struct skipnode *ptrs[1];
X };
X
/* Max number of pointers in a skiplist node */
#define SKIPDPTH 16
X
static struct skipnode *freeones[SKIPDPTH+1];	/* Free lists of skip nodes */
static struct skipnode *top=0;			/* Skip list root node */
static struct skipnode nil;			/* Ending skiplist node */
static struct skipnode *update[SKIPDPTH];	/* Record of search path */
X
/* Memory allocator for skip-list nodes */
X
static char *big=0;
static int bigx=0;
X
/* Allocation amount for skiplist data */
#define SKIPCHNK 256
X
/* Key is for recomputing skip-list search after a reentrant malloc */
X
static struct skipnode *skipa(x,key)
int x, key;
{
struct skipnode *t;
int amnt;
if(freeones[x])
X {
X t=freeones[x];
X freeones[x]=(struct skipnode *)t->value;
X return t;
X }
amnt=sizeof(struct skipnode)+sizeof(struct skipnode *)*(x-1);
if(bigx+amnt>SKIPCHNK || !big)
X {
X reent=1;
X big=(char *)malloc(SKIPCHNK);
X if(key)
X  {
X  struct skipnode *t=top;
X  int y;
X  for(y=top->nptrs;--y>=0;)
X   {
X   while(t->ptrs[y]->key<key) t=t->ptrs[y];
X   update[y]=t;
X   }
X  }
X reent=0;
X bigx=0;
X }
t=(struct skipnode *)(big+bigx);
bigx+=amnt;
return t;
}
X
/* Free a skip node */
X
static void freea(t)
struct skipnode *t;
{
t->value=(FREE *)freeones[t->nptrs];
freeones[t->nptrs]=t;
}
X
/* Insert a free block into the free-list */
X
static void freeit(b)
FREE *b;
{
struct skipnode *t=top;
int x;
b=normalize(b);
for(x=top->nptrs;--x>=0;)
X {
X while(t->ptrs[x]->key<b->size) t=t->ptrs[x];
X update[x]=t;
X }
t=t->ptrs[0];
if(t->key==b->size)
X {
X b->next=t->value;
X b->prev=0;
X t->value->prev=b;
X t->value=b;
X }
else
X {
X int level;
X for(level=1;random()<0x29000000;++level);
X if(level>15) level=15;
X b->size+=1;
X t=(struct skipnode *)skipa(level,b->size-1);
X b->size-=1;
X while(level>top->nptrs) update[top->nptrs++]=top;
X t->nptrs=level;
X for(x=0;x!=level;++x) t->ptrs[x]=update[x]->ptrs[x], update[x]->ptrs[x]=t;
X t->key=b->size;
X t->value=b;
X b->next=0; b->prev=0;
X }
}
X
/* Remove an element from the free list */
X
static void unfreeit(b)
FREE *b;
{
struct skipnode *t;
int y;
if(b->prev)
X {
X if(b->prev->next=b->next) b->next->prev=b->prev;
X return;
X }
t=top;
for(y=top->nptrs;--y>=0;)
X {
X while(t->ptrs[y]->key<b->size) t=t->ptrs[y];
X update[y]=t;
X }
t=t->ptrs[0];
if(b->next) b->next->prev=0, t->value=b->next;
else
X {
X int x;
X for(x=0;x!=top->nptrs && update[x]->ptrs[x]==t;++x)
X  update[x]->ptrs[x]=t->ptrs[x];
X while(top->nptrs && top->ptrs[top->nptrs-1]==&nil) --top->nptrs;
X freea(t);
X }
}
X
void *malloc(size)
{
int x;
int flg=0, y;
FREE *b;
struct skipnode *t;
if(!top)
X {
X nil.key=MAXINT;
X nil.nptrs=0;
X nil.ptrs[0]= &nil;
X top= &nil;
X top=(struct skipnode *)skipa(16,0);
X top->key=0;
X top->nptrs=0;
X for(x=0;x!=16;++x) top->ptrs[x]= &nil;
X }
size+=sizeof(int);
if(size<sizeof(FREE)) size=sizeof(FREE);
size=(size+sizeof(int)-1)&~(sizeof(int)-1);
loop:
b=0;
t=top;
for(y=top->nptrs;--y>=0;)
X {
X while(t->ptrs[y]->key<size) t=t->ptrs[y];
X update[y]=t;
X }
t=t->ptrs[0];
if(t->key!= MAXINT)
X {
X b=t->value;
X if(b->next) b->next->prev=0, t->value=b->next;
X else
X  {
X  for(x=0;x!=top->nptrs && update[x]->ptrs[x]==t;++x)
X   update[x]->ptrs[x]=t->ptrs[x];
X  while(top->nptrs && top->ptrs[top->nptrs-1]==&nil) --top->nptrs;
X  freea(t);
X  }
X }
if(b)
X {
X while(!(1&*(int *)((char *)b+b->size)))
X  {
X  FREE *c=(FREE *)((char *)b+b->size);
X  if((long)b->size+(long)c->size>=MAXSIZE) break;
X  b->size+=c->size;
X  unfreeit(c);
X  }
X if(normalize((char *)b+b->size)+sizeof(int)==heapend)
X  {
X  sbrk(-b->size);
X  heapend=(char *)b;
X  b->size=1;
X  goto loop;
X  }
X if((b->size-size)>=(size>>2) && b->size-size>=sizeof(FREE) && !reent)
X  {
X  FREE *c=(FREE *)((char *)b+size);
X  c->size=b->size-size;
X  b->size=size|1;
X  freeit(c);
X  }
X else b->size|=1;
X if(flg) trapflag=0;
X return (void *)((char *)b+sizeof(int));
X }
b=(FREE *)sbrk(size+sizeof(int));
if(!b || b==((FREE *)(long)-1))
X {
X if(mtrap && !trapflag)
X  {
X  trapflag=1;
X  flg=1;
X  mtrap(size);
X  goto loop;
X  }
X write(2,"\rOut of memory\r\n",16);
X _exit(1);
X }
b=normalize(b);
if(normalize(heapend)==(char *)b)
X {
X b=(FREE *)(heapend-sizeof(int));
X size+=sizeof(int);
X }
heapend=normalize((char *)b+size)+sizeof(int);
*((int *)heapend-1)=1;
b->size=size|1;
if(flg) trapflag=0;
return (void *)((char *)b+sizeof(int));
}
X
void *memalign(align,size)
int align,size;
{
FREE *b;
char *blk;
int off;
size+=sizeof(int);
if(size<sizeof(FREE)) size=sizeof(FREE);
size=(size+sizeof(int)-1)&~(sizeof(int)-1);
align=(align+sizeof(int)-1)&~(sizeof(int)-1);
if(!align) align=sizeof(int);
if(size>=align) blk=(char *)malloc(size+align+sizeof(FREE));
else blk=(char *)malloc(align*2+sizeof(FREE));
off=physical(blk)%align;
if(off)
X {
X b=(FREE *)(blk-sizeof(int));
X if(align-off>=sizeof(FREE)) blk+=align-off;
X else blk+=2*align-off;
X *((int *)blk-1)=b->size-(blk-sizeof(int)-(char *)b);
X b->size-= *((int *)blk-1);
X freeit(b);
X }
b=normalize((FREE *)(blk-sizeof(int)));
if((b->size-1-size)>=(size>>2) && b->size-1-size>=sizeof(FREE))
X {
X FREE *c=(FREE *)((char *)b+size);
X c->size=b->size-1-size;
X b->size=size+1;
X freeit(c);
X }
return (char *)b+sizeof(int);
}
X
void *realloc(blk,size)
void *blk;
int size;
{
FREE *b;
int osize;
if(!blk) return malloc(size);
b=(FREE *)((char *)blk-sizeof(int));
osize=b->size-1-sizeof(int);
size+=sizeof(int);
if(size<sizeof(FREE)) size=sizeof(FREE);
size=(size+sizeof(int)-1)&~(sizeof(int)-1);
while(!(1&*(int *)((char *)b+b->size-1)))
X {
X FREE *c=(FREE *)((char *)b+b->size-1);
X if((long)b->size+(long)c->size>=MAXSIZE) break;
X b->size+=c->size;
X unfreeit(c);
X }
if(size<=b->size-1)
X {
X if(b->size-1-size>size && b->size-1-size>=sizeof(FREE))
X  {
X  FREE *c=(FREE *)((char *)b+size);
X  c->size=b->size-size-1;
X  b->size=size+1;
X  freeit(c);
X  }
X return blk;
X }
else
X {
X char *n=(char *)malloc(size);
X FREE *c=(FREE *)(n-sizeof(int));
X if(normalize((char *)c+c->size-1)+sizeof(int)==heapend &&
X    (FREE *)normalize(((char *)b+b->size-1))==c)
X  {
X  sbrk(-(c->size-1+b->size-1-size));
X  b->size=size+1;
X  heapend=normalize((char *)b+b->size-1)+sizeof(int);
X  *((int *)heapend-1)=1;
X  return blk;
X  }
X mcpy(n,blk,osize);
X free(blk);
X return (void *)n;
X }
}
X
void free(blk)
void *blk;
{
FREE *b;
if(!blk) return;
b=(FREE *)((char *)blk-sizeof(int));
b->size-=1;
while(!(1&*(int *)((char *)b+b->size)))
X {
X FREE *c=(FREE *)((char *)b+b->size);
X if((long)b->size+(long)c->size>=MAXSIZE) break;
X b->size+=c->size;
X unfreeit(c);
X }
if(normalize((char *)b+b->size)+sizeof(int)==heapend)
X {
X heapend=(char *)b+sizeof(int);
X sbrk(-b->size);
X b->size=1;
X }
else freeit(b);
}
X
void *calloc(a,b)
int a,b;
{
return (void *)mset((char *)malloc(a*b),0,a*b);
}
SHAR_EOF
chmod 0600 heap.c ||
echo 'restore of heap.c failed'
Wc_c="`wc -c < 'heap.c'`"
test 8056 -eq "$Wc_c" ||
	echo 'heap.c: original size 8056, current size' "$Wc_c"
fi
# ============= heap.h ==============
if test -f 'heap.h' -a X"$1" != X"-c"; then
	echo 'x - skipping heap.h (File already exists)'
else
echo 'x - extracting heap.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'heap.h' &&
/* Fast space-efficient heap maneger
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
/* - Uses "best-fit" algorithm- but maintains a fast skip-list database of each
X *   set of equal sized free blocks.  This eliminates the long linked-list
X *   search delay which slows the "best-fit" algorithm.
X * - Contiguous free blocks get coalesced
X * - Gives memory back to operating system when it can
X * - Overhead for allocated blocks: sizeof(int)
X * - Minimum allocated block size is 2*sizeof(int) (not including overhead)
X * - Blocks are always aligned on integer boundaries
X * - Macro provided for reading block size
X * - 'memalign' routine provided for allocating blocks on a given alignment
X * - Works ok in segmented systems or where sbrk() is called by other functions
X */
X
#ifndef _Iheap
#define _Iheap 1
X
#include "config.h"
X
/* void (*mtrap)(int size);
X *
X * If 'mtrap' is set to 0 (it's default value), then if the system runs
X * out of memory, an error message is sent to stderr and the program is
X * aborted.
X *
X * If 'mtrap' is set to the address of a function, then that function gets
X * one chance (mtrap will only ever be called once for each out of memory
X * condition and it will never be reentered) to free up at least 'size' bytes
X * of memory.  If 'mtrap' doesn't free up the memory or if there isn't enough
X * contiguous space to satisfy the allocation request, the default action is
X * taken.  The 'mtrap' function may call the memory allocation routines (but
X * hopefully with smaller requests :-).
X */
extern void (*mtrap)();
X
/* void *malloc(int size);
X *
X * Allocate a block of at least 'size' bytes from the heap.  If 'size' is zero,
X * a small block is allocated.
X *
X * The allocated block will begin on an address which is a multiple of
X * sizeof(int).
X */
void *malloc();
X
/* void *calloc(int a,int b);
X *
X * Allocate a block of at least 'a'*'b' bytes from the heap.  The first 'a'*'b'
X * bytes are cleared.  If 'a'*'b' is zero, a small block is allocated (and it
X * is not cleared).
X *
X * The allocated block will begin on an address which is a multiple of
X * sizeof(int).
X */
void *calloc();
X
/* void *realloc(void *blk,int size);
X *
X * Modify amount allocated to 'blk' to 'size' and return pointer to block
X * (which might be at a different address).  If 'size' is zero, a small amount
X * is left allocated to the block.  If 'blk' is null, a new block is allocated.
X *
X * The allocated block will begin on an address which is a multiple of
X * sizeof(int).
X */
void *realloc();
X
/* void free(void *blk);
X *
X * Return a block to the heap so that it can be reused.  If 'blk'==0,
X * nothing happens.
X */
void free();
X
/* void *memalign(int align,int size);
X *
X * Allocate a block of at least 'size' bytes beginning on an address which
X * is a multiple of 'align'.  'align' is rounded up to a multiple of
X * sizeof(int).  If 'size' is zero, a small block is allocated.
X */
void *memalign();
X
/* int msize(void *blk);
X *
X * Return size of a block returned by malloc/realloc/calloc/memalign.  Returns
X * zero if 'blk' is 0.  Warning: this is an unsafe macro (blk can be
X * accessed more than once).
X */
#define msize(blk) ((blk)?*((int *)(blk)-1)-(1+sizeof(int)):0)
X
#endif
SHAR_EOF
chmod 0600 heap.h ||
echo 'restore of heap.h failed'
Wc_c="`wc -c < 'heap.h'`"
test 3883 -eq "$Wc_c" ||
	echo 'heap.h: original size 3883, current size' "$Wc_c"
fi
# ============= help.c ==============
if test -f 'help.c' -a X"$1" != X"-c"; then
	echo 'x - skipping help.c (File already exists)'
else
echo 'x - extracting help.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'help.c' &&
/* Help system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "tty.h"
#include "toomany.h"
#include "b.h"
#include "termcap.h"
#include "kbd.h"
#include "scrn.h"
#include "w.h"
#include "menu.h"
#include "help.h"
X
/* The loaded help screen */
X
char *hlptxt=0;
int hlpsiz=0;
int hlpbsz=0;
int hlplns=0;
X
static int uphelp=0;
X
/* Display help text */
X
void dsphlp(t)
SCREEN *t;
{
char *str=hlptxt;
int y,x,c;
int atr=0;
for(y=0;y!=t->wind;++y)
X {
X if(t->t->updtab[y])
X  {
X  for(x=0;x!=t->w-1;++x)
X   if(*str=='\n' || !*str)
X    if(eraeol(t->t,x,y)) return;
X    else break;
X   else
X    {
X    if(*str=='\\')
X     if(str[1]=='i' || str[1]=='u' || str[1]=='I' || str[1]=='U')
X      {
X      if(str[1]=='i' || str[1]=='I') atr^=INVERSE;
X      else atr^=UNDERLINE;
X      str+=2;
X      --x; continue;
X      }
X     else if(str[1]=='\\') c='\\'+atr, str+=2;
X     else { ++str; --x; continue; }
X    else c= (unsigned char)*str++ +atr;
X    if(t->t->scrn[x+y*t->w]!=c)
X     {
X     if(have) return;
X     t->t->scrn[x+y*t->w]=c;
X     outatr(t->t,x,y,c);
X     }
X    }
X  atr=0; t->t->updtab[y]=0;
X  }
X while(*str && *str!='\n') ++str;
X if(*str=='\n') ++str;
X }
}
X
/* Create the help window */
X
void helpon(t)
SCREEN *t;
{
if(!hlptxt) return;
t->wind=hlplns;
if(t->h-t->wind<FITHEIGHT) t->wind=t->h-FITHEIGHT;
if(t->wind<0)
X {
X t->wind=0;
X return;
X }
chsize(t,t->h-t->wind,t->h);
msetI(t->t->updtab,1,t->wind);
}
X
/* Eliminate the help window */
X
void helpoff(t)
SCREEN *t;
{
int z=t->wind;
t->wind=0;
chsize(t,t->h,t->h-z);
}
X
/* Toggle help on/off */
X
void uhelp(w)
W *w;
{
struct help *h;
if(w->huh) if(h=get_help(w->huh))
X {
X if(w->t->wind) helpoff(w->t);
X hlptxt=h->hlptxt;
X hlpsiz=h->hlpsiz;
X hlpbsz=h->hlpbsz;
X hlplns=h->hlplns;
X helpon(w->t);
X return;
X }
uhelpme(w);
}
X
/* Help selection menu */
X
void uheol(w) W *w; { MENU *m=(MENU *)w->object; meol(m); }
void uhbol(w) W *w; { MENU *m=(MENU *)w->object; mbol(m); }
void uheof(w) W *w; { MENU *m=(MENU *)w->object; meof(m); }
void uhbof(w) W *w; { MENU *m=(MENU *)w->object; mbof(m); }
void uhdnarw(w) W *w; { MENU *m=(MENU *)w->object; mdnarw(m); }
void uhuparw(w) W *w; { MENU *m=(MENU *)w->object; muparw(m); }
void uhltarw(w) W *w; { MENU *m=(MENU *)w->object; mltarw(m); }
void uhrtarw(w) W *w; { MENU *m=(MENU *)w->object; mrtarw(m); }
void hdumb() {}
void movehelp(w,x,y) W *w; { MENU *m=(MENU *)w->object; menumove(m,x,y); }
void resizehelp(w,x,y) W *w; { MENU *m=(MENU *)w->object; menuresz(m,x,y); }
void disphelp(w) W *w;
X {
X MENU *m=(MENU *)w->object;
X menugen(m);
X w->cury=0;
X w->curx=(m->cursor-m->top)*(m->width+1);
X }
void followhelp(w) W *w; { MENU *m=(MENU *)w->object; menufllw(m); }
void wkillhelp(w) W *w; { MENU *m=(MENU *)w->object; if(m) menurm(m); }
X
int prevcursor=0;
X
void uhrtn(w)
W *w;
{
MENU *m=(MENU *)w->object;
hlptxt=help_structs[m->cursor]->hlptxt;
hlpsiz=help_structs[m->cursor]->hlpsiz;
hlpbsz=help_structs[m->cursor]->hlpbsz;
hlplns=help_structs[m->cursor]->hlplns;
prevcursor=m->cursor;
wabort(w);
helpon(w->t);
}
X
void uhabort(w)
W *w;
{
MENU *m=(MENU *)w->object;
prevcursor=m->cursor;
wabort(w);
}
X
CONTEXT cthelp= {"help",0};
X
static WATOM watomhelp=
{
&cthelp,
disphelp,
followhelp,
wkillhelp,
resizehelp,
movehelp,
hdumb,
hdumb,
TYPEHELP
};
X
void uhelpme(w)
W *w;
{
W *new;
MENU *m;
if(w->t->wind)
X {
X helpoff(w->t);
X return;
X }
if(!help_names[0]) return;
if(!help_names[1])
X {
X helpon(w->t);
X return;
X }
if(!(new=wcreate(w->t,&watomhelp,w,w,w->main,1,NULL))) return;
new->object=(void *)(m=mkmenu(new->t,help_names,new->x,new->y,new->w,new->h));
m->cursor=prevcursor;
w->t->curwin=new;
}
SHAR_EOF
chmod 0600 help.c ||
echo 'restore of help.c failed'
Wc_c="`wc -c < 'help.c'`"
test 4291 -eq "$Wc_c" ||
	echo 'help.c: original size 4291, current size' "$Wc_c"
fi
# ============= help.h ==============
if test -f 'help.h' -a X"$1" != X"-c"; then
	echo 'x - skipping help.h (File already exists)'
else
echo 'x - extracting help.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'help.h' &&
/* Help system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ihelp
#define _Ihelp 1
X
#include "config.h"
#include "kbd.h"
X
extern char *hlptxt;
extern int hlpsiz, hlpbsz, hlplns;
void dsphlp();
X
void uhelp();
X
struct help
X {
X  char *hlptxt;
X  int hlpsiz;
X  int hlpbsz;
X  int hlplns;
X  char *name;
X  struct help *next;
X };
X
#define TYPEHELP 0x800
void uhelpme();
void uhabort();
void uhrtn();
X
void uhrtarw();
void uhltarw();
void uhuparw();
void uhdnarw();
void uhbof();
void uheof();
void uhbol();
void uheol();
X
extern CONTEXT cthelp;
X
extern char **help_names;
extern struct help **help_structs;
X
#endif
SHAR_EOF
chmod 0600 help.h ||
echo 'restore of help.h failed'
Wc_c="`wc -c < 'help.h'`"
test 1306 -eq "$Wc_c" ||
	echo 'help.h: original size 1306, current size' "$Wc_c"
fi
# ============= joerc ==============
if test -f 'joerc' -a X"$1" != X"-c"; then
	echo 'x - skipping joerc (File already exists)'
else
echo 'x - extracting joerc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'joerc' &&
X                         Initialization file for JOE
X
X JOE looks for this file in:
X	1 - .joerc
X	2 - $HOME/.joerc
X	3 - /usr/local/lib/joerc
X
X FIRST SECTION: Default global options:
X
X Put each option you want set in the first column:
X
X -mid		Cursor is recentered when scrolling is necessary
X -asis		Characters 160 - 254 shown as-is
X -stacol	Column number in status line
X -starow	Row number in status line
X -force		Force final newline when files are saved
X -help		Start with help on
X -pg nnn	No. lines to keep for PgUp/PgDn
X -gtab nnn	Default tab width for prompt windows
X
X SECOND SECTION: File name dependant local option settings:
X
X Each line with '*' in the first column indicates the modes which should be
X files which match the regular expression.  If more than one regular
X expression matches the file name, than the last matching one is chosen.
X
X Here is a list of modes which can be set:
X
X	-wordwrap		Wordwrap
X	-autoindent		Auto indent
X	-overwrite		Overtype mode
X	-lmargin nnn		Left margin
X	-rmargin nnn		Right margin
X	-tab nnn		Tab width
X	-indentc nnn		Indentation character (32 for space, 9 for tab)
X	-istep nnn		Number of indentation columns
*
-wordwrap
X
*.c
-autoindent
X
*.h
-autoindent
X
*akefile
*AKEFILE
*joerc
X
*.p
-autoindent
X
X THIRD SECTION: Named help screens:
X
X Use \i to turn on/off inverse video
X Use \u to turn on/off underline
X
{Basic
\i   Help Screen    turn off with ^KH                                            \i
\i \i\uCURSOR\u           \uGO TO\u            \uBLOCK\u      \uDELETE\u   \uMISC\u         \uEXIT\u      \i \i
\i \i^B left ^F right ^U  prev. screen ^KB begin  ^D char. ^KJ reformat ^KX save  \i \i
\i \i^P up   ^N down  ^V  next screen  ^KK end    ^Y line  ^TT overtype ^C  abort \i \i
\i \i^Z previous word ^A  beg. of line ^KM move   ^W >word `   Ctrl-    ^KZ shell \i \i
\i \i^X next word     ^E  end of line  ^KC copy   ^O word< ^\\  Meta-    \uFILE\u      \i \i
\i \i\uSEARCH\u           ^KU top of file  ^KW file   ^J >line ^R  retype   ^KE new   \i \i
\i \i^KF find text    ^KV end of file  ^KY delete ^_ undo  ^@  insert   ^KR insert\i \i
\i \i^L  find next    ^KL to line No.  ^K/ filter ^^ redo               ^KD save  \i \i
}
X
{Windows
\i   Help Screen    turn off with ^KH                                            \i
\i \i^KO Split the window into two.  You can then use ^KE to load a file into the \i \i
\i \i    new window.                                                              \i \i
\i \i^KG Make current window bigger         ^KT Make current window smaller       \i \i
\i \i^KN Go to the window below             ^KP Go to the window above            \i \i
\i \i^C  Eliminate the current window       ^KI Show all windows / Show one window\i \i
}
X
{Advanced
\i   Help Screen    turn off with ^KH                                            \i
\i \i ESC nn   repeat next command nn times     ^G   goto matching ( [ {          \i \i
\i \i ^K SPACE show position status             ^K-  goto prevous place in        \i \i
\i \i ^K [ 0-9 begin recording macro n               position history             \i \i
\i \i ^K ]     stop recording                   ^K=  goto next place              \i \i
\i \i ^K 0-9   play macro n                     ^K,  indent marked block less     \i \i
\i \i ^K A     center line                      ^K.  indent marked block more     \i \i
\i \i ^T X     rectangle mode                   ^K;  tag search                   \i \i
}
X
{Options
\i   Help Screen    turn off with ^KH                                            \i
\i \i                                Mode Settings                                \i \i
\i \i                                                                             \i \i
\i \i ^TT Insert/Overtype             ^TM Recenter cursor when it goes off window \i \i
\i \i ^TA Autoindent on/off           ^TF Force final NL when files are written   \i \i
\i \i ^TW Wordwrap on/off             ^TH Display characters above 127 as-is      \i \i
\i \i ^TL Left margin                 ^TN Show line number on status line         \i \i
\i \i ^TR Right margin                ^TC Show column number on status line       \i \i
\i \i ^TP No. PgUp/PgDn Lines         ^TD Tab width                               \i \i
\i \i ^TK Indent character            ^TI Indent step column width                \i \i
\i \i ^TX Rectangle mode                                                          \i \i
}
X
{Search
\i   Help Screen    turn off with ^KH                                            \i
\i \iSpecial search sequences:                                                    \i \i
\i \i    \\^     matches beginning of line     \\$     matches end of line          \i \i
\i \i    \\<     matches beginning of word     \\>     matches end of word          \i \i
\i \i    \\?     matches any single character  \\*     matches 0 or more characters \i \i
\i \i    \\c     matches balanced C expression \\\\     matches a \\                  \i \i
\i \i    \\[..]  matches one of a set          \\n     matches a newline            \i \i
\i \i    \\+     matches 0 or more of the character which follows the \\+           \i \i
\i \iSpecial replace sequences:                                                   \i \i
\i \i    \\&     replaced with text which matched search string                    \i \i
\i \i    \\0 - 9 replaced with text which matched Nth \\*, \\?, \\c, \\+, or \\[..]     \i \i
\i \i    \\\\     replaced with \\               \\n     replaced with newline        \i \i
}
X
{Names
\i   Help Screen    turn off with ^KH                                            \i
\i \i Hit TAB at file name prompts to generate menu of file names                 \i \i
\i \i Or use up/down keys to access history of previously entered names           \i \i
\i \i Special file names:                                                         \i \i
\i \i      !command                 Pipe in/out of a shell command                \i \i
\i \i      >>filename               Append to a file                              \i \i
\i \i      -                        Read/Write to/from standard I/O               \i \i
\i \i      filename,START,SIZE      Read/Write a part of a file/device            \i \i
\i \i          Give START/SIZE in decimal (255), octal (0377) or hex (0xFF)       \i \i
}
X
{Joe
\i   Help Screen    turn off with ^KH                                            \i
\i \i Joe Allen's email address:  'jhallen@world.std.com' or                      \i \i
\i \i 'rcarter' on the VWIS Linux BBS (508)793-9568                               \i \i
}
X
X FOURTH SECTION: Key bindings:
X
X :main are the main editing bindings
X :fprompt are file name prompt bindings
X :prompt are other prompt bindings
X :tab are file menu bindings
X :help are help menu bindings
X
X Use ^@ through ^_ and ^? for Ctrl chars
X Use SP for space
X Use a TO b to generate a range of characters
X Use UP DOWN RIGHT LEFT HOME END INS DEL PGUP PGDN
X     F1 F2 F3 F4 F5 F6 F7 F8 F9 F0
X     for the corresponding termcap key sequence definitions
X
X Simple macros can be made by comma seperating 2 or more command names.  For
X example:
X
X bof,bol	^T Z		Goto beginning of last line
X
X Also quoted matter is typed in literally:
X
X bol,">",dnarw	F1		Quote news article line
X
:main
X
type		^I		Tab
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abort		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtn		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:prompt
X
type		^I		Tab
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abortpw		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtnpw		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:fprompt
X
complete	^I		Complete file name
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abortpw		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtnpw		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:tab
X
aborttab	^C
arg		^[ 1 TO 9
backstab	^?
backstab	^H
boftab		^K U
boftab		^K ^U
boftab		^K u
boltab		HOME
boltab		^A
dnarwtab	DOWN
dnarwtab	^N
dnarwtab	^[ [ B
dnarwtab	^[ O B
eoftab		^K V
eoftab		^K ^V
eoftab		^K v
eoltab		END
eoltab		^E
explode		^K I
explode		^K ^I
explode		^K i
help		^K H
help		^K ^H
help		^K h
ltarwtab	LEFT
ltarwtab	^B
ltarwtab	^[ [ D
ltarwtab	^[ O D
nextw		^K N
nextw		^K ^N
nextw		^K n
play		^K 0 TO 9
prevw		^K P
prevw		^K ^P
prevw		^K p
record		^K [
retype		^R
rtarwtab	RIGHT
rtarwtab	^F
rtarwtab	^[ [ C
rtarwtab	^[ O C
rtntab		SP
rtntab		^M
shell		^K Z
shell		^K ^Z
shell		^K z
stop		^K ]
uparwtab	UP
uparwtab	^P
uparwtab	^[ [ A
uparwtab	^[ O A
X
:help
X
aborthelp	^C
arg		^[ 1 TO 9
bofhelp		^K U
bofhelp		^K ^U
bofhelp		^K u
bolhelp		HOME
bolhelp		^A
dnarwhelp	DOWN
dnarwhelp	^N
dnarwhelp	^[ [ B
dnarwhelp	^[ O B
eofhelp		^K V
eofhelp		^K ^V
eofhelp		^K v
eolhelp		END
eolhelp		^E
explode		^K I
explode		^K ^I
explode		^K i
ltarwhelp	LEFT
ltarwhelp	^B
ltarwhelp	^[ [ D
ltarwhelp	^[ O D
nextw		^K N
nextw		^K ^N
nextw		^K n
play		^K 0 TO 9
prevw		^K P
prevw		^K ^P
prevw		^K p
record		^K [
retype		^R
rtarwhelp	RIGHT
rtarwhelp	^F
rtarwhelp	^[ [ C
rtarwhelp	^[ O C
rtnhelp		SP
rtnhelp		^M
rtnhelp		^K H
rtnhelp		^K ^H
rtnhelp		^K h
shell		^K Z
shell		^K ^Z
shell		^K z
stop		^K ]
uparwhelp	UP
uparwhelp	^P
uparwhelp	^[ [ A
uparwhelp	^[ O A
SHAR_EOF
chmod 0600 joerc ||
echo 'restore of joerc failed'
Wc_c="`wc -c < 'joerc'`"
test 19130 -eq "$Wc_c" ||
	echo 'joerc: original size 19130, current size' "$Wc_c"
fi
# ============= kbd.c ==============
if test -f 'kbd.c' -a X"$1" != X"-c"; then
	echo 'x - skipping kbd.c (File already exists)'
else
echo 'x - extracting kbd.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'kbd.c' &&
/* Keyboard handler
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include "config.h"
#include "heap.h"
#include "zstr.h"
#include "va.h"
X
/* For help text loading in init. file */
#include "help.h"
X
/* For special key sequence table */
#include "scrn.h"
X
/* For option settings */
#include "bw.h"
X
#include "macro.h"
#include "kbd.h"
X
char **help_names;
struct help **help_structs;
struct help *first_help;
X
/* Create a KBD */
X
KBD *mkkbd(context)
CONTEXT *context;
{
KBD *kbd=(KBD *)malloc(sizeof(KBD));
kbd->topmap=context->kmap;
kbd->curmap=context->kmap;
return kbd;
}
X
/* Eliminate a KBD */
X
void rmkbd(k)
KBD *k;
{
free(k);
}
X
/* Lookup key in keyboard table */
X
static int findkey(kmap,c)
KMAP *kmap;
{
int x,y,z;
x=0; y=kmap->len; z= -1;
if(y)
X while(z!=(x+y)/2)
X  {
X  z=(x+y)/2;
X  if((kmap->keys[z].k&KEYMASK)==c) return z;
X  else if((kmap->keys[z].k&KEYMASK)>c) y=z;
X  else x=z;
X  }
return y;
}
X
/* Process next key for KBD */
X
MACRO *dokey(kbd,k)
KBD *kbd;
{
int n=findkey(kbd->curmap,k);
if(n==kbd->curmap->len || (kbd->curmap->keys[n].k&KEYMASK)!=k)
X kbd->curmap=kbd->topmap;
else if(kbd->curmap->keys[n].k&KEYSUB)
X kbd->curmap=kbd->curmap->keys[n].value.submap;
else
X {
X MACRO *macro=kbd->curmap->keys[n].value.macro;
X kbd->curmap=kbd->topmap;
X return macro;
X }
return 0;
}
X
/* Return command table index for given command name */
X
int findcmd(cmdtab,s)
CMDTAB *cmdtab;
char *s;
{
int x,y,z;
x=0; y=cmdtab->len; z= -1;
while(z!=(x+y)/2)
X {
X z=(x+y)/2;
X switch(zcmp(s,cmdtab->cmd[z].name))
X  {
X case  1: x=z; break;
X case -1: y=z; break;
X case  0: return z;
X  }
X }
return -1;
}
X
/* Return key code for key name */
X
static int keyval(s)
char *s;
{
int z1;
for(z1=0;z1!=NKEYS;++z1) if(!zcmp(s,seqs[z1].name))
X return seqs[z1].code;
if(s[0]=='^')
X if(s[1]=='?') return 127;
X else return s[1]&0x1f;
else if(!zcmp(s,"SP")) return ' ';
else return s[0];
}
X
/* Add a key to a keymap */
X
static void addkey(kmap,n,k,v)
KMAP *kmap;
MACRO *v;
{
if(kmap->len==kmap->size)
X kmap->keys=(KEY *)realloc(kmap->keys,sizeof(KEY)*(kmap->size+=64));
mbkwd(kmap->keys+n+1,kmap->keys+n,(kmap->len++-n)*sizeof(KEY));
kmap->keys[n].k=k;
kmap->keys[n].value.macro=v;
}
X
/* Eliminate a keymap */
X
static void rmkmap(kmap)
KMAP *kmap;
{
int x;
if(!kmap) return;
for(x=0;x!=kmap->len;++x)
X if(kmap->keys[x].k&KEYSUB) rmkmap(kmap->keys[x].value.submap);
X else rmmacro(kmap->keys[x].value.macro);
free(kmap->keys);
free(kmap);
}
X
OPTIONS *options=0;
extern int mid, dspasis, dspctrl, force, help, pgamnt, starow, stacol,
X           tabwidth;
X
void setoptions(bw,name)
BW *bw;
char *name;
{
OPTIONS *o;
for(o=options;o;o=o->next)
X if(rmatch(o->name,name))
X  {
X  bw->overtype=o->overtype;
X  bw->lmargin=o->lmargin;
X  bw->rmargin=o->rmargin;
X  bw->autoindent=o->autoindent;
X  bw->wordwrap=o->wordwrap;
X  bw->istep=o->istep;
X  bw->indentc=o->indentc;
X  bw->b->tab=o->tab;
X  break;
X  }
}
X
/* Process initialization file */
X
int prokbd(name,cntxts)
char *name;
CONTEXT **cntxts;
{
CONTEXT *context=0;		/* Current context */
KMAP *kmap;			/* Current keymap */
char buf[256];			/* Input buffer */
FILE *fd=fopen(name,"r");	/* File */
MACRO *macro=0;
struct help *tmp;
int nhelp=0;
int line=0;			/* Line number */
int err=0;			/* Set if there was any errors */
int x,y,n,z,c,d;
X
first_help=NULL;
help_names=vatrunc(NULL,0);
X
if(!fd) return -1;
X
fprintf(stderr,"Processing keymap file \'%s\'...",name); fflush(stdout);
X
while(++line, fgets(buf,256,fd))
X {
X /* Set file-dependant options */
X if(buf[0]=='*')
X  {
X  OPTIONS *n=(OPTIONS *)malloc(sizeof(OPTIONS));
X  for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
X  buf[x]=0;
X  n->lmargin=0;
X  n->rmargin=76;
X  n->overtype=0;
X  n->autoindent=0;
X  n->wordwrap=0;
X  n->tab=tabwidth;
X  n->indentc=' ';
X  n->istep=1;
X  n->next=options;
X  options=n;
X  n->name=zdup(buf);
X  continue;
X  }
X 
X if(buf[0]=='-')
X  {
X  int v;
X  for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
X  c=buf[x]; buf[x]=0;
X  if(!zcmp(buf+1,"mid")) mid=1;
X  else if(!zcmp(buf+1,"asis")) dspasis=1;
X  else if(!zcmp(buf+1,"stacol")) stacol=1;
X  else if(!zcmp(buf+1,"starow")) starow=1;
X  else if(!zcmp(buf+1,"force")) force=1;
X  else if(!zcmp(buf+1,"help")) help=1;
X  else if(!zcmp(buf+1,"pg") && c) sscanf(buf+x+1,"%d",&pgamnt);
X  else if(!zcmp(buf+1,"gtab") && c) sscanf(buf+x+1,"%d",&tabwidth);
X  else
X   if(options)
X    if(!zcmp(buf+1,"wordwrap")) options->wordwrap=1;
X    else if(!zcmp(buf+1,"autoindent")) options->autoindent=1;
X    else if(!zcmp(buf+1,"overwrite")) options->overtype=1;
X    else if(!zcmp(buf+1,"lmargin") && c) sscanf(buf+x+1,"%ld",&options->lmargin);
X    else if(!zcmp(buf+1,"rmargin") && c) sscanf(buf+x+1,"%ld",&options->rmargin);
X    else if(!zcmp(buf+1,"istep") && c) sscanf(buf+x+1,"%ld",&options->istep);
X    else if(!zcmp(buf+1,"tab") && c) sscanf(buf+x+1,"%d",&options->tab);
X    else if(!zcmp(buf+1,"indentc") && c) sscanf(buf+x+1,"%d",&options->indentc);
X    else fprintf(stderr,"\n%s %d: Unknown option",name,line);
X   else fprintf(stderr,"\n%s %d: No pattern selected for option",name,line);
X  continue;
X  }
X
X /* Process help text */
X if(buf[0]=='{')
X  {
X  int bfl;
X  tmp=(struct help *) malloc(sizeof(struct help));
X  nhelp++;
X  tmp->next=first_help;
X  first_help=tmp;
X  tmp->name=vsncpy(NULL,0,sz(buf+1)-1);
X  help_names=vaadd(help_names,tmp->name);
X  tmp->hlptxt=0;
X  tmp->hlpsiz=0;
X  tmp->hlpbsz=0;
X  tmp->hlplns=0;
X  up:
X  if(++line, !fgets(buf,256,fd))
X   {
X   err=1;
X   fprintf(stderr,
X           "\n%s %d: End of keymap file occured before end of help text",
X           name,line);
X   break;
X   }
X  if(buf[0]=='}')
X   {
X   if(!hlptxt)
X    hlptxt=tmp->hlptxt,
X    hlpsiz=tmp->hlpsiz,
X    hlpbsz=tmp->hlpbsz,
X    hlplns=tmp->hlplns;
X   continue;
X   }
X  bfl=zlen(buf);
X  if(tmp->hlpsiz+bfl>tmp->hlpbsz)
X   {
X   if(tmp->hlptxt) tmp->hlptxt=(char *)realloc(tmp->hlptxt,tmp->hlpbsz+bfl+1024);
X   else tmp->hlptxt=(char *)malloc(bfl+1024), tmp->hlptxt[0]=0;
X   tmp->hlpbsz+=bfl+1024;
X   }
X  zcpy(tmp->hlptxt+tmp->hlpsiz,buf);
X  tmp->hlpsiz+=bfl;
X  ++tmp->hlplns;
X  goto up;
X  }
X 
X /* Get context name */
X if(buf[0]==':')
X  {
X  for(x=1;buf[x] && buf[x]!=' ' && buf[x]!='\t' && buf[x]!='\n';++x);
X  buf[x]=0;
X  if(x==1) continue;
X  for(x=0,context=0;cntxts[x];++x)
X   if(!zcmp(buf+1,cntxts[x]->name))
X    {
X    context=cntxts[x];
X    break;
X    }
X  if(!context) fprintf(stderr,"\n%s %d: Unknown context",name,line), err=1;
X  continue;
X  }
X 
X /* Process Macro */
X x=0;
X macro=0;
X macroloop:
X if(buf[x]=='\"')
X  {
X  ++x;
X  while(buf[x] && buf[x]!='\"')
X   {
X   if(buf[x]=='\\' && buf[x+1])
X    {
X    ++x;
X    switch(buf[x])
X     {
X    case 'n': buf[x]=10; break;
X    case 'r': buf[x]=13; break;
X    case 'b': buf[x]=8; break;
X    case 'f': buf[x]=12; break;
X    case 'a': buf[x]=7; break;
X    case 't': buf[x]=9; break;
X    case 'x':
X     c=0;
X     if(buf[x+1]>='0' && buf[x+1]<='9') c=c*16+buf[++x]-'0';
X     else if(buf[x+1]>='a' && buf[x+1]<='f' ||
X             buf[x+1]>='A' && buf[x+1]<='F') c=c*16+(buf[++x]&0xF)+9;
X     if(buf[x+1]>='0' && buf[x+1]<='9') c=c*16+buf[++x]-'0';
X     else if(buf[x+1]>='a' && buf[x+1]<='f' ||
X             buf[x+1]>='A' && buf[x+1]<='F') c=c*16+(buf[++x]&0xF)+9;
X     buf[x]=c;
X     break;
X    case '0': case '1': case '2': case '3':
X    case '4': case '5': case '6': case '7':
X    case '8': case '9':
X     c=buf[x]-'0';
X     if(buf[x+1]>='0' && buf[x+1]<='7') c=c*8+buf[++x]-'0';
X     if(buf[x+1]>='0' && buf[x+1]<='7') c=c*8+buf[++x]-'0';
X     buf[x]=c;
X     break;
X     }
X    }
X   if(macro)
X    {
X    if(!macro->steps)
X     {
X     MACRO *m=macro;
X     macro=mkmacro(0,1,0);
X     addmacro(macro,m);
X     }
X    addmacro(macro,mkmacro(buf[x],1,findcmd(&cmdtab,"type")));
X    }
X   else macro=mkmacro(buf[x],1,findcmd(&cmdtab,"type"));
X   ++x;
X   }
X  if(buf[x]=='\"') ++x;
X  }
X else
X  {
X  for(y=x;
X      buf[y] && buf[y]!=',' && buf[y]!=' ' && buf[y]!='\t' && buf[y]!='\n';
X      ++y);
X  if(y!=x)
X   {
X   z=buf[y]; buf[y]=0;
X   n=findcmd(&cmdtab,buf+x);
X   if(n== -1)
X    {
X    fprintf(stderr,"\n%s %d: Key function \'%s\' not found",name,line,buf);
X    err=1;
X    continue;
X    }
X   else if(macro)
X    {
X    if(!macro->steps)
X     {
X     MACRO *m=macro;
X     macro=mkmacro(0,1,0);
X     addmacro(macro,m);
X     }
X    addmacro(macro,mkmacro(-1,1,n));
X    }
X   else macro=mkmacro(-1,1,n);
X   buf[x=y]=z;
X   }
X  }
X if(buf[x]==',')
X  {
X  ++x;
X  goto macroloop;
X  }
X
X if(!macro) continue;
X
X if(!context)
X  {
X  err=1;
X  fprintf(stderr,"\n%s %d: No context selected for key",name,line);
X  continue;
X  }
X
X /* Process key sequence */
X kmap=0;
X n= -1;
X while(buf[x]==' ' || buf[x]=='\t') ++x;
X while(1)
X  {
X  int qw,zz;
X  if(buf[x]==' ') ++x;
X  if(!buf[x] || buf[x]=='\n' || buf[x]==' ' || buf[x]=='\t') break;
X  /* Got Next key */
X  for(zz=x;buf[zz]!=' ' && buf[zz] && buf[zz]!='\t' && buf[zz]!='\n';++zz);
X  qw=buf[zz]; buf[zz]=0;
X  d=c=keyval(buf+x);
X  buf[zz]=qw; x=zz;
X
X  if(buf[x]==' ') ++x;
X  if(buf[x]=='T' && buf[x+1]=='O')
X   {
X   x+=2;
X   if(buf[x]==' ') ++x;
X   if(buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t')
X    {
X    for(zz=x;buf[zz]!=' ' && buf[zz] && buf[zz]!='\t' && buf[zz]!='\n';++zz);
X    qw=buf[zz]; buf[zz]=0;
X    d=keyval(buf+x);
X    buf[zz]=qw; x=zz;
X    }
X   }
X  if(d<c) d=c;
X
X  /* Add it as if it were a submap */
X  if(!kmap)
X   {
X   if(!(kmap=context->kmap))
X    {
X    kmap=(KMAP *)malloc(sizeof(KMAP));
X    kmap->keys=(KEY *)malloc((kmap->size=128)*sizeof(KEY));
X    kmap->len=0;
X    context->kmap=kmap;
X    }
X   }
X  else
X   if(kmap->keys[n].k&KEYSUB) kmap=kmap->keys[n].value.submap;
X   else
X    {
X    kmap->keys[n].value.submap=(KMAP *)malloc(sizeof(KMAP));
X    kmap->keys[n].k|=KEYSUB;
X    kmap=kmap->keys[n].value.submap;
X    kmap->keys=(KEY *)malloc((kmap->size=128)*sizeof(KEY));
X    kmap->len=0;
X    }
X  n=findkey(kmap,c);
X  if(n==kmap->len || (kmap->keys[n].k&KEYMASK)!=c) addkey(kmap,n,c,NULL);
X  }
X while(c<=d)
X  {
X  n=findkey(kmap,c);
X  if(n==kmap->len || (kmap->keys[n].k&KEYMASK)!=c)
X   addkey(kmap,n,c,c==d?macstk(macro,c):dupmacro(macstk(macro,c)));
X  else
X   {
X   if(kmap->keys[n].k&KEYSUB)
X    rmkmap(kmap->keys[n].value.submap),
X    kmap->keys[n].k&=~KEYSUB;
X   else
X    rmmacro(kmap->keys[n].value.macro);
X   kmap->keys[n].value.macro=(c==d?macstk(macro,c):dupmacro(macstk(macro,c)));
X   }
X  ++c;
X  }
X }
fclose(fd);
if(err) fprintf(stderr,"\ndone\n");
else fprintf(stderr,"done\n");
if (nhelp)
X {
X  help_structs=(struct help **) malloc(sizeof(struct help *)*nhelp);
X  tmp=first_help;
X  while(nhelp--)
X   {
X    help_structs[nhelp]=tmp;
X    tmp=tmp->next;
X   }
X }
return 0;
}
X
struct help *get_help(name)
X char *name;
X {
X  struct help *tmp;
X  for(tmp=first_help;tmp && zcmp(tmp->name,name);tmp=tmp->next);
X  return tmp;
X }
X
SHAR_EOF
chmod 0600 kbd.c ||
echo 'restore of kbd.c failed'
Wc_c="`wc -c < 'kbd.c'`"
test 11368 -eq "$Wc_c" ||
	echo 'kbd.c: original size 11368, current size' "$Wc_c"
fi
# ============= kbd.h ==============
if test -f 'kbd.h' -a X"$1" != X"-c"; then
	echo 'x - skipping kbd.h (File already exists)'
else
echo 'x - extracting kbd.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'kbd.h' &&
/* Keyboard handler
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ikbd
#define _Ikbd 1
X
#include "config.h"
#include "macro.h"
X
typedef struct key KEY;
typedef struct kmap KMAP;
typedef struct cmd CMD;
typedef struct context CONTEXT;
typedef struct cmdtab CMDTAB;
typedef struct kbd KBD;
X
/* The command table */
X
extern CMDTAB cmdtab;
X
typedef struct options OPTIONS;
struct options
X {
X OPTIONS *next;
X char *name;
X int overtype;
X long lmargin;
X long rmargin;
X int autoindent;
X int wordwrap;
X int tab;
X int indentc;
X long istep;
X };
X
void setoptions();
X
/* A key to macro binding in a keymap */
X
struct key
X {
X int k;			/* Key value */
X union
X  {
X  MACRO *macro;		/* Macro or */
X  KMAP *submap;		/* Submap address (for prefix keys) */
X  } value;
X };
X
/* A map of keycode to command/sub-map bindings */
X
struct kmap
X {
X int len;		/* Number of KEY entries */
X int size;		/* Malloc size of block */
X KEY *keys;		/* KEYs.  Sorted. */
X };
X
/* Masks & bits for 'k' entry in KEY */
X
#define KEYMASK 0x7fff	/* Mask to get key value */
#define KEYSUB 0x8000	/* Bit set for prefix key */
X
/* Command entry */
X
struct cmd
X {
X char *name;		/* Command name */
X int flag;		/* Execution flags */
X void (*func)();	/* Function bound to name */
X };
X
/* A Context (a set of bindings) */
X
struct context
X {
X char *name;		/* Name of this context */
X KMAP *kmap;		/* Keymap for this context */
X };
X
/* Command table */
X
struct cmdtab
X {
X CMD *cmd;		/* The entries themselves (sorted by name) */
X int len;		/* Number of entries */
X };
X
/* A keyboard handler */
X
struct kbd
X {
X KMAP *curmap;		/* Current keymap */
X KMAP *topmap;		/* Top-level keymap */
X };
X
/* KBD *mkkbd(CONTEXT *context);
X   Create a keyboard handler for the given context.
*/
KBD *mkkbd();
X
/* void rmkbd(KBD *);
X *
X * Eliminate a keyboard handler
X */
void rmkbd();
X
/* MACRO *dokey(KBD *kbd,char k);
X   Handle a key for a KBD:
X
X     Returns 0 for invalid or prefix keys
X
X     Returns a macro address for completed key-sequences
*/
MACRO *dokey();
X
/* int prokbd(char *name,CONTEXT **cmds);  Process a keymap set-up file into
X   the list of contexts.  Returns 0 for success or -1 for error
*/
int prokbd();
X
/* int findcmd(CMDTAB *cmdtab,char *s);
X * Return command table index for the named command
X */
int findcmd();
X
struct help *get_help();
X
#endif
SHAR_EOF
chmod 0600 kbd.h ||
echo 'restore of kbd.h failed'
Wc_c="`wc -c < 'kbd.h'`"
test 2999 -eq "$Wc_c" ||
	echo 'kbd.h: original size 2999, current size' "$Wc_c"
fi
# ============= macro.c ==============
if test -f 'macro.c' -a X"$1" != X"-c"; then
	echo 'x - skipping macro.c (File already exists)'
else
echo 'x - extracting macro.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'macro.c' &&
/* Keyboard macros
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "main.h"
#include "macro.h"
X
/* Create a macro */
X
MACRO *mkmacro(k,arg,n)
{
MACRO *macro=(MACRO *)malloc(sizeof(MACRO));
macro->steps=0;
macro->size=0;
macro->arg=arg;
macro->n=n;
macro->k=k;
return macro;
}
X
/* Eliminate a macro */
X
void rmmacro(macro)
MACRO *macro;
{
if(macro)
X {
X if(macro->steps)
X  {
X  int x;
X  for(x=0;x!=macro->n;++x) rmmacro(macro->steps[x]);
X  free(macro->steps);
X  }
X free(macro);
X }
}
X
/* Add a step to block macro */
X
void addmacro(macro,m)
MACRO *macro, *m;
{
if(macro->n==macro->size)
X macro->steps=(MACRO **)realloc(macro->steps,(macro->size+=5)*sizeof(MACRO *));
macro->steps[macro->n++]=m;
}
X
/* Duplicate a macro */
X
MACRO *dupmacro(mac)
MACRO *mac;
{
MACRO *m=(MACRO *)malloc(sizeof(MACRO));
int x;
m->k=mac->k;
m->n=mac->n;
m->arg=mac->arg;
if(mac->steps)
X {
X int x;
X m->steps=(MACRO **)malloc((m->size=mac->n)*sizeof(MACRO *));
X for(x=0;x!=m->n;++x) m->steps[x]=dupmacro(mac->steps[x]);
X }
else m->steps=0, m->size=0;
return m;
}
X
MACRO *macstk(m,k)
MACRO *m;
{
m->k=k;
return m;
}
X
MACRO *macsta(m,a)
MACRO *m;
{
m->arg=a;
return m;
}
X
/* Keyboard macro recorder */
X
MACRO *kbdmacro[10];
int playmode[10];
X
struct recmac *recmac=0;
X
void unmac()
{
if(recmac) rmmacro(recmac->m->steps[--recmac->m->n]);
}
X
void record(m)
MACRO *m;
{
if(recmac) addmacro(recmac->m,dupmacro(m));
}
X
void urecord(w)
W *w;
{
int c;
int n;
struct recmac *r;
n=query(w,"Macro to record (0-9 or ^C to abort): ");
if(n>'9' || n<'0') return;
unmac(); unmac();
r=(struct recmac *)malloc(sizeof(struct recmac));
r->m=mkmacro(0,1,0);
r->next=recmac;
r->n=n-'0';
recmac=r;
}
X
void ustop()
{
unmac();
if(recmac)
X {
X struct recmac *r=recmac;
X MACRO *m;
X recmac=r->next;
X if(kbdmacro[r->n]) rmmacro(kbdmacro[r->n]);
X kbdmacro[r->n]=r->m;
X if(recmac) record(m=mkmacro(r->n+'0',1,findcmd(&cmdtab,"play"))), rmmacro(m);
X free(r);
X }
}
X
void uplay(w,c)
W *w;
{
if(c>'9' || c<'0') return;
c-='0';
if(playmode[c] || !kbdmacro[c]) return;
playmode[c]=1;
exmacro(kbdmacro[c]);
playmode[c]=0;
}
SHAR_EOF
chmod 0600 macro.c ||
echo 'restore of macro.c failed'
Wc_c="`wc -c < 'macro.c'`"
test 2755 -eq "$Wc_c" ||
	echo 'macro.c: original size 2755, current size' "$Wc_c"
fi
# ============= macro.h ==============
if test -f 'macro.h' -a X"$1" != X"-c"; then
	echo 'x - skipping macro.h (File already exists)'
else
echo 'x - extracting macro.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'macro.h' &&
/* Keyboard macros
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Imacro
#define _Imacro 1
X
#include "config.h"
X
typedef struct macro MACRO;
X
struct macro
X {
X int k;		/* Keycode */
X int arg;	/* Repeat argument */
X int n;		/* Command number or number of steps */
X int size;	/* Malloc size of steps */
X MACRO **steps;	/* Block */
X };
X
struct recmac
X {
X struct recmac *next;
X int n;
X MACRO *m;
X };
X
extern struct recmac *recmac;	/* Set when macro is recording */
X
MACRO *mkmacro();
void addmacro();
MACRO *dupmacro();
void rmmacro();
MACRO *macstk();
MACRO *macsta();
void uplay();
void ustop();
void urecord();
void record();
void unmac();
X
#endif
SHAR_EOF
chmod 0600 macro.h ||
echo 'restore of macro.h failed'
Wc_c="`wc -c < 'macro.h'`"
test 1344 -eq "$Wc_c" ||
	echo 'macro.h: original size 1344, current size' "$Wc_c"
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
else
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
/* Editor startup and main edit loop
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include "config.h"
#include "vfile.h"
#include "blocks.h"
#include "tty.h"
#include "toomany.h"
#include "termcap.h"
#include "scrn.h"
#include "b.h"
#include "bw.h"
#include "tw.h"
#include "w.h"
#include "kbd.h"
#include "zstr.h"
#include "macro.h"
#include "tab.h"
#include "pw.h"
#include "edfuncs.h"
#include "poshist.h"
#include "pattern.h"
#include "help.h"
#include "vs.h"
#include "main.h"
X
/* Message to display when exiting the editor */
X
int help=0;
X
char *exmsg=0;
X
/* Main screen */
X
SCREEN *maint;
X
/* Command table */
X
#define EMID 1
#define ECHKXCOL 2
#define EFIXXCOL 4
#define EMINOR 8
#define EPOS 16
#define EMOVE 32
X
int typen;
X
static CMD cmds[]=
{
X  { "abort", TYPETW, uaborttw },
X  { "aborthelp", TYPEHELP, uhabort },
X  { "abortpw", TYPEPW, uabortpw },
X  { "aborttab", TYPETAB, tuabort },
X  { "arg", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uarg },
X  { "backs", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR, ubacks },
X  { "backstab", TYPETAB, tbacks },
X  { "backw", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL, ubackw },
X  { "blkcpy", TYPETW+TYPEPW+0, ublkcpy },
X  { "blkdel", TYPETW+TYPEPW+EFIXXCOL, ublkdel },
X  { "blkmove", TYPETW+TYPEPW+EFIXXCOL, ublkmove },
X  { "blksave", TYPETW+TYPEPW+0, ublksave },
X  { "bof", TYPETW+TYPEPW+EMOVE+EFIXXCOL, ubof },
X  { "bofhelp", TYPEHELP, uhbof },
X  { "boftab", TYPETAB, tbof },
X  { "bol", TYPETW+TYPEPW+EFIXXCOL, ubol },
X  { "bolhelp", TYPEHELP, uhbol },
X  { "boltab", TYPETAB, tbol },
X  { "center", TYPETW+TYPEPW+EFIXXCOL, ucenter },
X  { "check", TYPETW+TYPEPW+0, ucheck },
X  { "checkp", TYPETW+TYPEPW+0, ucheckp },
X  { "complete", TYPETW+TYPEPW, ucmplt },
X  { "delbol", TYPETW+TYPEPW+EFIXXCOL, udelbl },
X  { "delch", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR, udelch },
X  { "deleol", TYPETW+TYPEPW+0, udelel },
X  { "dellin", TYPETW+TYPEPW+EFIXXCOL, udelln },
X  { "delw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, udelw },
X  { "dnarw", TYPETW+TYPEPW+EMOVE, udnarw },
X  { "dnarwhelp", TYPEHELP, uhdnarw },
X  { "dnarwtab", TYPETAB, tdnarw },
X  { "dnslide", TYPETW+EMOVE, udnslide },
X  { "edit", TYPETW+TYPEPW, uedit },
X  { "eof", TYPETW+TYPEPW+EFIXXCOL+EMOVE, ueof },
X  { "eofhelp", TYPEHELP, uheof },
X  { "eoftab", TYPETAB, teof },
X  { "eol", TYPETW+TYPEPW+EFIXXCOL, ueol },
X  { "eolhelp", TYPEHELP, uheol },
X  { "eoltab", TYPETAB, teol },
X  { "explode", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uexpld },
X  { "exsave", TYPETW+TYPEPW, uexsve },
X  { "ffirst", TYPETW+TYPEPW+EMOVE, pffirst },
X  { "filt", TYPETW+TYPEPW+0, ufilt },
X  { "fnext", TYPETW+TYPEPW+EFIXXCOL+EMID+EMOVE, pfnext },
X  { "format", TYPETW+TYPEPW+EFIXXCOL, uformat },
X  { "groww", TYPETW, ugroww },
X  { "help", TYPETW+TYPEPW+TYPETAB, uhelp },
X  { "iasis", TYPETW+TYPEPW+TYPETAB+TYPEHELP+EFIXXCOL, uiasis },
X  { "iforce", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uiforce },
X  { "iindent", TYPETW+TYPEPW, uiindent },
X  { "iindentc", TYPETW+TYPEPW, uicindent },
X  { "iistep", TYPETW+TYPEPW, uiistep },
X  { "ilmargin", TYPETW+TYPEPW, uilmargin },
X  { "imid", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uimid },
X  { "insc", TYPETW+TYPEPW+EFIXXCOL, uinsc },
X  { "insf", TYPETW+TYPEPW+0, uinsf },
X  { "ipgamnt", TYPETW+TYPEPW, uipgamnt },
X  { "irmargin", TYPETW+TYPEPW+TYPETAB, uirmargin },
X  { "isquare", TYPETW+TYPEPW, uisquare },
X  { "istacol", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uistacol },
X  { "istarow", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uistarow },
X  { "itab", TYPETW+TYPEPW, uitab },
X  { "itype", TYPETW+TYPEPW, uitype },
X  { "iwrap", TYPETW+TYPEPW, uiwrap },
X  { "lindent", TYPETW+TYPEPW+0, ulindent },
X  { "line", TYPETW+TYPEPW+EMOVE, uline },
X  { "ltarw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, ultarw },
X  { "ltarwhelp", TYPEHELP, uhltarw },
X  { "ltarwtab", TYPETAB, tltarw },
X  { "markb", TYPETW+TYPEPW+0, umarkb },
X  { "markk", TYPETW+TYPEPW+0, umarkk },
X  { "nedge", TYPETW+TYPEPW+EFIXXCOL, unedge },
X  { "nextpos", TYPETW+TYPEPW+EFIXXCOL+EMID+EPOS, unextpos },
X  { "nextw", TYPETW+TYPEPW+TYPETAB+TYPEHELP, unextw },
X  { "nextword", TYPETW+TYPEPW+EFIXXCOL, unxtwrd },
X  { "open", TYPETW+TYPEPW+EFIXXCOL, uopen },
X  { "pedge", TYPETW+TYPEPW+EFIXXCOL, upedge },
X  { "pgdn", TYPETW+EMOVE, upgdn },
X  { "pgup", TYPETW+EMOVE, upgup },
X  { "play", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uplay },
X  { "prevpos", TYPETW+TYPEPW+EPOS+EMID+EFIXXCOL, uprevpos },
X  { "prevw", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uprevw },
X  { "prevword", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, uprvwrd },
X  { "quote", TYPETW+TYPEPW+EFIXXCOL, uquote },
X  { "quote8", TYPETW+TYPEPW+EFIXXCOL, uquote8 },
X  { "record", TYPETW+TYPEPW+TYPETAB+TYPEHELP, urecord },
X  { "redo", TYPETW+TYPEPW+EFIXXCOL, uredo },
X  { "retype", TYPETW+TYPEPW+TYPETAB+TYPEHELP, uretyp },
X  { "rindent", TYPETW+TYPEPW+0, urindent },
X  { "rtarw", TYPETW+TYPEPW+EFIXXCOL, urtarw },
X  { "rtarwhelp", TYPEHELP, uhrtarw },
X  { "rtarwtab", TYPETAB, trtarw },
X  { "rtn", TYPETW+TYPEPW+EFIXXCOL, urtn },
X  { "rtnhelp", TYPEHELP, uhrtn },
X  { "rtnpw", TYPEPW+EMID, upromptrtn },
X  { "rtntab", TYPETAB, trtn },
X  { "save", TYPETW+TYPEPW, usave },
X  { "shell", TYPETW+TYPEPW+TYPETAB+TYPEHELP, ushell },
X  { "shrinkw", TYPETW, ushrnk },
X  { "splitw", TYPETW, usplitw },
X  { "stat", TYPETW+TYPEPW, ustat },
X  { "stop", TYPETW+TYPEPW+TYPETAB+TYPEHELP, ustop },
X  { "tag", TYPETW+TYPEPW, utag },
X  { "tomatch", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL, utomatch },
X  { "type", TYPETW+TYPEPW+EFIXXCOL+EMINOR, utype },
X  { "undo", TYPETW+TYPEPW+EFIXXCOL, uundo },
X  { "uparw", TYPETW+TYPEPW+EMOVE, uuparw },
X  { "uparwhelp", TYPEHELP, uhuparw },
X  { "uparwtab", TYPETAB, tuparw },
X  { "upslide", TYPETW+EMOVE, uupslide }
};
X
CMDTAB cmdtab={cmds,sizeof(cmds)/sizeof(CMD)};
X
void dofollows()
{
W *w=maint->curwin; do
X {
X if(w->y!= -1) w->watom->follow(w);
X w=(W *)(w->link.next);
X }
X while(w!=maint->curwin);
}
X
/* Execute a command */
X
void execmd(n,k)
{
BW *bw=(BW *)maint->curwin->object;
if((cmdtab.cmd[n].flag&ECHKXCOL) && bw->cursor->xcol!=bw->cursor->col)
X goto skip;
if(!(cmdtab.cmd[n].flag&maint->curwin->watom->what)) goto skip;
cmdtab.cmd[n].func(maint->curwin,k);
if(leave) return;
bw=(BW *)maint->curwin->object;
X
if(!(cmdtab.cmd[n].flag&EPOS) &&
X   (maint->curwin->watom->what&(TYPETW|TYPEPW)))
X afterpos(maint->curwin,bw->cursor);
if(!(cmdtab.cmd[n].flag&(EMOVE|EPOS)) &&
X   (maint->curwin->watom->what&(TYPETW|TYPEPW)))
X aftermove(maint->curwin,bw->cursor);
X
skip:
if(cmdtab.cmd[n].flag&EFIXXCOL) bw->cursor->xcol=bw->cursor->col;
if(cmdtab.cmd[n].flag&EMID)
X {
X int omid=mid; mid=1;
X dofollows();
X mid=omid;
X }
}
X
MACRO *curmacro=0;
int macroptr;
X
void exmacro(m)
MACRO *m;
{
int arg=maint->arg;
int flg=0;
maint->arg=0;
X
if(!arg) arg=1;
X
if( m->steps ||
X    arg!=1 ||
X    !(cmdtab.cmd[m->n].flag&EMINOR)
X  ) flg=1;
X
if(flg) umclear();
while(arg-- && !leave)
X if(m->steps)
X  {
X  MACRO *tmpmac=curmacro;
X  int tmpptr=macroptr;
X  int x=0;
X  while(m && x!=m->n && !leave)
X   {
X   MACRO *d;
X   d=m->steps[x++];
X   curmacro=m;
X   macroptr=x;
X   exmacro(d);
X   m=curmacro;
X   x=macroptr;
X   }
X  curmacro=tmpmac;
X  macroptr=tmpptr;
X  }
X else execmd(m->n,m->k);
if(leave) return;
if(flg) umclear();
X
undomark();
}
X
void exemac(m)
MACRO *m;
{
record(m);
exmacro(m);
}
X
static int eungotten;
static int eungottenc;
X
static CONTEXT *cntxts[]= { &cmain, &cprmpt,&cttab,&cfprmpt,&cthelp,0 };
X
void eungetc(c)
{
if(c==MAXINT) return;
if(curmacro)
X {
X --macroptr;
X return;
X }
else
X {
X eungotten=1;
X eungottenc=c;
X unmac();
X }
}
X
int dengetc()
{
int c;
if(eungotten)
X {
X eungotten=0;
X c=eungottenc;
X }
else c=ngetc(maint->t);
return c;
}
X
int engetc()
{
MACRO *m;
int c;
if(eungotten)
X {
X eungotten=0;
X c=eungottenc;
X }
else if(curmacro)
X {
X if(curmacro->n!=macroptr && !curmacro->steps[macroptr]->steps &&
X    curmacro->steps[macroptr]->n==typen) c=curmacro->steps[macroptr++]->k;
X else c=MAXINT;
X }
else c=ngetc(maint->t);
record(m=mkmacro(c,1,typen)); rmmacro(m);
return c;
}
X
void edupd()
{
W *w;
dofollows();
ttflsh();
nscroll(maint->t);
dsphlp(maint);
w=maint->curwin; do
X {
X if(w->y!= -1)
X  {
X  w->watom->disp(w);
X  if(w->msgb)
X   {
X   msgout(w->t->t,w->y+w->h-1,w->msgb);
X   w->msgb=0;
X   w->t->t->updtab[w->y+w->h-1]=1;
X   }
X  if(w->msgt)
X   {
X   int y=w->h>1?1:0;
X   msgout(w->t->t,w->y+y,w->msgt);
X   w->msgt=0;
X   w->t->t->updtab[w->y+y]=1;
X   }
X  }
X w=(W *)(w->link.next);
X }
X while(w!=maint->curwin);
cpos(maint->t,
X     maint->curwin->x+maint->curwin->curx,
X     maint->curwin->y+maint->curwin->cury);
}
X
int edgetc()
{
edupd();
return engetc();
}
X
int dedgetc()
{
edupd();
return dengetc();
}
X
int main(argc,argv)
int argc;
char *argv[];
{
char *s;
SCRN *n;
W *w;
int c;
P *p;
typen=findcmd(&cmdtab,"type");
if(prokbd(".joerc",cntxts))
X {
X s=getenv("HOME");
X if(!s) goto in;
X s=vsncpy(NULL,0,sz(s));
X s=vsncpy(s,sLEN(s),sc("/.joerc"));
X if(prokbd(s,cntxts))
X  {
X  in:;
X  if(prokbd(s=JOERC,cntxts))
X   {
X   fprintf(stderr,"Couldn\'t open keymap file \'%s\'\n",s);
X   return 1;
X   }
X  }
X }
if(!(n=nopen())) return 1;
maint=screate(n);
X
if(argc<2)
X {
X W *w=wmktw(maint,bmk());
X BW *bw=(BW *)w->object;
X setoptions(bw,"");
X }
else
X {
X long lnum;
X int omid;
X for(c=1,lnum=0;argv[c];++c)
X  if(argv[c][0]=='+' && argv[c][1])
X   {
X   lnum=0;
X   sscanf(argv[c]+1,"%ld",&lnum);
X   if(lnum) --lnum;
X   }
X  else
X   {
X   B *b=bfind(argv[c]);
X   BW *bw;
X   int fl=0;
X   if(!b)
X    {
X    b=bmk();
X    fl=bload(b,argv[c]);
X    }
X   w=wmktw(maint,b);
X   if(fl) w->msgt=msgs[5+fl];
X   bw=(BW *)w->object;
X   setoptions(bw,argv[c]);
X   pline(bw->cursor,lnum);
X   lnum=0;
X   }
X wshowall(maint);
X omid=mid; mid=1;
X dofollows();
X mid=omid;
X }
if(help) helpon(maint);
msgnw(lastw(maint),"\\i** Joe's Own Editor v1.0.5 ** Copyright (C) 1992 Joseph H. Allen **\\i");
do
X {
X int wid,hei;
X MACRO *m=dokey(maint->curwin->kbd,dedgetc());
X ttgtsz(&wid,&hei);
X if(wid>=2 && wid!=maint->w ||
X    hei>=1 && hei!=maint->h)
X  {
X  nresize(maint->t,wid,hei);
X  sresize(maint);
X  }
X if(m) exemac(m);
X }
X while(!leave);
nclose(n);
if(exmsg) fprintf(stderr,"\n%s\n",exmsg);
return 0;
}
SHAR_EOF
chmod 0600 main.c ||
echo 'restore of main.c failed'
Wc_c="`wc -c < 'main.c'`"
test 10617 -eq "$Wc_c" ||
	echo 'main.c: original size 10617, current size' "$Wc_c"
fi
# ============= main.h ==============
if test -f 'main.h' -a X"$1" != X"-c"; then
	echo 'x - skipping main.h (File already exists)'
else
echo 'x - extracting main.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.h' &&
/* Editor startup and edit loop
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Imain
#define _Imain 1
X
#include "config.h"
#include "w.h"
X
#include "config.h"
X
extern char *exmsg;		/* Exit message */
extern int help;
extern SCREEN *maint;		/* Primary screen */
X
void eungetc();		/* Unget a character into editor kbd input */
void edupd();
int edgetc();		/* Get kbd character / refresh screen */
int engetc();		/* Get kbd character */
X
#endif
SHAR_EOF
chmod 0600 main.h ||
echo 'restore of main.h failed'
Wc_c="`wc -c < 'main.h'`"
test 1140 -eq "$Wc_c" ||
	echo 'main.h: original size 1140, current size' "$Wc_c"
fi
# ============= makefile ==============
if test -f 'makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping makefile (File already exists)'
else
echo 'x - extracting makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'makefile' &&
# Makefile for Joe's Own Editor
X
CC = cc
CFLAGS = -O -D_HPUX_SOURCE -DJOERC=\"/usr/local/lib/joerc\"
OBJS = main.o termcap.o vfile.o pathfunc.o queue.o blocks.o vs.o va.o scrn.o \
X       b.o bw.o tw.o pw.o help.o heap.o toomany.o queue.o zstr.o edfuncs.o \
X       kbd.o w.o reg.o tab.o pattern.o random.o regex.o undo.o menu.o macro.o \
X       poshist.o
X
foo:
X	@echo Type make followed by one of the following
X	@echo
X	@echo bsd hpux xenix sv posix termidx install clean
X
xenix: $(OBJS) ttyxenix.o olddir.o
X	$(CC) $(CFLAGS) -o joe $(OBJS) ttyxenix.o olddir.o -lx
X
posix: $(OBJS) ttyposix.o
X	$(CC) $(CFLAGS) -o joe $(OBJS) ttyposix.o
X
bsd: $(OBJS) ttybsd.o
X	$(CC) $(CFLAGS) -o joe $(OBJS) ttybsd.o
X
sv: $(OBJS) ttysv.o
X	$(CC) $(CFLAGS) -o joe $(OBJS) ttysv.o
X
hpux: $(OBJS) ttyhpux.o
X	$(CC) $(CFLAGS) -o joe $(OBJS) ttyhpux.o
X
termidx: termidx.o
X	$(CC) $(CFLAGS) -o termidx termidx.o
X
install: joe termidx
X	strip joe
X	strip termidx
X	mv joe /usr/local/bin
X	cp joerc /usr/local/lib/joerc
X	mv termidx /usr/local/bin
X	chmod a+x /usr/local/bin/joe
X	chmod a+r /usr/local/lib/joerc
X	chmod a+x /usr/local/bin/termidx
X
clean:
X	rm -f $(OBJS) ttyxenix.o ttyposix.o ttybsd.o ttyhpux.o ttysv.o
SHAR_EOF
chmod 0600 makefile ||
echo 'restore of makefile failed'
Wc_c="`wc -c < 'makefile'`"
test 1179 -eq "$Wc_c" ||
	echo 'makefile: original size 1179, current size' "$Wc_c"
fi
# ============= menu.c ==============
if test -f 'menu.c' -a X"$1" != X"-c"; then
	echo 'x - skipping menu.c (File already exists)'
else
echo 'x - extracting menu.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'menu.c' &&
/* Menu selection window
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "scrn.h"
#include "vs.h"
#include "va.h"
#include "menu.h"
X
void menufllw(m)
MENU *m;
{
m->top=m->cursor-m->cursor%m->perline;
}
X
void menugen(m)
MENU *m;
{
int col;
int x;
int *s=m->t->t->scrn+m->x+m->y*m->t->t->co;
col=0;
for(x=0;x!=m->perline && m->list[x+m->top];++x)
X {
X int atr,z;
X if(x+m->top==m->cursor) atr=INVERSE;
X else atr=0;
X if(col==m->w) break;
X for(z=0;m->list[x+m->top][z];++z)
X  {
X  if(col==m->w) break;
X  if(s[col]!=(unsigned char)m->list[x+m->top][z]+atr)
X   {
X   s[col]=(unsigned char)m->list[x+m->top][z]+atr;
X   outatr(m->t->t,m->x+col,m->y,s[col]);
X   }
X  ++col;
X  }
X while(z<m->width)
X  {
X  if(col==m->w) break;
X  if(s[col]!=' ')
X   s[col]=' ', outatr(m->t->t,m->x+col,m->y,' ');
X  ++col; ++z;
X  }
X if(col!=m->w)
X  {
X  if(s[col]!=' ')
X   s[col]=' ', outatr(m->t->t,m->x+col,m->y,' ');
X  ++col;
X  }
X }
if(col!=m->w) eraeol(m->t->t,m->x+col,m->y);
}
X
void menumove(m,x,y)
MENU *m;
{
m->x=x;
m->y=y;
}
X
void menuresz(m,wi,he)
MENU *m;
{
m->w=wi;
m->h=he;
}
X
void mconfig(m)
MENU *m;
{
/* Configure menu display parameters */
int x;
for(x=0,m->width=0;m->list[x];++x)
X if(zlen(m->list[x])>m->width) m->width=zlen(m->list[x]);
if(m->width>m->w) m->width=m->w-1;
m->perline=m->w/(m->width+1);
}
X
MENU *mkmenu(t,s,x,y,wi,h)
SCREEN *t;
char **s;
{
MENU *m=(MENU *)malloc(sizeof(MENU));
m->list=s;
m->top=0;
m->cursor=0;
m->t=t;
m->h=h; m->w=wi; m->x=x; m->y=y;
m->object=0;
mconfig(m);
return m;
}
X
void menurm(m)
MENU *m;
{
free(m);
}
X
void mbol(m)
MENU *m;
{
m->cursor=m->top;
}
X
void mbof(m)
MENU *m;
{
m->cursor=0;
}
X
void meof(m)
MENU *m;
{
if(aLEN(m->list)) m->cursor=aLEN(m->list)-1;
}
X
void meol(m)
MENU *m;
{
if(m->top+m->perline<aLEN(m->list))
X m->cursor=m->top+m->perline-1;
else meof(m);
}
X
void mrtarw(m)
MENU *m;
{
if(m->cursor+1<aLEN(m->list)) ++m->cursor;
}
X
void mltarw(m)
MENU *m;
{
if(m->cursor) --m->cursor;
}
X
void muparw(m)
MENU *m;
{
if(m->cursor>=m->perline) m->cursor-=m->perline;
}
X
void mdnarw(m)
MENU *m;
{
if(m->cursor+m->perline<aLEN(m->list)) m->cursor+=m->perline;
else if(m->top+m->perline<aLEN(m->list)) meof(m);
}
SHAR_EOF
chmod 0600 menu.c ||
echo 'restore of menu.c failed'
Wc_c="`wc -c < 'menu.c'`"
test 2874 -eq "$Wc_c" ||
	echo 'menu.c: original size 2874, current size' "$Wc_c"
fi
# ============= menu.h ==============
if test -f 'menu.h' -a X"$1" != X"-c"; then
	echo 'x - skipping menu.h (File already exists)'
else
echo 'x - extracting menu.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'menu.h' &&
/* Menu selection window
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Imenu
#define _Imenu 1
X
#include "config.h"
#include "w.h"
X
typedef struct menu MENU;
X
struct menu
X {
X char **list;		/* List of items */
X int top;		/* First item on screen */
X int cursor;		/* Item cursor is on */
X int width;		/* Width of widest item, up to 'w' max */
X int perline;		/* Number of items on each line */
X SCREEN *t;
X int h,w,x,y;
X void *object;
X };
X
MENU *mkmenu();
void menufllw();
void menugen();
void menumove();
void menuresz();
void menurm();
X
void muparw(), mdnarw(), mltarw(), mrtarw(), mbof(), meof(), mbol(), meol();
X
#endif
SHAR_EOF
chmod 0600 menu.h ||
echo 'restore of menu.h failed'
Wc_c="`wc -c < 'menu.h'`"
test 1318 -eq "$Wc_c" ||
	echo 'menu.h: original size 1318, current size' "$Wc_c"
fi
# ============= msdir.c ==============
if test -f 'msdir.c' -a X"$1" != X"-c"; then
	echo 'x - skipping msdir.c (File already exists)'
else
echo 'x - extracting msdir.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'msdir.c' &&
/* TURBO-C directory interface
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "zstr.h"
#include "blocks.h"
#include "dir.h"
X
int findfirst();
int findnext();
X
struct ffblk
X {
X char ff_reserved[21];
X char ff_attrib;
X int ff_ftime;
X int ff_fdate;
X long ff_fsize;
X char ff_name[13];
X };
X
struct duh
X {
X struct ffblk ffblk;
X int first;
X };
X
void *opendir(name)
char *name;
{
struct duh *duh=(struct duh *)malloc(sizeof(struct duh));
duh->first=findfirst("*.*",&duh->ffblk,0);
return duh;
}
X
void closedir(f)
struct duh *f;
{
free(f);
}
X
struct direct *readdir(f)
struct duh *f;
{
static struct direct direct;
while(f->first!= -1)
X if(!f->first)
X  {
X  zcpy(direct.d_name,f->ffblk.ff_name);
X  f->first=1;
X  return &direct;
X  }
X else f->first=findnext(&f->ffblk);
return 0;
}
SHAR_EOF
chmod 0600 msdir.c ||
echo 'restore of msdir.c failed'
Wc_c="`wc -c < 'msdir.c'`"
test 1505 -eq "$Wc_c" ||
	echo 'msdir.c: original size 1505, current size' "$Wc_c"
fi
# ============= olddir.c ==============
if test -f 'olddir.c' -a X"$1" != X"-c"; then
	echo 'x - skipping olddir.c (File already exists)'
else
echo 'x - extracting olddir.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'olddir.c' &&
/* Directory package for older UNIXs
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/dir.h>	/* If this doesn't exist, use: */
/* You'll also have to include in each module which uses these directory
X * functions
struct direct
X {
X short d_ino;
X char d_name[14];
X };
*/
#include "config.h"
#include "vs.h"
X
void *opendir(name)
char *name;
{
return fopen(name,"r");
}
X
static struct direct direct;
X
struct direct *readdir(f)
void *f;
{
while(1==fread(&direct,sizeof(struct direct),1,(FILE *)f))
X if(direct.d_ino) return &direct;
return 0;
}
X
void closedir(f)
FILE *f;
{
fclose(f);
}
X
int mkdir(s)
char *s;
{
char *y=0;
int rtval;
y=vsncpy(y,0,sc("/bin/mkdir "));
y=vsncpy(y,sLEN(y),sz(s));
y=vsncpy(y,sLEN(y),sc(" 2>/dev/null"));
rtval=system(y);
vsrm(y);
return rtval;
}
SHAR_EOF
chmod 0600 olddir.c ||
echo 'restore of olddir.c failed'
Wc_c="`wc -c < 'olddir.c'`"
test 1513 -eq "$Wc_c" ||
	echo 'olddir.c: original size 1513, current size' "$Wc_c"
fi
# ============= pathfunc.c ==============
if test -f 'pathfunc.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pathfunc.c (File already exists)'
else
echo 'x - extracting pathfunc.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pathfunc.c' &&
/* Directory and path functions
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include "config.h"
#include "vs.h"
#include "tty.h"
#include "pathfunc.h"
X
char *abspth(path)
char *path;
{
char *s=0;
int x=0;
int y;
if(path[0]=='/')
X {
X s=vsadd(s,'/');
X while(path[x]=='/') x++;
X y=1;
X }
else
X {
X if(!(s=pwd())) return 0;
X s=vsncpy(NULL,0,sz(s));
X if(s[1]) s=vsadd(s,'/');
X y=sLEN(s);
X }
while(path[x])
X {
X if(path[x]=='.' && (path[x+1]==0 || path[x+1]=='/'))
X  {
X  x++;
X  while(path[x]=='/') x++;
X  continue;
X  }
X if(path[x]=='.' && path[x+1]=='.' &&
X    (path[x+2]==0 || path[x+2]=='/'))
X  {
X  x+=2;
X  while(path[x]=='/') x++;
X  if(y!=1)
X   {
X   --y;
X   while(s[y-1]!='/') --y;
X   }
X  continue;
X  }
X do
X  s=vsset(s,y,path[x]), ++y, ++x;
X  while(path[x] && path[x]!='/');
X s=vsset(s,y,'/'), ++y;
X while(path[x]=='/') x++;
X }
if(y!=1 && s[y-1]=='/') --y;
s=vstrunc(s,y);
return s;
}
X
char *namprt(path)
char *path;
{
char *z=path+slen(path);
while(z!=path)
X if(z[-1]=='/') break;
X else --z;
return vsncpy(NULL,0,sz(z));
}
X
char *dirprt(path)
char *path;
{
char *z=path+slen(path);
while(z!=path)
X if(*(z-1)=='/') break;
X else --z;
return vsncpy(NULL,0,path,z-path);
}
X
char *begprt(path)
char *path;
{
char *z=path+slen(path);
while(z!=path && z[-1]=='/') --z;
if(z==path) return vsncpy(NULL,0,sz(path));
else
X {
X while(z!=path)
X  if(z[-1]=='/') break;
X  else --z;
X return vsncpy(NULL,0,path,z-path);
X }
}
X
char *endprt(path)
char *path;
{
char *z=path+slen(path);
while(z!=path && z[-1]=='/') --z;
if(z==path) return vsncpy(NULL,0,sc(""));
else
X {
X while(z!=path)
X  if(z[-1]=='/') break;
X  else --z;
X return vsncpy(NULL,0,sz(z));
X }
}
X
int mkpath(path)
char *path;
{
char *s;
if(path[0]=='/')
X {
X if(chddir("/")) return 1;
X s=path;
X goto in;
X }
while(path[0])
X {
X int c;
X while(*s && *s!='/') s++;
X c= *s; *s=0;
X if(chddir(path))
X  {
X  if(mkdir(path,0777)) return 1;
X  if(chddir(path)) return 1;
X  }
X *s=c;
X in:
X while(*s=='/') s++;
X path=s;
X }
return 0;
}
X
/* Create a temporary file */
X
char *mktmp(where)
char *where;
{
static int seq=0;
char *name=0;
int fd;
loop:
name=vsfmt(name,"%sJ%d%d.tmp",where,seq++%1000,(int)time(NULL)%1000);
if((fd=open(name,0))!= -1)
X {
X close(fd);
X goto loop;
X }
if((fd=creat(name,0777))== -1) return 0;
if(close(fd)) return 0;
return name;
}
SHAR_EOF
chmod 0600 pathfunc.c ||
echo 'restore of pathfunc.c failed'
Wc_c="`wc -c < 'pathfunc.c'`"
test 2984 -eq "$Wc_c" ||
	echo 'pathfunc.c: original size 2984, current size' "$Wc_c"
fi
# ============= pathfunc.h ==============
if test -f 'pathfunc.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pathfunc.h (File already exists)'
else
echo 'x - extracting pathfunc.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pathfunc.h' &&
/* Directory and path functions
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ipathfunc
#define _Ipathfunc
X
#include "config.h"
X
/* These comments aren't quite right: no drive and no conversion to lower
X * case for UNIX systems...
X */
X
/* char *abspth(char *path);
X * Convert given path into an absolute path (a path beginning with a drive
X * letter and ":\" and with no "."s or ".."s).
X *
X * This can be used to check if two paths refer to the same file:  Convert the
X * two paths into absolute paths and then compare the absolute paths.
X *
X * Also, this can be used to get the current drive and directory:
X * Use abspath("")
X *
X * Or, to get the current directory on another drive:  Use abspath("a:")
X *
X * Returns an malloc block containing the absolute path string or
X * 0 if the given path was in error or if couldn't read the current
X * directory (because the floppy was removed from the drive).
X */
char *abspth();
X
/* char *namprt(char *path);
X * Return name part of a path.  There may not be one if the last character
X * in the path is '/'.
X */
char *namprt();
X
/* char *dirprt(char *path);
X * Return directory and drive part of a path.  I.E., everything to the
X * left of the name part.
X */
char *dirprt();
X
char *begprt();
char *endprt();
X
/* int mkpath(char *path);
X * Make sure path exists.  If it doesn't, try to create it
X *
X * Returns 1 for error or 0 for success.  The current directory
X * and drive will be at the given path if successful, otherwise
X * the drive and path will be elsewhere (not necessarily where they
X * were before mkpath was called).
X */
int mkpath();
X
/* char *mktmp(char *);
X * Create an empty temporary file.  The file name created is the string passed
X * to this function postfixed with JXXXXXX.tmp, where XXXXXX is some number.
X */
char *mktmp();
X
/* Change drive:directory
X */
#define chddir chdir
X
#endif
SHAR_EOF
chmod 0600 pathfunc.h ||
echo 'restore of pathfunc.h failed'
Wc_c="`wc -c < 'pathfunc.h'`"
test 2548 -eq "$Wc_c" ||
	echo 'pathfunc.h: original size 2548, current size' "$Wc_c"
fi
# ============= pattern.c ==============
if test -f 'pattern.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pattern.c (File already exists)'
else
echo 'x - extracting pattern.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pattern.c' &&
/* Pattern matching system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "config.h"
#include "heap.h"
#include "termcap.h"
#include "toomany.h"
#include "vfile.h"
#include "scrn.h"
#include "tty.h"
#include "queue.h"
#include "b.h"
#include "regex.h"
#include "kbd.h"
#include "bw.h"
#include "vs.h"
#include "w.h"
#include "pathfunc.h"
#include "va.h"
#include "edfuncs.h"
#include "pattern.h"
X
B *findhist=0;
X
void pfnext();
X
#define SRBACKWARDS 1
#define SRIGNORE 2
#define SRREPLACE 4
X
static void set_replace(w,s)
X W *w;
X char *s;
X { 
X if(w->t->replace) vsrm(w->t->replace);
X w->t->replace=s;
X pfnext(w);
X }
X
static void set_options(w,s)
X W *w;
X char *s;
X {
X int x;
X w->t->options=0;
X w->t->repeat= -1;
X for(x=0;s[x];++x)
X  switch(s[x])
X   {
X  case 'r': case 'R': w->t->options|=SRREPLACE; break;
X  case 'b': case 'B': w->t->options|=SRBACKWARDS; break;
X  case 'i': case 'I': w->t->options|=SRIGNORE; break;
X  case '0': case '1': case '2': case '3': case '4':
X  case '5': case '6': case '7': case '8': case '9':
X   if(w->t->repeat== -1) w->t->repeat=0;
X   w->t->repeat=w->t->repeat*10+s[x]-'0';
X   break;
X   }
X vsrm(s);
X if(w->t->options&SRREPLACE) wmkpw(w,"Replace with (^C to abort): ",&findhist,set_replace,"Search");
X else pfnext(w);
X }
X
static void set_pattern(w,s)
X W *w;
X char *s;
X {
X if(w->t->pattern) vsrm(w->t->pattern);
X w->t->pattern=s;
X wmkpw(w,"(I)gnore case (R)eplace (B)ackwards NNN (^C to abort): ",NULL,set_options,"Search");
X }
X
void pffirst(w)
X W *w;
X {
X wmkpw(w,"Find (^C to abort): ",&findhist,set_pattern,"Search"); 
X }
X
char *entire=0;
X
static int searchf(w)
W *w;
{
BW *bw=(BW *)w->object;
P *start=pdup(bw->cursor);
P *end=pdup(bw->cursor);
int x;
for(x=0;x!=sLEN(w->t->pattern) && w->t->pattern[x]!='\\';++x);
if(w->t->options&SRIGNORE)
X while(pfindfni(start,w->t->pattern,x))
X  {
X  pset(end,start);
X  pfwrd(end,x);
X  if(pimatch(w->t->pattern+x,sLEN(w->t->pattern)-x,end,0))
X   {
X   w->t->foundlen=end->byte-start->byte;
X   entire=vstrunc(entire,w->t->foundlen);
X   brmem(start,entire,w->t->foundlen);
X   pset(bw->cursor,end);
X   prm(start); prm(end);
X   pfcol(bw->cursor);
X   bw->cursor->xcol=bw->cursor->col;
X   return 1;
X   }
X  if(pgetc(start)== MAXINT) break;
X  }
else
X while(pfindfn(start,w->t->pattern,x))
X  {
X  pset(end,start);
X  pfwrd(end,x);
X  if(pmatch(w->t->pattern+x,sLEN(w->t->pattern)-x,end,0))
X   {
X   w->t->foundlen=end->byte-start->byte;
X   entire=vstrunc(entire,w->t->foundlen);
X   brmem(start,entire,w->t->foundlen);
X   pset(bw->cursor,end);
X   prm(start); prm(end);
X   pfcol(bw->cursor);
X   bw->cursor->xcol=bw->cursor->col;
X   return 1;
X   }
X  if(pgetc(start)== MAXINT) break;
X  }
prm(start); prm(end);
return 0;
}
X
static int searchb(w)
W *w;
{
BW *bw=(BW *)w->object;
P *start=pdup(bw->cursor);
P *end=pdup(bw->cursor);
int x;
for(x=0;x!=sLEN(w->t->pattern) && w->t->pattern[x]!='\\';++x);
if(w->t->options&SRIGNORE)
X while(pbkwdf(start,1L) && pfindrni(start,w->t->pattern,x))
X  {
X  pset(end,start);
X  pfwrd(end,x);
X  if(pimatch(w->t->pattern+x,sLEN(w->t->pattern)-x,end,0))
X   {
X   w->t->foundlen=end->byte-start->byte;
X   entire=vstrunc(entire,w->t->foundlen);
X   brmem(start,entire,w->t->foundlen);
X   pset(bw->cursor,start);
X   prm(start); prm(end);
X   pfcol(bw->cursor);
X   bw->cursor->xcol=bw->cursor->col;
X   return 1;
X   }
X  }
else
X while(pbkwdf(start,1L) && pfindrn(start,w->t->pattern,x))
X  {
X  pset(end,start);
X  pfwrd(end,x);
X  if(pmatch(w->t->pattern+x,sLEN(w->t->pattern)-x,end,0))
X   {
X   w->t->foundlen=end->byte-start->byte;
X   entire=vstrunc(entire,w->t->foundlen);
X   brmem(start,entire,w->t->foundlen);
X   pset(bw->cursor,start);
X   prm(start); prm(end);
X   pfcol(bw->cursor);
X   bw->cursor->xcol=bw->cursor->col;
X   return 1;
X   }
X  }
prm(start); prm(end);
return 0;
}
X
static void insert(bw,s,len)
BW *bw;
char *s;
{
int x;
while(len)
X {
X for(x=0;x!=len && s[x]!='\\';++x);
X if(x)
X  {
X  binsm(bw->cursor,s,x);
X  pfwrd(bw->cursor,x);
X  len-=x;
X  s+=x;
X  }
X else if(len>=2)
X  {
X  if(s[1]=='\\') binsc(bw->cursor,'\\'), pgetc(bw->cursor);
X  else if(s[1]=='n') binsc(bw->cursor,'\n'), pgetc(bw->cursor);
X  else if((s[1]>='a' && s[1]<='z' ||
X          s[1]>='A' && s[1]<='Z') && pieces[(s[1]&0x1f)-1])
X   {
X   binsm(bw->cursor,sv(pieces[(s[1]&0x1f)-1]));
X   pfwrd(bw->cursor,sLEN(pieces[(s[1]&0x1f)-1]));
X   }
X  else if(s[1]>='0' && s[1]<='9' && pieces[s[1]-'0'])
X   {
X   binsm(bw->cursor,sv(pieces[s[1]-'0']));
X   pfwrd(bw->cursor,sLEN(pieces[s[1]-'0']));
X   }
X  else if(s[1]=='&' && entire)
X   {
X   binsm(bw->cursor,sv(entire));
X   pfwrd(bw->cursor,sLEN(entire));
X   }
X  s+=2; len-=2;
X  }
X else len=0;
X }
}
X
static void replace(w)
W *w;
{
BW *bw=(BW *)w->object;
P *q=pdup(bw->cursor);
if(w->t->options&SRBACKWARDS)
X {
X q=pfwrd(q,w->t->foundlen);
X bdel(bw->cursor,q);
X prm(q);
X }
else
X {
X q=pbkwd(q,w->t->foundlen);
X bdel(q,bw->cursor);
X prm(q);
X }
insert(bw,sv(w->t->replace));
}
X
void pfnext(w)
X W *w;
X {
X BW *bw=(BW *)w->object;
X int c;
X int rest=0;
X int flg=0;
X int orgmid=mid;
X mid=1;
X if(!w->t->pattern) { pffirst(w); goto done; }
X next:
X if(w->t->repeat!= -1)
X  if(!w->t->repeat) goto done;
X  else --w->t->repeat;
X if(w->t->options&SRBACKWARDS)
X  { if(!searchb(w)) { if(!flg || !(w->t->options&SRREPLACE)) msgnw(w,"Not found"); w->t->repeat= -1; goto done; } }
X else
X  if(!searchf(w)) { if(!flg || !(w->t->options&SRREPLACE)) msgnw(w,"Not found"); w->t->repeat= -1; goto done; }
X flg=1;
X if(w->t->options&SRREPLACE)
X  if(rest) { replace(w); goto next; }
X  else
X   {
X   do
X    {
X    P *mb=w->t->markb, *mk=w->t->markk;
X    if(w->t->options&SRBACKWARDS)
X     {
X     w->t->markb=pdup(bw->cursor);
X     w->t->markk=pdup(bw->cursor);
X     pfwrd(w->t->markk,w->t->foundlen);
X     }
X    else
X     {
X     w->t->markk=pdup(bw->cursor);
X     w->t->markb=pdup(bw->cursor);
X     pbkwd(w->t->markb,w->t->foundlen);
X     }
X    updall();
X    c=queryn(w,"Replace (Y)es (N)o (R)est (^C to abort)?");
X    prm(w->t->markb); prm(w->t->markk);
X    w->t->markb=mb; w->t->markk=mk;
X    if(c=='N' || c=='n') { goto next; }
X    if(c=='Y' || c=='y') { replace(w); goto next; }
X    if(c=='R' || c=='r') { replace(w); rest=1; goto next; }
X    }
X    while(c!=MAXINT && c!='C'-'@');
X   }
X else if(w->t->repeat!= -1) goto next;
X done:
X updall();
X bw->cursor->xcol=bw->cursor->col;
X mid=orgmid;
X }
SHAR_EOF
chmod 0600 pattern.c ||
echo 'restore of pattern.c failed'
Wc_c="`wc -c < 'pattern.c'`"
test 7010 -eq "$Wc_c" ||
	echo 'pattern.c: original size 7010, current size' "$Wc_c"
fi
# ============= pattern.h ==============
if test -f 'pattern.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pattern.h (File already exists)'
else
echo 'x - extracting pattern.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pattern.h' &&
/* Pattern matching system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ipattern
#define _Ipattern 1
X
void pffirst();
void pfnext();
X
#endif
SHAR_EOF
chmod 0600 pattern.h ||
echo 'restore of pattern.h failed'
Wc_c="`wc -c < 'pattern.h'`"
test 841 -eq "$Wc_c" ||
	echo 'pattern.h: original size 841, current size' "$Wc_c"
fi
# ============= poshist.c ==============
if test -f 'poshist.c' -a X"$1" != X"-c"; then
	echo 'x - skipping poshist.c (File already exists)'
else
echo 'x - extracting poshist.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'poshist.c' &&
/* Position history
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "poshist.h"
#include "queue.h"
#include "b.h"
#include "w.h"
#include "bw.h"
X
typedef struct pos POS;
X
struct pos
X {
X LINK(POS) link;
X P *p;
X W *w;
X };
X
POS pos={{&pos,&pos}};
POS *curpos=&pos;
int npos=0;
X
void markpos(w,p)
W *w;
P *p;
{
POS *new=(POS *)malloc(sizeof(POS));
new->p=pdup(p);
new->w=w;
enqueb(POS,link,&pos,new);
if(++npos==20)
X {
X new=pos.link.next;
X if(new->p) prm(new->p);
X free(deque(POS,link,new));
X }
}
X
void afterpos()
{
if(curpos!=&pos)
X {
X demote(POS,link,&pos,curpos);
X curpos=&pos;
X }
}
X
void aftermove(w,p)
W *w;
P *p;
{
if(pos.link.prev!=&pos &&
X   pos.link.prev->w==w &&
X   pos.link.prev->p &&
X   Iabs(pos.link.prev->p->line-p->line)<3
X  )
X pset(pos.link.prev->p,p);
else markpos(w,p);
}
X
void windie(w)
W *w;
{
POS *n;
for(n=pos.link.prev;n!=&pos;n=n->link.prev) if(n->w==w) n->w=0;
}
X
void unextpos(w)
W *w;
{
lp:
if(curpos->link.next!=&pos && curpos!=&pos)
X {
X BW *bw;
X curpos=curpos->link.next;
X if(!curpos->p || !curpos->w) goto lp;
X if(w->t->curwin==curpos->w &&
X    curpos->p->byte==((BW *)w->t->curwin->object)->cursor->byte) goto lp;
X if(w->t->curwin!=curpos->w)
X  {
X  w->t->curwin=curpos->w;
X  if(w->t->curwin->y== -1) wfit(w->t);
X  }
X w=w->t->curwin;
X bw=(BW *)w->object;
X if(bw->cursor->byte!=curpos->p->byte) pset(bw->cursor,curpos->p);
X }
}
X
void uprevpos(w)
W *w;
{
lp:
if(curpos->link.prev!=&pos)
X {
X BW *bw;
X curpos=curpos->link.prev;
X if(!curpos->p || !curpos->w) goto lp;
X if(w->t->curwin==curpos->w &&
X    curpos->p->byte==((BW *)w->t->curwin->object)->cursor->byte) goto lp;
X if(w->t->curwin!=curpos->w)
X  {
X  w->t->curwin=curpos->w;
X  if(w->t->curwin->y== -1) wfit(w->t);
X  }
X w=w->t->curwin;
X bw=(BW *)w->object;
X if(bw->cursor->byte!=curpos->p->byte) pset(bw->cursor,curpos->p);
X }
}
SHAR_EOF
chmod 0600 poshist.c ||
echo 'restore of poshist.c failed'
Wc_c="`wc -c < 'poshist.c'`"
test 2503 -eq "$Wc_c" ||
	echo 'poshist.c: original size 2503, current size' "$Wc_c"
fi
# ============= poshist.h ==============
if test -f 'poshist.h' -a X"$1" != X"-c"; then
	echo 'x - skipping poshist.h (File already exists)'
else
echo 'x - extracting poshist.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'poshist.h' &&
/* Position history
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iposhist
#define _Iposhist 1
X
#include "config.h"
X
void afterpos();
void aftermove();
void windie();
void uprevpos();
void unextpos();
X
#endif
SHAR_EOF
chmod 0600 poshist.h ||
echo 'restore of poshist.h failed'
Wc_c="`wc -c < 'poshist.h'`"
test 908 -eq "$Wc_c" ||
	echo 'poshist.h: original size 908, current size' "$Wc_c"
fi
# ============= pw.c ==============
if test -f 'pw.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pw.c (File already exists)'
else
echo 'x - extracting pw.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pw.c' &&
/* Prompt windows
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "w.h"
#include "vfile.h"
#include "toomany.h"
#include "termcap.h"
#include "b.h"
#include "edfuncs.h"
#include "kbd.h"
#include "scrn.h"
#include "bw.h"
#include "zstr.h"
#include "help.h"
#include "tab.h"
#include "undo.h"
#include "pw.h"
X
CONTEXT cprmpt={"prompt",0};
CONTEXT cfprmpt={"fprompt",0};
X
/* Move prompt window */
X
static void movepw(w,x,y)
W *w;
int x,y;
{
}
X
/* Resize prompt window */
X
static void resizepw(w,wi,he)
W *w;
int wi,he;
{
}
X
/* Abort prompt window */
X
static void killpw(w)
W *w;
{
BW *bw=(BW *)w->object;
PW *pw=(PW *)bw->object;
bwrm(bw);
free(pw->prompt);
free(pw);
}
X
/* Update a prompt window */
X
static void followpw(w)
W *w;
{
BW *bw=(BW *)w->object;
bwfllw(bw);
}
X
static void disppw(w)
W *w;
{
int x;
BW *bw=(BW *)w->object;
PW *pw=(PW *)bw->object;
X
/* Scroll buffer and position prompt */
if(pw->promptlen>w->w/2+w->w/4)
X {
X pw->promptofst=pw->promptlen-w->w/2;
X if(bw->cursor->col<w->w-(pw->promptlen-pw->promptofst))
X  bw->offset=0;
X else
X  bw->offset=bw->cursor->col-(w->w-(pw->promptlen-pw->promptofst)-1);
X }
else
X { 
X if(bw->cursor->col<w->w-pw->promptlen) pw->promptofst=0, bw->offset=0;
X else if(bw->cursor->col>=w->w)
X  pw->promptofst=pw->promptlen, bw->offset=bw->cursor->col-(w->w-1);
X else
X  pw->promptofst=pw->promptlen-(w->w-bw->cursor->col-1),
X  bw->offset=bw->cursor->col-(w->w-(pw->promptlen-pw->promptofst)-1);
X }
X
/* Set cursor position */
w->curx=bw->cursor->col-bw->offset+pw->promptlen-pw->promptofst;
w->cury=0;
X
/* Generate prompt */
w->t->t->updtab[w->y]=1;
genfmt(w->t->t,w->x,w->y,pw->promptofst,pw->prompt,0);
X
/* Position and size buffer */
bwmove(bw,w->x+pw->promptlen-pw->promptofst,w->y);
bwresz(bw,w->w-(pw->promptlen-pw->promptofst),1);
X
/* Generate buffer */
bwgen(bw);
}
X
/* When user hits return in a prompt window */
X
void upromptrtn(w)
W *w;
{
BW *bw=(BW *)w->object;
PW *pw=(PW *)bw->object;
char *s;
W *win;
void (*pfunc)();
peol(bw->cursor);
s=brvs(bw->top,bw->cursor->byte-bw->top->byte);
if(pw->hist)
X if(bw->b->chnged)
X  {
X  P *q=pdup(pw->hist->eof);
X  binsm(q,s,bw->cursor->byte-bw->top->byte);
X  peof(q);
X  binsc(q,'\n');
X  prm(q);
X  }
X else
X  {
X  P *q=pdup(pw->hist->bof);
X  P *r;
X  P *t;
X  pline(q,bw->top->line);
X  r=pdup(q);
X  pnextl(r);
X  t=pdup(pw->hist->eof);
X  binsb(t,q,r);
X  bdel(q,r);
X  prm(q); prm(r); prm(t);
X  }
win=w->win;
X
pfunc=pw->pfunc;
wabort(w);
pfunc(win,s);
}
X
/* When user aborts a prompt window ^C */
X
void uabortpw(w)
W *w;
{
wabort(w);
}
X
static void inspw(w,b,l,n,flg)
W *w;
B *b;
long l,n;
int flg;
{
BW *bw=(BW *)w->object;
if(b==bw->b) bwins(bw,l,n,flg);
}
X
static void delpw(w,b,l,n,flg)
W *w;
B *b;
long l,n;
int flg;
{
BW *bw=(BW *)w->object;
if(b==bw->b) bwdel(bw,l,n,flg);
}
X
static WATOM watompw=
{
&cprmpt,
disppw,
followpw,
killpw,
resizepw,
movepw,
inspw,
delpw,
TYPEPW
};
X
static WATOM watomfpw=
{
&cfprmpt,
disppw,
followpw,
killpw,
resizepw,
movepw,
inspw,
delpw,
TYPEPW
};
X
/* Create a prompt window */
X
W *wmkpw(w,prompt,history,func,huh)
W *w;
char *prompt;
B **history;
void (*func)();
char *huh;
{
W *new;
PW *pw;
BW *bw;
new=wcreate(w->t,&watompw,w,w,w->main,1,huh);
if(!new) return 0;
new->object=(void *)(bw=bwmk(new->t,bmk(),new->x,new->y,new->w,1));
bw->object=(void *)(pw=(PW *)malloc(sizeof(PW)));
pw->prompt=zdup(prompt);
pw->promptlen=fmtlen(prompt);
pw->promptofst=0;
pw->pfunc=func;
if(history)
X {
X if(!*history) *history=bmk();
X pw->hist= *history;
X binsb(bw->cursor,pw->hist->bof,pw->hist->eof);
X bw->b->chnged=0;
X peof(bw->cursor); peof(bw->top); pbol(bw->top);
X }
else pw->hist=0;
w->t->curwin=new;
return new;
}
X
W *wmkfpw(w,prompt,history,func,huh)
W *w;
char *prompt;
B **history;
void (*func)();
char *huh;
{
W *new;
PW *pw;
BW *bw;
new=wcreate(w->t,&watomfpw,w,w,w->main,1,huh);
if(!new) return 0;
new->object=(void *)(bw=bwmk(new->t,bmk(),new->x,new->y,new->w,1));
bw->object=(void *)(pw=(PW *)malloc(sizeof(PW)));
pw->prompt=zdup(prompt);
pw->promptlen=fmtlen(prompt);
pw->promptofst=0;
pw->pfunc=func;
if(history)
X {
X if(!*history) *history=bmk();
X pw->hist= *history;
X binsb(bw->cursor,pw->hist->bof,pw->hist->eof);
X bw->b->chnged=0;
X peof(bw->cursor); peof(bw->top); pbol(bw->top);
X }
else pw->hist=0;
w->t->curwin=new;
return new;
}
SHAR_EOF
chmod 0600 pw.c ||
echo 'restore of pw.c failed'
Wc_c="`wc -c < 'pw.c'`"
test 4996 -eq "$Wc_c" ||
	echo 'pw.c: original size 4996, current size' "$Wc_c"
fi
# ============= pw.h ==============
if test -f 'pw.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pw.h (File already exists)'
else
echo 'x - extracting pw.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pw.h' &&
/* Prompt windows
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ipw
#define _Ipw 1
X
#include "config.h"
#include "kbd.h"
X
typedef struct pw PW;
X
struct pw
X {
X void (*pfunc)();		/* Func which gets called when RTN is hit */
X char *prompt;			/* Prompt string */
X int promptlen;			/* Width of prompt string */
X int promptofst;		/* Prompt scroll offset */
X B *hist;			/* History buffer */
X };
X
#define TYPEPW 0x200
X
extern CONTEXT cprmpt, cfprmpt;
X
/* W *wmkpw(W *w,char *prompt,void (*func)());
X * Create a prompt window for the given window
X */
W *wmkpw();
X
/* W *wmkfpw(W *w,char *prompt,void (*func)());
X * Create a prompt window for the given window
X * Use mappings for file names
X */
W *wmkfpw();
X
void uabortpw();
void upromptrtn();
X
#endif
SHAR_EOF
chmod 0600 pw.h ||
echo 'restore of pw.h failed'
Wc_c="`wc -c < 'pw.h'`"
test 1442 -eq "$Wc_c" ||
	echo 'pw.h: original size 1442, current size' "$Wc_c"
fi
# ============= queue.c ==============
if test -f 'queue.c' -a X"$1" != X"-c"; then
	echo 'x - skipping queue.c (File already exists)'
else
echo 'x - extracting queue.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'queue.c' &&
/* Doubly linked list primitives
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "queue.h"
X
void *QUEUE;
void *ITEM;
void *LAST;
SHAR_EOF
chmod 0600 queue.c ||
echo 'restore of queue.c failed'
Wc_c="`wc -c < 'queue.c'`"
test 846 -eq "$Wc_c" ||
	echo 'queue.c: original size 846, current size' "$Wc_c"
fi
# ============= queue.h ==============
if test -f 'queue.h' -a X"$1" != X"-c"; then
	echo 'x - skipping queue.h (File already exists)'
else
echo 'x - extracting queue.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'queue.h' &&
/* Doubly linked list primitives
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iqueue
#define _Iqueue 1
X
#include "config.h"
X
extern void *ITEM;
extern void *QUEUE;
extern void *LAST;
X
#define LINK(type) struct { type *next; type *prev; }
X
#define izque(type,member,item) \
X	( \
X	QUEUE=(void *)(item), \
X	((type *)QUEUE)->member.prev=(type *)QUEUE, \
X	((type *)QUEUE)->member.next=(type *)QUEUE, \
X	(type *)QUEUE \
X	)
X
#define deque(type,member,item) \
X	( \
X	ITEM=(void *)(item), \
X	((type *)ITEM)->member.prev->member.next=((type *)ITEM)->member.next, \
X	((type *)ITEM)->member.next->member.prev=((type *)ITEM)->member.prev, \
X	(type *)ITEM \
X	)
X
#define qempty(type,member,item) \
X	( \
X	QUEUE=(void *)(item), \
X	(type *)QUEUE==((type *)QUEUE)->member.next \
X	)
X
#define enquef(type,member,queue,item) \
X	( \
X	ITEM=(void *)(item), \
X	QUEUE=(void *)(queue), \
X	((type *)ITEM)->member.next=((type *)QUEUE)->member.next, \
X	((type *)ITEM)->member.prev=(type *)QUEUE, \
X	((type *)QUEUE)->member.next->member.prev=(type *)ITEM, \
X	((type *)QUEUE)->member.next=(type *)ITEM, \
X	(type *)ITEM \
X	)
X
#define enqueb(type,member,queue,item) \
X	( \
X	ITEM=(void *)(item), \
X	QUEUE=(void *)(queue), \
X	((type *)ITEM)->member.next=(type *)QUEUE, \
X	((type *)ITEM)->member.prev=((type *)QUEUE)->member.prev, \
X	((type *)QUEUE)->member.prev->member.next=(type *)ITEM, \
X	((type *)QUEUE)->member.prev=(type *)ITEM, \
X	(type *)ITEM \
X	)
X
#define promote(type,member,queue,item) \
X	( \
X	enquef(type,member,(queue),deque(type,member,(item))) \
X	)
X
#define demote(type,member,queue,item) \
X	( \
X	enqueb(type,member,(queue),deque(type,member,(item))) \
X	)
X
#define splicef(type,member,queue,chain) \
X	( \
X	ITEM=(void *)(chain), \
X	LAST=(void *)((type *)ITEM)->member.prev, \
X	QUEUE=(void *)(queue), \
X	((type *)LAST)->member.next=((type *)QUEUE)->member.next, \
X	((type *)ITEM)->member.prev=(type *)QUEUE, \
X	((type *)QUEUE)->member.next->member.prev=(type *)LAST, \
X	((type *)QUEUE)->member.next=(type *)ITEM, \
X	(type *)ITEM \
X	)
X
#define spliceb(type,member,queue,chain) \
X	( \
X	ITEM=(void *)(chain), \
X	LAST=(void *)((type *)ITEM)->member.prev, \
X	QUEUE=(void *)(queue), \
X	((type *)LAST)->member.next=(type *)QUEUE, \
X	((type *)ITEM)->member.prev=((type *)QUEUE)->member.prev, \
X	((type *)QUEUE)->member.prev->member.next=(type *)ITEM, \
X	((type *)QUEUE)->member.prev=(type *)LAST, \
X	(type *)ITEM \
X	)
X
#define snip(type,member,first,last) \
X	( \
X	ITEM=(void *)(first), \
X	LAST=(void *)(last), \
X	((type *)LAST)->member.next->member.prev=((type *)ITEM)->member.prev, \
X	((type *)ITEM)->member.prev->member.next=((type *)LAST)->member.next, \
X	((type *)ITEM)->member.prev=(type *)LAST, \
X	((type *)LAST)->member.next=(type *)ITEM, \
X	(type *)ITEM \
X	)
X
#endif
SHAR_EOF
chmod 0600 queue.h ||
echo 'restore of queue.h failed'
Wc_c="`wc -c < 'queue.h'`"
test 3442 -eq "$Wc_c" ||
	echo 'queue.h: original size 3442, current size' "$Wc_c"
fi
# ============= random.c ==============
if test -f 'random.c' -a X"$1" != X"-c"; then
	echo 'x - skipping random.c (File already exists)'
else
echo 'x - extracting random.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'random.c' &&
/*
X * Copyright (c) 1983 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
/*
X * This is derived from the Berkeley source:
X *	@(#)random.c	5.5 (Berkeley) 7/6/88
X * It was reworked for the GNU C Library by Roland McGrath.
X * Fixed to be portable to MSDOS by jhallen
X */
X
#include "config.h"
#include "random.h"
X
/* An improved random number generation package.  In addition to the standard
X   rand()/srand() like interface, this package also has a special state info
X   interface.  The initstate() routine is called with a seed, an array of
X   bytes, and a count of how many bytes are being passed in; this array is
X   then initialized to contain information for random number generation with
X   that much state information.  Good sizes for the amount of state
X   information are 32, 64, 128, and 256 bytes.  The state can be switched by
X   calling the setstate() function with the same array as was initiallized
X   with initstate().  By default, the package runs with 128 bytes of state
X   information and generates far better random numbers than a linear
X   congruential generator.  If the amount of state information is less than
X   32 bytes, a simple linear congruential R.N.G. is used.  Internally, the
X   state information is treated as an array of longs; the zeroeth element of
X   the array is the type of R.N.G. being used (small integer); the remainder
X   of the array is the state information for the R.N.G.  Thus, 32 bytes of
X   state information will give 7 longs worth of state information, which will
X   allow a degree seven polynomial.  (Note: The zeroeth word of state
X   information also has some other information stored in it; see setstate
X   for details).  The random number generation technique is a linear feedback
X   shift register approach, employing trinomials (since there are fewer terms
X   to sum up that way).  In this approach, the least significant bit of all
X   the numbers in the state table will act as a linear feedback shift register,
X   and will have period 2^deg - 1 (where deg is the degree of the polynomial
X   being used, assuming that the polynomial is irreducible and primitive).
X   The higher order bits will have longer periods, since their values are
X   also influenced by pseudo-random carries out of the lower bits.  The
X   total period of the generator is approximately deg*(2**deg - 1); thus
X   doubling the amount of state information has a vast influence on the
X   period of the generator.  Note: The deg*(2**deg - 1) is an approximation
X   only good for large deg, when the period of the shift register is the
X   dominant factor.  With deg equal to seven, the period is actually much
X   longer than the 7*(2**7 - 1) predicted by this formula.  */
X
/* For each of the currently supported random number generators, we have a
X   break value on the amount of state information (you need at least thi
X   bytes of state info to support this random number generator), a degree for
X   the polynomial (actually a trinomial) that the R.N.G. is based on, and
X   separation between the two lower order coefficients of the trinomial.  */
X
/* Linear congruential.  */
#define	TYPE_0		0
#define	BREAK_0		8
#define	DEG_0		0
#define	SEP_0		0
X
/* x**7 + x**3 + 1.  */
#define	TYPE_1		1
#define	BREAK_1		32
#define	DEG_1		7
#define	SEP_1		3
X
/* x**15 + x + 1.  */
#define	TYPE_2		2
#define	BREAK_2		64
#define	DEG_2		15
#define	SEP_2		1
X
/* x**31 + x**3 + 1.  */
#define	TYPE_3		3
#define	BREAK_3		128
#define	DEG_3		31
#define	SEP_3		3
X
/* x**63 + x + 1.  */
#define	TYPE_4		4
#define	BREAK_4		256
#define	DEG_4		63
#define	SEP_4		1
X
/* Array versions of the above information to make code run faster.
X   Relies on fact that TYPE_i == i.  */
X
#define	MAX_TYPES	5	/* Max number of types above.  */
X
static int degrees[MAX_TYPES] = { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
static int seps[MAX_TYPES] = { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };
X
/* Initially, everything is set up as if from:
X	initstate(1, randtbl, 128);
X   Note that this initialization takes advantage of the fact that srandom
X   advances the front and rear pointers 10*rand_deg times, and hence the
X   rear pointer which starts at 0 will also end up at zero; thus the zeroeth
X   element of the state information, which contains info about the current
X   position of the rear pointer is just
X	(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.  */
X
static long randtbl[DEG_3 + 1] =
X  { TYPE_3,
X      0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342,
X      0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb,
X      0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
X      0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86,
X      0xda672e2a, 0x1588ca88, 0xe369735d, 0x904f35f7,
X      0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
X      0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b,
X      0xf5ad9d0e, 0x8999220b, 0x27fb47b9
X    };
X
/* FPTR and RPTR are two pointers into the state info, a front and a rear
X   pointer.  These two pointers are always rand_sep places aparts, as they
X   cycle through the state information.  (Yes, this does mean we could get
X   away with just one pointer, but the code for random is more efficient
X   this way).  The pointers are left positioned as they would be from the call:
X	initstate(1, randtbl, 128);
X   (The position of the rear pointer, rptr, is really 0 (as explained above
X   in the initialization of randtbl) because the state table pointer is set
X   to point to randtbl[1] (as explained below).)  */
X
static long *fptr = &randtbl[SEP_3 + 1];
static long *rptr = &randtbl[1];
X
X
X
/* The following things are the pointer to the state information table,
X   the type of the current generator, the degree of the current polynomial
X   being used, and the separation between the two pointers.
X   Note that for efficiency of random, we remember the first location of
X   the state information, not the zeroeth.  Hence it is valid to access
X   state[-1], which is used to store the type of the R.N.G.
X   Also, we remember the last location, since this is more efficient than
X   indexing every time to find the address of the last element to see if
X   the front and rear pointers have wrapped.  */
X
static long *state = &randtbl[1];
X
static int rand_type = TYPE_3;
static int rand_deg = DEG_3;
static int rand_sep = SEP_3;
X
static long *end_ptr = &randtbl[sizeof(randtbl) / sizeof(randtbl[0])];
X
/* Initialize the random number generator based on the given seed.  If the
X   type is the trivial no-state-information type, just remember the seed.
X   Otherwise, initializes state[] based on the given "seed" via a linear
X   congruential generator.  Then, the pointers are set to known locations
X   that are exactly rand_sep places apart.  Lastly, it cycles the state
X   information a given number of times to get rid of any initial dependencies
X   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
X   for default usage relies on values produced by this routine.  */
X
void srandom(x)
unsigned x;
{
X  state[0] = x;
X  if (rand_type != TYPE_0)
X    {
X      register long i;
X      for (i = 1; i < rand_deg; ++i)
X	state[i] = (1103515145 * state[i - 1]) + 12345;
X      fptr = &state[rand_sep];
X      rptr = &state[0];
X      for (i = 0; i < 10 * rand_deg; ++i) random();
X    }
}
X
/* Initialize the state information in the given array of N bytes for
X   future random number generation.  Based on the number of bytes we
X   are given, and the break values for the different R.N.G.'s, we choose
X   the best (largest) one we can and set things up for it.  srandom is
X   then called to initialize the state information.  Note that on return
X   from srandom, we set state[-1] to be the type multiplexed with the current
X   value of the rear pointer; this is so successive calls to initstate won't
X   lose this information and will be able to restart with setstate.
X   Note: The first thing we do is save the current state, if any, just like
X   setstate so that it doesn't matter when initstate is called.
X   Returns a pointer to the old state.  */
X
void *initstate(seed, arg_state, n)
unsigned seed;
void *arg_state;
{
X  void *ostate = (void *) &state[-1];
X
X  if (rand_type == TYPE_0)
X    state[-1] = rand_type;
X  else
X    state[-1] = (MAX_TYPES * (rptr - state)) + rand_type;
X  if (n < BREAK_1)
X    {
X      if (n < BREAK_0)
X	{
X	  return NULL;
X	}
X      rand_type = TYPE_0;
X      rand_deg = DEG_0;
X      rand_sep = SEP_0;
X    }
X  else if (n < BREAK_2)
X    {
X      rand_type = TYPE_1;
X      rand_deg = DEG_1;
X      rand_sep = SEP_1;
X    }
X  else if (n < BREAK_3)
X    {
X      rand_type = TYPE_2;
X      rand_deg = DEG_2;
X      rand_sep = SEP_2;
X    }
X  else if (n < BREAK_4)
X    {
X      rand_type = TYPE_3;
X      rand_deg = DEG_3;
X      rand_sep = SEP_3;
X    }
X  else
X    {
X      rand_type = TYPE_4;
X      rand_deg = DEG_4;
X      rand_sep = SEP_4;
X    }
X
X  state = &((long *) arg_state)[1];	/* First location.  */
X  /* Must set END_PTR before srandom.  */
X  end_ptr = &state[rand_deg];
X  srandom(seed);
X  if (rand_type == TYPE_0)
X    state[-1] = rand_type;
X  else
X    state[-1] = (MAX_TYPES * (rptr - state)) + rand_type;
X
X  return ostate;
}
X
/* Restore the state from the given state array.
X   Note: It is important that we also remember the locations of the pointers
X   in the current state information, and restore the locations of the pointers
X   from the old state information.  This is done by multiplexing the pointer
X   location into the zeroeth word of the state information. Note that due
X   to the order in which things are done, it is OK to call setstate with the
X   same state as the current state
X   Returns a pointer to the old state information.  */
void *setstate(arg_state)
void *arg_state;
{
X  register long *new_state = (long *) arg_state;
X  register int type = new_state[0] % MAX_TYPES;
X  register int rear = new_state[0] / MAX_TYPES;
X  void *ostate = (void *) &state[-1];
X
X  if (rand_type == TYPE_0)
X    state[-1] = rand_type;
X  else
X    state[-1] = (MAX_TYPES * (rptr - state)) + rand_type;
X
X  switch (type)
X    {
X    case TYPE_0:
X    case TYPE_1:
X    case TYPE_2:
X    case TYPE_3:
X    case TYPE_4:
X      rand_type = type;
X      rand_deg = degrees[type];
X      rand_sep = seps[type];
X      break;
X    default:
X      /* State info munged.  */
X      return NULL;
X    }
X
X  state = &new_state[1];
X  if (rand_type != TYPE_0)
X    {
X      rptr = &state[rear];
X      fptr = &state[(rear + rand_sep) % rand_deg];
X    }
X  /* Set end_ptr too.  */
X  end_ptr = &state[rand_deg];
X
X  return ostate;
}
X
/* If we are using the trivial TYPE_0 R.N.G., just do the old linear
X   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the
X   same in all ther other cases due to all the global variables that have been
X   set up.  The basic operation is to add the number at the rear pointer into
X   the one at the front pointer.  Then both pointers are advanced to the next
X   location cyclically in the table.  The value returned is the sum generated,
X   reduced to 31 bits by throwing away the "least random" low bit.
X   Note: The code takes advantage of the fact that both the front and
X   rear pointers can't wrap on the same call by not testing the rear
X   pointer if the front one has wrapped.  Returns a 31-bit random number.  */
X
long random()
{
X  if (rand_type == TYPE_0)
X    {
X      state[0] = ((state[0] * 1103515245) + 12345) & MAXLONG;
X      return state[0];
X    }
X  else
X    {
X      long i;
X      *fptr += *rptr;
X      /* Chucking least random bit.  */
X      i = (*fptr >> 1) & MAXLONG;
X      ++fptr;
X      if (fptr >= end_ptr)
X	{
X	  fptr = state;
X	  ++rptr;
X	}
X      else
X	{
X	  ++rptr;
X	  if (rptr >= end_ptr)
X	    rptr = state;
X	}
X      return i;
X    }
}
SHAR_EOF
chmod 0600 random.c ||
echo 'restore of random.c failed'
Wc_c="`wc -c < 'random.c'`"
test 12354 -eq "$Wc_c" ||
	echo 'random.c: original size 12354, current size' "$Wc_c"
fi
# ============= random.h ==============
if test -f 'random.h' -a X"$1" != X"-c"; then
	echo 'x - skipping random.h (File already exists)'
else
echo 'x - extracting random.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'random.h' &&
#ifndef _Irandom
#define _Irandom 1
X
#include "config.h"
X
long random();
void srandom();
void *initstate();
void *setstate();
X
#endif
SHAR_EOF
chmod 0600 random.h ||
echo 'restore of random.h failed'
Wc_c="`wc -c < 'random.h'`"
test 134 -eq "$Wc_c" ||
	echo 'random.h: original size 134, current size' "$Wc_c"
fi
# ============= reg.c ==============
if test -f 'reg.c' -a X"$1" != X"-c"; then
	echo 'x - skipping reg.c (File already exists)'
else
echo 'x - extracting reg.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'reg.c' &&
/* Generate list of matching directory entries
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/dir.h>
#include "config.h"
#include "vs.h"
#include "va.h"
#include "regex.h"
X
char **rexpnd(path,word)
char *path, *word;
{
void *dir;
char **lst=0;
struct direct *de;
if(path && path[0]) dir=opendir(path);
else dir=opendir(".");
if(!dir) return 0;
while(de=readdir(dir))
X if(zcmp(".",de->d_name))
X  if(rmatch(word,de->d_name))
X   lst=vaadd(lst,vsncpy(NULL,0,de->d_name,slen(de->d_name)));
closedir(dir);
return lst;
}
SHAR_EOF
chmod 0600 reg.c ||
echo 'restore of reg.c failed'
Wc_c="`wc -c < 'reg.c'`"
test 1259 -eq "$Wc_c" ||
	echo 'reg.c: original size 1259, current size' "$Wc_c"
fi
# ============= regex.c ==============
if test -f 'regex.c' -a X"$1" != X"-c"; then
	echo 'x - skipping regex.c (File already exists)'
else
echo 'x - extracting regex.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'regex.c' &&
/* Regular expression subroutines
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "zstr.h"
#include "vs.h"
#include "b.h"
#include "regex.h"
X
static int brackz(a,c)
unsigned char **a;
unsigned char c;
{
int flag;
unsigned char *s= *a;
if(*s=='^' || *s=='*')
X {
X flag=1;
X ++s;
X 
X if(*s==']')
X  {
X  ++s;
X  if(c==']') flag=0;
X  }
X
X while(*s)
X  if(*s==']') { ++s; break; }
X  else
X   {
X   if(c==*s) flag=0;
X   if(s[1]=='-' && s[2] && s[2]!=']' && s[0]<=s[2])
X    {
X    if(c>=s[0] && c<=s[2]) flag=0;
X    s+=2;
X    }
X   ++s;
X   }
X
X *a=s;
X return flag;
X }
else
X {
X flag=0;
X
X if(*s==']')
X  {
X  ++s;
X  if(c==']') flag=1;
X  }
X
X while(*s)
X  if(*s==']') { ++s; break; }
X  else
X   {
X   if(c==*s) flag=1;
X   if(s[1]=='-' && s[2] && s[2]!=']' && s[0]<=s[2])
X    {
X    if(c>=s[0] && c<=s[2]) flag=1;
X    s+=2;
X    }
X   ++s;
X   }
X 
X *a=s;
X return flag;
X }
}
X
static int brack(a,la,c)
unsigned char **a;
int *la;
unsigned char c;
{
int flag;
unsigned char *s= *a;
int l= *la;
if(!l) return 0;
if(*s=='^' || *s=='*')
X {
X flag=1;
X ++s; --l;
X 
X if(l && *s==']')
X  {
X  ++s; --l;
X  if(c==']') flag=0;
X  }
X
X while(l)
X  if(*s==']') { ++s; --l; break; }
X  else
X   {
X   if(c==*s) flag=0;
X   if(l>=3 && s[1]=='-' && s[2]!=']' && s[0]<=s[2])
X    {
X    if(c>=s[0] && c<=s[2]) flag=0;
X    s+=2; l-=2;
X    }
X   ++s; --l;
X   }
X
X *a=s; *la=l;
X return flag;
X }
else
X {
X flag=0;
X
X if(l && *s==']')
X  {
X  ++s; --l;
X  if(c==']') flag=1;
X  }
X
X while(l)
X  if(*s==']') { ++s; --l; break; }
X  else
X   {
X   if(c==*s) flag=1;
X   if(l>=3 && s[1]=='-' && s[2]!=']' && s[0]<=s[2])
X    {
X    if(c>=s[0] && c<=s[2]) flag=1;
X    s+=2; l-=2;
X    }
X   ++s; --l;
X   }
X 
X *a=s; *la=l;
X return flag;
X }
}
X
int rmatch(a,b)
char *a, *b;
{
for(;;)
X switch(*a)
X  {
X case '*': ++a;
X           do if(rmatch(a,b)) return 1; while(*b++);
X           return 0;
X
X case '[': ++a;
X           if(!*b) return 0;
X           if(!brackz(&a,*b)) return 0;
X           ++b;
X           break;
X
X case '?': ++a;
X           if(!*b) return 0;
X           ++b;
X           break;
X
X case 0:   if(!*b) return 1;
X           else return 0;
X
X case '\\':
X           if(!*++a) return 0;
X
X default:  if(*a++!=*b++) return 0;
X  }
}
X
int rimatch(a,b)
char *a, *b;
{
for(;;)
X switch(*a)
X  {
X case '*': ++a;
X           do if(rimatch(a,b)) return 1; while(*b++);
X           return 0;
X
X case '[': ++a;
X           if(!*b) return 0;
X           if(!brackz(&a,*b)) return 0;
X           ++b;
X           break;
X
X case '?': ++a;
X           if(!*b) return 0;
X           ++b;
X           break;
X
X case 0:   if(!*b) return 1;
X           else return 0;
X
X case '\\':
X           if(!*++a) return 0;
X
X default:  if(toup(*a++)!=toup(*b++)) return 0;
X  }
}
X
char *pieces[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X
static void savec(n,c)
char c;
{
char *s=0;
if(pieces[n]) vsrm(pieces[n]);
s=vsncpy(s,0,&c,1);
pieces[n]=s;
}
X
static void saves(n,p,szz)
P *p;
long szz;
{
if(szz>=MAXINT-31) pieces[n]=vstrunc(pieces[n],0);
else
X {
X pieces[n]=vstrunc(pieces[n],szz);
X brmem(p,pieces[n],szz);
X }
}
X
static int skip_special(p)
X P *p;
X {
X  int to, s;
X  P *q;
X  switch(s=pgetc(p))
X   {
X    case '"':
X    do
X     if((s=pgetc(p))=='\\') pgetc(p), s=pgetc(p);
X     while(s!=MAXINT && s!='\"');
X    if(s=='\"') return MAXINT-1;
X    break;
X
X    case '\'':
X    do
X     if((s=pgetc(p))=='\\') s=pgetc(p), s=pgetc(p);
X     while(s!=MAXINT && s!='\'');
X    if(s=='\'') return MAXINT-1;
X    break;
X
X    case '[': to=']'; goto skip;
X    case '(': to=')'; goto skip;
X    case '{': to='}';
X    skip: do
X     s=skip_special(p);
X     while(s!=to && s!=MAXINT);
X    if(s==to) return MAXINT-1;
X    break;
X
X    case '/':
X    s=pgetc(p);
X    if(s=='*')
X     do
X      {
X      s=pgetc(p);
X      while(s=='*') if((s=pgetc(p))=='/') return MAXINT-1;
X      } while(s!=MAXINT);
X    else
X     if(s!=MAXINT) s=prgetc(p);
X     else s='/';
X    break;
X
X   }
X  return s;
X }
X
int pmatch(regex,len,p,n)
char *regex;
P *p;
{
int c,d;
P *q;
while(len--)
X switch(c=*regex++)
X  {
X case '\\':
X  if(!len--) return 0;
X  switch(c=*regex++)
X   {
X  case '?':
X   d=pgetc(p);
X   if(d== MAXINT) return 0;
X   savec(n++,(char)d);
X   break;
X
X  case 'n':
X   d=pgetc(p);
X   if(d!='\n') return 0;
X   break;
X
X  case '*':
X   q=pdup(p);
X   do
X    {
X    long pb=p->byte;
X    if(pmatch(regex,len,p,n+1))
X     { saves(n,q,pb-q->byte); prm(q); return 1; }
X    }
X    while(pgetc(p)!= MAXINT);
X   pset(p,q); prm(q);
X   return 0;
X	
X  case 'c':
X   q=pdup(p);
X   do
X    {
X    long pb=p->byte;
X    if(pmatch(regex,len,p,n+1))
X     { saves(n,q,pb-q->byte); prm(q); return 1; }
X    }
X    while((c=skip_special(p))!= MAXINT);
X   pset(p,q); prm(q);
X   return 0;
X
X  case '[':
X   d=pgetc(p);
X   if(d== MAXINT) return 0;
X   if(!brack(&regex,&len,d)) { prgetc(p); return 0; }
X   savec(n++,(char)d);
X   break;
X
X  case '+':
X   {
X    char *oregex=regex;
X    int olen=len;
X    q=pdup(p);
X    /* move forward */
X    if (len--,(*regex++=='['))
X     brack(&regex,&len,c);
X    do
X     {
X      long pb=p->byte;
X      if(pmatch(regex,len,p,n+1))
X       { saves(n,q,pb-q->byte); prm(q); return 1; }
X      regex=oregex;
X      len=olen;
X     }
X    while(
X     (MAXINT!=(c=pgetc(p))) &&
X      (
X       (len--,(*regex++=='[')) ?
X        brack(&regex,&len,c) :
X        regex[-1]==c
X      ));
X    pset(p,q); prm(q);
X    return 0;
X   }
X   
X  case '^':
X   if(!pisbol(p)) return 0;
X   break;
X
X  case '$':
X   if(!piseol(p)) return 0;
X   break;
X
X  case '<':
X   if(!pisbow(p)) return 0;
X   break;
X  
X  case '>':
X   if(!piseow(p)) return 0;
X   break;
X  
X  default:
X   d=pgetc(p);
X   if(d!=c) { if(d!= MAXINT) prgetc(p); return 0; }
X   }
X  break;
X
X default:
X  d=pgetc(p);
X  if(d!=c) { if(d!= MAXINT) prgetc(p); return 0; }
X  }
return 1;
}
X
int pimatch(regex,len,p,n)
char *regex;
P *p;
{
int c,d;
P *q;
while(len--)
X switch(c=*regex++)
X  {
X case '\\':
X  if(!len--) return 0;
X  switch(c=*regex++)
X   {
X  case '?':
X   d=pgetc(p);
X   if(d==MAXINT) return 0;
X   savec(n++,(char)d);
X   break;
X  
X  case 'n':
X   d=pgetc(p);
X   if(d!='\n') return 0;
X   break;
X  
X  case '*':
X   q=pdup(p);
X   do
X    {
X    long pb=p->byte;
X    if(pimatch(regex,len,p,n+1))
X     { saves(n,q,pb-q->byte); prm(q); return 1; }
X    }
X    while(pgetc(p)!= MAXINT);
X   pset(p,q); prm(q);
X   return 0;
X
X  case 'c':
X   q=pdup(p);
X   do
X    {
X    long pb=p->byte;
X    if(pimatch(regex,len,p,n+1))
X     { saves(n,q,pb-q->byte); prm(q); return 1; }
X    }
X    while((c=skip_special(p))!= MAXINT);
X   pset(p,q); prm(q);
X   return 0;
X
X  case '[':
X   d=pgetc(p);
X   if(d==MAXINT) return 0;
X   if(!brack(&regex,&len,d)) { prgetc(p); return 0; }
X   savec(n++,(char)d);
X   break;
X
X  case '+':
X   {
X    char *oregex=regex;
X    int olen=len;
X    q=pdup(p);
X    /* move forward */
X    if (len--,(*regex++=='['))
X     brack(&regex,&len,c);
X    do
X     {
X      long pb=p->byte;
X      if(pimatch(regex,len,p,n+1))
X       { saves(n,q,pb-q->byte); prm(q); return 1; }
X      regex=oregex;
X      len=olen;
X     }
X    while(
X     (MAXINT!=(c=pgetc(p))) &&
X      (
X       (len--,(*regex++=='[')) ?
X        brack(&regex,&len,c) :
X        toup(regex[-1])==toup(c)
X      ));
X    pset(p,q); prm(q);
X    return 0;
X   }
X
X  case '^':
X   if(!pisbol(p)) return 0;
X   break;
X
X  case '$':
X   if(!piseol(p)) return 0;
X   break;
X
X  case '<':
X   if(!pisbow(p)) return 0;
X   break;
X  
X  case '>':
X   if(!piseow(p)) return 0;
X   break;
X  
X  default:
X   d=pgetc(p);
X   if(toup(d)!=toup(c)) { if(d!=MAXINT) prgetc(p); return 0; }
X   }
X  break;
X
X default:
X  d=pgetc(p);
X  if(toup(d)!=toup(c)) { if(d!=MAXINT) prgetc(p); return 0; }
X  }
return 1;
}
SHAR_EOF
chmod 0600 regex.c ||
echo 'restore of regex.c failed'
Wc_c="`wc -c < 'regex.c'`"
test 8187 -eq "$Wc_c" ||
	echo 'regex.c: original size 8187, current size' "$Wc_c"
fi
# ============= regex.h ==============
if test -f 'regex.h' -a X"$1" != X"-c"; then
	echo 'x - skipping regex.h (File already exists)'
else
echo 'x - extracting regex.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'regex.h' &&
/* Regular expression subroutines
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iregex
#define _Iregex 1
X
extern char *pieces[];
int rmatch();
int pmatch();
int pimatch();
X
#endif
SHAR_EOF
chmod 0600 regex.h ||
echo 'restore of regex.h failed'
Wc_c="`wc -c < 'regex.h'`"
test 879 -eq "$Wc_c" ||
	echo 'regex.h: original size 879, current size' "$Wc_c"
fi
# ============= scrn.c ==============
if test -f 'scrn.c' -a X"$1" != X"-c"; then
	echo 'x - skipping scrn.c (File already exists)'
else
echo 'x - extracting scrn.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'scrn.c' &&
/* Device independant TTY interface for JOE
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <signal.h>
#include "blocks.h"
#include "heap.h"
#include "vs.h"
#include "termcap.h"
#include "tty.h"
#include "zstr.h"
#include "scrn.h"
X
extern int mid;
X
/* Table of key sequences which we will translate to single codes */
X
SEQ seqs[NKEYS]=
{
X { "kd", KEYDOWN, "DOWN" },
X { "ku", KEYUP, "UP" },
X { "kl", KEYLEFT, "LEFT" },
X { "kr", KEYRIGHT, "RIGHT" },
X { "k0", KEYF0, "F0" },
X { "k1", KEYF1, "F1" },
X { "k2", KEYF2, "F2" },
X { "k3", KEYF3, "F3" },
X { "k4", KEYF4, "F4" },
X { "k5", KEYF5, "F5" },
X { "k6", KEYF6, "F6" },
X { "k7", KEYF7, "F7" },
X { "k8", KEYF8, "F8" },
X { "k9", KEYF9, "F9" },
X { "kD", KEYDEL, "DEL" },
X { "kI", KEYINS, "INS" },
X { "kh", KEYHOME, "HOME" },
X { "kH", KEYEND, "END" },
X { "kN", KEYPGDN, "PGDN" },
X { "kP", KEYPGUP, "PGUP" }
};
X
/* Set attributes */
X
void attr(t,c)
SCRN *t;
int c;
{
int e;
c&=~255;
e=(t->attrib&~c);
if(e&UNDERLINE)
X {
X if(t->ue) texec(t->cap,t->ue,1), e&=~UNDERLINE;
X t->attrib&=~UNDERLINE;
X }
if(e&INVERSE)
X {
X if(t->se) texec(t->cap,t->se,1), e&=~INVERSE;
X else if(t->me) texec(t->cap,t->me,1), e=0, t->attrib=0;
X t->attrib&=~INVERSE;
X }
if(e)
X {
X if(t->me) texec(t->cap,t->me,1);
X t->attrib=0;
X }
e=(c&~t->attrib);
if(e&INVERSE)
X if(t->mr) texec(t->cap,t->mr,1);
X else if(t->so) texec(t->cap,t->so,1);
if(e&UNDERLINE)
X if(t->us) texec(t->cap,t->us,1);
if(e&BLINK)
X if(t->mb) texec(t->cap,t->mb,1);
if(e&BOLD)
X if(t->md) texec(t->cap,t->md,1);
if(e&DIM)
X if(t->mh) texec(t->cap,t->mh,1);
t->attrib=c;
}
X
/* Set scrolling region */
X
void setregn(t,top,bot)
SCRN *t;
int top,bot;
{
if(!t->cs)
X {
X t->top=top;
X t->bot=bot;
X return;
X }
if(t->top!=top || t->bot!=bot)
X {
X t->top=top;
X t->bot=bot;
X texec(t->cap,t->cs,1,top,bot-1);
X t->x= -1; t->y= -1;
X }
}
X
/* Enter insert mode */
X
void setins(t,x)
SCRN *t;
{
if(t->ins!=1 && t->im)
X {
X t->ins=1;
X texec(t->cap,t->im,1,x);
X }
}
X
/* Exit insert mode */
X
void clrins(t)
SCRN *t;
{
if(t->ins!=0)
X {
X texec(t->cap,t->ei,1);
X t->ins=0;
X }
}
X
/* Erase from given screen coordinate to end of line */
X
int eraeol(t,x,y)
SCRN *t;
{
int *s, *ss;
int w=t->co-x-1;			/* Don't worry about last column */
if(w<=0) return 0;
s=t->scrn+y*t->co+x;
ss=s+w;
do if(*--ss!=' ') { ++ss; break; } while(ss!=s);
if((ss-s>3 || s[w]!=' ') && t->ce)
X {
X cpos(t,x,y);
X attr(t,0);
X texec(t->cap,t->ce,1);
X msetI(s,' ',w);
X }
else while(s!=ss) outatr(t,x,y,' '), ++x, *s++=' ';
return 0;
}
X
/* Output a character with attributes */
X
void outatr(t,x,y,c)
SCRN *t;
{
unsigned char ch;
if(c== -1) c=' ';
if(t->ins) clrins(t);
ch=c; c-=ch;
if(t->x!=x || t->y!=y) cpos(t,x,y);
if(c!=t->attrib) attr(t,c);
if(t->hz && ch=='~') ch='\\';
ttputc(ch);
++t->x;
}
X
/* As above but useable in insert mode */
/* The cursor position must already be correct */
X
void outatri(t,x,y,c)
SCRN *t;
{
unsigned char ch;
if(c== -1) c=' ';
ch=c; c-=ch;
if(c!=t->attrib) attr(t,c);
if(t->hz && ch=='~') ch='\\';
ttputc(ch);
++t->x;
}
X
/* Overstrike terminal handling */
X
void outatr1(t,x,y,c)
SCRN *t;
{
if(t->os && t->eo &&
X   (t->scrn[x+t->co*y]!=' ' || (t->scrn[x+t->co*y]&~255)!=(c&~255)) ||
X   t->ul && (c&255)=='_' && (!t->os || t->eo)
X  )
X outatr(t,x,y,' ');
outatr(t,x,y,c);
if(c&UNDERLINE && !t->us)
X {
X cpos(t,x,y), texec(t->cap,t->uc,1);
X if(++t->x==t->co)
X  if(t->am) t->x=0, ++t->y;
X  else if(t->xn) t->x= -1, t->y= -1;
X  else --t->x;
X }
}
X
void out(t,c)
char *t;
char c;
{
ttputc(c);
}
X
SCRN *nopen()
{
SCRN *t=(SCRN *)malloc(sizeof(SCRN));
int x,y;
char *p;
ttopen();
X
if(!(t->cap=getcap(NULL,baud,out,NULL)))
X {
X free(t);
X ttclose();
X fprintf(stdout,"Couldn't load termcap/terminfo entry\n");
X return 0;
X }
X
t->li=getnum(t->cap,"li"); if(t->li<1) t->li=24;
t->co=getnum(t->cap,"co"); if(t->co<2) t->co=80;
x=y=0;
ttgtsz(&x,&y);
if(x>7 && y>3) t->li=y, t->co=x;
x=y=0;
if(p=getenv("LINES")) sscanf(p,"%d",&y);
if(p=getenv("COLUMNS")) sscanf(p,"%d",&x);
if(x>7) t->co=x;
if(y>3) t->li=y;
X
t->hz=getflag(t->cap,"hz");
t->os=getflag(t->cap,"os");
t->eo=getflag(t->cap,"eo");
if(getflag(t->cap,"hc")) t->os=1;
if(t->os || getflag(t->cap,"ul")) t->ul=1;
else t->ul=0;
X
t->xn=getflag(t->cap,"xn");
t->am=getflag(t->cap,"am");
X
t->ti=getstr(t->cap,"ti");
t->cl=getstr(t->cap,"cl");
t->cd=getstr(t->cap,"cd");
X
t->te=getstr(t->cap,"te");
X
t->mb=0; t->md=0; t->mh=0; t->mr=0; t->avattr=0;
if(!(t->me=getstr(t->cap,"me"))) goto oops;
if((t->mb=getstr(t->cap,"mb"))) t->avattr|=BLINK;
if((t->md=getstr(t->cap,"md"))) t->avattr|=BOLD;
if((t->mh=getstr(t->cap,"mh"))) t->avattr|=DIM;
if((t->mr=getstr(t->cap,"mr"))) t->avattr|=INVERSE;
oops:
X
t->so=0; t->se=0;
if(getnum(t->cap,"sg")<=0 && !t->mr && getstr(t->cap,"se"))
X {
X if(t->so=getstr(t->cap,"so")) t->avattr|=INVERSE;
X t->se=getstr(t->cap,"se");
X }
if(getflag(t->cap,"xs") || getflag(t->cap,"xt")) t->so=0;
X
t->us=0; t->ue=0;
if(getnum(t->cap,"ug")<=0 && getstr(t->cap,"ue"))
X {
X if(t->us=getstr(t->cap,"us")) t->avattr|=UNDERLINE;
X t->ue=getstr(t->cap,"ue");
X }
X
if(!(t->uc=getstr(t->cap,"uc"))) if(t->ul) t->uc="_";
if(t->uc) t->avattr|=UNDERLINE;
X
t->ms=getflag(t->cap,"ms");
X
t->da=getflag(t->cap,"da");
t->db=getflag(t->cap,"db");
t->cs=getstr(t->cap,"cs");
t->rr=getflag(t->cap,"rr");
t->sf=getstr(t->cap,"sf");
t->sr=getstr(t->cap,"sr");
t->SF=getstr(t->cap,"SF");
t->SR=getstr(t->cap,"SR");
t->al=getstr(t->cap,"al");
t->dl=getstr(t->cap,"dl");
t->AL=getstr(t->cap,"AL");
t->DL=getstr(t->cap,"DL");
if(!getflag(t->cap,"ns") && !t->sf) t->sf="\12";
X
if(!getflag(t->cap,"in") && baud<38400)
X {
X t->dc=getstr(t->cap,"dc");
X t->DC=getstr(t->cap,"DC");
X t->dm=getstr(t->cap,"dm");
X t->ed=getstr(t->cap,"ed");
X
X t->im=getstr(t->cap,"im");
X t->ei=getstr(t->cap,"ei");
X t->ic=getstr(t->cap,"ic");
X t->IC=getstr(t->cap,"IC");
X t->ip=getstr(t->cap,"ip");
X t->mi=getflag(t->cap,"mi");
X }
else
X {
X t->dm=0; t->dc=0; t->DC=0; t->ed=0;
X t->im=0; t->ic=0; t->IC=0; t->ip=0; t->ei=0;
X t->mi=1;
X }
X
t->bs=0;
if(getstr(t->cap,"bc")) t->bs=getstr(t->cap,"bc");
else if(getstr(t->cap,"le")) t->bs=getstr(t->cap,"le");
if(getflag(t->cap,"bs")) t->bs="\10";
X
t->cbs=tcost(t->cap,t->bs,1,2,2);
X
t->lf="\12";
if(getstr(t->cap,"do")) t->lf=getstr(t->cap,"do");
t->clf=tcost(t->cap,t->lf,1,2,2);
X
t->up=getstr(t->cap,"up");
t->cup=tcost(t->cap,t->up,1,2,2);
X
t->nd=getstr(t->cap,"nd");
X
t->tw=8;
if(getnum(t->cap,"it")>0) t->tw=getnum(t->cap,"it");
else if(getnum(t->cap,"tw")>0) t->tw=getnum(t->cap,"tw");
X
if(!(t->ta=getstr(t->cap,"ta"))) if(getflag(t->cap,"pt")) t->ta="\11";
t->bt=getstr(t->cap,"bt");
if(getflag(t->cap,"xt")) t->ta=0, t->bt=0;
X
t->cta=tcost(t->cap,t->ta,1,2,2);
t->cbt=tcost(t->cap,t->bt,1,2,2);
X
t->ho=getstr(t->cap,"ho");
t->cho=tcost(t->cap,t->ho,1,2,2);
t->ll=getstr(t->cap,"ll");
t->cll=tcost(t->cap,t->ll,1,2,2);
X
t->cr="\15";
if(getstr(t->cap,"cr")) t->cr=getstr(t->cap,"cr");
if(getflag(t->cap,"nc") || getflag(t->cap,"xr")) t->cr=0;
t->ccr=tcost(t->cap,t->cr,1,2,2);
X
t->cRI=tcost(t->cap,t->RI=getstr(t->cap,"RI"),1,2,2);
t->cLE=tcost(t->cap,t->LE=getstr(t->cap,"LE"),1,2,2);
t->cUP=tcost(t->cap,t->UP=getstr(t->cap,"UP"),1,2,2);
t->cDO=tcost(t->cap,t->DO=getstr(t->cap,"DO"),1,2,2);
t->cch=tcost(t->cap,t->ch=getstr(t->cap,"ch"),1,2,2);
t->ccv=tcost(t->cap,t->cv=getstr(t->cap,"cv"),1,2,2);
t->ccb=tcost(t->cap,t->cb=getstr(t->cap,"cb"),1,2,2);
t->ccm=tcost(t->cap,t->cm=getstr(t->cap,"cm"),1,2,2);
X
t->cce=tcost(t->cap,t->ce=getstr(t->cap,"ce"),1,2,2);
X
x=0;
for(y=0;y!=NKEYS;++y)
X if(getstr(t->cap,seqs[y].seq))
X  {
X  char *s=tcompile(t->cap,getstr(t->cap,seqs[y].seq));
X  if(s)
X   {
X   t->ktab[x].s=s;
X   t->ktab[x].l=sLen(s);
X   t->ktab[x].n=seqs[y].code;
X   ++x;
X   }
X  }
t->tabsize=x;
t->kbufp=0;
t->dumpptr= -1;
X
/* Make sure terminal can do absolute positioning */
if(t->cm) goto ok;
if(t->ch && t->cv) goto ok;
if(t->ho && (t->lf || t->DO || t->cv)) goto ok;
if(t->ll && (t->up || t->UP || t->cv)) goto ok;
if(t->cr && t->cv) goto ok;
leave=1;
ttclose();
signrm();
fprintf(stderr,"Sorry, your terminal can't do absolute cursor positioning\n");
fprintf(stderr,"It\'s broken\n");
return 0;
ok:
X
/* Determine if we can scroll */
if((t->sr || t->SR) && (t->sf || t->SF) && t->cs ||
X   (t->al || t->AL) && (t->dl || t->DL)) t->scroll=1;
else t->scroll=0, mid=1;
X
/* Determine if we can ins/del within lines */
if((t->im || t->ic || t->IC) && (t->dc || t->DC)) t->insdel=1;
else t->insdel=0;
X
/* Adjust for high baud rates */
if(baud>=38400) t->scroll=0, t->insdel=0, mid=0;
X
/* Initialize variable screen size dependant vars */
t->scrn=0; t->sary=0; t->updtab=0; t->compose=0;
t->ofst=0; t->ary=0;
t->htab=(struct hentry *)malloc(256*sizeof(struct hentry));
nresize(t,t->co,t->li);
X
/* Send out terminal initialization string */
if(t->ti) texec(t->cap,t->ti,1);
X
return t;
} 
X
/* Change size of screen */
X
void nresize(t,w,h)
SCRN *t;
{
if(h<4) h=4;
if(w<8) w=8;
t->li=h;
t->co=w;
if(t->sary) free(t->sary);
if(t->updtab) free(t->updtab);
if(t->scrn) free(t->scrn);
if(t->compose) free(t->compose);
if(t->ofst) free(t->ofst);
if(t->ary) free(t->ary);
t->scrn=(int *)malloc(t->li*t->co*sizeof(int));
t->sary=(int *)calloc(t->li,sizeof(int));
t->updtab=(int *)malloc(t->li*sizeof(int));
t->compose=(int *)malloc(t->co*sizeof(int));
t->ofst=(int *)malloc(t->co*sizeof(int));
t->ary=(struct hentry *)malloc(t->co*sizeof(struct hentry));
nredraw(t);
}
X
/* Calculate cost of positioning the cursor using only relative cursor
X * positioning functions: t->(lf, DO, up, UP, bs, LE, RI, ta, bt) and rewriting
X * characters (to move right)
X *
X * This doesn't use the am and bw capabilities although it probably could.
X */
X
static int relcost(t,x,y,ox,oy)
register SCRN *t;
register int x,y,ox,oy;
{
int cost=0, c;
X
/* If we don't know the cursor position, force use of absolute positioning */
if(oy== -1 || ox== -1) return 10000;
X
/* First adjust row */
if(y>oy)
X /* Have to go down */
X if(t->lf)
X  if(t->cDO<(c=(y-oy)*t->clf)) cost+=t->cDO;
X  else cost+=c;
X else if(t->DO) cost+=t->cDO;
X else return 10000;
else if(y<oy)
X /* Have to go up */
X if(t->up)
X  if(t->cUP<(c=(oy-y)*t->cup)) cost+=t->cUP;
X  else cost+=c;
X else if(t->UP) cost+=t->cUP;
X else return 10000;
X
/* Now adjust column */
X
/* Use tabs */
if(x>ox && t->ta)
X {
X int ntabs=(x-ox+ox%t->tw)/t->tw;
X int cstunder=x%t->tw+t->cta*ntabs, cstover;
X if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
X else cstover=10000;
X if(cstunder<t->cRI && cstunder<x-ox && cstover>cstunder)
X  return cost+cstunder;
X else if(cstover<t->cRI && cstover<x-ox) return cost+cstover;
X }
else if(x<ox && t->bt)
X {
X int ntabs=(ox-x+t->tw-ox%t->tw)/t->tw;
X int cstunder,cstover;
X if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
X if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
X if(cstunder<t->cLE && (t->bs?cstunder<(ox-x)*t->cbs:1) && cstover>cstunder)
X  return cost+cstunder;
X else if(cstover<t->cRI && (t->bs?cstover<(ox-x)*t->cbs:1)) return cost+cstover;
X }
X
/* Use simple motions */
if(x<ox)
X /* Have to go left */
X if(t->bs) 
X  if(t->cLE<(c=(ox-x)*t->cbs)) cost+=t->cLE;
X  else cost+=c;
X else if(t->LE) cost+=t->cLE;
X else return 10000;
else if(x>ox)
X /* Have to go right */
X /* Hmm.. this should take into account possible attribute changes */
X if(t->cRI<x-ox) cost+=t->cRI;
X else cost+=x-ox;
X
return cost;
}
X
/* Find optimal set of cursor positioning commands to move from the current
X * cursor row and column (either or both of which might be unknown) to the
X * given new row and column and execute them.
X */
X
static void cposs(t,x,y)
register SCRN *t;
register int x,y;
{
register int bestcost,cost;
int bestway;
int hy;
int hl;
X
/* Home y position is usually 0, but it is 'top' if we have scrolling region
X * relative addressing
X */
if(t->rr) hy=t->top, hl=t->bot-1;
else hy=0, hl=t->li-1;
X
/* Assume best way is with only using relative cursor positioning */
X
bestcost=relcost(t,x,y,t->x,t->y); bestway=0;
X
/* Now check if combinations of absolute cursor positioning functions are
X * better (or necessary in case one or both cursor positions are unknown)
X */
X
if(t->ccr<bestcost)
X {
X cost=relcost(t,x,y,0,t->y)+t->ccr;
X if(cost<bestcost) bestcost=cost, bestway=1;
X }
if(t->cho<bestcost)
X {
X cost=relcost(t,x,y,0,hy)+t->cho;
X if(cost<bestcost) bestcost=cost, bestway=2;
X }
if(t->cll<bestcost)
X {
X cost=relcost(t,x,y,0,hl)+t->cll;
X if(cost<bestcost) bestcost=cost, bestway=3;
X }
if(t->cch<bestcost && x!=t->x)
X {
X cost=relcost(t,x,y,x,t->y)+tcost(t->cap,t->ch,1,x);
X if(cost<bestcost) bestcost=cost, bestway=4;
X }
if(t->ccv<bestcost && y!=t->y)
X {
X cost=relcost(t,x,y,t->x,y)+tcost(t->cap,t->cv,1,y);
X if(cost<bestcost) bestcost=cost, bestway=5;
X }
if(t->ccb<bestcost)
X {
X cost=relcost(t,x,y,0,y)+tcost(t->cap,t->cb,1,y);
X if(cost<bestcost) bestcost=cost, bestway=13;
X }
if(t->ccm<bestcost)
X {
X cost=tcost(t->cap,t->cm,1,y,x);
X if(cost<bestcost) bestcost=cost, bestway=6;
X }
if(t->cch+t->ccv<bestcost && x!=t->x && y!=t->y)
X {
X cost=tcost(t->cap,t->cv,1,y-hy)+tcost(t->cap,t->ch,1,x);
X if(cost<bestcost) bestcost=cost, bestway=7;
X }
if(t->ccv+t->ccr<bestcost && y!=t->y)
X {
X cost=tcost(t->cap,t->cv,1,y)+tcost(t->cap,t->cr,1)+
X      relcost(t,x,y,0,y);
X if(cost<bestcost) bestcost=cost, bestway=8;
X }
if(t->cll+t->cch<bestcost)
X {
X cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->ch,1,x)+
X      relcost(t,x,y,x,hl);
X if(cost<bestcost) bestcost=cost, bestway=9;
X }
if(t->cll+t->ccv<bestcost)
X {
X cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->cv,1,y)+
X      relcost(t,x,y,0,y);
X if(cost<bestcost) bestcost=cost, bestway=10;
X }
if(t->cho+t->cch<bestcost)
X {
X cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->ch,1,x)+
X      relcost(t,x,y,x,hy);
X if(cost<bestcost) bestcost=cost, bestway=11;
X }
if(t->cho+t->ccv<bestcost)
X {
X cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->cv,1,y)+
X      relcost(t,x,y,0,y);
X if(cost<bestcost) bestcost=cost, bestway=12;
X }
X
/* Do absolute cursor positioning if we don't know the cursor position or
X * if it is faster than doing only relative cursor positioning
X */
X
switch(bestway)
X {
case 1: texec(t->cap,t->cr,1); t->x=0; break;
case 2: texec(t->cap,t->ho,1); t->x=0; t->y=hy; break;
case 3: texec(t->cap,t->ll,1); t->x=0; t->y=hl; break;
case 9: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto doch;
case 11: texec(t->cap,t->ho,1); t->x=0; t->y=hy;
X  doch:
case 4: texec(t->cap,t->ch,1,x); t->x=x; break;
case 10: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto docv;
case 12: texec(t->cap,t->ho,1); t->x=0; t->y=hy; goto docv;
case 8: texec(t->cap,t->cr,1); t->x=0;
X  docv:
case 5: texec(t->cap,t->cv,1,y); t->y=y; break;
case 6: texec(t->cap,t->cm,1,y,x); t->y=y, t->x=x; break;
case 7: texec(t->cap,t->cv,1,y); t->y=y;
X        texec(t->cap,t->ch,1,x); t->x=x;
X        break;
case 13: texec(t->cap,t->cb,1,y); t->y=y; t->x=0; break;
X }
X
/* Use relative cursor position functions if we're not there yet */
X
/* First adjust row */
if(y>t->y)
X /* Have to go down */
X if(!t->lf || t->cDO<(y-t->y)*t->clf)
X  texec(t->cap,t->DO,1,y-t->y), t->y=y;
X else while(y>t->y) texec(t->cap,t->lf,1), ++t->y;
else if(y<t->y)
X /* Have to go up */
X if(!t->up || t->cUP<(t->y-y)*t->cup)
X  texec(t->cap,t->UP,1,t->y-y), t->y=y;
X else while(y<t->y) texec(t->cap,t->up,1), --t->y;
X
/* Use tabs */
if(x>t->x && t->ta)
X {
X int ntabs=(x-t->x+t->x%t->tw)/t->tw;
X int cstunder=x%t->tw+t->cta*ntabs, cstover;
X if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
X else cstover=10000;
X if(cstunder<t->cRI && cstunder<x-t->x && cstover>cstunder)
X  {
X  if(ntabs)
X   {
X   t->x=x-x%t->tw;
X   do texec(t->cap,t->ta,1); while(--ntabs);
X   }
X  }
X else if(cstover<t->cRI && cstover<x-t->x)
X  {
X  t->x=t->tw+x-x%t->tw;
X  ++ntabs;
X  do texec(t->cap,t->ta,1); while(--ntabs);
X  }
X }
else if(x<t->x && t->bt)
X {
X int ntabs=((t->x+t->tw-1)-(t->x+t->tw-1)%t->tw-
X            ((x+t->tw-1)-(x+t->tw-1)%t->tw))/t->tw;
X int cstunder,cstover;
X if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
X if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
X if(cstunder<t->cLE && (t->bs?cstunder<(t->x-x)*t->cbs:1) && cstover>cstunder)
X  {
X  if(ntabs)
X   {
X   do texec(t->cap,t->bt,1); while(--ntabs);
X   t->x=x+t->tw-x%t->tw;
X   }
X  }
X else if(cstover<t->cRI && (t->bs?cstover<(t->x-x)*t->cbs:1))
X  {
X  t->x=x-x%t->tw; ++ntabs;
X  do texec(t->cap,t->bt,1); while(--ntabs);
X  }
X }
X
/* Now adjust column */
if(x<t->x)
X /* Have to go left */
X if(!t->bs || t->cLE<(t->x-x)*t->cbs)
X  texec(t->cap,t->LE,1,t->x-x), t->x=x;
X else while(x<t->x) texec(t->cap,t->bs,1), --t->x;
else if(x>t->x)
X /* Have to go right */
X /* Hmm.. this should take into account possible attribute changes */
X if(t->cRI<x-t->x) texec(t->cap,t->RI,1,x-t->x), t->x=x;
X else
X  {
X  if(t->ins) clrins(t);
X  while(x>t->x)
X   {
X   int c=t->scrn[t->x+t->y*t->co];
X   outatr(t,t->x,y,c);
X   }
X  }
}
X
void cpos(t,x,y)
register SCRN *t;
register int x,y;
{
if(y==t->y)
X {
X if(x==t->x) return;
X if(x>t->x && x-t->x<4)
X  {
X  int *cs=t->scrn+t->x+t->co*t->y;
X  if(t->ins)
X   if(t->nd)
X    {
X    do texec(t->cap,t->nd,1); while(++t->x!=x);
X    return;
X    }
X   else clrins(t);
X  do { int c=*cs++; outatr(t,t->x,t->y,c); } while(x!=t->x);
X  return;
X  }
X }
if(!t->ms && t->attrib&(INVERSE|UNDERLINE))
X attr(t,t->attrib&~(INVERSE|UNDERLINE));
if(y<t->top || y>=t->bot) setregn(t,0,t->li);
cposs(t,x,y);
}
X
static void doinschr(t,x,y,s,n)
SCRN *t;
int x,y,*s,n;
{
int a;
if(x<0) s-=x, x=0;
if(x>=t->co-1 || n<=0) return;
if(t->im || t->ic || t->IC)
X {
X cpos(t,x,y);
X setins(t,x);
X if(n==1 && t->ic || !t->IC)
X  for(a=0;a!=n;++a)
X   {
X   texec(t->cap,t->ic,1,x);
X   outatri(t,x+a,y,s[a]);
X   texec(t->cap,t->ip,1,x);
X   }
X else
X  {
X  texec(t->cap,t->IC,1,n);
X  for(a=0;a!=n;++a) outatri(t,x+a,y,s[a]);
X  }
X if(!t->mi) clrins(t);
X }
mmove(t->scrn+x+t->co*y+n,t->scrn+x+t->co*y,(t->co-(x+n))*sizeof(int));
mcpy(t->scrn+x+t->co*y,s,n*sizeof(int));
}
X
static void dodelchr(t,x,y,n)
SCRN *t;
int x,y,n;
{
int a;
if(x<0) x=0;
if(!n || x>=t->co-1) return;
if(t->dc || t->DC)
X {
X cpos(t,x,y);
X texec(t->cap,t->dm,1,x);		/* Enter delete mode */
X if(n==1 && t->dc || !t->DC)
X  for(a=n;a;--a) texec(t->cap,t->dc,1,x);
X else texec(t->cap,t->DC,1,n);
X texec(t->cap,t->ed,1,x);		/* Exit delete mode */
X }
mmove(t->scrn+t->co*y+t->x,t->scrn+t->co*y+t->x+n,(t->co-(x+n))*sizeof(int));
}
X
/* Insert/Delete within line */
X
void magic(t,y,cs,s,placex)
SCRN *t;
int y,*cs,*s;
{
struct hentry *htab=t->htab;
int *ofst=t->ofst;
int aryx=1;
int x;
if(!(t->im || t->ic || t->IC) ||
X   !(t->dc || t->DC)) return;
mset(htab,0,256*sizeof(struct hentry));
msetI(ofst,0,t->co);
X
/* Build hash table */
for(x=0;x!=t->co-1;++x)
X t->ary[aryx].next=htab[cs[x]&255].next,
X t->ary[aryx].loc=x,
X ++htab[cs[x]&255].loc,
X htab[cs[x]&255].next=aryx++;
X
/* Build offset table */
for(x=0;x<t->co-1;)
X if(htab[s[x]&255].loc>=15) ofst[x++]= t->co-1;
X else
X  {
X  int aryy;
X  int maxaryy;
X  int maxlen=0;
X  int best=0;
X  int bestback=0;
X  int z;
X  for(aryy=htab[s[x]&255].next;aryy;aryy=t->ary[aryy].next)
X   {
X   int amnt,back;
X   int tsfo=t->ary[aryy].loc-x;
X   int cst= -Iabs(tsfo);
X   int pre=32;
X   for(amnt=0;x+amnt<t->co-1 && x+tsfo+amnt<t->co-1;++amnt)
X    {
X    if(cs[x+tsfo+amnt]!=s[x+amnt]) break;
X    else if(s[x+amnt]&255!=32 || pre!=32) ++cst;
X    pre=s[x+amnt]&255;
X    }
X   pre=32;
X   for(back=0;back+x>0 && back+tsfo+x>0;--back)
X    {
X    if(cs[x+tsfo+back-1]!=s[x+back-1]) break;
X    else if(s[x+back-1]&255!=32 || pre!=32) ++cst;
X    pre=s[x+back-1]&255;
X    }
X   if(cst>best) maxaryy=aryy, maxlen=amnt, best=cst, bestback=back;
X   }
X  if(!maxlen) ofst[x]=t->co-1, maxlen=1;
X  else if(best<2) for(z=0;z!=maxlen;++z) ofst[x+z]=t->co-1;
X  else for(z=0;z!=maxlen-bestback;++z)
X   ofst[x+z+bestback]=t->ary[maxaryy].loc-x;
X  x+=maxlen;
X  }
X
/* Apply scrolling commands */
X
for(x=0;x!=t->co-1;++x)
X {
X int q=ofst[x];
X if(q && q!=t->co-1)
X  if(q>0)
X   {
X   int z,fu;
X   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
X   while(s[x]==cs[x] && x<placex) ++x;
X   dodelchr(t,x,y,q);
X   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
X   x=z-1;
X   }
X  else
X   {
X   int z,fu;
X   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
X   while(s[x+q]==cs[x+q] && x-q<placex) ++x;
X   doinschr(t,x+q,y,s+x+q,-q);
X   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
X   x=z-1;
X   }
X }
}
X
static void doupscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt, x;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sf || t->SF))
X {
X setregn(t,0,t->li);
X cpos(t,0,t->li-1);
X if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,t->li-1);
X else texec(t->cap,t->SF,a,a);
X goto done;
X }
if(bot==t->li && (t->dl || t->DL))
X {
X setregn(t,0,t->li);
X cpos(t,0,top);
X if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
X else texec(t->cap,t->DL,a,a);
X goto done;
X }
if(t->cs && ( t->sf || t->SF ))
X {
X setregn(t,top,bot);
X cpos(t,0,bot-1);
X if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,bot-1);
X else texec(t->cap,t->SF,a,a);
X goto done;
X }
if((t->dl || t->DL) && (t->al || t->AL))
X {
X cpos(t,0,top);
X if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
X else texec(t->cap,t->DL,a,a);
X a=amnt;
X cpos(t,0,bot-amnt);
X if(amnt==1 && t->al || !t->AL) while(a--) texec(t->cap,t->al,1,bot-amnt);
X else texec(t->cap,t->AL,a,a);
X goto done;
X }
msetI(t->updtab+top,1,bot-top);
return;
X
done:
mfwrd(t->scrn+top*t->co,t->scrn+(top+amnt)*t->co,
X      (bot-top-amnt)*t->co*sizeof(int));
if(bot==t->li && t->db)
X {
X msetI(t->scrn+(t->li-amnt)*t->co,-1,amnt*t->co);
X msetI(t->updtab+t->li-amnt,1,amnt);
X }
else msetI(t->scrn+(bot-amnt)*t->co,' ',amnt*t->co);
}
X
static void dodnscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt,x;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sr || t->SR))
X {
X setregn(t,0,t->li);
X cpos(t,0,0);
X if(amnt==1 && t->sr || !t->SR)
X  while(a--) texec(t->cap,t->sr,1,0);
X else texec(t->cap,t->SR,a,a);
X goto done;
X }
if(bot==t->li && (t->al || t->AL))
X {
X setregn(t,0,t->li);
X cpos(t,0,top);
X if(amnt==1 && t->al || !t->AL)
X  while(a--) texec(t->cap,t->al,1,top);
X else texec(t->cap,t->AL,a,a);
X goto done;
X }
if(t->cs && (t->sr || t->SR))
X {
X setregn(t,top,bot);
X cpos(t,0,top);
X if(amnt==1 && t->sr || !t->SR)
X  while(a--) texec(t->cap,t->sr,1,top);
X else texec(t->cap,t->SR,a,a);
X goto done;
X }
if((t->dl || t->DL) && (t->al || t->AL))
X {
X cpos(t,0,bot-amnt);
X if(amnt==1 && t->dl || !t->DL)
X  while(a--) texec(t->cap,t->dl,1,bot-amnt);
X else texec(t->cap,t->DL,a,a);
X a=amnt;
X cpos(t,0,top);
X if(amnt==1 && t->al || !t->AL)
X  while(a--) texec(t->cap,t->al,1,top);
X else texec(t->cap,t->AL,a,a);
X goto done;
X }
msetI(t->updtab+top,1,bot-top);
return;
done:
mbkwd(t->scrn+(top+amnt)*t->co,t->scrn+top*t->co,
X      (bot-top-amnt)*t->co*sizeof(int));
if(!top && t->da)
X {
X msetI(t->scrn,-1,amnt*t->co);
X msetI(t->updtab,1,amnt);
X }
else msetI(t->scrn+t->co*top,' ',amnt*t->co);
}
X
void nscroll(t)
SCRN *t;
{
int y,z,q,r,p;
for(y=0;y!=t->li;++y)
X {
X q=t->sary[y];
X if(have) return;
X if(q && q!=t->li)
X  if(q>0)
X   {
X   for(z=y;z!=t->li && t->sary[z]==q;++z) t->sary[z]=0;
X   doupscrl(t,y,z+q,q), y=z-1;
X   }
X  else
X   {
X   for(r=y;r!=t->li && (t->sary[r]<0 || t->sary[r]==t->li);++r);
X   p=r-1; do
X    {
X    q=t->sary[p];
X    if(q && q!=t->li)
X     {
X     for(z=p;t->sary[z]=0, (z && t->sary[z-1]==q);--z);
X     dodnscrl(t,z+q,p+1,-q);
X     p=z+1;
X     }
X    }
X    while(p--!=y);
X   y=r-1;
X   }
X }
msetI(t->sary,0,t->li);
}
X
void nescape(t)
SCRN *t;
{
attr(t,0);
clrins(t,0);
setregn(t,0,t->li);
cpos(t,0,t->li-1);
eraeol(t,0,t->li-1);
if(t->te) texec(t->cap,t->te,1);
}
X
void nreturn(t)
SCRN *t;
{
if(t->ti) texec(t->cap,t->ti,1);
nredraw(t);
}
X
void nclose(t)
SCRN *t;
{
int x;
leave=1;
attr(t,0);
clrins(t);
setregn(t,0,t->li);
cpos(t,0,t->li-1);
if(t->te) texec(t->cap,t->te,1);
ttclose();
rmcap(t->cap);
free(t->scrn);
free(t->sary);
free(t->ofst);
free(t->htab);
free(t->ary);
for(x=0;x!=t->tabsize;++x) vsrm(t->ktab[x].s);
free(t);
}
X
int ngetc(t)
SCRN *t;
{
int c,w,h,x;
wayup:
if(t->dumpptr>=0)
X {
X c=t->kbuf[t->dumpptr++];
X if(t->dumpptr==t->kbufp)
X  {
X  t->dumpptr= -1;
X  t->kbufp=0;
X  }
X return c;
X }
up:
c=ttgetc();
if(t->kbufp==32) t->kbufp=0;
t->kbuf[t->kbufp++]=c;
w=0;
for(h=0;h!=t->tabsize;++h)
X {
X for(x=0;x!=t->kbufp && x!=t->ktab[h].l;++x)
X  if(t->ktab[h].s[x]!=t->kbuf[x]) goto nomatch;
X if(x==t->ktab[h].l)
X  {
X  c=t->ktab[h].n;
X  goto found;
X  }
X else if(x==t->kbufp) w=1;
X nomatch:;
X }
if(w) goto up;
/* Have to dump each char */
t->dumpptr=0;
goto wayup;
found:
t->kbufp=0;
X
return c;
}
X
void nscrldn(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
X {
X for(x=bot;x!=top+amnt;--x)
X  t->sary[x-1]=(t->sary[x-amnt-1]==t->li?t->li:t->sary[x-amnt-1]-amnt),
X  t->updtab[x-1]=t->updtab[x-amnt-1];
X for(x=top;x!=top+amnt;++x) t->updtab[x]=0;
X }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+top,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+top,1,amnt);
}
X
void nscrlup(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
X {
X for(x=top+amnt;x!=bot;++x)
X  t->sary[x-amnt]=(t->sary[x]==t->li?t->li:t->sary[x]+amnt),
X  t->updtab[x-amnt]=t->updtab[x];
X for(x=bot-amnt;x!=bot;++x) t->updtab[x]=0;
X }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+bot-amnt,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+bot-amnt,1,amnt);
}
X
void nredraw(t)
SCRN *t;
{
msetI(t->scrn,-1,t->li*t->co);
msetI(t->sary,0,t->li);
msetI(t->updtab,-1,t->li);
t->x= -1;
t->y= -1;
t->top=t->li;
t->bot=0;
t->attrib= -1;
t->ins= -1;
attr(t,0);
clrins(t);
setregn(t);
if(t->cl)
X {
X texec(t->cap,t->cl,1,0);
X t->x=0; t->y=0;
X msetI(t->scrn,' ',t->li*t->co);
X }
else if(t->cd)
X {
X cpos(t,0,0);
X texec(t->cap,t->cd,1,0);
X msetI(t->scrn,' ',t->li*t->co);
X }
}
SHAR_EOF
chmod 0600 scrn.c ||
echo 'restore of scrn.c failed'
Wc_c="`wc -c < 'scrn.c'`"
test 26464 -eq "$Wc_c" ||
	echo 'scrn.c: original size 26464, current size' "$Wc_c"
fi
# ============= scrn.h ==============
if test -f 'scrn.h' -a X"$1" != X"-c"; then
	echo 'x - skipping scrn.h (File already exists)'
else
echo 'x - extracting scrn.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'scrn.h' &&
/* Device independant tty interface for JOE
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iscrn
#define _Iscrn 1
X
#include "config.h"
#include "termcap.h"
#include "tty.h"
X
typedef struct seq SEQ;
typedef struct scrn SCRN;
X
/* Number of key sequence translation entries */
X
#define NKEYS 20
X
/* Sepecial key sequence structure */
X
struct seq
X {
X char *seq;
X int code;
X char *name;
X };
X
extern SEQ seqs[];
X
struct hentry
X {
X int next;
X int loc;
X };
X
/* Each terminal has one of these */
X
struct scrn
X {
X CAP *cap;		/* Termcap/Terminfo data */
X
X int li;			/* Screen height */
X int co;			/* Screen width */
X
X char *ti;			/* Initialization string */
X char *cl;			/* Home and clear screen... really an
X 				   init. string */
X char *cd;			/* Clear to end of screen */
X char *te;			/* Restoration string */
X
X int hz;			/* Terminal can't print ~s */
X int os;			/* Terminal overstrikes */
X int eo;			/* Can use blank to erase even if os */
X int ul;			/* _ overstrikes */
X int am;			/* Terminal has autowrap, but not magicwrap */
X int xn;			/* Terminal has magicwrap */
X
X char *so;			/* Enter standout (inverse) mode */
X char *se;			/* Exit standout mode */
X
X char *us;			/* Enter underline mode */
X char *ue;			/* Exit underline mode */
X char *uc;			/* Single time underline character */
X
X int ms;			/* Ok to move when in standout/underline mode */
X
X char *mb;			/* Enter blinking mode */
X char *md;			/* Enter bold mode */
X char *mh;			/* Enter dim mode */
X char *mr;			/* Enter inverse mode */
X char *me;			/* Exit above modes */
X
X int da, db;			/* Extra lines exist above, below */
X char *al, *dl, *AL, *DL;	/* Insert/delete lines */
X char *cs;			/* Set scrolling region */
X int rr;			/* Set for scrolling region relative addressing */
X char *sf, *SF, *sr, *SR;	/* Scroll */
X
X char *dm, *dc, *DC, *ed;	/* Delete characters */
X char *im, *ic, *IC, *ip, *ei;	/* Insert characters */
X int mi;			/* Set if ok to move while in insert mode */
X
X char *bs;			/* Move cursor left 1 */
X int cbs;
X char *lf;			/* Move cursor down 1 */
X int clf;
X char *up;			/* Move cursor up 1 */
X int cup;
X char *nd;			/* Move cursor right 1 */
X
X char *ta;			/* Move cursor to next tab stop */
X int cta;
X char *bt;			/* Move cursor to previous tab stop */
X int cbt;
X int tw;			/* Tab width */
X
X char *ho;			/* Home cursor to upper left */
X int cho;
X char *ll;			/* Home cursor to lower left */
X int cll;
X char *cr;			/* Move cursor to left edge */
X int ccr;
X char *RI;			/* Move cursor right n */
X int cRI;
X char *LE;			/* Move cursor left n */
X int cLE;
X char *UP;			/* Move cursor up n */
X int cUP;
X char *DO;			/* Move cursor down n */
X int cDO;
X char *ch;			/* Set cursor column */
X int cch;
X char *cv;			/* Set cursor row */
X int ccv;
X char *cb;			/* Goto beginning of specified line */
X int ccb;
X char *cm;			/* Set cursor row and column */
X int ccm;
X
X char *ce;			/* Clear to end of line */
X int cce;
X
X /* Basic abilities */
X int scroll;			/* Set to use scrolling */
X int insdel;			/* Set to use insert/delete within line */
X
X /* Key-sequence translation table */
X
X struct
X  {
X  char *s;			/* Key sequence string */
X  int l;			/* Key sequence string length */
X  int n;			/* Value which should be returned for this string */
X  } ktab[NKEYS];
X
X int tabsize;			/* Number of entries in translation table */
X
X /* Input buffer for translations */
X
X char kbuf[32];			/* Keyboard buffer */
X int kbufp;			/* Keyboard buffer index */
X int dumpptr;			/* When we pass unmatched chars */
X
X /* Current state of terminal */
X int *scrn;			/* Current contents of screen */
X int x,y;			/* Current cursor position (-1 for unknown) */
X int top,bot;			/* Current scrolling region */
X int attrib;			/* Current character attributes */
X int ins;			/* Set if we're in insert mode */
X
X int *updtab;			/* Dirty lines table */
X int avattr;			/* Bits set for available attributes */
X int *sary;			/* Scroll buffer array */
X
X int *compose;			/* Line compose buffer */
X int *ofst;			/* stuff for magic */
X struct hentry *htab;
X struct hentry *ary;
X };
X
/* SCRN *nopen(void);
X *
X * Open the screen (sets TTY mode so that screen may be used immediatly after
X * the 'nopen').
X */
SCRN *nopen();
X
/* void nresize(SCRN *t,int w,int h);
X *
X * Change size of screen.  For example, call this when you find out that
X * the Xterm changed size.
X */
void nresize();
X
/* void nredraw(SCRN *t);
X *
X * Invalidate all state variables for the terminal.  This way, everything gets
X * redrawn.
X */
void nredraw();
X
void nescape();
void nreturn();
X
/* void nclose(SCRN *t);
X *
X * Close the screen and restore TTY to initial state.
X *
X * if 'flg' is set, tclose doesn't mess with the signals.
X */
void nclose();
X
/* int ngetc(SCRN *t);
X *
X * Get next input character.  Arrow keys are translated into the integer codes
X * shown below.
X */
int ngetc();
X
#define KEYUP 256	/* Arrow keys */			/* ku */
#define KEYDOWN 257						/* kd */
#define KEYLEFT 258						/* kl */
#define KEYRIGHT 259						/* kr */
#define KEYF0 260	/* Function keys (is F0 really F10?) */ /* k0 */
#define KEYF1 261						/* k1 */
#define KEYF2 262
#define KEYF3 263
#define KEYF4 270
#define KEYF5 265
#define KEYF6 266
#define KEYF7 267
#define KEYF8 268
#define KEYF9 269						/* k9 */
#define KEYDEL 383	/* Delete character */			/* kD */
#define KEYINS 271	/* Insert character */			/* kI */
#define KEYHOME 272	/* Home key */				/* kh */
#define KEYEND 273	/* End key */				/* kH */
#define KEYPGDN 274	/* Page down key */			/* kN */
#define KEYPGUP 275	/* Page up key */			/* kP */
#define KEYBACKS 264	/* Backspace key */			/* kb */
X
/* void cpos(SCRN *t,int x,int y);
X *
X * Set cursor position
X */
void cpos();
X
/* void attr(SCRN *t,int a);
X *
X * Set attributes
X */
void attr();
X
/* void outatr(SCRN *t,int x,int y,int c);
X *
X * Output a character at the given screen cooridinate.  The cursor position
X * after this function is executed is indeterminate.
X */
void outatr();
X
/* Character attribute bits */
X
#define INVERSE 256
#define UNDERLINE 512
#define BOLD 1024
#define BLINK 2048
#define DIM 4096
X
/* int eraeol(SCRN *t,int x,int y);
X *
X * Erase from screen coordinate to end of line.
X */
int eraeol();
X
/* void nscrlup(SCRN *t,int top,int bot,int amnt);
X *
X * Buffered scroll request.  Request that some lines up.  'top' and 'bot'
X * indicate which lines to scroll.  'bot' is the last line to scroll + 1.
X * 'amnt' is distance in lines to scroll.
X */
void nscrlup();
X
/* void nscrldn(SCRN *t,int top,int bot,int amnt);
X *
X * Buffered scroll request.  Scroll some lines down.  'top' and 'bot'
X * indicate which lines to scroll.  'bot' is the last line to scroll + 1.
X * 'amnt' is distance in lines to scroll.
X */
void nscrldn();
X
/* void nscroll(SCRN *t);
X *
X * Execute buffered scroll requests
X */
void nscroll();
X
/* void magic(SCRN *t,int y,int *cur,int *new);
X *
X * Figure out and execute line shifting
X */
void magic();
X
#endif
SHAR_EOF
chmod 0600 scrn.h ||
echo 'restore of scrn.h failed'
Wc_c="`wc -c < 'scrn.h'`"
test 7538 -eq "$Wc_c" ||
	echo 'scrn.h: original size 7538, current size' "$Wc_c"
fi
# ============= tab.c ==============
if test -f 'tab.c' -a X"$1" != X"-c"; then
	echo 'x - skipping tab.c (File already exists)'
else
echo 'x - extracting tab.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tab.c' &&
/* File selection menu
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "config.h"
#include "heap.h"
#include "scrn.h"
#include "kbd.h"
#include "vs.h"
#include "w.h"
#include "bw.h"
#include "zstr.h"
#include "pathfunc.h"
#include "va.h"
#include "menu.h"
#include "edfuncs.h"
#include "tty.h"
#include "tab.h"
X
CONTEXT cttab={"tab",0};
X
#define F_DIR		1
#define F_NORMAL	2
#define F_EXEC		4
X
char **rexpnd();
X
static int get_entries(tab,prv)
TAB *tab;
{
int a;
int which=0;
char *oldpwd;
char **files=(char **)rexpnd(tab->path,tab->pattern);
if(!files) return -1;
if(!aLEN(files)) return -1;
tab->len=aLEN(files);
vsrm(tab->files); tab->files=files;
vasort(files,tab->len);
if(tab->type) free(tab->type);
tab->type=(char *)malloc(tab->len);
oldpwd=pwd(); chdir(tab->path);
for(a=0;a!=tab->len;a++)
X {
X struct stat buf;
X mset(&buf,0,sizeof(struct stat));
X stat(files[a],&buf);
X if(buf.st_ino==prv) which=a;
X if((buf.st_mode&S_IFMT)==S_IFDIR) tab->type[a]=F_DIR;
X else if(buf.st_mode&(0100|0010|0001)) tab->type[a]=F_EXEC;
X else tab->type[a]=F_NORMAL;
X }
chdir(oldpwd);
return which;
}
X
static void wkilltab(w)
W *w;
{
MENU *m=(MENU *)w->object;
TAB *tab;
if(m) tab=(TAB *)m->object;
else tab=0;
if(tab)
X {
X vsrm(tab->path);
X vsrm(tab->pattern);
X varm(tab->files);
X free(tab->type);
X free(tab);
X }
if(m)
X {
X varm(m->list);
X menurm(m);
X }
}
X
static void followtab(w)
W *w;
{
MENU *m=(MENU *)w->object;
menufllw(m);
}
X
static void disptab(w)
W *w;
{
MENU *m=(MENU *)w->object;
menugen(m);
w->cury=0;
w->curx=(m->cursor-m->top)*(m->width+1);
}
X
static void resizetab(w,wi,he)
W *w;
{
MENU *m=(MENU *)w->object;
menuresz(m,wi,he);
}
X 
static void movetab(w,x,y)
W *w;
{
MENU *m=(MENU *)w->object;
menumove(m,x,y);
}
X 
static void tdumb() {}
X
void tltarw(w)
W *w;
{
MENU *m=(MENU *)w->object;
mltarw(m);
}
X 
void trtarw(w)
W *w;
{
MENU *m=(MENU *)w->object;
mrtarw(m);
}
X 
void tuparw(w)
W *w;
{
MENU *m=(MENU *)w->object;
muparw(m);
}
X 
void tdnarw(w)
W *w;
{
MENU *m=(MENU *)w->object;
mdnarw(m);
}
X 
void tbof(w)
W *w;
{
MENU *m=(MENU *)w->object;
mbof(m);
}
X 
void teof(w)
W *w;
{
MENU *m=(MENU *)w->object;
meof(m);
}
X 
void tbol(w)
W *w;
{
MENU *m=(MENU *)w->object;
mbol(m);
}
X 
void teol(w)
W *w;
{
MENU *m=(MENU *)w->object;
meol(m);
}
X
int treload(w,m,tab,flg)
W *w;
MENU *m;
TAB *tab;
{
BW *bw;
P *p;
int x;
int which;
char **list;
struct stat buf;
if((which=get_entries(tab,tab->prv))<0) return 1;
if(tab->path && tab->path[0]) stat(tab->path,&buf);
else stat(".",&buf);
tab->prv=buf.st_ino;
if(!flg) which=0;
if(m) { vsrm(m->list); menurm(m); }
list=vaensure(NULL,aLEN(tab->files));
for(x=0;tab->files[x];++x)
X {
X vaset(list,x,vsncpy(NULL,0,sv(tab->files[x])));
X if(tab->type[x]==F_DIR) list[x]=vsncpy(list[x],sLEN(list[x]),sc("/"));
X else if(tab->type[x]==F_EXEC) list[x]=vsncpy(list[x],sLEN(list[x]),sc("*"));
X }
w->object=(void *)(m=mkmenu(w->t,list,w->x,w->y,w->w,w->h));
m->object=tab;
m->cursor=which;
bw=(BW *)w->win->object;
p=pdup(bw->cursor); pbol(p);
peol(bw->cursor);
bdel(p,bw->cursor);
if(sLEN(tab->path))
X {
X binsm(bw->cursor,sv(tab->path)), peol(bw->cursor);
X if(tab->path[sLEN(tab->path)-1]!='/')
X  binsm(bw->cursor,sc("/")), peol(bw->cursor);
X }
binsm(bw->cursor,sv(tab->pattern)); peol(bw->cursor);
prm(p);
return 0;
}
X 
void trtn(w)
W *w;
{
MENU *m=(MENU *)w->object;
TAB *tab=(TAB *)m->object;
if(tab->type[m->cursor]==F_DIR)
X { /* Switch directories */
X char *orgpath=tab->path;
X char *orgpattern=tab->pattern;
X char *e=endprt(tab->path);
X if(!zcmp(tab->files[m->cursor],"..") && sLEN(e) &&
X    !(e[0]=='.' && e[1]=='.' && (!e[2] || e[2]=='/')))
X  tab->path=begprt(tab->path);
X else
X  {
X  tab->path=vsncpy(NULL,0,sv(tab->path));
X  tab->path=vsncpy(tab->path,sLEN(tab->path),sv(m->list[m->cursor]));
X  }
X vsrm(e);
X tab->pattern=vsncpy(NULL,0,sc("*"));
X if(treload(w,m,tab,0))
X  {
X  msgnw(w,"Couldn\'t read directory ");
X  vsrm(tab->pattern); tab->pattern=orgpattern;
X  vsrm(tab->path); tab->path=orgpath;
X  }
X else
X  {
X  vsrm(orgpattern);
X  vsrm(orgpath);
X  }
X }
else
X { /* Select name */
X BW *bw=(BW *)w->win->object;
X P *p;
X p=pdup(bw->cursor); pbol(p);
X peol(bw->cursor);
X bdel(p,bw->cursor);
X if(sLEN(tab->path))
X  {
X  binsm(bw->cursor,sv(tab->path)), peol(bw->cursor);
X  if(tab->path[sLEN(tab->path)-1]!='/')
X   binsm(bw->cursor,sc("/")), peol(bw->cursor);
X  }
X binsm(bw->cursor,sv(tab->files[m->cursor])); peol(bw->cursor);
X bw->cursor->xcol=bw->cursor->col;
X prm(p);
X wabort(w);
X }
}
X
void tbacks(w)
W *w;
{
MENU *m=(MENU *)w->object;
TAB *tab=(TAB *)m->object;
char *orgpath=tab->path;
char *orgpattern=tab->pattern;
char *e=endprt(tab->path);
if(sLEN(e)) tab->path=begprt(tab->path);
else
X {
X vsrm(e);
X return;
X }
vsrm(e);
tab->pattern=vsncpy(NULL,0,sc("*"));
if(treload(w,m,tab,1))
X {
X msgnw(w,"Couldn\'t read directory ");
X vsrm(tab->pattern); tab->pattern=orgpattern;
X vsrm(tab->path); tab->path=orgpath;
X }
else
X {
X vsrm(orgpattern);
X vsrm(orgpath);
X }
}
X
void tuabort(w)
W *w;
{
BW *bw=(BW *)w->win->object;
P *p=pdup(bw->cursor); pbol(p);
peol(bw->cursor);
bdel(p,bw->cursor);
prm(p);
wabort(w);
}
X
static WATOM watomtab=
{
&cttab,
disptab,
followtab,
wkilltab,
resizetab,
movetab,
tdumb,
tdumb,
TYPETAB
};
X
/* Create a tab window */
X
void ucmplt(w)
W *w;
{
W *new;
TAB *tab;
P *p, *q;
char *cline, *tmp;
BW *bw;
long a,b;
if(!(new=wcreate(w->t,&watomtab,w,w,w->main,1,NULL))) return;
tab=(TAB *)malloc(sizeof(TAB));
tab->files=0;
tab->type=0;
bw=(BW *)w->object;
p=pdup(bw->cursor); pbol(p);
q=pdup(bw->cursor); peol(q);
tmp=brvs(p,q->byte-p->byte);
cline=parsens(tmp,&a,&b);
vsrm(tmp);
prm(p); prm(q);
tmp=namprt(cline);
tab->pattern=vsncpy(sv(tmp),sc("*"));
tab->path=dirprt(cline);
tab->prv=0;
vsrm(cline);
if(treload(new,NULL,tab,0))
X {
/* msgnw(w,"Couldn\'t read directory "); */
X vsrm(tab->path);
X vsrm(tab->pattern);
X free(tab);
X w->t->curwin=new;
X wabort(new);
X }
else
X {
X w->t->curwin=new;
X if(!sLEN(tab->files)) tuabort(new);
X else if(sLEN(tab->files)==1) trtn(new);
X }
}
SHAR_EOF
chmod 0600 tab.c ||
echo 'restore of tab.c failed'
Wc_c="`wc -c < 'tab.c'`"
test 6687 -eq "$Wc_c" ||
	echo 'tab.c: original size 6687, current size' "$Wc_c"
fi
# ============= tab.h ==============
if test -f 'tab.h' -a X"$1" != X"-c"; then
	echo 'x - skipping tab.h (File already exists)'
else
echo 'x - extracting tab.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tab.h' &&
/* File selection menu
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Itab
#define _Itab 1
X
#include "config.h"
#include "kbd.h"
X
typedef struct tab TAB;
X
struct tab
X {
X char *path;
X char *pattern;
X int len;
X char **files;
X char *type;
X int prv;
X };
X
#define TYPETAB 0x400
X
void ucmplt();
extern CONTEXT cttab;
void tuabort();
void tbacks();
void tbof();
void tbol();
void teol();
void teof();
void tltarw();
void tdnarw();
void trtarw();
void trtn();
void tuparw();
X
#endif
SHAR_EOF
chmod 0600 tab.h ||
echo 'restore of tab.h failed'
Wc_c="`wc -c < 'tab.h'`"
test 1173 -eq "$Wc_c" ||
	echo 'tab.h: original size 1173, current size' "$Wc_c"
fi
# ============= termcap ==============
if test -f 'termcap' -a X"$1" != X"-c"; then
	echo 'x - skipping termcap (File already exists)'
else
echo 'x - extracting termcap (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'termcap' &&
##############################################################################
#
# Joe's termcap file
#
# These expect that you're using some kind of handshaking (no padding info
# is given).  Also JOE doesn't use the last column of the screen, so the
# am/xn parameters can be wrong
#
# JOE understands these extensions to termcap:
#
# AL DL SF SR IC DC UP DO RI LE - parametized versions of normal termcap
#                                 capabilities.  For example, AL inserts n
#                                 lines and LE moves n positions left.
#
# rr                            - Flag which indicates that the cursor
#                                 is restricted to scrolling region (cursor
#                                 addressing is still screen relative, however).
#
# cb                            - Like cv, but goes to beginning of given
#                                 line.
#
##############################################################################
X
# The pre-ansi terminal
X
vt52|dec vt52:\
X	:co#80:li#24:\
X	:ho=\EH:cm=\EY%+ %+ :\
X	:up=\EA:nd=\EC:pt:bs:\
X	:cd=\EJ:ce=\EK:cl=\EH\EJ:\
X	:sr=\EI:\
X	:ku=\EA:kd=\EB:kr=\EC:kl=\ED:
X
##############################################################################
#
# The "ANSI" family of terminals
#
##############################################################################
X
# The capabilities in this entry are understood to be the least-common
# denominator of what's called ANSI (except, of course, for the IBM PC, which
# doesn't know what ESC [ J is).
X
ansi|Basic Ansi tty:\
X	:co#80:li#25:am:\
X	:ho=\E[H:cm=\E[%i%d;%dH:cb=\E[%i%dH:\
X	:up=\E[A:UP=\E[%dA:DO=\E[%dB:nd=\E[C:RI=\E[%dC:pt:bs:LE=\E[%dD:\
X	:cd=\E[J:ce=\E[K:cl=\E[H\E[J:\
X	:so=\E[7m:se=\E[m:ms:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:me=\E[m:\
X	:ku=\E[A:kd=\E[B:kl=\E[D:kr=\E[C:
X
# Use for good implementations of non-DEC ansi.  Most PC UNIX consoles
# look like this
X
fansi|Full Ansi tty (includes inserts and deletes):\
X	:al=\E[L:AL=\E[%dL:dl=\E[M:DL=\E[%dM:\
X	:ic=\E[@:IC=\E[%d@:dc=\E[P:DC=\E[%dP:\
X	:tc=ansi:
X
# Use for vt100-like ansi implementations
X
ansi100:Ansi tty with scrolling regions but no inserts or deletes:\
X	:li#24:\
X	:cs=\E[%i%d;%dr:sr=\EM:\
X	:tc=ansi:
X
# Advanced DEC-style ansi terminals.  Use for vt102s and above
X
decansi:Full DEC-style Ansi tty (scrolling regions/insert mode/deletes):\
X	:li#24:\
X	:cs=\E[%i%d;%dr:sr=\EM:\
X	:al=\E[L:AL=\E[%dL:dl=\E[M:DL=\E[%dM:\
X	:im=\E[4h:ei=\E[4l:mi:dc=\E[P:DC=\E[%dP:\
X	:tc=ansi:
X
##############################################################################
#
# Derived "ANSI" terminals
#
##############################################################################
X
ansisys|IBM PC using ANSI.SYS:\
X        :cd@:ms@:pt@:cl=\E[H\E[2J:do=\E[B:\
X	:ku=^@H:kd=^@P:kl=^@K:kr=^@M:\
X	:kI=^@R:kD=^@S:kh=^@G:kH=^@O:kP=^@I:kN=^@Q:\
X	:k1=^@;:k2=^@<:k3=^@=:k4=^@>:k5=^@?:\
X	:k6=^@@:k7=^@A:k8=^@B:k9=^@C:k0=^@D:\
X        :tc=ansi:
X
nansisys|IBM PC using NANSI.SYS or ZANSI.SYS:\
X        :cd@:ms@:pt@:cl=\E[H\E[2J:do=\E[B:\
X	:ku=^@H:kd=^@P:kl=^@K:kr=^@M:\
X	:kI=^@R:kD=^@S:kh=^@G:kH=^@O:kP=^@I:kN=^@Q:\
X	:k1=^@;:k2=^@<:k3=^@=:k4=^@>:k5=^@?:\
X	:k6=^@@:k7=^@A:k8=^@B:k9=^@C:k0=^@D:\
X        :tc=fansi:
X
xenix:Xenix console:\
X	:bt=\E[Z:\
X	:kI=\E[L:kD=^?:kh=\E[H:kH=\E[F:kP=\E[I:kN=\E[G:\
X	:k1=\E[M:k2=\E[N:k3=\E[O:k4=\E[P:k5=\E[Q:\
X	:k6=\E[R:k7=\E[S:k8=\E[T:k9=\E[U:k0=\E[V:\
X	:tc=fansi:
X
linux:Linux console:\
X	:kI=\E[2~:kD=\E[3~:kh=\E[1~:kH=\E[4~:kP=\E[5~:kN=\E[6~:\
X	:k1=\E[[A:k2=\E[[B:k3=\E[[C:k4=\E[[D:k5=\E[[E:\
X	:k6=\E[17~:k7=\E[18~:k8=\E[19~:k9=\E[20~:k10=\E[21~:\
X	:tc=fansi:
X
pt:Convergent Technologies PT booted from a miniframe:\
X	:li#26:ns:\
X	:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:k5=\EOT:\
X	:k6=\EOU:k7=\EOV:k8=\EOW:k9=\EOX:k0=\EOY:\
X	:tc=fansi:
X
ptem:Convergent Technologies PT using its own firmware:\
X	:li#26:rr:\
X	:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:k5=\EOT:\
X	:k6=\EOU:k7=\EOV:k8=\EOW:k9=\EOX:k0=\EOY:\
X	:tc=decansi:
X
xterm|X windows terminal emulator:\
X	:xn:\
X	:kb=\b:ks=\E=:ke=\E>:\
X	:k1=\E[11~:k2=\E[12~:k3=\E[13~:k4=\E[14~:k5=\E[15~:\
X	:k6=\E[17~:k7=\E[18~:k8=\E[19~:k9=\E[20~:k0=\E[21~:\
X	:kh=\E[8~:\
X	:tc=decansi:
X
vt100|DEC VT100:\
X	:li#24:\
X	:ks=\E\075:ke=\E\076:\
X	:kh=\E[H:\
X	:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:tc=ansi100:
X
vt102|DEC VT102:\
X	:li#24:\
X	:ks=\E\075:ke=\E\076:\
X	:kh=\E[H:\
X	:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:tc=decansi:
X
vt220|DEC VT220:\
X	:ke=\E>:ks=\E=:\
X	:kb=^?:\
X	:kI=\E[2~:kD=\E[3~:kh=\E[1~:kH=\E[4~:kP=\E[5~:kN=\E[6~:\
X	:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:k5=\E[17~:\
X	:k6=\E[18~:k7=\E[19~:k8=\E[20~:k9=\E[21~:k0=\E[29~:\
X	:tc=decansi:
SHAR_EOF
chmod 0600 termcap ||
echo 'restore of termcap failed'
Wc_c="`wc -c < 'termcap'`"
test 4577 -eq "$Wc_c" ||
	echo 'termcap: original size 4577, current size' "$Wc_c"
fi
# ============= termcap.c ==============
if test -f 'termcap.c' -a X"$1" != X"-c"; then
	echo 'x - skipping termcap.c (File already exists)'
else
echo 'x - extracting termcap.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'termcap.c' &&
/* TERMCAP database interface
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "config.h"
#include "blocks.h"
#include "heap.h"
#include "vs.h"
#include "va.h"
#include "zstr.h"
#include "queue.h"
#include "termcap.h"
X
/* Return true if termcap line matches name */
X
static int match(s,name)
char *s, *name;
{
if(s[0]==0 || s[0]=='#') return 0;
do
X {
X int x;
X for(x=0;s[x]==name[x] && name[x] && s[x];++x);
X if(name[x]==0 && (s[x]==':' || s[x]=='|')) return 1;
X while(s[x]!=':' && s[x]!='|' && s[x]) ++x;
X s+=x+1;
X }
X while(s[-1]=='|');
return 0;
}
X
/* Find termcap entry in a file */
X
static char *lfind(s,pos,fd,name)
char *s, *name;
FILE *fd;
int pos;
{
int c,x;
if(!s) s=vsmk(1024);
loop:
while(c=getc(fd), c==' ' || c=='\t' || c=='#')
X do c=getc(fd); while(!(c== -1 || c=='\n'));
if(c== -1) return s=vstrunc(s,pos);
ungetc(c,fd);
s=vstrunc(s,x=pos);
while(1)
X {
X c=getc(fd);
X if(c== -1 || c=='\n')
X  if(x!=pos && s[x-1]=='\\')
X   {
X   --x;
X   if(!match(s+pos,name)) goto loop;
X   else break;
X   }
X  else
X   if(!match(s+pos,name)) goto loop;
X   else return vstrunc(s,x);
X else if(c=='\r') ;
X else s=vsset(s,x,c), ++x;
X }
while(c=getc(fd), c!= -1)
X if(c=='\n')
X  if(s[x-1]=='\\') --x;
X  else break;
X else if(c=='\r') ;
X else s=vsset(s,x,c), ++x;
s=vstrunc(s,x);
return s;
}
X
/* Lookup termcap entry in index */
X
static long findidx(file,name)
FILE *file;
char *name;
{
char buf[80];
long addr=0;
while(fgets(buf,80,file))
X {
X int x=0, flg=0, c, y, z;
X do
X  {
X  int y;
X  for(y=x;buf[y] && buf[y]!=' ' && buf[y]!='\n';++y);
X  c=buf[y]; buf[y]=0;
X  if(c=='\n' || !c)
X   {
X   z=0; sscanf(buf+x,"%x",&z);
X   addr+=z;
X   }
X  else if(!zcmp(buf+x,name)) flg=1;
X  x=y+1;
X  }
X  while(c && c!='\n');
X if(flg) return addr;
X }
return 0;
}
X
/* Load termcap entry */
X
CAP *getcap(name,baud,out,outptr)
char *name;
unsigned baud;
void (*out)();
void *outptr;
{
CAP *cap;
FILE *f, *f1;
long idx;
int x,y,c,z,ti;
char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
int sortsiz;
X
if(!name && !(name=getenv("TERM"))) return 0;
name=vsncpy(NULL,0,sz(name));
X
cap=(CAP *)malloc(sizeof(CAP));
cap->tbuf=vsmk(1024);
cap->sort=(struct sortentry *)malloc(sizeof(struct sortentry)*(sortsiz=64));
cap->sortlen=0;
X
tp=getenv("TERMCAP");
X
if(tp && tp[0]=='/') namebuf=vsncpy(NULL,0,sz(tp));
else
X {
X if(tp) vsncpy(sv(cap->tbuf),sz(tp));
X if((tp=getenv("TERMPATH"))) namebuf=vsncpy(NULL,0,sz(tp));
X else if((tp=getenv("HOME")))
X  namebuf=vsncpy(NULL,0,sz(tp)),
X  namebuf=vsadd(namebuf,'/'),
X  namebuf=vsncpy(sv(namebuf),sz(TERMPATH));
X else namebuf=vsncpy(NULL,0,sz(TERMPATH));
X }
X
npbuf=vawords(NULL,sv(namebuf),sc("\t "));
vsrm(namebuf);
X
y=0; ti=0;
X
if(match(cap->tbuf,name)) goto checktc;
X
dofiles:
cap->tbuf=vstrunc(cap->tbuf,0);
X
nextfile:
if(!npbuf[y])
X {
X varm(npbuf);
X vsrm(name);
X vsrm(cap->tbuf);
X free(cap->sort);
X free(cap);
X return 0;
X }
idx=0;
idxname=vsncpy(NULL,0,sz(npbuf[y]));
idxname=vsncpy(idxname,sLEN(idxname),sc(".idx"));
f1=fopen(npbuf[y],"r");
++y;
if(!f1) goto nextfile;
f=fopen(idxname,"r");
if(f)
X {
X struct stat buf, buf1;
X fstat(fileno(f),&buf);
X fstat(fileno(f1),&buf1);
X if(buf.st_mtime>buf1.st_mtime) idx=findidx(f,name);
X else fprintf(stderr,"%s is out of date\n",idxname);
X fclose(f);
X }
vsrm(idxname);
fseek(f1,idx,0);
cap->tbuf=lfind(cap->tbuf,ti,f1,name);
fclose(f1);
if(sLEN(cap->tbuf)==ti) goto nextfile;
X
checktc:
x=sLEN(cap->tbuf);
do
X {
X cap->tbuf[x]=0;
X while(x && cap->tbuf[--x]!=':');
X }
X while(x && (!cap->tbuf[x+1] || cap->tbuf[x+1]==':'));
X
if(cap->tbuf[x+1]=='t' && cap->tbuf[x+2]=='c' && cap->tbuf[x+3]=='=')
X {
X name=vsncpy(NULL,0,sz(cap->tbuf+x+4));
X cap->tbuf[x]=0;
X cap->tbuf[x+1]=0;
X ti=x+1;
X sLen(cap->tbuf)=x+1;
X if(y) --y;
X goto nextfile;
X }
X
doline:
pp=cap->tbuf+ti;
X
/* Process line at pp */
X
loop:
while(*pp && *pp!=':') ++pp;
if(*pp)
X {
X int q;
X *pp++=0;
X loop1:
X if(pp[0]==' ' || pp[0]=='\t') goto loop;
X for(q=0;pp[q] && pp[q]!='#' && pp[q]!='=' && pp[q]!='@' && pp[q]!=':';++q);
X qq=pp;
X c=pp[q]; pp[q]=0;
X if(c) pp+=q+1;
X else pp+=q;
X
X x=0; y=cap->sortlen; z= -1;
X if(!y) { z=0; goto in; }
X while(z!=(x+y)/2)
X  {
X  z=(x+y)/2;
X  switch(zcmp(qq,cap->sort[z].name))
X   {
X  case  1: x=z; break;
X  case -1: y=z; break;
X  case  0:
X   if(c=='@')
X    mfwrd(cap->sort+z,cap->sort+z+1,
X          (cap->sortlen---(z+1))*sizeof(struct sortentry));
X   else
X    if(c && c!=':') cap->sort[z].value=qq+q+1;
X    else cap->sort[z].value=0;
X   if(c==':') goto loop1;
X   else goto loop;
X   }
X  }
X in:
X if(cap->sortlen==sortsiz)
X  cap->sort=(struct sortentry *)realloc(cap->sort,
X                                        (sortsiz+=32)*sizeof(struct sortentry));
X mbkwd(cap->sort+y+1,cap->sort+y,
X       (cap->sortlen++-y)*sizeof(struct sortentry));
X cap->sort[y].name=qq;
X if(c && c!=':') cap->sort[y].value=qq+q+1;
X else cap->sort[y].value=0;
X if(c==':') goto loop1;
X else goto loop;
X }
X
if(ti)
X {
X for(--ti;ti;--ti) if(!cap->tbuf[ti-1]) break;
X goto doline;
X }
X
varm(npbuf);
vsrm(name);
X
cap->pad=getstr(cap,"pc");
if(getenv("DOPADDING")) cap->dopadding=1;
else cap->dopadding=0;
return setcap(cap,baud,out,outptr);
}
X
struct sortentry *findcap(cap,name)
CAP *cap;
char *name;
{
int x,y,z;
x=0; y=cap->sortlen; z= -1;
while(z!=(x+y)/2)
X {
X z=(x+y)/2;
X switch(zcmp(name,cap->sort[z].name))
X  {
X case  1: x=z; break;
X case -1: y=z; break;
X case  0: return cap->sort+z;
X  }
X }
return 0;
}
X
CAP *setcap(cap,baud,out,outptr)
CAP *cap;
unsigned baud;
void (*out)();
void *outptr;
{
cap->baud=baud;
cap->div=100000/baud;
cap->out=out;
cap->outptr=outptr;
return cap;
}
X
int getflag(cap,name)
CAP *cap;
char *name;
{
return findcap(cap,name)!=0;
}
X
char *getstr(cap,name)
CAP *cap;
char *name;
{
struct sortentry *s=findcap(cap,name);
if(s) return s->value;
else return 0;
}
X
int getnum(cap,name)
CAP *cap;
char *name;
{
struct sortentry *s=findcap(cap,name);
if(s && s->value) return atoi(s->value);
return -1;
}
X
void rmcap(cap)
CAP *cap;
{
vsrm(cap->tbuf);
free(cap->sort);
free(cap);
}
X
static char escape(s)
char **s;
{
char c= *(*s)++;
if(c=='^' && **s)
X if(**s!='?') return 037&*(*s)++;
X else return (*s)++, 127;
else if(c=='\\' && **s)
X switch(c= *((*s)++))
X  {
X case '0': case '1': case '2': case'3': case '4': case '5': case '6': case '7':
X           c-='0';
X           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
X           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
X           return c;
X case 'e':
X case 'E': return 27;
X case 'n':
X case 'l': return 10;
X case 'r': return 13;
X case 't': return 9;
X case 'b': return 8;
X case 'f': return 12;
X case 's': return 32;
X default: return c;
X  }
else return c;
}
X
void texec(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
int c, tenth=0, x;
int args[4];
int vars[128];
int *a=args;
X
/* Copy args into array (yuk) */
args[0]=a0; args[1]=a1; args[2]=a2; args[3]=a3;
X
/* Do nothing if there is no string */
if(!s) return;
X
/* Get tenths of MS of padding needed */
while(*s>='0' && *s<='9') tenth=tenth*10+*s++-'0';
tenth*=10;
if(*s=='.') ++s, tenth+= *s++-'0';
X
/* Check if we have to multiply by number of lines */
if(*s=='*') ++s, tenth*=l;
X
/* Output string */
while(c= *s++)
X if(c=='%' && *s)
X  switch(x=a[0], c= escape(&s))
X   {
X  case 'C': if(x>=96) cap->out(cap->outptr,x/96), x%=96;
X  case '+': if(*s) x+= escape(&s);
X  case '.': cap->out(cap->outptr,x); ++a; break;
X  case 'd': if(x<10) goto one;
X  case '2': if(x<100) goto two;
X  case '3': c='0'; while(x>=100) ++c, x-=100; cap->out(cap->outptr,c);
X       two: c='0'; while(x>=10) ++c, x-=10; cap->out(cap->outptr,c);
X       one: cap->out(cap->outptr,'0'+x); ++a; break;
X  case 'r': a[0]=a[1]; a[1]=x; break;
X  case 'i': ++a[0]; ++a[1]; break;
X  case 'n': a[0]^=0140; a[1]^=0140; break;
X  case 'm': a[0]^=0177; a[1]^=0177; break;
X  case 'f': ++a; break;
X  case 'b': --a; break;
X  case 'a': x=s[2];
X            if(s[1]=='p') x=a[x-0100];
X            switch(*s)
X             {
X             case '+': a[0]+=x; break;
X             case '-': a[0]-=x; break;
X             case '*': a[0]*=x; break;
X             case '/': a[0]/=x; break;
X             case '%': a[0]%=x; break;
X             case 'l': a[0]=vars[x]; break;
X             case 's': vars[x]=a[0]; break;
X             default:  a[0]=x;
X             }
X            s+=3;
X            break;
X  case 'D': a[0]=a[0]-2*(a[0]&15); break;
X  case 'B': a[0]=16*(a[0]/10)+a[0]%10; break;
X  case '>': if(a[0]>escape(&s)) a[0]+=escape(&s); else escape(&s);
X   default: cap->out(cap->outptr,'%'); cap->out(cap->outptr,c);
X   }
X else --s, cap->out(cap->outptr,escape(&s));
X
/* Output padding characters */
if(cap->dopadding)
X if(cap->pad)
X  while(tenth>=cap->div)
X   for(s=cap->pad;*s;++s) cap->out(cap->outptr,*s), tenth-=cap->div;
X else
X  while(tenth>=cap->div) cap->out(cap->outptr,0), tenth-=cap->div;
}
X
static int total;
X
static void cst()
{
++total;
}
X
int tcost(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
void (*out)()=cap->out;
if(!s) return 10000;
total=0;
cap->out=cst;
texec(cap,s,l,a0,a1,a2,a3);
cap->out=out;
return total;
}
X
static char *ssp;
static void cpl(ptr,c)
char *ptr;
char c;
{
vsadd(ssp,c);
}
X
char *tcompile(cap,s,a0,a1,a2,a3)
CAP *cap;
char *s;
int a0,a1,a2,a3;
{
void (*out)()=cap->out;
int div=cap->div;
if(!s) return 0;
cap->out=cpl; cap->div=10000;
ssp=vsmk(10);
texec(cap,s,0,a0,a1,a2,a3);
cap->out=out; cap->div=div;
return ssp;
}
X
/* Old termcap compatibility */
X
short ospeed;		/* Output speed */
char PC, *UP, *BC;		/* Unused */
static CAP *latest;	/* CAP entry to use */
X
static stupid(ptr,c)
void (*ptr)();
char c;
{
ptr(c);
}
X
int tgetent(buf,name)
char *buf, *name;
{
latest=getcap(name,9600,stupid,NULL);
if(latest) return 1;
else return -1;
}
X
int tgetflag(name)
char *name;
{
return getflag(latest,name);
}
X
int tgetnum(name)
char *name;
{
return getnum(latest,name);
}
X
char *tgetstr(name)
char *name;
{
return getstr(latest,name);
}
X
static int latestx, latesty;
X
char *tgoto(str,x,y)
char *str;
int x,y;
{
latestx=x; latesty=y;
return str;
}
X
void tputs(str,l,out)
char *str;
int l;
void (*out)();
{
latest->outptr=(void *)out;
if(latest->baud!=ospeed) latest->baud=ospeed, latest->div=100000/ospeed;
texec(latest,str,l,latesty,latestx);
}
SHAR_EOF
chmod 0600 termcap.c ||
echo 'restore of termcap.c failed'
Wc_c="`wc -c < 'termcap.c'`"
test 10843 -eq "$Wc_c" ||
	echo 'termcap.c: original size 10843, current size' "$Wc_c"
fi
# ============= termcap.h ==============
if test -f 'termcap.h' -a X"$1" != X"-c"; then
	echo 'x - skipping termcap.h (File already exists)'
else
echo 'x - extracting termcap.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'termcap.h' &&
/* TERMCAP/TERMINFO header file
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Itermcap
#define _Itermcap 1
X
#include "config.h"
X
typedef struct cap CAP;
X
#define TERMPATH ".termcap /etc/termcap"
X
struct sortentry
X {
X char *name;
X char *value;
X };
X
struct cap
X {
X char *tbuf;			/* Termcap entry loaded here */
X
X struct sortentry *sort;	/* Pointers to each capability stored in here */
X int sortlen;			/* Number of capabilities */
X
X char *abuf;			/* For terminfo compatible version */
X char *abufp;
X 
X int div;			/* tenths of MS per char */
X int baud;			/* Baud rate */
X char *pad;			/* Padding string or NULL to use NUL */
X void (*out)();			/* Character output routine */
X void *outptr;			/* First arg passed to output routine.  Second
X 				   arg is character to write */
X int dopadding;			/* Set if pad characters should be used */
X };
X
/* CAP *getcap(char *s,int baud,void (*out)(void *outptr,char c),void *outptr);
X *
X * Get CAP entry for terminal named in 's'.  If 's' is zero, the name in
X * the environment variable 'TERM' is used instead.  Space for the returned
X * CAP is allocated from the heap using malloc.
X *
X * 'baud'   is the baud rate used for 'texec' to calculate number of pad chars
X * 'out'    is the function 'texec' uses to output characters
X * 'outptr' is the passed as the first arg to 'out'
X *
X * This is how 'getcap' finds the entry:  First a list of file names is
X * built.  If the environment variable 'TERMCAP' begins with a '/', it
X * is used as the list of file names.  Otherwise, if the environment
X * variable 'TERMPATH' is set, it is used as the list of file names.  If
X * that isn't set, then the string TERMPATH defined above is appended
X * to value of the 'HOME' environment variable, and that is used as the
X * list of names (a '/' is placed between the value of the environment
X * variable and the string).  If HOME isn't set, then TERMPATH alone is
X * used as the list of file names (without prepending a '/').
X *
X * Now the contents of the environment variable 'TERMCAP' (if it's defined and
X * if it doesn't begin with a '/') and the files from the above list are
X * scanned for the terminal name.  The contents of the environment variable
X * are scanned first, then the files are scanned in the order they appear in
X * the named list.
X *
X * If the last part of a matching termcap entry is a 'tc=filename', then
X * the current file is rewound and rescanned for the matching entry (and if
X * it's not found, the next entry in the file name list is searched).  If
X * a matching termcap entry in the TERMCAP environment variable ends with
X * a 'tc=filename', then all of the files in the name list are searched.
X *
X * There is no limit on the size of the termcap entries.  No checking is
X * done for self-refering 'tc=filename' links (so all of core will be
X * allocated if there are any).
X */
CAP *getcap();
X
/* CAP *setcap(CAP *cap,int baud,void (*out)(void *outptr,char c),void *outptr);
X *
X * Reset baud, out and outptr for a CAP
X */ 
CAP *setcap();
X
/* char *getstr(CAP *cap,char *name);
X *
X * Get value of string capability or return NULL if it's not found.  A fast
X * binary search is used to find the capability.  The char * returned points into
X * the buffer used to load the termcap entry.  It should not be modified or
X * freed.
X */
char *getstr();
X
/* int getflag(CAP *cap,char *name);
X *
X * Return true if the named capability is found in 'cap'.  A fast binary
X * search is used to lookup the capability.
X */
int getflag();
X
/* int getnum(CAP *cap,char *name);
X *
X * Return value of numeric capability or return -1 if it's not found.  A fast
X * binary search is used to lookup the capability.
X */
int getnum();
X
/* void rmcap(CAP *cap);
X *
X * Eliminate a CAP entry.
X */
void rmcap();
X
/* void texec(CAP *cap,char *str,int l,int a0,int a1,int a2,int a3);
X
X   Execute and output a termcap string capability.
X
X   'cap' is the CAP returned by getcap which contains the baud rate and output
X   function.
X   
X   'str' is the string to execute.  If 'str'==NULL, nothing happens.
X   
X   'l' is the number of lines effected by this string.  For example, if you
X   use the clear to end of screen capability, the number of lines between
X   the current cursor position and the end of the screen should be
X   given here.
X
X   'a0' - 'a1' are the arguments for the string
*/
void texec();
X
/* int tcost(CAP *cap,char *str, int l, int a0, int a1, int a2, int a3);
X   Return cost in number of characters which need to be sent
X   to execute a termcap string capability.
X
X   'cap' is the CAP returned by getcap which contains the baud rate and output
X   functions.
X   
X   'str' is the string to execute.  If 'str'==NULL, tcost return 10000.
X   
X   'l' is the number of lines effected by this string.  Ex: if you
X   use the clear to end of screen capability, the number of lines between
X   the current cursor position and the end of the screen should be
X   given here.
X
X   'a0' - 'a3' are arguements passed to the string
*/
int tcost();
X
/* char *tcompile(CAP *cap,char *str,int a0,int a1,int a2,int a3);
X
X   Compile a string capability.  Returns a pointer to a variable length
X   string (see vstr.h) containing the compiled string capability.
X   Pad characters are not placed in the string.
*/
char *tcompile();
X
/* Old termcap support */
int tgetent();
char *tgetstr();
int tgetflag();
int tgetnum();
char *tgoto();
void tputs();
extern short ospeed;
extern char PC, *UP, *BC;
X
#endif
SHAR_EOF
chmod 0600 termcap.h ||
echo 'restore of termcap.h failed'
Wc_c="`wc -c < 'termcap.h'`"
test 6116 -eq "$Wc_c" ||
	echo 'termcap.h: original size 6116, current size' "$Wc_c"
fi
# ============= termidx.c ==============
if test -f 'termidx.c' -a X"$1" != X"-c"; then
	echo 'x - skipping termidx.c (File already exists)'
else
echo 'x - extracting termidx.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'termidx.c' &&
/* Program to generate termcap index file
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
X
gen(s,fd)
char *s;
FILE *fd;
{
int c,x;
long addr=0, oaddr;
loop:
while(c=getc(fd), c==' ' || c=='\t' || c=='#')
X do c=getc(fd); while(!(c== -1 || c=='\n'));
if(c== -1) return;
if(c=='\n') goto loop;
oaddr=addr;
addr=ftell(fd)-1;
ungetc(c,fd);
s[x=0]=0;
while(1)
X {
X c=getc(fd);
X if(c== -1 || c=='\n')
X  {
X  if(x!=0 && s[x-1]=='\\') --x;
X  if(x)
X   {
X   int y,z,flg;
X   s[x]=0; z=0; flg=0;
X   do
X    {
X    for(y=z;s[y] && s[y]!='|' && s[y]!=':';++y);
X    c=s[y]; s[y]=0;
X    if(strlen(s+z)>2 && !strchr(s+z,' ') &&
X       !strchr(s+z,'\t')) (flg && putchar(' ')), fputs(s+z,stdout), flg=1;
X    s[y]=c;
X    z=y+1;
X    }
X    while(c && c!=':');
X   if(flg) printf(" %x\n",addr-oaddr);
X   }
X  goto loop;
X  }
X else if(c=='\r') ;
X else s[x++]=c;
X }
}
X
main()
{
char array[65536];
gen(array,stdin);
}
SHAR_EOF
chmod 0600 termidx.c ||
echo 'restore of termidx.c failed'
Wc_c="`wc -c < 'termidx.c'`"
test 1592 -eq "$Wc_c" ||
	echo 'termidx.c: original size 1592, current size' "$Wc_c"
fi
# ============= terminfo.c ==============
if test -f 'terminfo.c' -a X"$1" != X"-c"; then
	echo 'x - skipping terminfo.c (File already exists)'
else
echo 'x - extracting terminfo.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'terminfo.c' &&
/* TERMINFO database interface
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "termcap.h"
#include "vs.h"
X
/* Get terminfo entry */
X
CAP *getcap(name,baud,out,outptr)
char *name;
int baud;
void (*out)();
void *outptr;
{
CAP *cap;
if(NULL==name && NULL==(name=getenv("TERM"))) return NULL;
cap=(CAP *)malloc(sizeof(CAP));
cap->out=out;
cap->outptr=outptr;
cap->tbuf=(char *)malloc(4096);
cap->abuf=(char *)malloc(4096);
cap->abufp=cap->abuf;
cap->baud=baud;
cap->div=100000/baud;
ospeed=baud;
if(tgetent(cap->tbuf,name)!=1)
X {
X free(cap->tbuf);
X free(cap->abuf);
X return NULL;
X }
cap->pad=getstr(cap,"pc");
if(NULL!=cap->pad) PC=cap->pad[0];
else PC=0;
BC=0; UP=0;
return cap;
}
X
/* Get string capability */
/* Warning, repeated calls to this will eventually use up all of cap->abuf */
X
char *getstr(cap,name)
CAP *cap;
char *name;
{
return tgetstr(name,&cap->abufp);
}
X
/* Get flag capability */
X
int getflag(cap,name)
CAP *cap;
char *name;
{
return tgetflag(name);
}
X
/* Get numeric capability */
X
int getnum(cap,name)
CAP *cap;
char *name;
{
return tgetnum(name);
}
X
/* Eliminate a CAP */
X
void rmcap(cap)
CAP *cap;
{
free(cap->tbuf);
free(cap->abuf);
free(cap); 
}
X
/* Execute a string capability */
X
static CAP *outcap;
X
static int outout(c)
{
outcap->out(outcap->outptr,c);
}
X
void texec(cap,str,l,a0,a1,a2,a3)
CAP *cap;
char *str;
int l,a0,a1,a2,a3;
{
char *a;
outcap=cap;
a=tgoto(str,a1,a0);
tputs(a,l,outout);
}
X
static int total;
X
static void cst()
{
++total;
}
X
int tcost(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
void (*out)()=cap->out;
if(NULL==s) return 10000;
total=0;
cap->out=cst;
texec(cap,s,l,a0,a1,a2,a3);
cap->out=out;
return total;
}
X
static char *ssp;
static void cpl(ptr,c)
char *ptr;
char c;
{
vsadd(ssp,c);
}
X
char *tcompile(cap,s,a0,a1,a2,a3)
CAP *cap;
char *s;
int a0,a1,a2,a3;
{
void (*out)()=cap->out;
int div=cap->div;
if(NULL==s) return NULL;
cap->out=cpl; cap->div=10000;
ssp=vsmk(10);
texec(cap,s,0,a0,a1,a2,a3);
cap->out=out; cap->div=div;
return ssp;
}
SHAR_EOF
chmod 0600 terminfo.c ||
echo 'restore of terminfo.c failed'
Wc_c="`wc -c < 'terminfo.c'`"
test 2705 -eq "$Wc_c" ||
	echo 'terminfo.c: original size 2705, current size' "$Wc_c"
fi
# ============= todojoe ==============
if test -f 'todojoe' -a X"$1" != X"-c"; then
	echo 'x - skipping todojoe (File already exists)'
else
echo 'x - extracting todojoe (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'todojoe' &&
=-=-=
shell window
background loading
X
=-=-=
make identifier length significant in first 8 (6?) places for old C compilers
X
=-=-=
block restricted searches
X
=-=-=
key bindings which depend on file type
X
=-=-=
hexadecimal edit mode
fixed record length edit mode
X
=-=-=
key layout:
X  delete to beginning of line	?
X  search backwards		?
X  yank/unyank			?/?
X
=-=-=
message file for easily changing languages
X
=-=-=
should use temporary edit buffers instead of memory blocks for
undo, cut, s&r.  Will be faster and eliminate malloc
problem on small machines (with undo: use a single buffer?)
X
maybe there should be a cut block to buffer function which does no
copying except at the ends...
X
at least undo records should be eliminated when a large block is requested
X
=-=-=
ttybad?
X
X
msdos-
X
X how to get it to recognize CR-LF? - use translating fopen?
X
X msdos doesn't have 'sys/dir.h' does it?  yuck...
X
X how to give memory back during shell escapes?
X
=-=-=
verticle windows  		- difficult to get scrolling to work right
X
=-=-=
xedit and folding stuff		- regex too slow?
X
=-=-=
multiple line prompts/menu windows
X
=-=-=
block coalescing in b.c.
X
=-=-=
store number of lines in block headers, maybe could then use faster search
algorithm
X
=-=-=
insert and delete should determine number of columns so that fixup doesn't
have to call pfcol so much.
SHAR_EOF
chmod 0600 todojoe ||
echo 'restore of todojoe failed'
Wc_c="`wc -c < 'todojoe'`"
test 1341 -eq "$Wc_c" ||
	echo 'todojoe: original size 1341, current size' "$Wc_c"
fi
# ============= toomany.c ==============
if test -f 'toomany.c' -a X"$1" != X"-c"; then
	echo 'x - skipping toomany.c (File already exists)'
else
echo 'x - extracting toomany.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'toomany.c' &&
/* Oh no! Too many files!
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "config.h"
#include "vs.h"
#include "heap.h"
#include "toomany.h"
X
static int nopen=0;
static File openfiles={{&openfiles,&openfiles}};
X
static void toomany()
{
File *f;
for(f=openfiles.link.prev;f!=&openfiles;f=f->link.prev)
X if(f->fd!= -1)
X  {
X  close(f->fd);
X  f->fd= -1;
X  --nopen;
X  return;
X  }
}
X
static void reopen(file)
File *file;
{
if(nopen==Fmaxopen) toomany();
if(file->writeable) file->fd=open(file->name,O_RDWR /* | O_BINARY */);
else file->fd=open(file->name,O_RDONLY /* |O_BINARY */);
if(file->fd== -1)
X {
X /* Uh... */
X }
++nopen;
lseek(file->fd,file->pos,0);
}
X
File *Fopen(name)
char *name;
{
File *file;
int fd;
int writeable;
struct stat buf;
if(nopen==Fmaxopen) toomany();
fd=open(name,O_RDWR /*|O_BINARY*/);
if(fd== -1) fd=open(name,O_RDONLY/*|O_BINARY*/), writeable=0;
else writeable=1;
if(fd== -1) return NULL;
++nopen;
fstat(fd,&buf);
file=(File *)malloc(sizeof(File));
file->fd= fd;
file->writeable= writeable;
file->name=vsncpy(NULL,0,sz(name));
file->size=buf.st_size;
file->pos=0;
file->inode=buf.st_ino;
file->dev=buf.st_dev;
enquef(File,link,&openfiles,file);
return file;
}
X
void Fclose(file)
File *file;
{
if(file->fd!= -1) close(file->fd), --nopen;
deque(File,link,file);
free(file);
}
X
int Fread(file,buf,size)
File *file;
char *buf;
{
int amnt;
promote(File,link,&openfiles,file);
if(file->fd== -1) reopen(file);
amnt=read(file->fd,buf,size);
if(amnt>0) file->pos+=amnt;
return amnt;
}
X
int Fwrite(file,buf,size)
File *file;
char *buf;
{
int amnt;
if(!file->writeable) return -1;
promote(File,link,&openfiles,file);
if(file->fd== -1) reopen(file);
amnt=write(file->fd,buf,size);
if(amnt>0)
X {
X file->pos+=amnt;
X if(file->pos>file->size) file->size=file->pos;
X }
return amnt;
}
X
int Fseek(file,pos)
File *file;
long pos;
{
promote(File,link,&openfiles,file);
if(file->fd== -1) reopen(file);
file->pos=lseek(file->fd,pos,0);
if(file->pos<0) return -1;
return 0;
}
SHAR_EOF
chmod 0600 toomany.c ||
echo 'restore of toomany.c failed'
Wc_c="`wc -c < 'toomany.c'`"
test 2733 -eq "$Wc_c" ||
	echo 'toomany.c: original size 2733, current size' "$Wc_c"
fi
# ============= toomany.h ==============
if test -f 'toomany.h' -a X"$1" != X"-c"; then
	echo 'x - skipping toomany.h (File already exists)'
else
echo 'x - extracting toomany.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'toomany.h' &&
/* Too many files!
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Itoomany
#define _Itoomany 1
X
#include "config.h"
#include "queue.h"
X
typedef struct File File;
X
#define Fmaxopen 16
X
struct File
X {
X LINK(File) link;		/* Linked list of open files */
X int fd;			/* The file or -1 if closed */
X char *name;			/* Name of the file */
X int writeable;			/* Set if it's ok to write to the file */
X long size;			/* Current size of file */
X long pos;			/* Current file pointer */
X int inode;			/* Inode of file */
X int dev;			/* Device file is on */
X };
X
File *Fopen();
int Fread();
int Fwrite();
int Fseek();
void Fclose();
X
#endif
SHAR_EOF
chmod 0600 toomany.h ||
echo 'restore of toomany.h failed'
Wc_c="`wc -c < 'toomany.h'`"
test 1322 -eq "$Wc_c" ||
	echo 'toomany.h: original size 1322, current size' "$Wc_c"
fi
# ============= tty.h ==============
if test -f 'tty.h' -a X"$1" != X"-c"; then
	echo 'x - skipping tty.h (File already exists)'
else
echo 'x - extracting tty.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tty.h' &&
/* TTY interface header file
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Itty
#define _Itty 1
X
#include "config.h"
X
/* void ttopen(void);  Open the tty (attached to stdin) for use inside of JOE
X *
X * (0) Call sigjoe()
X *     There is also 'void ttopnn(void)' which does not do this step.
X *
X * (1) fflush(stdout)
X *
X * (2) Save the current state of the tty
X *
X * (3) Disable CR/LF/NL input translations,
X *     Disable all output processing,
X *     Disable echo and line editing, and
X *     Place tty in character at a time mode.
X *     (basically, disable all processing except for XON/XOFF if it's set)
X *
X * (4) Set this new tty state without loosing any typeahead
X *
X * (5) Store the baud rate in the global variable 'baud'
X *
X * (6) Divide the baud rate into the constant DIVIDEND and store the result
X *     in the global variable 'upc'.  This should come out to the number
X *     of microseconds needed to send each character.  The constant 'DIVIDEND'
X *     should be chosen so that 'upc' reflects the real throughput of the
X *     tty, not the theoretical best throughput.
X *
X * (7) Create an output buffer of a size which depends on 'upc' and the
X *     constant 'TIMES'.  'TIMES' is the number of times per second JOE
X *     should check for typeahead.  Since we only check for typehead after
X *     the output buffer is flushed, 'upc' and the size of the output buffer
X *     determine how often this occurs.  So for example if 'upc'==1000 (~9600
X *     baud) and 'TIMES'==3, the output buffer size is set to 333 characters.
X *     Each time this buffer is completely flushed, 1/3 of a second will go by.
X */
void ttopen();
void ttopnn();
extern unsigned long upc;
extern unsigned baud;
X
#define TIMES 3
#define DIVIDEND 10000000
X
/* void ttclose(void);  Restore the tty back to its original mode.
X *
X * (1) ttyflsh()
X *
X * (2) Restore the original tty mode which aopen() had saved.  Do this without
X *     loosing any typeahead.
X *
X * (3) Call signrm().  There is also 'void ttyclsn(void)' which does not do
X *     the this step.
X */
void ttclose();
void ttclsn();
X
/* int ttgetc(void);  Flush the output and get the next character from the tty
X *
X * (1) ttflsh()
X *
X * (2) Read the next input character
X *     If the input closed, call 'ttsig' with 0 as its argument.
X *
X * (3) Clear 'have'
X */
int ttgetc();
X
/* void ttputc(char c);  Write a character to the output buffer.  If it becomes
X * full, call ttflsh()
X */
extern int obufp;
extern int obufsiz;
extern char *obuf;
#define ttputc(c) (obuf[obufp++]=(c), obufp==obufsiz && ttflsh())
X
/* void ttputs(char *s);  Write a string to the output buffer.  Any time the
X * output buffer gets full, call ttflsh()
X */
void ttputs();
X
/* void ttshell(char *s);  Run a shell command or if 's' is zero, run a
X * sub-shell
X */
void ttshell();
X
/* void ttsusp(void);  Suspend the process, or if the UNIX can't do it, call
X * ttshell(NULL)
X */
void ttsusp();
X
/* int ttflsh(void);  Flush the output buffer and check for typeahead.
X *
X * (1) write() any character in the output buffer to the tty.  Sleep for the
X *     amount of time it should take for all of these characters to get
X *     to the tty.  This is so that any buffering between the editor and the
X *     tty is defeated.  If this is not done, the screen update will not be
X *     able to defer for typeahead.
X *
X *     The best way to do this (and it's currently only possible in BSD) is to
X *     set a timer for the necessary amount, write the characters to the tty,
X *     and then sleep until the timer expires.
X *
X *     If this can't be done, it's usually ok to 'write' and then to sleep for
X *     the necessary amount of time.  However, you will notice delays in the
X *     screen update if the 'write' actually takes any significant amount of
X *     time to execute (it usually takes none since all it usually does is
X *     write to an operating system buffer).
X *
X * (2) If the global variable 'leave' is not set and if the global variable
X *     'have' is not set, check for typeahead.  If there is any, set the global
X *     variable 'have'.  This absolutely must not read any characters from the
X *     'tty' if 'leave' is set or typeahead will be lost when the editor exits
X *     or does a shell escape.
X */
int ttflsh();
X
extern int have;
extern int leave;
X
/* void ttsig(int n);  Signal handler you provide.  This is called if the
X * editor gets a hangup signal, termination signal or if the input closes.
X * It is called with 'n' set to the number of the caught signal or 0 if the
X * input closed.
X */
void ttsig();
X
/* void ttgtsz(int *x,int *y);  Get size of screen from ttsize/winsize
X * structure */
void ttgtsz();
X
/* You don't have to call these: ttopen/ttclose do it for you.  These
X * may be needed to make your own shell escape sequences.
X */
X
/* void sigjoe(void);  Set the signal handling for joe.  I.E., ignore all
X * signals the user can generate from the keyboard (SIGINT, SIGQUIT, SIGPIPE)
X * and trap the software terminate and hangup signals (SIGTERM, SIGHUP) so
X * that 'ttsig' gets called.
X */
void sigjoe();
X
/* void signrm(void);  Set above signals back to their default values.
X */
void signrm();
X
/* char *pwd();  Get current working directory into a static buffer.
X */
char *pwd();
X
#endif
SHAR_EOF
chmod 0600 tty.h ||
echo 'restore of tty.h failed'
Wc_c="`wc -c < 'tty.h'`"
test 5951 -eq "$Wc_c" ||
	echo 'tty.h: original size 5951, current size' "$Wc_c"
fi
# ============= ttybsd.c ==============
if test -f 'ttybsd.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttybsd.c (File already exists)'
else
echo 'x - extracting ttybsd.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttybsd.c' &&
/* TTY interface for BSD UNIX
X   Copyright (C) 1991 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License
along with JOE; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#include <sgtty.h>
#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include "config.h"
#include "heap.h"
#include "tty.h"
X
#ifndef HZ
#define HZ 10			/* Clock ticks/second */
#endif
X
/* The terminal */
X
FILE *term=0;
X
/* The original tty state */
X
static struct sgttyb oarg;
static struct tchars otarg;
static struct ltchars oltarg;
X
/* The output buffer, index and size. */
X
char *obuf=0;
int obufp=0;
int obufsiz;
X
/* The baud rate */
X
unsigned baud;
unsigned long upc;
X
/* Code to baud-rate conversion table */
X
static int speeds[]=
{
B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,B1200,1200,
B1800,1800,B2400,2400,B4800,4800,B9600,9600,EXTA,19200,EXTB,38400
};
X
/* Input buffer, typeahead indication flag and editor is about to exit flag */
X
int have=0;
static char havec;
int leave=0;
X
/* TTY mode flag.  1 for open, 0 for closed */
X
static int ttymode=0;
X
void sigjoe()
{
signal(SIGHUP,ttsig);
signal(SIGTERM,ttsig);
signal(SIGINT,SIG_IGN);
signal(SIGPIPE,SIG_IGN);
signal(SIGQUIT,SIG_IGN);
}
X
void signrm()
{
signal(SIGHUP,SIG_DFL);
signal(SIGTERM,SIG_DFL);
signal(SIGINT,SIG_DFL);
signal(SIGPIPE,SIG_DFL);
signal(SIGQUIT,SIG_DFL);
}
X
void ttopen()
{
sigjoe();
ttopnn();
}
X
void ttopnn()
{
int x;
struct sgttyb arg;
struct tchars targ;
struct ltchars ltarg;
if(!term && !(term=fopen("/dev/tty","r+")))
X {
X fprintf(stderr,"Couldn\'t open tty\n");
X exit(1);
X }
if(ttymode) return;
ttymode=1;
fflush(term);
ioctl(fileno(term),TIOCGETP,&arg);
ioctl(fileno(term),TIOCGETC,&targ);
ioctl(fileno(term),TIOCGLTC,&ltarg);
oarg=arg; otarg=targ; oltarg=ltarg;
arg.sg_flags=( (arg.sg_flags&~(ECHO|CRMOD) ) | CBREAK) ;
targ.t_intrc= -1;
targ.t_quitc= -1;
targ.t_eofc= -1;
targ.t_brkc= -1;
ltarg.t_suspc= -1;
ltarg.t_dsuspc= -1;
ltarg.t_rprntc= -1;
ltarg.t_flushc= -1;
ltarg.t_werasc= -1;
ltarg.t_lnextc= -1;
ioctl(fileno(term),TIOCSETN,&arg);
ioctl(fileno(term),TIOCSETC,&targ);
ioctl(fileno(term),TIOCSLTC,&ltarg);
baud=9600;
upc=0;
for(x=0;x!=30;x+=2)
X if(arg.sg_ospeed==speeds[x])
X  {
X  baud=speeds[x+1];
X  break;
X  }
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
if(obuf) free(obuf);
if(!(TIMES*upc)) obufsiz=4096;
else
X {
X obufsiz=1000000/(TIMES*upc);
X if(obufsiz>4096) obufsiz=4096;
X }
if(!obufsiz) obufsiz=1;
obuf=(char *)malloc(obufsiz);
}
X
void ttclose()
{
ttclsn();
signrm();
}
X
void ttclsn()
{
int oleave=leave;
if(ttymode) ttymode=0;
else return;
leave=1;
ttflsh();
ioctl(fileno(term),TIOCSETN,&oarg);
ioctl(fileno(term),TIOCSETC,&otarg);
ioctl(fileno(term),TIOCSLTC,&oltarg);
leave=oleave;
}
X
static int yep;
static dosig() { yep=1; } 
X
int ttflsh()
{
if(obufp)
X {
X struct itimerval a,b;
X unsigned long usec=obufp*upc;
X if(usec>=500000/HZ && baud<38400)
X  {
X  a.it_value.tv_sec=usec/1000000;
X  a.it_value.tv_usec=usec%1000000;
X  a.it_interval.tv_usec=0;
X  a.it_interval.tv_sec=0;
X  signal(SIGALRM,dosig);
X  yep=0;
X  sigsetmask(sigmask(SIGALRM));
X  setitimer(ITIMER_REAL,&a,&b);
X  write(fileno(term),obuf,obufp);
X  while(!yep) sigpause(0);
X  signal(SIGALRM,SIG_DFL);
X  }
X else write(fileno(term),obuf,obufp);
X obufp=0;
X }
if(!have && !leave)
X {
X fcntl(fileno(term),F_SETFL,FNDELAY);
X if(read(fileno(term),&havec,1)==1) have=1;
X fcntl(fileno(term),F_SETFL,0);
X }
return 0;
}
X
int ttgetc()
{
ttflsh();
if(have) have=0;
else if(read(fileno(term),&havec,1)<1) ttsig(0);
return havec;
}
X
void ttputs(s)
char *s;
{
while(*s)
X {
X obuf[obufp++]= *(s++);
X if(obufp==obufsiz) ttflsh();
X }
}
X
void ttgtsz(x,y)
int *x, *y;
{
#ifdef TIOCGSIZE
struct ttysize getit;
#else
#ifdef TIOCGWINSZ
struct winsize getit;
#endif
#endif
*x=0; *y=0;
#ifdef TIOCGSIZE
if(ioctl(fileno(term),TIOCGSIZE,&getit)!= -1)
X {
X *x=getit.ts_cols;
X *y=getit.ts_lines;
X }
#else
#ifdef TIOCGWINSZ
if(ioctl(fileno(term),TIOCGWINSZ,&getit)!= -1)
X {
X *x=getit.ws_col;
X *y=getit.ws_row;
X }
#endif
#endif
}
X
void ttshell(cmd)
char *cmd;
{
int x,omode=ttymode;
char *s=getenv("SHELL");
if(!s) return;
ttclsn();
if(x=fork())
X {
X if(x!= -1) wait(0);
X if(omode) ttopnn();
X }
else
X {
X signrm();
X if(cmd) execl(s,s,"-c",cmd,NULL);
X else
X  {
X  fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
X  execl(s,s,NULL);
X  }
X _exit(0);
X }
}
X
static int gotsig;
X
static void dosi()
{
gotsig=1;
}
X
void ttsusp()
{
#ifdef SIGCONT
int omode=ttymode;
ttclsn();
gotsig=0;
fprintf(stderr,"You have suspended the program.  Type \'fg\' to return\n");
signal(SIGCONT,dosi);
sigsetmask(sigmask(SIGCONT));
kill(0,SIGTSTP);
while(!gotsig) sigpause(0);
signal(SIGCONT,SIG_DFL);
if(omode) ttopnn();
#else
ttshell(NULL);
#endif
}
X
char *getwd();
char *pwd()
{
static buf[1024];
return getwd(buf);
}
SHAR_EOF
chmod 0600 ttybsd.c ||
echo 'restore of ttybsd.c failed'
Wc_c="`wc -c < 'ttybsd.c'`"
test 5407 -eq "$Wc_c" ||
	echo 'ttybsd.c: original size 5407, current size' "$Wc_c"
fi
# ============= ttyhpux.c ==============
if test -f 'ttyhpux.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttyhpux.c (File already exists)'
else
echo 'x - extracting ttyhpux.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttyhpux.c' &&
/* TTY interface for HPUX (AT&T SV + BSD EXTENSIONS)
X   Copyright (C) 1991 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version. 
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  
X
You should have received a copy of the GNU General Public License
along with JOE; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <sys/param.h>
#include <termio.h>
#include "config.h"
#include "heap.h"
#include "tty.h"
X
#ifndef HZ
#define HZ 10
#endif
X
FILE *term=0;
X
static struct termio oldterm;
X
char *obuf=0;
int obufp=0;
int obufsiz;
X
unsigned long upc;
unsigned baud;
X
int have=0;
static char havec;
int leave=0;
static int ttymode=0;
X
static int speeds[]=
{
B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,B1200,1200,
B1800,1800,B2400,2400,B4800,4800,B9600,9600,EXTA,19200,EXTB,38400
};
X
void sigjoe()
{
signal(SIGHUP,ttsig);
signal(SIGTERM,ttsig);
signal(SIGINT,SIG_IGN);
signal(SIGPIPE,SIG_IGN);
signal(SIGQUIT,SIG_IGN);
}
X
void signrm()
{
signal(SIGHUP,SIG_DFL);
signal(SIGTERM,SIG_DFL);
signal(SIGINT,SIG_DFL);
signal(SIGPIPE,SIG_DFL);
signal(SIGQUIT,SIG_DFL);
}
X
void ttopen()
{
sigjoe();
ttopnn();
}
X
void ttopnn()
{
int x;
struct termio newterm;
if(!term && !(term=fopen("/dev/tty","r+")))
X {
X fprintf(stderr,"Couldn\'t open tty\n");
X exit(1);
X }
if(ttymode) return;
else ttymode=1;
fflush(term);
ioctl(fileno(term),TCGETA,&oldterm);
newterm=oldterm;
newterm.c_lflag=0;
newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
newterm.c_oflag=0;
newterm.c_cc[VMIN]=1;
newterm.c_cc[VTIME]=0;
ioctl(fileno(term),TCSETAW,&newterm);
upc=0;
baud=9600;
for(x=0;x!=30;x+=2)
X if((newterm.c_cflag&CBAUD)==speeds[x])
X  {
X  baud=speeds[x+1];
X  break;
X  }
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
if(obuf) free(obuf);
if(!(TIMES*upc)) obufsiz=4096;
else
X {
X obufsiz=1000000/(TIMES*upc);
X if(obufsiz>4096) obufsiz=4096;
X }
if(!obufsiz) obufsiz=1;
obuf=(char *)malloc(obufsiz);
}
X
void ttclose()
{
ttclsn();
signrm();
}
X
void ttclsn()
{
int oleave=leave;
if(ttymode) ttymode=0;
else return;
leave=1;
ttflsh();
ioctl(fileno(term),TCSETAW,&oldterm);
leave=oleave;
}
X
static int yep;
X
static void dosig() { yep=1; } 
X
int ttflsh()
{
if(obufp)
X {
X struct itimerval a,b;
X unsigned long usec=obufp*upc;
X if(usec>=500000/HZ && baud<38400)
X  {
X  a.it_value.tv_sec=usec/1000000;
X  a.it_value.tv_usec=usec%1000000;
X  a.it_interval.tv_usec=0;
X  a.it_interval.tv_sec=0;
X  signal(SIGALRM,dosig);
X  yep=0;
X  sigsetmask(sigmask(SIGALRM));
X  setitimer(ITIMER_REAL,&a,&b);
X  write(fileno(term),obuf,obufp);
X  while(!yep) sigpause(0);
X  signal(SIGALRM,SIG_DFL);
X  }
X else write(fileno(term),obuf,obufp);
X obufp=0;
X }
if(!have && !leave)
X {
X fcntl(fileno(term),F_SETFL,O_NDELAY);
X if(read(fileno(term),&havec,1)==1) have=1;
X fcntl(fileno(term),F_SETFL,0);
X }
return 0;
}
X
int ttgetc()
{
ttflsh();
if(have) have=0;
else if(read(fileno(term),&havec,1)<1) ttsig(0);
return havec;
}
X
void ttputs(s)
char *s;
{
while(*s)
X {
X obuf[obufp++]= *(s++);
X if(obufp==obufsiz) ttflsh();
X }
}
X
void ttgtsz(x,y)
int *x, *y;
{
#ifdef TIOCGSIZE
struct ttysize getit;
#else
#ifdef TIOCGWINSZ
struct winsize getit;
#endif
#endif
*x=0; *y=0;
#ifdef TIOCGSIZE
if(ioctl(fileno(term),TIOCGSIZE,&getit)!= -1)
X {
X *x=getit.ts_cols;
X *y=getit.ts_lines;
X }
#else
#ifdef TIOCGWINSZ
if(ioctl(fileno(term),TIOCGWINSZ,&getit)!= -1)
X {
X *x=getit.ws_col;
X *y=getit.ws_row;
X }
#endif
#endif
}
X
void ttshell(cmd)
char *cmd;
{
int x,omode=ttymode;
char *s=getenv("SHELL");
if(!s) return;
ttclsn();
if(x=fork())
X {
X if(x!= -1) wait(0);
X if(omode) ttopnn();
X }
else
X {
X signrm();
X if(cmd) execl(s,s,"-c",cmd,NULL);
X else
X  {
X  fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
X  execl(s,s,NULL);
X  }
X _exit(0);
X }
}
X
static int gotsig;
X
static void dosi()
{
gotsig=1;
}
X
void ttsusp()
{
#ifdef SIGCONT
int omode=ttymode;
ttclsn();
gotsig=0;
fprintf(stderr,"You have suspended the program.  Type \'fg\' to return\n");
signal(SIGCONT,dosi);
sigsetmask(sigmask(SIGCONT));
kill(0,SIGTSTP);
while(!gotsig) sigpause(0);
signal(SIGCONT,SIG_DFL);
if(omode) ttopnn();
#else
ttshell(NULL);
#endif
}
X
char *getcwd();
char *pwd()
{
static char buf[1024];
return getcwd(buf,1024);
}
SHAR_EOF
chmod 0600 ttyhpux.c ||
echo 'restore of ttyhpux.c failed'
Wc_c="`wc -c < 'ttyhpux.c'`"
test 4717 -eq "$Wc_c" ||
	echo 'ttyhpux.c: original size 4717, current size' "$Wc_c"
fi
# ============= ttymsdos.c ==============
if test -f 'ttymsdos.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttymsdos.c (File already exists)'
else
echo 'x - extracting ttymsdos.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttymsdos.c' &&
/* TTY interface for MSDOS using TURBO-C
X   Copyright (C) 1991 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version. 
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  
X
You should have received a copy of the GNU General Public License
along with JOE; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#include <stdio.h>
#include <conio.h>
#include <bios.h>
#include "config.h"
#include "tty.h"
X
unsigned baud=38400;
unsigned long upc;
int have=0;
int leave=0;
static int ttymode=0;
X
void ttputs(s)
char *s;
{
fputs(s,stdout);
if(!have) have=bioskey(1);
}
X
void ttputc(c)
char c;
{
putchar(c);
if(!have) have=bioskey(1);
}
X
void sigjoe()
{
}
X
void signrm()
{
}
X
void ttopen()
{
ttopnn();
}
X
void ttopnn()
{
fflush(stdout);
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
}
X
void ttclose()
{
ttclsn();
}
X
void ttclsn()
{
ttflsh();
}
X
void ttflsh()
{
fflush(stdout);
if(!have) have=bioskey(1);
}
X
int ttgetc()
{
char c;
have=0;
c=getch();
return c;
}
X
void ttgtsz(x,y)
int *x, *y;
{
}
X
void ttshell(cmd)
char *cmd;
{
char *s=getenv("COMSPEC");
if(cmd) system(cmd);
else if(s) system(s);
}
X
void ttsusp()
{
ttshell(NULL);
}
X
char *getcwd();
char *pwd()
{
static char buf[1024];
return getcwd(buf,1024);
}
SHAR_EOF
chmod 0600 ttymsdos.c ||
echo 'restore of ttymsdos.c failed'
Wc_c="`wc -c < 'ttymsdos.c'`"
test 1705 -eq "$Wc_c" ||
	echo 'ttymsdos.c: original size 1705, current size' "$Wc_c"
fi
# ============= ttyposix.c ==============
if test -f 'ttyposix.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttyposix.c (File already exists)'
else
echo 'x - extracting ttyposix.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttyposix.c' &&
/* TTY interface for POSIX
X   Copyright (C) 1991 Joseph H. Allen
X   (Contributed by Mike Lijewski)
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  
X
You should have received a copy of the GNU General Public License along with
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 675
Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/param.h>
#include <termios.h>
#include <unistd.h>
#include "config.h"
#include "heap.h"
#include "tty.h"
X
#ifndef HZ
#define HZ 10
#endif
X
static struct termios oldterm;
X
char *obuf=0;
int obufp=0;
int obufsiz;
unsigned long upc;
unsigned baud;
int have=0;
int leave=0;
static int ttymode=0;
static char havec;
FILE *term=0;
X
static speed_t speeds[]=
{
B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,B1200,1200,
B1800,1800,B2400,2400,B4800,4800,B9600,9600,EXTA,19200,EXTB,38400,B19200,19200,
B38400,38400
};
X
void esignal(a,b)
int a;
void (*b)();
{
struct sigaction action;
sigemptyset(&action.sa_mask);
action.sa_flags=0;
action.sa_handler=b;
sigaction(a,&action,NULL);
}
X
void sigjoe()
{
esignal(SIGHUP,ttsig);
esignal(SIGTERM,ttsig);
esignal(SIGPIPE,SIG_IGN);
esignal(SIGINT,SIG_IGN);
esignal(SIGQUIT,SIG_IGN);
}
X
void signrm()
{
esignal(SIGHUP,SIG_DFL);
esignal(SIGTERM,SIG_DFL);
esignal(SIGQUIT,SIG_DFL);
esignal(SIGPIPE,SIG_DFL);
esignal(SIGINT,SIG_DFL);
}
X
void ttopen()
{
sigjoe();
ttopnn();
}
X
void ttopnn()
{
int x;
speed_t bd;
struct termios newterm;
if(!term && !(term=fopen("/dev/tty","r+")))
X {
X fprintf(stderr,"Couldn\'t open tty\n");
X exit(1);
X }
if(ttymode) return;
else ttymode=1;
fflush(term);
tcdrain(fileno(term));
tcgetattr(fileno(term),&oldterm);
newterm=oldterm;
newterm.c_lflag&=0;
newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
newterm.c_oflag&=0;
newterm.c_cc[VMIN]=1;
newterm.c_cc[VTIME]=0;
tcsetattr(fileno(term),TCSANOW,&newterm);
upc=0;
bd=cfgetospeed(&newterm);
baud=9600;
for(x=0;x!=34;x+=2)
X if(bd==speeds[x])
X  {
X  baud=speeds[x+1];
X  break;
X  }
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
if(obuf) free(obuf);
if(!(TIMES*upc)) obufsiz=4096;
else
X {
X obufsiz=1000000/(TIMES*upc);
X if(obufsiz>4096) obufsiz=4096;
X }
if(!obufsiz) obufsiz=1;
obuf=(char *)malloc(obufsiz);
}
X
void ttclose()
{
ttclsn();
signrm();
}
X
void ttclsn()
{
int oleave=leave;
if(ttymode) ttymode=0;
else return;
leave=1;
ttflsh();
tcsetattr(fileno(term),TCSANOW,&oldterm);
leave=oleave;
}
X
static int yep;
X
static void dosig() { yep=1; } 
X
int ttflsh()
{
if(obufp)
X {
X struct itimerval a,b;
X unsigned long usec=obufp*upc;
X if(usec>=500000/HZ && baud<38400)
X  {
X  a.it_value.tv_sec=usec/1000000;
X  a.it_value.tv_usec=usec%1000000;
X  a.it_interval.tv_usec=0;
X  a.it_interval.tv_sec=0;
X  esignal(SIGALRM,dosig);
X  yep=0;
X  sigsetmask(sigmask(SIGALRM));
X  setitimer(ITIMER_REAL,&a,&b);
X  write(fileno(term),obuf,obufp);
X  while(!yep) sigpause(0);
X  esignal(SIGALRM,SIG_DFL);
X  }
X else write(fileno(term),obuf,obufp);
X obufp=0;
X }
if(!have && !leave)
X {
X fcntl(fileno(term),F_SETFL,O_NDELAY);
X if(read(fileno(term),&havec,1)==1) have=1;
X fcntl(fileno(term),F_SETFL,0);
X }
return 0;
}
X
int ttgetc()
{
ttflsh();
if(have) have=0;
else if(read(fileno(term),&havec,1)<1) ttsig(0);
return havec;
}
X
void ttputs(s)
char *s;
{
while(*s)
X {
X obuf[obufp++]= *(s++);
X if(obufp==obufsiz) ttflsh();
X }
}
X
void ttgtsz(x,y)
int *x, *y;
{
#ifdef TIOCGSIZE
struct ttysize getit;
#else
#ifdef TIOCGWINSZ
struct winsize getit;
#endif
#endif
*x=0; *y=0;
#ifdef TIOCGSIZE
if(ioctl(fileno(term),TIOCGSIZE,&getit)!= -1)
X {
X *x=getit.ts_cols;
X *y=getit.ts_lines;
X }
#else
#ifdef TIOCGWINSZ
if(ioctl(fileno(term),TIOCGWINSZ,&getit)!= -1)
X {
X *x=getit.ws_col;
X *y=getit.ws_row;
X }
#endif
#endif
}
X
void ttshell(cmd)
char *cmd;
{
int x,omode=ttymode;
char *s=getenv("SHELL");
if(!s) return;
ttclsn();
if(x=fork())
X {
X if(x!= -1) wait(0);
X if(omode) ttopnn();
X }
else
X {
X signrm();
X if(cmd) execl(s,s,"-c",cmd,NULL);
X else
X  {
X  fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
X  execl(s,s,NULL);
X  }
X _exit(0);
X }
}
X
static int gotsig;
X
static void dosi()
{
gotsig=1;
}
X
void ttsusp()
{
#ifdef SIGCONT
int omode=ttymode;
ttclsn();
gotsig=0;
fprintf(stderr,"You have suspended the program.  Type \'fg\' to return\n");
esignal(SIGCONT,dosi);
sigsetmask(sigmask(SIGCONT));
kill(0,SIGTSTP);
while(!gotsig) sigpause(0);
esignal(SIGCONT,SIG_DFL);
if(omode) ttopnn();
#else
ttshell(NULL);
#endif
}
X
char *getcwd();
char *pwd()
{
static char buf[1024];
return getcwd(buf,1024);
}
SHAR_EOF
chmod 0600 ttyposix.c ||
echo 'restore of ttyposix.c failed'
Wc_c="`wc -c < 'ttyposix.c'`"
test 5008 -eq "$Wc_c" ||
	echo 'ttyposix.c: original size 5008, current size' "$Wc_c"
fi
# ============= ttysv.c ==============
if test -f 'ttysv.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttysv.c (File already exists)'
else
echo 'x - extracting ttysv.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttysv.c' &&
/* TTY interface for SYS V UNIX
X   Copyright (C) 1991 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version. 
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  
X
You should have received a copy of the GNU General Public License
along with JOE; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <sys/param.h>
#include <termio.h>
#include "config.h"
#include "tty.h"
X
static struct termio oldterm;
X
#ifndef HZ
#define HZ 10
#endif
X
FILE *term=0;
X
char *obuf=0;
int obufp=0;
int obufsiz;
X
unsigned baud;
unsigned long upc;
X
static int speeds[]=
{
B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,B1200,1200,
B1800,1800,B2400,2400,B4800,4800,B9600,9600,EXTA,19200,EXTB,38400
};
X
int leave=0;
static char havec;
int have=0;
static int ttymode=0;
X
void sigjoe()
{
signal(SIGHUP,ttsig);
signal(SIGTERM,ttsig);
signal(SIGINT,SIG_IGN);
signal(SIGPIPE,SIG_IGN);
signal(SIGQUIT,SIG_IGN);
}
X
void signrm()
{
signal(SIGHUP,SIG_DFL);
signal(SIGTERM,SIG_DFL);
signal(SIGINT,SIG_DFL);
signal(SIGPIPE,SIG_DFL);
signal(SIGQUIT,SIG_DFL);
}
X
void ttopen()
{
sigjoe();
ttopnn();
}
X
void ttopnn()
{
int x;
struct termio newterm;
if(!term && !(term=fopen("/dev/tty","r+")))
X {
X fprintf(stderr,"Couldn\'t open tty\n");
X exit(1);
X }
if(ttymode) return;
else ttymode=1;
fflush(term);
ioctl(fileno(term),TCGETA,&oldterm);
newterm=oldterm;
newterm.c_lflag=0;
newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
newterm.c_oflag=0;
newterm.c_cc[VMIN]=1;
newterm.c_cc[VTIME]=0;
ioctl(fileno(term),TCSETAW,&newterm);
upc=0;
baud=9600;
for(x=0;x!=30;x+=2)
X if((newterm.c_cflag&CBAUD)==speeds[x])
X  {
X  baud=speeds[x+1];
X  break;
X  }
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
if(obuf) free(obuf);
if(!(TIMES*upc)) obufsiz=4096;
else
X {
X obufsiz=1000000/(TIMES*upc);
X if(obufsiz>4096) obufsiz=4096;
X }
if(!obufsiz) obufsiz=1;
obuf=(char *)malloc(obufsiz);
}
X
void ttclose()
{
ttclsn();
signrm();
}
X
void ttclsn()
{
int oleave=leave;
if(ttymode) ttymode=0;
else return;
leave=1;
ttflsh();
ioctl(fileno(term),TCSETAW,&oldterm);
leave=oleave;
}
X
int ttflsh()
{
if(obufp)
X {
X write(fileno(term),obuf,obufp);
X obufp=0;
X }
/* Oh well, nothing but a second timer in SYS V */
if(!have && !leave)
X {
X fcntl(fileno(term),F_SETFL,O_NDELAY);
X if(read(fileno(term),&havec,1)==1) have=1;
X fcntl(fileno(term),F_SETFL,0);
X }
return 0;
}
X
int ttgetc()
{
ttflsh();
if(have) have=0;
else if(read(fileno(term),&havec,1)<1) ttsig(0);
return havec;
}
X
void ttputs(s)
char *s;
{
while(*s)
X {
X obuf[obufp++]= *(s++);
X if(obufp==obufsiz) ttflsh();
X }
}
X
void ttgtsz(x,y)
int *x, *y;
{
#ifdef TIOCGSIZE
struct ttysize getit;
#else
#ifdef TIOCGWINSZ
struct winsize getit;
#endif
#endif
*x=0; *y=0;
#ifdef TIOCGSIZE
if(ioctl(fileno(term),TIOCGSIZE,&getit)!= -1)
X {
X *x=getit.ts_cols;
X *y=getit.ts_lines;
X }
#else
#ifdef TIOCGWINSZ
if(ioctl(fileno(term),TIOCGWINSZ,&getit)!= -1)
X {
X *x=getit.ws_col;
X *y=getit.ws_row;
X }
#endif
#endif
}
X
void ttshell(cmd)
char *cmd;
{
int x,omode=ttymode;
char *s=getenv("SHELL");
if(!s) return;
ttclsn();
if(x=fork())
X {
X if(x!= -1) wait(0);
X if(omode) ttopnn();
X }
else
X {
X signrm();
X if(cmd) execl(s,s,"-c",cmd,NULL);
X else
X  {
X  fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
X  execl(s,s,NULL);
X  }
X _exit(0);
X }
}
X
static int gotsig;
X
static void dosi()
{
gotsig=1;
}
X
void ttsusp()
{
#ifdef SIGCONT
int omode=ttymode;
ttclsn();
gotsig=0;
fprintf(stderr,"You have suspended the program.  Type \'fg\' to return\n");
signal(SIGCONT,dosi);
sigsetmask(sigmask(SIGCONT));
kill(0,SIGTSTP);
while(!gotsig) sigpause(0);
signal(SIGCONT,SIG_DFL);
if(omode) ttopnn();
#else
ttshell(NULL);
#endif
}
X
char *getcwd();
char *pwd()
{
static char buf[1024];
return getcwd(buf,1024);
}
SHAR_EOF
chmod 0600 ttysv.c ||
echo 'restore of ttysv.c failed'
Wc_c="`wc -c < 'ttysv.c'`"
test 4269 -eq "$Wc_c" ||
	echo 'ttysv.c: original size 4269, current size' "$Wc_c"
fi
# ============= ttyxenix.c ==============
if test -f 'ttyxenix.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ttyxenix.c (File already exists)'
else
echo 'x - extracting ttyxenix.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttyxenix.c' &&
/* Terminal interface for XENIX
X   Copyright (C) 1991 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version. 
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  
X
You should have received a copy of the GNU General Public License
along with JOE; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#include <stdio.h>
#include <signal.h>
#include <termio.h>
#include "config.h"
#include "heap.h"
#include "tty.h"
X
FILE *term=0;
X
/* Original state of the tty */
X
static struct termio oldterm;
X
/* Output buffer, index and size */
X
char *obuf=0;
int obufp=0;
int obufsiz;
X
/* Baud rate */
X
unsigned long upc;
unsigned baud;
X
/* Baud rate code to baud rate translation table */
X
static int speeds[]=
{
B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,B1200,1200,
B1800,1800,B2400,2400,B4800,4800,B9600,9600,EXTA,19200,EXTB,38400
};
X
/* 'Typeahead' and 'editor is about to exit' flag */
X
int have=0;
int leave=0;
static int ttymode=0;
X
void sigjoe()
{
signal(SIGHUP,ttsig);
signal(SIGTERM,ttsig);
signal(SIGINT,SIG_IGN);
signal(SIGPIPE,SIG_IGN);
}
X
void signrm()
{
signal(SIGHUP,SIG_DFL);
signal(SIGTERM,SIG_DFL);
signal(SIGINT,SIG_DFL);
signal(SIGPIPE,SIG_DFL);
}
X
void ttopen()
{
sigjoe();
ttopnn();
}
X
void ttopnn()
{
int x;
struct termio newterm;
if(!term && !(term=fopen("/dev/tty","r+")))
X {
X fprintf(stderr,"Couldn\'t open tty\n");
X exit(1);
X }
if(ttymode) return;
else ttymode=1;
fflush(term);
ioctl(fileno(term),TCGETA,&oldterm);
newterm=oldterm;
newterm.c_lflag=0;
newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
newterm.c_oflag=0;
newterm.c_cc[VMIN]=1;
newterm.c_cc[VTIME]=0;
ioctl(fileno(term),TCSETAW,&newterm);
upc=0;
baud=9600;
for(x=0;x!=30;x+=2)
X if((newterm.c_cflag&CBAUD)==speeds[x])
X  {
X  baud=speeds[x+1];
X  break;
X  }
{
char *bs=getenv("BAUD");
if(bs)
X {
X sscanf(bs,"%u",&baud);
X }
}
upc=DIVIDEND/baud;
if(obuf) free(obuf);
if(!(TIMES*upc)) obufsiz=4096;
else
X {
X obufsiz=1000000/(TIMES*upc);
X if(obufsiz>4096) obufsiz=4096;
X }
if(!obufsiz) obufsiz=1;
obuf=(char *)malloc(obufsiz);
}
X
void ttclose()
{
ttclsn();
signrm();
}
X
void ttclsn()
{
int oleave=leave;
if(ttymode) ttymode=0;
else return;
leave=1;
ttflsh();
ioctl(fileno(term),TCSETAW,&oldterm);
leave=oleave;
}
X
int ttflsh()
{
if(obufp)
X {
X write(fileno(term),obuf,obufp);
X if(baud<38400) if(obufp*upc/1000) nap(obufp*upc/1000);
X obufp=0;
X }
if(!have && !leave) if(rdchk(fileno(term))>0) have=1;
return 0;
}
X
int ttgetc()
{
char c;
ttflsh();
if(read(fileno(term),&c,1)<1) ttsig(0);
have=0;
return c;
}
X
void ttputs(s)
char *s;
{
while(*s)
X {
X obuf[obufp++]= *(s++);
X if(obufp==obufsiz) ttflsh();
X }
}
X
void ttgtsz(x,y)
int *x, *y;
{
#ifdef TIOCGSIZE
struct ttysize getit;
#else
#ifdef TIOCGWINSZ
struct winsize getit;
#endif
#endif
*x=0; *y=0;
#ifdef TIOCGSIZE
if(ioctl(fileno(term),TIOCGSIZE,&getit)!= -1)
X {
X *x=getit.ts_cols;
X *y=getit.ts_lines;
X }
#else
#ifdef TIOCGWINSZ
if(ioctl(fileno(term),TIOCGWINSZ,&getit)!= -1)
X {
X *x=getit.ws_col;
X *y=getit.ws_row;
X }
#endif
#endif
}
X
void ttshell(cmd)
char *cmd;
{
int x,omode=ttymode;
char *s=getenv("SHELL");
if(!s) return;
ttclsn();
if(x=fork())
X {
X if(x!= -1) wait(0);
X if(omode) ttopnn();
X }
else
X {
X signrm();
X if(cmd) execl(s,s,"-c",cmd,NULL);
X else
X  {
X  fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
X  execl(s,s,NULL);
X  }
X _exit(0);
X }
}
X
static int gotsig;
X
static void dosi()
{
gotsig=1;
}
X
void ttsusp()
{
#ifdef SIGCONT
int omode=ttymode;
ttclsn();
gotsig=0;
fprintf(stderr,"You have suspended the program.  Type \'fg\' to return\n");
signal(SIGCONT,dosi);
sigsetmask(sigmask(SIGCONT));
kill(0,SIGTSTP);
while(!gotsig) sigpause(0);
signal(SIGCONT,SIG_DFL);
if(omode) ttopnn();
#else
ttshell(NULL);
#endif
}
X
char *getcwd();
char *pwd()
{
static char buf[1024];
return getcwd(buf,1024);
}
SHAR_EOF
chmod 0600 ttyxenix.c ||
echo 'restore of ttyxenix.c failed'
Wc_c="`wc -c < 'ttyxenix.c'`"
test 4223 -eq "$Wc_c" ||
	echo 'ttyxenix.c: original size 4223, current size' "$Wc_c"
fi
# ============= tw.c ==============
if test -f 'tw.c' -a X"$1" != X"-c"; then
	echo 'x - skipping tw.c (File already exists)'
else
echo 'x - extracting tw.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tw.c' &&
/* Text editing windows
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "w.h"
#include "toomany.h"
#include "termcap.h"
#include "vfile.h"
#include "b.h"
#include "edfuncs.h"
#include "tty.h"
#include "kbd.h"
#include "scrn.h"
#include "bw.h"
#include "zstr.h"
#include "vs.h"
#include "help.h"
#include "undo.h"
#include "main.h"
#include "macro.h"
#include "tw.h"
X
extern char *exmsg;
X
/* Update a text window */
X
static void followtw(w)
W *w;
{
BW *bw=(BW *)w->object;
bwfllw(bw);
}
X
int starow=0;
int stacol=0;
X
static void disptw(w)
W *w;
{
P *p;
char buf[40];
BW *bw=(BW *)w->object;
TW *tw=(TW *)bw->object;
X
w->cury=bw->cursor->line-bw->top->line+bw->y-w->y;
w->curx=bw->cursor->xcol-bw->offset+bw->x-w->x;
X
if(starow!=tw->starow || stacol!=tw->stacol ||
X   starow || stacol) w->t->t->updtab[w->y]=1;
if(bw->b->name==tw->stanam) goto nosta0;
if(bw->b->name && tw->stanam && !zcmp(bw->b->name,tw->stanam)) goto nosta0;
if(tw->stanam) free(tw->stanam), tw->stanam=0;
if(bw->b->name) tw->stanam=zdup(bw->b->name);
w->t->t->updtab[w->y]=1;
nosta0:
if(bw->b->chnged!=tw->stamod) w->t->t->updtab[w->y]=1;
if(tw->stahlp!=!!w->t->wind) w->t->t->updtab[w->y]=1;
if(tw->starec!=recmac) w->t->t->updtab[w->y]=1;
X
if(!w->t->t->updtab[w->y]) goto nosta;
X
tw->stahlp=!!w->t->wind;
tw->stamod=bw->b->chnged;
tw->starec=recmac;
tw->stalin=vstrunc(tw->stalin,0);
X
tw->starow=starow;
if(starow)
X {
X tw->stalin=vsncpy(tw->stalin,0,sc("R="));
X sprintf(buf,"%4ld",bw->cursor->line+1);
X tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sz(buf));
X tw->stalin=vsadd(tw->stalin,' ');
X }
tw->stacol=stacol;
if(stacol)
X {
X tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sc("C="));
X sprintf(buf,"%3ld",bw->cursor->col+1);
X tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sz(buf));
X tw->stalin=vsadd(tw->stalin,' ');
X }
if(bw->b->name) tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sz(bw->b->name));
else tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sc("(Unnamed)"));
if(bw->b->chnged) tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sc(" (Modified)"));
if(recmac)
X {
X sprintf(buf," (Macro %d recording...)",recmac->n);
X tw->stalin=vsncpy(tw->stalin,sLEN(tw->stalin),sz(buf));
X }
X
tw->stalin=vstrunc(tw->stalin,w->w);
if(!w->t->wind && w->w>=40)
X tw->stalin=vsncpy(tw->stalin,w->w-17,sc("Ctrl-K H for help"));
X
/* Output status line */
X {
X int z;
X int *s=w->t->t->scrn+w->x+w->t->t->co*w->y;
X for(z=0;tw->stalin[z];++z)
X  {
X  if(have) goto nosta;
X  if(s[z]!=(unsigned char)tw->stalin[z]+INVERSE)
X   {
X   int c=s[z]=(unsigned char)tw->stalin[z]+INVERSE;
X   outatr(w->t->t,w->x+z,w->y,c);
X   }
X  }
X }
w->t->t->updtab[w->y]=0;
nosta:
X
bwgen(bw);
}
X
/* Abort text window */
X
static void killtw(w)
W *w;
{
BW *bw=(BW *)w->object;
TW *tw=(TW *)bw->object;
bwrm(bw);
vsrm(tw->stalin);
free(tw);
}
X
/* Move text window */
X
static void movetw(w,x,y)
W *w;
int x,y;
{
BW *bw=(BW *)w->object;
bwmove(bw,x,y+1);
}
X
/* Resize text window */
X
static void resizetw(w,wi,he)
W *w;
int wi,he;
{
BW *bw=(BW *)w->object;
bwresz(bw,wi,he-1);
}
X
/* Split current window */
X
void usplitw(w)
W *w;
{
BW *bw=(BW *)w->object;
TW *tw=(TW *)bw->object;
int newh=getgrouph(w);
W *new;
TW *newtw;
BW *newbw;
if(newh/2<FITHEIGHT) return;
new=wcreate(w->t,w->watom,findbotw(w),NULL,w,newh/2+(newh&1),NULL);
if(!new) return;
new->object=(void *)(newbw=bwmk(w->t,bw->b,new->x,new->y+1,new->w,new->h-1));
++bw->b->count;
newbw->lmargin=bw->lmargin;
newbw->rmargin=bw->rmargin;
newbw->autoindent=bw->autoindent;
newbw->wordwrap=bw->wordwrap;
newbw->overtype=bw->overtype;
newbw->indentc=bw->indentc;
newbw->istep=bw->istep;
newbw->offset=bw->offset;
newbw->object=(void *)(newtw=(TW *)malloc(sizeof(TW)));
newtw->staupd=tw->staupd;
newtw->stanam=0;
newtw->stalin=0;
newtw->stamod=0;
newtw->stahlp=0;
pset(newbw->top,bw->top);
pset(newbw->cursor,bw->cursor);
new->t->curwin=new;
}
X
/* User routine for aborting a text window */
X
void uaborttw(w)
W *w;
{
BW *bw=(BW *)w->object;
TW *tw=(TW *)bw->object;
if(bw->b->chnged && bw->b->count==1)
X {
X int c=query(w,"Loose changes to this file (y,n)? ");
X if(c!='y' && c!='Y') return;
X if(bw->b->name)
X  {
X  exmsg=vsncpy(NULL,0,sc("File "));
X  exmsg=vsncpy(exmsg,sLEN(exmsg),sz(bw->b->name));
X  exmsg=vsncpy(exmsg,sLEN(exmsg),sc(" not saved."));
X  }
X else exmsg=vsncpy(NULL,0,sc("File (Unnamed) not saved."));
X }
else if(!exmsg)
X {
X if(bw->b->name)
X  {
X  exmsg=vsncpy(NULL,0,sc("File "));
X  exmsg=vsncpy(exmsg,sLEN(exmsg),sz(bw->b->name));
X  exmsg=vsncpy(exmsg,sLEN(exmsg),sc(" not changed so no update needed."));
X  }
X else exmsg=vsncpy(NULL,0,sc("File (Unnamed) not changed so no update needed."));
X }
wabort(w);		/* Eliminate this window and it's children */
if(!leave) if(exmsg) vsrm(exmsg), exmsg=0;
}
X
void ucheckp(w)
W *w;
{
BW *bw=(BW *)w->object;
checkp(bw->b);
}
X
void ucheck(w)
W *w;
{
BW *bw=(BW *)w->object;
check(bw->b);
}
X
CONTEXT cmain={"main",0};
X
static void instw(w,b,l,n,flg)
W *w;
B *b;
long l,n;
int flg;
{
BW *bw=(BW *)w->object;
if(b==bw->b) bwins(bw,l,n,flg);
}
X
static void deltw(w,b,l,n,flg)
W *w;
B *b;
long l,n;
int flg;
{
BW *bw=(BW *)w->object;
if(b==bw->b) bwdel(bw,l,n,flg);
}
X
static WATOM watomtw=
{
&cmain,
disptw,
followtw,
killtw,
resizetw,
movetw,
instw,
deltw,
TYPETW
};
X
/* Create a text window.  It becomes the last window on the screen */
X
W *wmktw(t,b)
SCREEN *t;
B *b;
{
W *w;
BW *bw;
TW *tw;
w=wcreate(t,&watomtw,NULL,NULL,NULL,t->h,NULL);
w->object=(void *)(bw=bwmk(t,b,w->x,w->y+1,w->w,w->h-1));
bw->object=(void *)(tw=(TW *)malloc(sizeof(TW)));
tw->staupd=1; /* Unneeded? */
tw->stanam=0;
tw->starec=recmac;
tw->stalin=0;
tw->stamod=0;
tw->stahlp=0;
tw->starow=starow;
tw->stacol=stacol;
return w;
}
SHAR_EOF
chmod 0600 tw.c ||
echo 'restore of tw.c failed'
Wc_c="`wc -c < 'tw.c'`"
test 6362 -eq "$Wc_c" ||
	echo 'tw.c: original size 6362, current size' "$Wc_c"
fi
# ============= tw.h ==============
if test -f 'tw.h' -a X"$1" != X"-c"; then
	echo 'x - skipping tw.h (File already exists)'
else
echo 'x - extracting tw.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tw.h' &&
/* Text editing windows
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Itw
#define _Itw 1
X
#include "config.h"
#include "kbd.h"
#include "main.h"
X
typedef struct tw TW;
X
extern int starow, stacol;
X
struct tw
X {
X /* Status line info */
X char *stanam;
X char *stalin;
X int stamod;
X int stahlp;
X struct recmac *starec;
X int starow;
X int stacol;
X int staupd;			/* Set if status line should get updated */
X };
X
#define TYPETW 0x100
X
extern CONTEXT cmain;
X
/* W *wmktw(SCREEN *t,B *b)
X */
W *wmktw();
X
void uaborttw();
void usplitw();
void ucheck();
void ucheckp();
X
#endif
SHAR_EOF
chmod 0600 tw.h ||
echo 'restore of tw.h failed'
Wc_c="`wc -c < 'tw.h'`"
test 1265 -eq "$Wc_c" ||
	echo 'tw.h: original size 1265, current size' "$Wc_c"
fi
# ============= undo.c ==============
if test -f 'undo.c' -a X"$1" != X"-c"; then
	echo 'x - skipping undo.c (File already exists)'
else
echo 'x - extracting undo.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'undo.c' &&
/* UNDO system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "b.h"
#include "w.h"
#include "bw.h"
#include "undo.h"
X
static UNDO undos={{&undos,&undos}};
X
int inundo=0;
X
void undomk(b)
B *b;
{
UNDO *undo=(UNDO *)malloc(sizeof(UNDO));
undo->nrecs=0;
undo->ptr=0;
undo->first=0;
undo->last=0;
izque(UNDOREC,link,&undo->recs);
b->undo=undo;
enquef(UNDO,link,&undos,undo);
}
X
void undorm(b)
B *b;
{
UNDO *undo=b->undo;
while(!qempty(UNDOREC,link,&undo->recs))
X {
X free(undo->recs.link.next->data);
X free(deque(UNDOREC,link,undo->recs.link.next));
X }
free(deque(UNDO,link,undo));
}
X
void uundo(w)
W *w;
{
UNDOREC *upto;
BW *bw=(BW *)w->object;
UNDO *undo=bw->b->undo;
if(!undo->nrecs) return;
if(!undo->ptr)
X {
X if(undo->recs.link.prev->where!=bw->cursor->byte)
X  pfwrd(pbof(bw->cursor),undo->recs.link.prev->where);
X undo->ptr=&undo->recs;
/* return; */
X }
if(undo->ptr->link.prev==&undo->recs) return;
upto=undo->ptr->link.prev->unit;
loop:
undo->ptr=undo->ptr->link.prev;
if(undo->ptr->where!=bw->cursor->byte)
X pfwrd(pbof(bw->cursor),undo->ptr->where);
inundo=1;
if(undo->ptr->del)
X {
X binsm(bw->cursor,undo->ptr->data,undo->ptr->len);
X undo->ptr->del=0;
X }
else
X {
X P *q=pdup(bw->cursor);
X pfwrd(q,undo->ptr->len);
X bdel(bw->cursor,q);
X prm(q);
X undo->ptr->del=1;
X }
inundo=0;
if(upto && upto!=undo->ptr) goto loop;
if(undo->ptr->first) bw->b->chnged=0;
}
X
void uredo(w)
W *w;
{
UNDOREC *upto;
BW *bw=(BW *)w->object;
UNDO *undo=bw->b->undo;
if(!undo->ptr) return;
if(undo->ptr==&undo->recs) return;
upto=undo->ptr->unit;
loop:
if(undo->ptr->where!=bw->cursor->byte)
X pfwrd(pbof(bw->cursor),undo->ptr->where);
inundo=1;
if(undo->ptr->del)
X {
X binsm(bw->cursor,undo->ptr->data,undo->ptr->len);
X undo->ptr->del=0;
X }
else
X {
X P *q=pdup(bw->cursor);
X pfwrd(q,undo->ptr->len);
X bdel(bw->cursor,q);
X prm(q);
X undo->ptr->del=1;
X }
inundo=0;
undo->ptr=undo->ptr->link.next;
if(upto && upto!=undo->ptr->link.prev) goto loop;
}
X
static void undogc(undo)
UNDO *undo;
{
UNDOREC *unit=undo->recs.link.next->unit;
if(unit)
X while(unit!=undo->recs.link.next)
X  {
X  free(undo->recs.link.next->data);
X  free(deque(UNDOREC,link,undo->recs.link.next));
X  }
free(undo->recs.link.next->data);
free(deque(UNDOREC,link,undo->recs.link.next));
--undo->nrecs;
}
X
static void undomark1(undo)
UNDO *undo;
{
if(undo->first)
X {
X undo->first->unit=undo->last;
X undo->last->unit=undo->first;
X undo->first=undo->last=0;
X if(++undo->nrecs==UNDOKEEP) undogc(undo);
X }
}
X
void umclear()
{
UNDO *undo;
for(undo=undos.link.next;undo!=&undos;undo=undo->link.next)
X {
X UNDOREC *rec;
X for(rec=undo->recs.link.next;rec!=&undo->recs;rec=rec->link.next)
X  rec->min=0;
X }
}
X
void undomark()
{
UNDO *undo;
for(undo=undos.link.next;undo!=&undos;undo=undo->link.next) undomark1(undo);
}
X
static void undoover(undo)
UNDO *undo;
{
if(undo->ptr && undo->ptr!=&undo->recs)
X {
X while(undo->recs.link.prev!=undo->ptr)
X  {
X  free(undo->recs.link.prev->data);
X  free(deque(UNDOREC,link,undo->recs.link.prev));
X  }
X free(undo->recs.link.prev->data);
X free(deque(UNDOREC,link,undo->recs.link.prev));
X }
undo->ptr=0;
}
X
void undoins(p,size)
P *p;
long size;
{
UNDOREC *rec;
if(inundo) return;
undoover(p->b->undo);
rec=p->b->undo->recs.link.prev;
if(rec->min && rec!=&p->b->undo->recs && rec->del==0 && p->byte==rec->where+rec->len)
X {
X rec->data=(char *)realloc(rec->data,rec->len+size);
X brmem(p,rec->data+rec->len,size);
X rec->len+=size;
X }
else if(rec->min &&
X        rec!=&p->b->undo->recs && rec->del==0 && p->byte==rec->where)
X {
X rec->data=(char *)realloc(rec->data,rec->len+size);
X mmove(rec->data+size,rec->data,rec->len);
X brmem(p,rec->data,size);
X rec->len+=size;
X }
else
X {
X rec=(UNDOREC *)malloc(sizeof(UNDOREC));
X rec->data=(char *)malloc(size);
X if(!p->b->undo->first) p->b->undo->first=rec;
X p->b->undo->last=rec;
X rec->where=p->byte;
X rec->min=1;
X rec->unit=0;
X rec->len=size;
X rec->del=0;
X if(qempty(UNDOREC,link,&p->b->undo->recs) && !p->b->chnged) rec->first=1;
X else rec->first=0;
X brmem(p,rec->data,rec->len);
X enqueb(UNDOREC,link,&p->b->undo->recs,rec);
X }
}
X
void undodel(p,size)
P *p;
long size;
{
UNDOREC *rec;
if(inundo) return;
undoover(p->b->undo);
rec=p->b->undo->recs.link.prev;
if(rec->min && rec!=&p->b->undo->recs && rec->del==1
X   && p->byte==rec->where)
X {
X rec->data=(char *)realloc(rec->data,rec->len+size);
X brmem(p,rec->data+rec->len,size);
X rec->len+=size;
X }
else if(rec->min &&
X        rec!=&p->b->undo->recs && rec->del==1 && p->byte+size==rec->where)
X {
X rec->data=(char *)realloc(rec->data,rec->len+size);
X mmove(rec->data+size,rec->data,rec->len);
X brmem(p,rec->data,size);
X rec->len+=size;
X rec->where=p->byte;
X }
else
X {
X rec=(UNDOREC *)malloc(sizeof(UNDOREC));
X rec->data=(char *)malloc(size);
X if(!p->b->undo->first) p->b->undo->first=rec;
X p->b->undo->last=rec;
X rec->where=p->byte;
X rec->min=1;
X rec->unit=0;
X rec->len=size;
X rec->del=1;
X if(qempty(UNDOREC,link,&p->b->undo->recs) && !p->b->chnged) rec->first=1;
X else rec->first=0;
X brmem(p,rec->data,rec->len);
X enqueb(UNDOREC,link,&p->b->undo->recs,rec);
X }
}
SHAR_EOF
chmod 0600 undo.c ||
echo 'restore of undo.c failed'
Wc_c="`wc -c < 'undo.c'`"
test 5709 -eq "$Wc_c" ||
	echo 'undo.c: original size 5709, current size' "$Wc_c"
fi
# ============= undo.h ==============
if test -f 'undo.h' -a X"$1" != X"-c"; then
	echo 'x - skipping undo.h (File already exists)'
else
echo 'x - extracting undo.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'undo.h' &&
/* UNDO system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iundo
#define _Iundo 1
X
#include "queue.h"
X
/* Number of undo records to keep */
X
#define UNDOKEEP 100
X
typedef struct undorec UNDOREC;
typedef struct undo UNDO;
X
extern int inundo;
X
/* An undo record */
struct undorec
X {
X LINK(UNDOREC) link;		/* Doubly linked list of undo records */
X int first;			/* Set if this is the first undo rec */
X int min;			/* Set if this is from a minor change */
X long where;			/* Buffer position this are from */
X int del;			/* Set for delete, Clr for insert */
X int len;			/* No. chars in this rec */
X UNDOREC *unit;			/* Last/First rec in unit */
X char *data;			/* The chars */
X };
X
/* An undo point */
struct undo
X {
X LINK(UNDO) link;		/* Doubly linked list of undo points */
X UNDOREC recs;			/* Undo records */
X int nrecs;			/* Number of undo records */
X UNDOREC *ptr;			/* Undo/Redo location */
X UNDOREC *first;		/* First of unit */
X UNDOREC *last;			/* Last of unit */
X };
X
void umclear();			/* Prevent combinding of undo recs */
void undomark();		/* Everything from prev. mark is a unit */
void undoend();
void undomk();
void undorm();
void uundo();
void uredo();
void undoins();
void undodel();
X
#endif
SHAR_EOF
chmod 0600 undo.h ||
echo 'restore of undo.h failed'
Wc_c="`wc -c < 'undo.h'`"
test 1901 -eq "$Wc_c" ||
	echo 'undo.h: original size 1901, current size' "$Wc_c"
fi
# ============= va.c ==============
if test -f 'va.c' -a X"$1" != X"-c"; then
	echo 'x - skipping va.c (File already exists)'
else
echo 'x - extracting va.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'va.c' &&
/* Variable length array of strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "blocks.h"
#include "heap.h"
#include "zstr.h"
#include "va.h"
X
aELEMENT(*vamk(len))
int len;
{
int *new=(int *)malloc((1+len)*sizeof(aCAST)+2*sizeof(int));
new[0]=len;
new[1]=0;
((aELEMENT(*))(new+2))[0]=aterm;
return (aELEMENT(*))(new+2);
}
X
void varm(vary)
aELEMENT(*vary);
{
if(vary)
X {
X vazap(vary,0,aLen(vary));
X free((int *)vary-2);
X }
}
X
int alen(ary)
aELEMENT(*ary);
{
if(ary)
X {
X aELEMENT(*beg)=ary;
X while(acmp(*ary,aterm)) ++ary;
X return ary-beg;
X }
else return 0;
}
X
aELEMENT(*vaensure(vary,len))
aELEMENT(*vary);
int len;
{
if(!vary) vary=vamk(len);
else if(len>aSiz(vary))
X {
X int x;
X len+=(len>>2);
X vary=(aELEMENT(*))(2+(int *)realloc(
X       (int *)vary-2,(len+1)*sizeof(aCAST)+2*sizeof(int) ));
X aSiz(vary)=len;
X }
return vary;
}
X
aELEMENT(*vazap(vary,pos,n))
aELEMENT(*vary);
int pos,n;
{
if(vary)
X {
X int x;
X if(pos<aLen(vary))
X  if(pos+n<=aLen(vary))
X   for(x=pos;x!=pos+n;++x) adel(vary[x]);
X  else
X   for(x=pos;x!=aLen(vary);++x) adel(vary[x]);
X }
return vary;
}
X
aELEMENT(*vatrunc(vary,len))
aELEMENT(*vary);
int len;
{
if(!vary || len>aLEN(vary)) vary=vaensure(vary,len);
if(len<aLen(vary))
X {
X vary=vazap(vary,len,aLen(vary)-len);
X vary[len]=vary[aLen(vary)];
X aLen(vary)=len;
X }
else if(len>aLen(vary))
X {
X vary=vafill(vary,aLen(vary),ablank,len-aLen(vary));
X }
return vary;
}
X
aELEMENT(*vafill(vary,pos,el,len))
aELEMENT(*vary);
aELEMENT(el);
int pos,len;
{
int olen=aLEN(vary), x;
if(!vary || pos+len>aSIZ(vary))
X vary=vaensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X aLen(vary)=pos+len;
X }
for(x=pos;x!=pos+len;++x) vary[x]=adup(el);
if(pos>olen) vary=vafill(vary,pos,ablank,pos-olen);
return vary;
}
X
aELEMENT(*vancpy(vary,pos,array,len))
aELEMENT(*vary);
aELEMENT(*array);
int pos, len;
{
int olen=aLEN(vary);
if(!vary || pos+len>aSIZ(vary)) vary=vaensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X aLen(vary)=pos+len;
X }
if(pos>olen) vary=vafill(vary,olen,ablank,pos-olen);
mfwrd(vary+pos,array,len*sizeof(aCAST));
return vary;
}
X
aELEMENT(*vandup(vary,pos,array,len))
aELEMENT(*vary);
aELEMENT(*array);
int pos, len;
{
int olen=aLEN(vary), x;
if(!vary || pos+len>aSIZ(vary)) vary=vaensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X aLen(vary)=pos+len;
X }
if(pos>olen) vary=vafill(vary,olen,ablank,pos-olen);
for(x=pos;x!=len;++x) vary[x]=adup(array[x]);
return vary;
}
X
aELEMENT(*vafield(vary,pos,len))
aELEMENT(*vary);
int pos,len;
{
if(pos+len>aLEN(vary)) vary=vatrunc(vary,pos,len);
return vary;
}
X
aELEMENT(*vadup(vary))
aELEMENT(*vary);
{
return vandup(NULL,0,vary,aLEN(vary));
}
X
aELEMENT(*_vaset(vary,pos,el))
aELEMENT(*vary);
aELEMENT(el);
int pos;
{
if(!vary || pos+1>aSIZ(vary)) vary=vaensure(vary,pos+1);
if(pos>aLen(vary))
X {
X vary=vafill(vary,aLen(vary),ablank,pos-aLen(vary));
X vary[pos+1]=vary[pos];
X vary[pos]=el;
X aLen(vary)=pos+1;
X }
else if(pos==aLen(vary))
X {
X vary[pos+1]=vary[pos];
X vary[pos]=el;
X aLen(vary)=pos+1;
X }
else
X {
X adel(vary[pos]);
X vary[pos]=el;
X }
return vary;
}
X
aELEMENT(*vains(vary,pos,n))
aELEMENT(*vary);
int pos,n;
{
if(!vary || aLEN(vary)+n>aSIZ(vary)) vary=vaensure(vary,aLEN(vary)+n);
if(pos>=aLen(vary)) vary=vatrunc(vary,pos+n);
else
X {
X mbkwd(vary+pos+n,vary+pos,aLen(vary)-(pos+n)+1);
X aLen(vary)+=n;
X }
return vary;
}
X
aELEMENT(*vadel(vary,pos,n))
aELEMENT(*vary);
int pos,n;
{
if(pos>=aLEN(vary)) return vary;
if(pos+n>=aLen(vary)) return vatrunc(vary,pos);
mfwrd(vary+pos,vary+pos+n,aLen(vary)-(pos+n)+1);
aLen(vary)-=n;
return vary;
}
X
int _acmp(a,b)
aELEMENT(*a);
aELEMENT(*b);
{
return acmp(*a,*b);
}
X
aELEMENT(*vasort(ary,len))
aELEMENT(*ary);
int len;
{
if(!ary || !len) return ary;
qsort(ary,len,sizeof(aCAST),_acmp);
return ary;
}
X
int vabsearch(ary,len,el)
aELEMENT(*ary);
aELEMENT(el);
int len;
{
int x,y,z;
if(!ary || !len) return 0;
y=len;
x=0;
z=~0;
while(z!=(x+y)/2)
X {
X z=(x+y)/2;
X switch(acmp(el,ary[z]))
X  {
X case  1: x=z; break;
X case -1: y=z; break;
X case  0: return z;
X  }
X }
return y;
}
X
int vafirst(ary,len,el)
aELEMENT(*ary);
aELEMENT(el);
int len;
{
int x;
if(!ary || !len) return ~0;
for(x=0;x!=len;++x) if(!acmp(ary[x],el)) return x;
return ~0;
}
X
int valast(ary,len,el)
aELEMENT(*ary);
aELEMENT(el);
int len;
{
int x=len;
if(!ary || !len) return ~0;
do
X {
X --x;
X if(!acmp(ary[x],el)) return x;
X }
X while(x);
return ~0;
}
X
int vacmpn(a,alen,b,blen)
aELEMENT(*a);
aELEMENT(*b);
int alen, blen;
{
int x,l;
int t;
if(!a && !b) return 0;
if(!a) return -1;
if(!b) return 1;
if(alen>blen) l=aLen(a);
else l=blen;
for(x=0;x!=l;++x) if(t=acmp(a[x],b[x])) return t;
if(alen>blen) return  1;
if(alen<blen) return -1;
return 0;
}
X
int vacmp(a,b)
aELEMENT(*a);
aELEMENT(*b);
{
return vacmpn(av(a),av(b));
}
X
int vaa(a,alen,b,blen)
aELEMENT(*a);
aELEMENT(*b);
int alen, blen;
{
int x;
if(!a && !b) return 0;
if(!a || !b) return ~0;
if(alen<blen) return ~0;
if(!blen) return 0;
for(x=0;x!=alen-blen;++x) if(!vacmpn(a,blen,b,blen)) return x;
return ~0;
}
X
int vascan(a,alen,b,blen)
aELEMENT(*a);
aELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
X {
X int z=vabsearch(b,blen,a[x]);
X if(z<blen && !acmp(b[z],a[x])) return x;
X }
return ~0;
}
X
int vaspan(a,alen,b,blen)
aELEMENT(*a);
aELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
X {
X int z=vabsearch(b,blen,a[x]);
X if(z==blen || acmp(b[z],a[x])) break;
X }
return x;
}
X
aELEMENT(*vawords(a,s,len,sep,seplen))
aELEMENT(*a);
char *s, *sep;
int len, seplen;
{
int x;
if(!a) a=vamk(10);
else a=vatrunc(a,0);
loop:
x=vsspan(s,len,sep,seplen);
s+=x; len-=x;
if(len)
X {
X x=vsscan(s,len,sep,seplen);
X if(x!= ~0)
X  {
X  a=vaadd(a,vsncpy(vsmk(x),0,s,x));
X  s+=x; len-=x;
X  if(len) goto loop;
X  }
X else a=vaadd(a,vsncpy(vsmk(len),0,s,len));
X }
return a;
}
X
aELEMENT(*vaiwords(a,s,len,inc,inclen))
aELEMENT(*a);
char *s, *inc;
int len, inclen;
{
int x;
if(!a) a=vamk(10);
else a=vatrunc(a,0);
loop:
x=vsscan(s,len,inc,inclen);
s+=x; len-=x;
if(len)
X {
X x=vsspan(s,len,inc,inclen);
X if(x!= ~0)
X  {
X  a=vaadd(a,vsncpy(vsmk(x),0,s,x));
X  s+=x; len-=x;
X  if(len) goto loop;
X  }
X else a=vaadd(a,vsncpy(vsmk(len),0,s,len));
X }
return a;
}
SHAR_EOF
chmod 0600 va.c ||
echo 'restore of va.c failed'
Wc_c="`wc -c < 'va.c'`"
test 6830 -eq "$Wc_c" ||
	echo 'va.c: original size 6830, current size' "$Wc_c"
fi
# ============= va.h ==============
if test -f 'va.h' -a X"$1" != X"-c"; then
	echo 'x - skipping va.h (File already exists)'
else
echo 'x - extracting va.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'va.h' &&
/* Variable length arrays of strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iva
#define _Iva
X
#include "config.h"
#include "vs.h"
X
/* Functions and global variable you have to define.  Replace these with
X * macros or defines here if they are not to be actual functions 
X */
X
#define aELEMENT(a) char *a
#define aCAST char *
/* aELEMENT(adup()); */
#define adup(s) vsdup(s)
/* aELEMENT(adel()); */
#define adel(s) vsrm(s)
/* int acmp(); */
#define acmp(a,b) vscmp((a),(b))
/* extern aELEMENT(ablank); */
#define ablank NULL
/* extern aELEMENT(aterm); */
#define aterm NULL
X
/************************/
/* Creation/Destruction */
/************************/
X
/* aELEMENT(*vamk(int len));
X * Create a variable length array.  Space for 'len' elements is preallocated.
X */
aELEMENT(*vamk());
X
/* void varm(aELEMENT(*vary));
X * Free an array and everything which is in it.  Does nothing if 'vary' is
X * 0.
X */
void varm();
X
/********************/
/* Space management */
/********************/
X
/* int aSIZ(aELEMENT(*vary));
X * int aSiz(aELEMENT(*vary));
X * Access size part of array.  This int indicates the number of elements which
X * can fit in the array before realloc needs to be called.  It does not include
X * the extra space needed for the terminator and the header.
X *
X * aSIZ returns 0 if you pass it 0.  aSiz does not do this checking,
X * but can be used as an lvalue.
X */
#define aSIZ(a) ((a)?*((int *)(a)-2):0)
#define aSiz(a) (*((int *)(a)-2))
X
/* int aLEN(aELEMENT(*vary));
X * int aLen(aELEMENT(*vary));
X * Access length part of array.  This int indicates the number of elements
X * currently in the array (not including the terminator).  This should be
X * used primarily for reading the size of the array.  It can be used for
X * setting the size of the array, but it must be used with care since it
X * does not eliminate elements (if the size decreases) or make sure there's
X * enough room (if the size increases).  See vensure and vtrunc.
X *
X * aLEN return a length of zero if 'vary' is 0.
X * aLen doesn't do this checking, but can be used as an lvalue
X */
#define aLEN(a) ((a)?*((int *)(a)-1):0)
#define aLen(a) (*((int *)(a)-1))
X
/* int alen(aELEMENT(*ary));
X * Compute length of char or variable length array by searching for termination
X * element.  Returns 0 if 'vary' is 0.
X */
int alen();
X
/* aELEMENT(*vaensure(aELEMENT(*vary),int len));
X * Make sure there's enough space in the array for 'len' elements.  Whenever
X * vaensure reallocs the array, it allocates 25% more than the necessary
X * minimum space in anticipation of future expansion.  If 'vary' is 0,
X * it creates a new array.
X */
aELEMENT(*vaensure());
X
/* aELEMENT(*vazap(aELEMENT(*vary),int pos,int n));
X * Destroy n elements from an array beginning at pos.  Is ok if pos/n go
X * past end of array.  This does not change the aLEN() value of the array.
X * This does nothing and returns 0 if 'vary' is 0.  Note that this
X * function does not actually write to the array.  This does not stop if
X * a aterm is encountered.
X */
aELEMENT(*vazap());
X
/* aELEMENT(*vatrunc(aELEMENT(*vary),int len));
X * Truncate array to indicated size.  This zaps or expands with blank elements
X * and sets the LEN() of the array.  A new array is created if 'vary' is 0.
X */
aELEMENT(*vatrunc());
X
/************************************/
/* Function which write to an array */
/************************************/
X
/* aELEMENT(*vafill(aELEMENT(*vary),int pos,aELEMENT(el),int len));
X * Set 'len' element of 'vary' beginning at 'pos' to duplications of 'el'.
X * Ok, if pos/len are past end of array.  If 'vary' is 0, a new array is
X * created.
X *
X * This does not zap previous values.  If you need that to happen, call
X * vazap first.  It does move the terminator around properly though.
X */
aELEMENT(*vafill());
X
/* aELEMENT(*vancpy(aELEMENT(*vary),int pos,aELEMENT(*array),int len));
X * Copy 'len' elements from 'array' onto 'vary' beginning at position 'pos'.
X * 'array' can be a normal char array since the length is passed seperately.  The
X * elements are copied, not duplicated.  A new array is created if 'vary' is
X * 0.  This does not zap previous elements.
X */
aELEMENT(*vancpy());
X
/* aELEMENT(*vandup(aELEMENT(*vary),int pos,aELEMENT(*array),int len));
X * Duplicate 'len' elements from 'array' onto 'vary' beginning at position
X * 'pos'.  'array' can be a char array since its length is passed seperately.  A
X * new array is created if 'vary' is 0.
X */
aELEMENT(*vandup());
X
/* aELEMENT(*vafield(aELEMENT(*vary),int pos,int len));
X * Make sure a field exists at 'pos' of length 'len'.  If there isn't one,
X * 'vary' is extended with blank elements.  This does not eliminate elements
X * which already exist in the field.  Use vazap for that.
X */
aELEMENT(*vafield());
X
/* aELEMENT(*vadup(aELEMENT(*vary)));
X * Duplicate array.  This is just a functionalized version of:
X *
X *   vandup(NULL,0,vary,aLEN(vary));
X *
X * but since you need to be able to refer to this particular function by
X * address often it's given here.
X *
X * (actually, there's bazillions of these simple combinations of the above
X * functions and the macros of the next section.  You'll probably want to make
X * functionalized instances of the ones you use most often - especially since
X * the macros aren't safe).
X */ 
aELEMENT(*vadup());
X
/* aELEMENT(*vaset(aELEMENT(*vary),int pos,aELEMENT(element)));
X * Set an element in an array.  Any value of 'pos' is valid.  A new array
X * is created if 'vary' is 0.  The previous contents of the position is
X * deleted.    This does not duplicate 'element'.  If you need 'element'
X * duplicated, call: vaset(vary,pos,adup(element));
X */
aELEMENT(*_vaset());
X
#define vaset(v,p,el)  \
X (!(v) || (p)>aLen(v) || (p)==aLen(v) && (p)==aSiz(v) ?  \
X  _vaset((v),(p),(el)) \
X : \
X  ((p)==aLen(v) ? \
X   ((v)[(p)+1]=(v)[p], (v)[p]=(el), aLen(v)=(p)+1, (v)) \
X  : \
X   (adel((v)[p]), (v)[p]=(el), (v)) \
X  ) \
X )   
X
/* aELEMENT(*vaadd(aELEMENT(*vary),aELEMENT(element)));
X * Concatenate a single element to the end of 'vary'.  A new array is created
X * if 'vary' is 0.  This does not duplicate element: call
X * vaadd(vary,adup(element));  If you need it duplicated.
X */
#define vaadd(v,el) \
X (!(v) || aLen(v)==aSiz(v) ? \
X  _vaset((v),aLEN(v),(el)) \
X : \
X  ((v)[aLen(v)+1]=(v)[aLen(v)], (v)[aLen(v)]=(el), \
X   aLen(v)=aLen(v)+1, (v)) \
X )
X
/**************************************/
/* Functions which read from an array */
/**************************************/
X
/* These macros are used to generate the address/size pairs which get
X * passed to the functions of the previous section.
X */
X
/* { aELEMENT(*),int } av(aELEMENT(*array));
X * Return array,size pair.  Uses aLEN to get size.
X */
#define av(a) (a),aLEN(a)
X
/* { aELEMENT(*),int } az(aELEMENT(*array));
X * Return array,size pair.  Uses alen to get size.
X */
#define az(a) (a),alen(a)
X
/* { aELEMENT(*),int } ac(aELEMENT(*array));
X * Return array,size pair.  Uses 'sizeof' to get size.
X */
#define ac(a) (a),(sizeof(a)/sizeof(aCAST))
X
/* { aELEMENT(*),int } arest(aELEMENT(*vary),int pos);
X * Return array,size pair of rest of array beginning at pos.  If
X * pos is past end of array, gives size of 0.
X */
#define arest(a,p) ((a)+(p)),(((p)>aLEN(a))?0:aLen(a)-(p))
X
/* { aELEMENT(*),int } apart(aELEMENT(*vary),int pos,int len);
X * Return array,size pair of 'len' elements of array beginning with pos.  If
X * pos is past end of array, gives size of 0.  If pos+len is past end of array,
X * returns number of elements to end of array.
X */
#define apart(a,p,l) \
X ((a)+(p)),((p)>=aLEN(a)?0:((p)+(l)>aLen(a)?aLen(a)-(p):(l)))
X
/* aELEMENT(vaget(aELEMENT(*vary),int pos));
X * Get an element from an array.  Any value of pos is valid; if it's past the
X * end of the array or if 'vary' is 0, the terminator is returned.  This
X * does not make a duplicate of the returned element.  If you want that, pass
X * the return value of this to adup.
X */
#define vaget(a,p) ((p)>=aLEN(a)?aterm:(a)[p])
X
/**********************/
/* Insertion/Deletion */
/**********************/
X
/* aELEMENT(*vains(aELEMENT(*vary),int pos,int n));
X * Insert n empty slots into the array.  If 'pos' >= the length of the array,
X * the array is simply extended.  The new slots are not set to anything.
X * This does not set the elements in the created hole to any particular
X * value: use vafill if you need that to occur.
X */
aELEMENT(*vains());
X
/* aELEMENT(*vadel(aELEMENT(*vary),int pos,int n));
X * Delete n slots from the array.  This does not zap the elements first; call
X * vazap first if you need this to happen.
X */
aELEMENT(*vadel());
X
/*************************/
/* Searching and Sorting */
/*************************/
X
/* aELEMENT(*vasort(aELEMENT(*ary),int len))
X * Sort the elements of an array (char or variable length) using qsort().
X */
aELEMENT(*vasort());
X
/* int vabsearch(aELEMENT(*ary),int len,aELEMENT(element));
X * Do a binary search on a sorted variable length or char array.  Returns position
X * of matching element or the position where the element should be if it was
X * not found.  (You should test with acmp to find out which).
X *
X * Hmm... this should really indicate whether or not the element was found.
X */
int vabsearch();
X
/* int vafirst(aELEMENT(*ary),int len,aELEMENT(element));
X * Find offset to first matching element in 'vary' or return ~0 if not found.
X */
int vafirst();
X
/* int valast(aELEMENT(*ary),int len,aELEMENT(element));
X * Find offset to last matching element in 'vary' or return ~0 if none found.
X */
int valast();
X
/* int vaa(aELEMENT(*a),int alen,aELEMENT(*b),int blen);
X * Do a substring search on 'a'.  Return offset from 'a' to first matching
X * occurance of 'b' in 'a' or return ~0 if none found.
X */
int vaa();
X
/* int vacmpn(aELEMENT(*a),int alen,aELEMENT(*b),int blen);
X *
X * Compare two arrays using acmp.  If 'a' > 'b', return 1.  If 'a' == 'b',
X * return 0.  If 'a' < 'b', return -1.  Longer strings are > shorter ones if
X * their beginning match.
X */
int vacmpn();
X
/* int vacmp(aELEMENT(*a),aELEMENT(*b));
X *
X * Functionalized version of: vacmpn(av(a),av(b));
X */
int vacmp();
X
/* int vascan(aELEMENT(*a),int alen,aELEMENT(*b),int blen);
X * Find offset of first matching element in 'a' which matches any
X * of the elements passed in 'b'.  Array 'b' must be sorted.
X *
X * Hmm... this really needs to return what the found element is.
X */
int vascan();
X
/* int vaspan(aELEMENT(*a),int alen,aELEMENT(*b),int blen);
X * Find offset of first matching element in 'a' which does not match any
X * of the elements passed in 'b'.  Array 'b' must be sorted.
X */
int vaspan();
X
/* aELEMENT(*vawords(aELEMENT(*a),char *s,int len,char *sep,int seplen));
X * Generate list of strings out of words in 's' seperated with the characters
X * in 'sep'.  The characters in 'sep' must be sorted.
X */
aELEMENT(*vawords());
X
/* aELEMENT(*vaiwords(aELEMENT(*a),char *s,int len,char *sep,int seplen));
X * Same as above, but you give the characters to be included in the words
X * instead of the seperators.
X */
aELEMENT(*vaiwords());
X
#endif
SHAR_EOF
chmod 0600 va.h ||
echo 'restore of va.h failed'
Wc_c="`wc -c < 'va.h'`"
test 11674 -eq "$Wc_c" ||
	echo 'va.h: original size 11674, current size' "$Wc_c"
fi
# ============= vfile.c ==============
if test -f 'vfile.c' -a X"$1" != X"-c"; then
	echo 'x - skipping vfile.c (File already exists)'
else
echo 'x - extracting vfile.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vfile.c' &&
/* Software virtual memory system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "config.h"
#include "vs.h"
#include "blocks.h"
#include "heap.h"
#include "queue.h"
#include "pathfunc.h"
#include "toomany.h"
#include "random.h"
#include "vfile.h"
X
static VFILE vfiles={{&vfiles,&vfiles}};	/* Known vfiles */
static VPAGE *freepages=0;	/* Linked list of free pages */
static VPAGE *htab[HTSIZE];	/* Hash table of page headers */
static long curvalloc=0;	/* Amount of memory in use */
static long maxvalloc= ILIMIT;	/* Maximum allowed */
char *vbase;			/* Data first entry in vheader refers to */
VPAGE **vheaders=0;		/* Array of header addresses */
static int vheadsz=0;		/* No. entries allocated to vheaders */
X
void vflsh()
{
VPAGE *vp;
VPAGE *vlowest;
long addr;
VFILE *vfile;
int x;
for(vfile=vfiles.link.next;
X    vfile!=&vfiles;
X    vfile=vfile->link.next)
X {
X loop:
X addr= MAXLONG;
X vlowest=0;
X for(x=0;x!=HTSIZE;x++)
X  for(vp=htab[x];vp;vp=vp->next)
X   if(vp->addr<addr && vp->dirty && vp->vfile==vfile && !vp->count)
X    addr=vp->addr, vlowest=vp;
X if(vlowest)
X  {
X  if(!vfile->name) vfile->name=mktmp("/tmp/");
X  if(!vfile->fd)
X   {
X   vfile->fd=Fopen(vfile->name);
X   }
X  Fseek(vfile->fd,addr);
X  if(addr+PGSIZE>vsize(vfile))
X   {
X   Fwrite(vfile->fd,vlowest->data,(int)(vsize(vfile)-addr));
X   vfile->size=vsize(vfile);
X   }
X  else
X   {
X   Fwrite(vfile->fd,vlowest->data,PGSIZE);
X   if(addr+PGSIZE>vfile->size) vfile->size=addr+PGSIZE;
X   }
X  vlowest->dirty=0;
X  goto loop;
X  }
X }
}
X
void vflshf(vfile)
VFILE *vfile;
{
VPAGE *vp;
VPAGE *vlowest;
long addr;
int x;
loop:
addr= MAXLONG;
vlowest=0;
for(x=0;x!=HTSIZE;x++)
X for(vp=htab[x];vp;vp=vp->next)
X  if(vp->addr<addr && vp->dirty && vp->vfile==vfile && !vp->count)
X   addr=vp->addr, vlowest=vp;
if(vlowest)
X {
X if(!vfile->name) vfile->name=mktmp("/tmp/");
X if(!vfile->fd)
X  {
X  vfile->fd=Fopen(vfile->name);
X  }
X Fseek(vfile->fd,addr);
X if(addr+PGSIZE>vsize(vfile))
X  {
X  Fwrite(vfile->fd,vlowest->data,(int)(vsize(vfile)-addr));
X  vfile->size=vsize(vfile);
X  }
X else
X  {
X  Fwrite(vfile->fd,vlowest->data,PGSIZE);
X  if(addr+PGSIZE>vfile->size) vfile->size=addr+PGSIZE;
X  }
X vlowest->dirty=0;
X goto loop;
X }
}
X
char *vlock(vfile,addr)
VFILE *vfile;
long addr;
{
VPAGE *vp, *pp;
int x,y;
int ofst=(addr&(PGSIZE-1));
addr-=ofst;
X
for(vp=htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)];vp;vp=vp->next)
X if(vp->vfile==vfile && vp->addr==addr) return ++vp->count, vp->data+ofst;
X
if(freepages)
X {
X vp=freepages;
X freepages=vp->next;
X goto gotit;
X }
X
if(curvalloc+PGSIZE<=maxvalloc)
X {
X vp=(VPAGE *)malloc(sizeof(VPAGE)*INC);
X if(vp)
X  {
X  vp->data=(char *)memalign(PGSIZE,PGSIZE*INC);
X  if(vp->data)
X   {
X   int q;
X   curvalloc+=PGSIZE*INC;
X   if(!vheaders)
X    vheaders=(VPAGE **)malloc((vheadsz=INC)*sizeof(VPAGE *)),
X    vbase=vp->data;
X   else
X    if(vp->data<vbase)
X     {
X     VPAGE **t=vheaders;
X     int amnt=(physical(vbase)-physical(vp->data))>>LPGSIZE;
X     vheaders=(VPAGE **)malloc((amnt+vheadsz)*sizeof(VPAGE *));
X     mcpy(vheaders+amnt,t,vheadsz*sizeof(VPAGE *));
X     vheadsz+=amnt;
X     vbase=vp->data;
X     free(t);
X     }
X    else if(((physical(vp->data+PGSIZE*INC)-physical(vbase))>>LPGSIZE)>vheadsz)
X     {
X     vheaders=(VPAGE **)realloc(vheaders,
X      (vheadsz=(((physical(vp->data+PGSIZE*INC)-physical(vbase))>>LPGSIZE)))*sizeof(VPAGE *));
X     }
X   for(q=1;q!=INC;++q)
X    {
X    vp[q].next=freepages;
X    freepages=vp+q;
X    vp[q].data=vp->data+q*PGSIZE;
X    vheader(vp->data+q*PGSIZE)=vp+q;
X    }
X   vheader(vp->data)=vp;
X   goto gotit;
X   }
X  free(vp);
X  vp=0;
X  }
X }
X
for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
X for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
X  if(!vp->count && !vp->dirty)
X   {
X   pp->next=vp->next;
X   goto gotit;
X   }
vflsh();
for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
X for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
X  if(!vp->count && !vp->dirty)
X   {
X   pp->next=vp->next;
X   goto gotit;
X   }
write(2,"Out of memory\r\n",15);
exit(1);
X
gotit:
vp->addr=addr;
vp->vfile=vfile;
vp->dirty=0;
vp->count=1;
vp->next=htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)];
htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)]=vp;
X
if(addr<vfile->size)
X {
X if(!vfile->fd)
X  {
X  vfile->fd=Fopen(vfile->name);
X  }
X Fseek(vfile->fd,addr);
X if(addr+PGSIZE>vfile->size)
X  {
X  Fread(vfile->fd,vp->data,(int)(vfile->size-addr));
X  mset(vp->data+vfile->size-addr,0,PGSIZE-(int)(vfile->size-addr));
X  }
X else Fread(vfile->fd,vp->data,PGSIZE);
X }
else mset(vp->data,0,PGSIZE);
X
return vp->data+ofst;
}
X
VFILE *vtmp()
{
VFILE *new=(VFILE *)malloc(sizeof(VFILE));
new->fd= 0;
new->name=0;
new->alloc=0;
new->size=0;
new->left=0;
new->lv=0;
new->vpage=0;
new->flags=1;
new->vpage1=0;
new->addr= -1;
return enqueb(VFILE,link,&vfiles,new);
}
X
VFILE *vopen(name)
char *name;
{
VFILE *new=(VFILE *)malloc(sizeof(VFILE));
new->name=vsncpy(NULL,0,sz(name));
new->fd=Fopen(name);
if(!new->fd)
X {
X fprintf(stderr,"Couldn\'t open \'%s\'\n",name);
X free(new);
X return 0;
X }
new->size=new->fd->size;
new->alloc=new->size;
new->left=0;
new->lv=0;
new->vpage=0;
new->flags=0;
new->vpage1=0;
new->addr= -1;
return enqueb(VFILE,link,&vfiles,new);
}
X
void vclose(vfile)
VFILE *vfile;
{
VPAGE *vp, *pp;
int x;
if(vfile->name)
X {
X if(vfile->flags) unlink(vfile->name);
X else vflshf(vfile);
X vsrm(vfile->name);
X }
if(vfile->fd) Fclose(vfile->fd);
free(deque(VFILE,link,vfile));
for(x=0;x!=HTSIZE;x++)
X for(pp=(VPAGE *)(htab+x), vp=pp->next;vp;)
X  if(vp->vfile==vfile)
X   {
X   pp->next=vp->next;
X   vp->next=freepages;
X   freepages=vp;
X   vp=pp->next;
X   }
X  else pp=vp, vp=vp->next;
}
X
/* this is now broken */
void vlimit(amount)
long amount;
{
VPAGE *vp, *pp;
int x,y;
maxvalloc=amount;
while(curvalloc>maxvalloc)
X if(freepages)
X  {
X  vp=freepages;
X  freepages=vp->next;
X  free(vp->data);
X  free(vp);
X  curvalloc-=PGSIZE;
X  }
X else
X  {
X  again:
X  for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
X   for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
X    if(!vp->count && !vp->dirty)
X     {
X     pp->next=vp->next;
X     free(vp->data);
X     free(vp);
X     if((curvalloc-=PGSIZE)<=maxvalloc) return;
X     goto again;
X     }
X  vflsh();
X  again1:
X  for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
X   for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
X    if(!vp->count && !vp->dirty)
X     {
X     pp->next=vp->next;
X     free(vp->data);
X     free(vp);
X     if((curvalloc-=PGSIZE)<=maxvalloc) return;
X     goto again1;
X     }
X  return;
X  }
}
X
long valloc(vfile,size)
VFILE *vfile;
long size;
{
long start=vsize(vfile);
vfile->alloc=start+size;
if(vfile->lv)
X {
X if(vheader(vfile->vpage)->addr+PGSIZE>vfile->alloc)
X  vfile->lv=PGSIZE-(vfile->alloc-vheader(vfile->vpage)->addr);
X else vfile->lv=0;
X }
return start;
}
X
void vseek(vfile,addr)
VFILE *vfile;
long addr;
{
vfile->alloc=vsize(vfile);
if(addr>vfile->alloc) vfile->alloc=addr;
if(!vfile->vpage) vfile->vpage=vlock(vfile,addr&~(long)(PGSIZE-1));
else if(vheader(vfile->vpage)->addr!=(addr&~(long)(PGSIZE-1)))
X {
X vunlock(vfile->vpage);
X vfile->vpage=vlock(vfile,addr&~(long)(PGSIZE-1));
X }
vfile->bufp=vfile->vpage+(addr&(PGSIZE-1));
vfile->left=vfile->vpage+PGSIZE-vfile->bufp;
if(vheader(vfile->vpage)->addr+PGSIZE>vfile->alloc)
X vfile->lv=PGSIZE-(vfile->alloc-vheader(vfile->vpage)->addr);
else vfile->lv=0;
}
X
int _vrgetc(vfile)
VFILE *vfile;
{
if(vtell(vfile)==0) return MAXINT;
vseek(vfile,vtell(vfile)-1);
++vfile->bufp;
--vfile->left;
return vrgetc(vfile);
}
X
int _vgetc(vfile)
VFILE *vfile;
{
if(vtell(vfile)==vsize(vfile)) return MAXINT;
vseek(vfile,vtell(vfile));
return vgetc(vfile);
}
X
int nmvgetc(v) VFILE *v; { return vgetc(v); } 
X
int _vputc(vfile,c)
VFILE *vfile;
char c;
{
vseek(vfile,vtell(vfile));
return vputc(vfile,c);
}
X
short vgetw(vfile)
VFILE *vfile;
{
short w;
if(vtell(vfile)+2>vsize(vfile)) return -1;
w=vgetc(vfile);
w+=((short)vgetc(vfile)<<8);
return w;
}
X
short vputw(vfile,w)
VFILE *vfile;
short w;
{
vputc(vfile,w);
vputc(vfile,w>>8);
return w;
}
X
long vgetl(vfile)
VFILE *vfile;
{
long w;
if(vtell(vfile)+4>vsize(vfile)) return -1;
w=vgetc(vfile);
w+=((long)vgetc(vfile)<<8);
w+=((long)vgetc(vfile)<<16);
w+=((long)vgetc(vfile)<<24);
return w;
}
X
long vputl(vfile,w)
VFILE *vfile;
long w;
{
vputc(vfile,w);
vputc(vfile,w>>8);
vputc(vfile,w>>16);
vputc(vfile,w>>24);
return w;
}
X
int _rc(vfile,addr)
VFILE *vfile;
long addr;
{
if(vfile->vpage1) vunlock(vfile->vpage1);
vfile->vpage1=vlock(vfile,vfile->addr=(addr&~(long)(PGSIZE-1)));
return rc(vfile,addr);
}
X
int _wc(vfile,addr,c)
VFILE *vfile;
long addr;
char c;
{
if(addr+1>vsize(vfile)) valloc(vfile,addr+1-vsize(vfile));
if(vfile->vpage1) vunlock(vfile->vpage1);
vfile->vpage1=vlock(vfile,vfile->addr=(addr&~(long)(PGSIZE-1)));
return wc(vfile,addr,c);
}
X
short rw(vfile,addr)
VFILE *vfile;
long addr;
{
short c;
if(addr+2>vsize(vfile)) return -1;
c=rc(vfile,addr);
c+=((short)rc(vfile,addr+1)<<8);
return c;
}
X
short ww(vfile,addr,c)
VFILE *vfile;
long addr;
short c;
{
if(addr+2>vsize(vfile)) valloc(vfile,addr+2-vsize(vfile));
wc(vfile,addr,c);
wc(vfile,addr+1,c>>8);
return c;
}
X
long rl(vfile,addr)
VFILE *vfile;
long addr;
{
long c;
if(addr+4>vsize(vfile)) return -1;
c=rc(vfile,addr);
c+=((long)rc(vfile,addr+1)<<8);
c+=((long)rc(vfile,addr+2)<<16);
c+=((long)rc(vfile,addr+3)<<24);
return c;
}
X
long wl(vfile,addr,c)
VFILE *vfile;
long addr;
long c;
{
if(addr+4>vsize(vfile)) valloc(vfile,addr+4-vsize(vfile));
wc(vfile,addr,c);
wc(vfile,addr+1,c>>8);
wc(vfile,addr+2,c>>16);
wc(vfile,addr+3,c>>24);
return c;
}
X
void vread(v,blk,size)
VFILE *v;
char *blk;
int size;
{
long addr=vtell(v);
char *src;
int x;
while(size)
X {
X src=vlock(v,addr);
X x=PGSIZE-(addr&(PGSIZE-1));
X if(x>=size)
X  {
X  vseek(v,addr+size);
X  mcpy(blk,src,size);
X  vunlock(src);
X  return;
X  }
X size-=x;
X addr+=x;
X mcpy(blk,src,x);
X blk+=x;
X vunlock(src);
X }
vseek(v,addr);
}
X
void vwrite(v,blk,size)
VFILE *v;
char *blk;
int size;
{
long addr=vtell(v);
char *src;
int x;
if(addr+size>vsize(v)) valloc(v,addr+size-vsize(v));
while(size)
X {
X src=vlock(v,addr);
X x=PGSIZE-(addr&(PGSIZE-1));
X if(x>=size)
X  {
X  vseek(v,addr+size);
X  mcpy(src,blk,size);
X  vchanged(src);
X  vunlock(src);
X  return;
X  }
X size-=x;
X addr+=x;
X mcpy(src,blk,x);
X blk+=x;
X vchanged(src);
X vunlock(src);
X }
vseek(v,addr);
}
X
/* Write string to vfile */
X
void vputs(v,s)
VFILE *v;
char *s;
{
while(*s) vputc(v,*s), ++s;
}
X
/* Read a line from a file */
X
char *vgets(v,s)
VFILE *v;
char *s;
{
int c;
int x=0;
if(!sSIZ(s)) s=vstrunc(s,0);
while(c=vgetc(v), c!= MAXINT && c!='\n')
X {
X if(x==sSiz(s)) s=vsensure(s,x+10);
X s[x++]=c;
X }
if(x==sSiz(s)) s=vsensure(s,x+1);
sLen(s)=x;
s[x]=0;
return s;
}
SHAR_EOF
chmod 0600 vfile.c ||
echo 'restore of vfile.c failed'
Wc_c="`wc -c < 'vfile.c'`"
test 11446 -eq "$Wc_c" ||
	echo 'vfile.c: original size 11446, current size' "$Wc_c"
fi
# ============= vfile.h ==============
if test -f 'vfile.h' -a X"$1" != X"-c"; then
	echo 'x - skipping vfile.h (File already exists)'
else
echo 'x - extracting vfile.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vfile.h' &&
/* Software virtual memory system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ivfile
#define _Ivfile 1
X
#include "config.h"
#include "queue.h"
#include "toomany.h"
X
typedef struct vpage VPAGE;
typedef struct vfile VFILE;
X
#define PGSIZE 1024		/* Page size in bytes (Must be power of 2) */
#define LPGSIZE 10		/* LOG base 2 of PGSIZE */
#define ILIMIT (PGSIZE*256)	/* Max amount to buffer */
#define HTSIZE 256		/* Entries in hash table.  Must be pwr of 2 */
#define INC 8			/* Pages to allocate each time */
X
/* Page header */
X
struct vpage
X {
X VPAGE *next;			/* Next page with same hash value */
X VFILE *vfile;			/* Owner vfile */
X long addr;			/* Address of this page */
X int count;			/* Reference count */
X int dirty;			/* Set if page changed */
X char *data;			/* The data in the page */
X };
X
/* File structure */
X
struct vfile
X {
X LINK(VFILE) link;		/* Doubly linked list of vfiles */
X long size;			/* Number of bytes in physical file */
X long alloc;			/* Number of bytes allocated to file */
X File *fd;			/* Physical file */
X int writeable;			/* Set if we can write */
X char *name;			/* File name.  0 if unnamed */
X int flags;			/* Set if this is only a temporary file */
X
X /* For array I/O */
X char *vpage1;			/* Page address */
X long addr;			/* File address of above page */
X
X /* For stream I/O */
X char *bufp;			/* Buffer pointer */
X char *vpage;			/* Buffer pointer points in here */
X int left;			/* Space left in bufp */
X int lv;				/* Amount of append space at end of buffer */
X };
X
extern char *vbase;		/* Data first entry in vheader refers to */
extern VPAGE **vheaders;	/* Array of headers */
X
/* VFILE *vtmp(V);
X *
X * Open a temporary virtual file.  File goes away when closed.  No actual
X * file is generated if everything fits in memory.
X */
VFILE *vtmp();
X
/* VFILE *vopen(char *name);
X *
X * Open a file for reading and if possible, writing.  If the file could not
X * be opened, NULL is returned.
X */
VFILE *vopen();
X
/* long vsize(VFILE *);
X *
X * Return size of file
X */
X
#define vsize(vfile) \
X	( \
X	  (vfile)->left<(vfile)->lv ? \
X	    (vfile)->alloc+(vfile)->lv-(vfile)->left \
X	  : \
X	    (vfile)->alloc \
X	)
X
/* void vclose(VFILE *vfile);
X *
X * Close a file.
X */
void vclose();
X
/* void vlimit(long amount);
X *
X * Set limit (in bytes) on amount of memory the virtual file system may
X * use.  This limit can be exceeded if all existing vpages are being referenced
X * and a new vpage is requested.
X *
X * When vlimit is called, the limit is immediatly enforced by elimiting
X * non-referenced vpages.
X */
X
void vlimit();
X
/* void vflsh(void); 
X *
X * Write all changed pages to the disk
X */
X
void vflsh();
X
/* void vflshf(VFILE *vfile);
X *
X * Write changed pages for a specific file to the disk
X */
X
void vflshf();
X
/* char *vlock(VFILE *vfile,long addr);
X *
X * Translate virtual address to physical address.  'addr' does not have
X * to be on any particular alignment, but if you wish to access more than
X * a single byte, you have to be aware of where page boundaries are (virtual
X * address multiples of PGSIZE).
X *
X * The page containing the data is locked in memory (so that it won't be
X * freed or used for something else) until 'vunlock' is used.
X *
X * Warning:  If you allocate more than one page and use (change) them out of
X * order, vflsh will screw up if writing past the end of a file is illegal
X * in the host filesystem.
X *
X * Also:  This function does not allocate space to the file.  Use valloc()
X * for that.  You can vlock() pages past the allocated size of the file, but
X * be careful when you do this (you normally shouldn't- the only time you
X * ever might want to is to implement your own version of valloc()).
X */
X
char *vlock();
X
/* VPAGE *vheader(char *);
X * Return address of page header for given page
X */
X
#define vheader(p) (vheaders[(physical((char *)(p))-physical(vbase))>>LPGSIZE])
X
/* void vchanged(char *);
X *
X * Indicate that a vpage was changed so that it will be written back to the
X * file.  Any physical address which falls within the page may be given.
X */
X
#define vchanged(vpage) ( vheader(vpage)->dirty=1 )
X
/* void vunlock(char *);
X * Unreference a vpage (call one vunlock for every vlock)
X * Any physical address which falls within the page may be given.
X */
X
#define vunlock(vpage)  ( --vheader(vpage)->count )
X
/* void vupcount(char *);
X * Indicate that another reference is being made to a vpage
X */
X
#define vupcount(vpage) ( ++vheader(vpage)->count )
X
/* long valloc(VFILE *vfile,long size);
X *
X * Allocate space at end of file
X *
X * Returns file address of beginning of allocated space
X */
X
long valloc();
X
/******************************************************************************
X * The folloing functions implement stream I/O on top of the above software   *
X * virtual memory system                                                      *
X ******************************************************************************/
X
/* void vseek(VFILE *vfile,long addr);
X *
X * Seek to a file address.  Allocates space to the file if you seek past the
X * end.
X */
void vseek();
X
/* int vrgetc(VFILE *);
X * int vgetc(VFILE *);
X *
X * Get next character / Get previous character functions.
X * They return MAXINT for end of file / beginning of file.
X */
X
int _vgetc();
int _vrgetc();
X
#define vrgetc(v) \
X        ( (v)->left!=PGSIZE ? ( ++(v)->left, (int)(unsigned)*(--(v)->bufp) ) : _vrgetc(v) )
X
#define vgetc(v) \
X	( (v)->left>(v)->lv ? ( --(v)->left, (int)(unsigned)*((v)->bufp++) ) : _vgetc(v) )
X
/* int vputc(VFILE *,I);
X *
X * Put character.  Returns character which is written.
X */
X
int _vputc();
X
#define vputc(v,c) \
X	( \
X	  (v)->left ? \
X	   ( \
X	   --(v)->left, \
X	   vchanged((v)->vpage), \
X 	   (int)(unsigned)(*((v)->bufp++)=(c)) \
X	   ) \
X	  : \
X	   _vputc((v),(c)) \
X	)
X
/* long vtell(VFILE *);
X *
X * Return current file position
X */
X
#define vtell(v) \
X	( \
X	 (v)->vpage ? \
X	  ( vheader((v)->vpage)->addr+(v)->bufp-(v)->vpage ) \
X	 : \
X	  0L \
X	)
X
/* long vgetl(VFILE *);
X *
X * Get long.  No alignment requirements.  Returns -1 if goes past end of file.
X */
X
long vgetl();
X
/* short vgetw(VFILE *);
X *
X * Get short.  No alignment requirements.  Returns -1 if goes past end of file.
X */
X
short vgetw();
X
/* long vputl(VFILE *,long);
X *
X * Put long.  No alignment requirements.
X * Returns value written.
X */
X
long vputl();
X
/* short vputw(VFILE *,short);
X *
X * Put long.  No alignement requirements.
X * Returns value written.
X */
X
short vputw();
X
/* char *vgets(VFILE *v,char *s,U p);
X *
X * Read line into a variable length string beginning at 'p'.  If 's' is 0, a
X * new string is created.  The \n is not copied into the string.
X *
X * This requires that you use the 'vs.h' / 'vs.c' library.
X */
X
char *vgets();
X
/* void vputs(VFILE *v,char *s);
X *
X * Write string. \n is not appended */
X
void vputs();
X
/* void vread(VFILE *,char *,U size);
X *
X * Read bytes from a virtual file into a local data block
X */
X
void vread();
X
/* void vwrite(VFILE *,char *,U size);
X *
X * Write bytes from a local data block into a virtual file
X */
X
void vwrite();
X
/*************************************************************************** 
X * The following functions implement array I/O on top of the above virtual *
X * memory system (cheap memory mapped files)                               *
X ***************************************************************************/
X
/* int rc(VFILE *vfile,long addr);
X *
X * Read character.  Returns MAXINT if past end of file.
X */
X
int _rc();
X
#define rc(v,a) \
X	( \
X	  (a)>=vsize(v) ? MAXINT : \
X	    ( \
X	      (v)->addr==((a)&~(PGSIZE-1)) ? \
X	       (v)->vpage1[(a)&(PGSIZE-1)] \
X	      : \
X	       _rc((v),(a)) \
X	    ) \
X	)
X
/* int wc(VFILE *vfile,long addr,char c);
X *
X * Write character.  Return character written.  This automatically allocates
X * space to the file.
X */
X
int _wc();
X
#define wc(v,a,c) \
X	( \
X	  (v)->addr==((a)&~(PGSIZE-1)) ? \
X	   ( \
X	   vheader((v)->vpage1)->dirty=1, \
X	   ((a)+1>vsize(v) && valloc(v,(a)+1-vsize(v))), \
X	   (v)->vpage1[(a)&(PGSIZE-1)]=(c) \
X	   ) \
X	  : \
X	   _wc((v),(a),(c)) \
X	)
X
/* long rl(VFILE *vfile,long addr);
X * Read big-endian long.  No alignment requirements.  Returns -1 if goes past
X * end of file.
X */
X
long rl();
X
/* long wl(VFILE *vfile,long addr,long c);
X * Write big-endian long.  No alignment requirements.  Automatically expands
X * file if necessary.
X */
X
long wl();
X
/* short rw(VFILE *vfile,long addr);
X * Read big-endian short.  No alignment requirements.  Returns -1 if goes past
X * end of file.
X */
X
short rw();
X
/* short ww(VFILE *vfile,long addr,short c);
X * Write big-endian short.  No alignment requirements.  Automatically expands
X * file if necessary.
X */
X
short ww();
X
#endif
SHAR_EOF
chmod 0600 vfile.h ||
echo 'restore of vfile.h failed'
Wc_c="`wc -c < 'vfile.h'`"
test 9358 -eq "$Wc_c" ||
	echo 'vfile.h: original size 9358, current size' "$Wc_c"
fi
# ============= vs.c ==============
if test -f 'vs.c' -a X"$1" != X"-c"; then
	echo 'x - skipping vs.c (File already exists)'
else
echo 'x - extracting vs.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vs.c' &&
/* Variable length strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include <varargs.h>
#include "config.h"
#include "heap.h"
#include "zstr.h"
#include "blocks.h"
#include "vs.h"
X
int sicmp(a,b)
char a,b;
{
if(a>='A' || a<='Z') a+='a'-'A';
if(b>='A' || b<='Z') b+='a'-'A';
return scmp(a,b);
}
X
sELEMENT(*vsmk(len))
int len;
{
int *new=(int *)malloc((1+len)*sizeof(sCAST)+2*sizeof(int));
new[0]=len;
new[1]=0;
((sELEMENT(*))(new+2))[0]=sdup(sterm);
return (sELEMENT(*))(new+2);
}
X
void vsrm(vary)
sELEMENT(*vary);
{
if(vary) free((int *)vary-2);
}
X
int slen(ary)
sELEMENT(*ary);
{
if(ary)
X {
X sELEMENT(*beg)=ary;
X while(scmp(*ary,sterm)) ++ary;
X return ary-beg;
X }
else return 0;
}
X
sELEMENT(*vsensure(vary,len))
sELEMENT(*vary);
int len;
{
if(!vary) vary=vsmk(len);
else if(len>sSiz(vary))
X {
X int x;
X len+=(len>>2);
X vary=(sELEMENT(*))(2+(int *)realloc(
X       (int *)vary-2,(len+1)*sizeof(sCAST)+2*sizeof(int) ));
X sSiz(vary)=len;
X }
return vary;
}
X
sELEMENT(*vszap(vary,pos,n))
sELEMENT(*vary);
int pos,n;
{
return vary;
}
X
sELEMENT(*vstrunc(vary,len))
sELEMENT(*vary);
int len;
{
if(!vary || len>sLEN(vary)) vary=vsensure(vary,len);
if(len<sLen(vary))
X {
X vary[len]=vary[sLen(vary)];
X sLen(vary)=len;
X }
else if(len>sLen(vary))
X {
X vary=vsfill(vary,sLen(vary),sblank,len-sLen(vary));
X }
return vary;
}
X
sELEMENT(*vsfill(vary,pos,el,len))
sELEMENT(*vary);
sELEMENT(el);
int pos,len;
{
int olen=sLEN(vary), x;
if(!vary || pos+len>sSIZ(vary))
X vary=vsensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X sLen(vary)=pos+len;
X }
for(x=pos;x!=pos+len;++x) vary[x]=sdup(el);
if(pos>olen) vary=vsfill(vary,pos,sblank,pos-olen);
return vary;
}
X
sELEMENT(*vsncpy(vary,pos,array,len))
sELEMENT(*vary);
sELEMENT(*array);
int pos, len;
{
int olen=sLEN(vary);
if(!vary || pos+len>sSIZ(vary)) vary=vsensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X sLen(vary)=pos+len;
X }
if(pos>olen) vary=vsfill(vary,olen,sblank,pos-olen);
mfwrd(vary+pos,array,len*sizeof(sCAST));
return vary;
}
X
sELEMENT(*vsndup(vary,pos,array,len))
sELEMENT(*vary);
sELEMENT(*array);
int pos, len;
{
int olen=sLEN(vary), x;
if(!vary || pos+len>sSIZ(vary)) vary=vsensure(vary,pos+len);
if(pos+len>olen)
X {
X vary[pos+len]=vary[olen];
X sLen(vary)=pos+len;
X }
if(pos>olen) vary=vsfill(vary,olen,sblank,pos-olen);
for(x=pos;x!=len;++x) vary[x]=sdup(array[x]);
return vary;
}
X
sELEMENT(*vsfield(vary,pos,len))
sELEMENT(*vary);
int pos,len;
{
if(pos+len>sLEN(vary)) vary=vstrunc(vary,pos,len);
return vary;
}
X
sELEMENT(*vsdup(vary))
sELEMENT(*vary);
{
return vsndup(NULL,0,vary,sLEN(vary));
}
X
sELEMENT(*_vsset(vary,pos,el))
sELEMENT(*vary);
sELEMENT(el);
int pos;
{
if(!vary || pos+1>sSIZ(vary)) vary=vsensure(vary,pos+1);
if(pos>sLen(vary))
X {
X vary=vsfill(vary,sLen(vary),sblank,pos-sLen(vary));
X vary[pos+1]=vary[pos];
X vary[pos]=el;
X sLen(vary)=pos+1;
X }
else if(pos==sLen(vary))
X {
X vary[pos+1]=vary[pos];
X vary[pos]=el;
X sLen(vary)=pos+1;
X }
else
X {
X sdel(vary[pos]);
X vary[pos]=el;
X }
return vary;
}
X
sELEMENT(*vsins(vary,pos,n))
sELEMENT(*vary);
int pos,n;
{
if(!vary || sLEN(vary)+n>sSIZ(vary)) vary=vsensure(vary,sLEN(vary)+n);
if(pos>=sLen(vary)) vary=vstrunc(vary,pos+n);
else
X {
X mbkwd(vary+pos+n,vary+pos,sLen(vary)-(pos+n)+1);
X sLen(vary)+=n;
X }
return vary;
}
X
sELEMENT(*vsdel(vary,pos,n))
sELEMENT(*vary);
int pos,n;
{
if(pos>=sLEN(vary)) return vary;
if(pos+n>=sLen(vary)) return vstrunc(vary,pos);
mfwrd(vary+pos,vary+pos+n,sLen(vary)-(pos+n)+1);
sLen(vary)-=n;
return vary;
}
X
int _scmp(a,b)
sELEMENT(a);
sELEMENT(b);
{
return scmp(a,b);
}
X
sELEMENT(*vssort(ary,len))
sELEMENT(*ary);
int len;
{
if(!ary || !len) return ary;
qsort(ary,len,sizeof(sCAST),_scmp);
return ary;
}
X
int vsbsearch(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x,y,z;
if(!ary || !len) return 0;
y=len;
x=0;
z=~0;
while(z!=(x+y)/2)
X {
X z=(x+y)/2;
X switch(scmp(el,ary[z]))
X  {
X case  1: x=z; break;
X case -1: y=z; break;
X case  0: return z;
X  }
X }
return y;
}
X
int vsfirst(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x;
if(!ary || !len) return ~0;
for(x=0;x!=len;++x) if(!scmp(ary[x],el)) return x;
return ~0;
}
X
int vslast(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x=len;
if(!ary || !len) return ~0;
do
X {
X --x;
X if(!scmp(ary[x],el)) return x;
X }
X while(x);
return ~0;
}
X
int vscmpn(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x,l;
int t;
if(!a && !b) return 0;
if(!a) return -1;
if(!b) return 1;
if(alen>blen) l=sLen(a);
else l=blen;
for(x=0;x!=l;++x) if(t=scmp(a[x],b[x])) return t;
if(alen>blen) return  1;
if(alen<blen) return -1;
return 0;
}
X
int vscmp(a,b)
sELEMENT(*a);
sELEMENT(*b);
{
return vscmpn(sv(a),sv(b));
}
X
int vsicmpn(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x,l;
int t;
if(!a && !b) return 0;
if(!a) return -1;
if(!b) return 1;
if(alen>blen) l=sLen(a);
else l=blen;
for(x=0;x!=l;++x) if(t=sicmp(a[x],b[x])) return t;
if(alen>blen) return  1;
if(alen<blen) return -1;
return 0;
}
X
int vsicmp(a,b)
sELEMENT(*a);
sELEMENT(*b);
{
return vsicmpn(sv(a),sv(b));
}
X
int vss(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
if(!a && !b) return 0;
if(!a || !b) return ~0;
if(alen<blen) return ~0;
if(!blen) return 0;
for(x=0;x!=alen-blen;++x) if(!vscmpn(a,blen,b,blen)) return x;
return ~0;
}
X
int vsscan(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
X {
X int z=vsbsearch(b,blen,a[x]);
X if(z<blen && !scmp(b[z],a[x])) return x;
X }
return ~0;
}
X
int vsspan(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
X {
X int z=vsbsearch(b,blen,a[x]);
X if(z==blen || scmp(b[z],a[x])) break;
X }
return x;
}
X
sELEMENT(*vsread(d,p,getC,ptr))
sELEMENT(*d);
int (*getC)();
int p;
void *ptr;
{
int c;
if(!d) d=vsmk(10);
c=getC(ptr);
if(c== MAXINT) { vsrm(d); return 0; }
else if(c== '\n') return d;
else d=vsset(d,p,c), p++; 
while(c=getC(ptr), c!= MAXINT && c!= '\n') d=vsset(d,p,c), p++;
return d;
}
X
sELEMENT(*vwords(s,a,len,t))
char **a, *s, t;
int len;
{
int x;
if(!s) s=vsmk(32);
else s=vstrunc(s,0);
for(x=0;x!=len;++x)
X {
X s=vsncpy(s,sLEN(s),sz(a[x]));
X if(a[1]) vsadd(s,t);
X }
return s;
}
X
/* Subroutine to generate a single numeric field */
X
#define _space 1
#define _plus 2
#define _minus 4
#define _long 8
#define _prec 16
#define _base 32
#define _field 64
#define _signed 128
#define _upper 256
X
static char _CVV[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static char _cvv[]="0123456789abcdefghijklmnopqrstuvwxyz";
X
static int _cvt(ts,base,flag,n)
char *ts;
int base,flag;
unsigned long n;
{
int x,y=0;
char ary[64], *cv=flag&_upper?_CVV:_cvv;
X
if(flag&_signed)
X {
X if(!(flag&_long)) n=(long)(int)n;
X if((long)n<0)
X  {
X  ts[y++]='-';
X  n= -n;
X  goto skip;
X  }
X }
if(flag&_plus) ts[y++]='+';
if(flag&_space) ts[y++]=' ';
skip:
X
x=0;
do ary[x++]=cv[n%base]; while(n/=base);
while(x) ts[y++]=ary[--x];
return y;
}
X
/* Variable length string printf */
X
char *vsfmt(va_alist)
va_dcl
{
va_list pvar;
char *s, *fmt;	/* Input string / Format string */
int n=0;		/* Index into s: where next char goes */
int ssz;		/* Needed size for s */
char c;
int y;
int flag;		/* Flag bits for a conversion */
int extra;
int base;		/* Base of a conversion */
int field;	/* Field width */
int precision;
int tmp;
char *poi;
char ts[66];
X
va_start(pvar);
s=va_arg(pvar,char *);
fmt=va_arg(pvar,char *);
X
ssz=slen(fmt);
X
if(!s) s=vsmk(ssz);
else s=vsensure(s,ssz);
X
while(c= *fmt++)
X if(c=='%')
X  {
X  flag=0;
X  base=0;
X  field=0;
X  precision=0;
X up:
X  if(!(c= *fmt++)) goto done;
X  if(c==' ') { flag|=_space; goto up; }
X  if(c=='+') { flag|=_plus; goto up; }
X  if(c=='-') { flag|=_minus; goto up; }
X up1:
X  if(c>='0' && c<='9')
X   {
X   flag|=_base;
X   base=base*10+c-'0';
X   if(!(c= *fmt++)) goto done;
X   goto up1;
X   }
X  if(c=='_') if(!(c= *fmt++)) goto done;
X  else goto down1;
X up2:
X  if(c>='0' && c<='9')
X   {
X   flag|=_field;
X   field=field*10+c-'0';
X   if(!(c= *fmt++)) goto done;
X   goto up2;
X   }
X down1:
X  if(c=='.') if(!(c= *fmt++)) goto done;
X  else goto down2;
X up3:
X  if(c>='0' && c<='9')
X   {
X   flag|=_prec;
X   precision=precision*10+c-'0';
X   if(!(c= *fmt++)) goto done;
X   goto up3;
X   }
X down2:
X  if(c=='l')
X   {
X   flag|=_long;
X   if(!(c= *fmt++)) goto done;
X   }
X  if(!(flag&_base)) base=10;
X  if(!(flag&_prec)) precision=1;
X  switch(c)
X   {
X  case 'd':
X   flag|=_signed;
X   goto dn;
X  case 'D':
X   flag|=_signed+_upper;
X   goto dn;
X  case 'U':
X   flag|=_upper;
X   goto dn;
X  case 'u':
X  dn:
X   y=_cvt(ts,base,flag,(unsigned long)
X                        (flag&_long?va_arg(pvar,long):va_arg(pvar,int)));
X   if(ts[0]==' '||ts[0]=='+'|| ts[0]=='-') extra=1;
X   else extra=0;
X   ssz+=Umax(field,tmp=Umax(precision+extra,y))-2;
X   s=vsensure(s,ssz);
X   if(flag&_minus)
X    {
X    if(extra) s[n++]=ts[0];
X    if(precision>y-extra)
X     {
X     mset(s+n,'0',precision-y);
X     n+=precision-y+extra;
X     }
X    mcpy(s+n,ts+extra,y-extra);
X    n+=y-extra;
X    if(field>tmp)
X     {
X     mset(s+n,' ',field-tmp);
X     n+=field-tmp;
X     }
X    }
X   else
X    {
X    if(field>tmp)
X     {
X     mset(s+n,' ',field-tmp);
X     n+=field-tmp;
X     }
X    if(extra) s[n++]=ts[0];
X    if(precision>y-extra)
X     {
X     mset(s+n,'0',precision-y+extra);
X     n+=precision-y+extra;
X     }
X    mcpy(s+n,ts+extra,y-extra);
X    n+=y-extra;
X    }
X   break;
X  case 'c':
X   ssz+=Umax(1,field)-2;
X   s=vsensure(s,ssz);
X   if(flag&_minus)
X    {
X    s[n++]= (flag&_long?va_arg(pvar,long):va_arg(pvar,int));
X    if(field>1)
X     {
X     mset(s+n,' ',field-1);
X     n+=field-1;
X     }
X    }
X   else
X    {
X    if(field>1)
X     {
X     mset(s+n,' ',field-1);
X     n+=field-1;
X     }
X    s[n++]= (flag&_long?va_arg(pvar,long):va_arg(pvar,int));
X    }
X   break;
X  case 's':
X   poi= va_arg(pvar,char *);
X   extra= slen(poi);
X   if(flag&_prec) extra=Umin(precision,extra);
X   ssz+=Umax(field,extra);
X   s=vsensure(s,ssz);
X   if(flag&_minus)
X    {
X    mcpy(s+n,poi,extra);
X    n+=extra;
X    if(field>extra)
X     {
X     mset(s+n,' ',field-extra);
X     n+=field-extra;
X     }
X    }
X   else
X    {
X    if(field>extra)
X     {
X     mset(s+n,' ',field-extra);
X     n+=field-extra;
X     }
X    mcpy(s+n,poi,extra);
X    n+=extra;
X    }
X   break;
X  case '%': s[n++]='%';
X   }
X  }
X else s[n++]=c;
X
done:
va_end(pvar);
sLen(s)=n;
s[n]=0;
return s;
}
SHAR_EOF
chmod 0600 vs.c ||
echo 'restore of vs.c failed'
Wc_c="`wc -c < 'vs.c'`"
test 10956 -eq "$Wc_c" ||
	echo 'vs.c: original size 10956, current size' "$Wc_c"
fi
# ============= vs.h ==============
if test -f 'vs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping vs.h (File already exists)'
else
echo 'x - extracting vs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vs.h' &&
/* Variable length strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Ivs
#define _Ivs
X
#include "config.h"
X
/* Functions and global variable you have to define.  Replace these with
X * macros or defines here if they are not to be actual functions 
X */
X
#define sELEMENT(a) char a
#define sCAST char
/* sELEMENT(sdup()); */
#define sdup(a) (a)
/* sELEMENT(sdel()); */
#define sdel(a) 0
/* int scmp(); */
#define scmp(a,b) ((a)>(b)?1:((a)==(b)?0:-1))
X
int sicmp();
X
/* extern sELEMENT(sblank); */
#define sblank ' '
/* extern sELEMENT(sterm); */
#define sterm '\0'
X
/************************/
/* Creation/Destruction */
/************************/
X
/* sELEMENT(*vsmk(int len));
X * Create a variable length array.  Space for 'len' elements is preallocated.
X */
sELEMENT(*vsmk());
X
/* void vsrm(sELEMENT(*vary));
X * Free an array and everything which is in it.  Does nothing if 'vary' is
X * 0.
X */
void vsrm();
X
/********************/
/* Space management */
/********************/
X
/* int sSIZ(sELEMENT(*vary));
X * int sSiz(sELEMENT(*vary));
X * Access size part of array.  This int indicates the number of elements which
X * can fit in the array before realloc needs to be called.  It does not include
X * the extra space needed for the terminator and the header.
X *
X * sSIZ returns 0 if you pass it 0.  sSiz does not do this checking,
X * but can be used as an lvalue.
X */
#define sSIZ(a) ((a)?*((int *)(a)-2):0)
#define sSiz(a) (*((int *)(a)-2))
X
/* int sLEN(sELEMENT(*vary));
X * int sLen(sELEMENT(*vary));
X * Access length part of array.  This int indicates the number of elements
X * currently in the array (not including the terminator).  This should be
X * used primarily for reading the size of the array.  It can be used for
X * setting the size of the array, but it must be used with care since it
X * does not eliminate elements (if the size decreases) or make sure there's
X * enough room (if the size increases).  See vensure and vtrunc.
X *
X * sLEN return a length of zero if 'vary' is 0.
X * sLen doesn't do this checking, but can be used as an lvalue
X */
#define sLEN(a) ((a)?*((int *)(a)-1):0)
#define sLen(a) (*((int *)(a)-1))
X
/* int slen(sELEMENT(*ary));
X * Compute length of char or variable length array by searching for termination
X * element.  Returns 0 if 'vary' is 0.
X */
int slen();
X
/* sELEMENT(*vsensure(sELEMENT(*vary),int len));
X * Make sure there's enough space in the array for 'len' elements.  Whenever
X * vsensure reallocs the array, it allocates 25% more than the necessary
X * minimum space in anticipation of future expansion.  If 'vary' is 0,
X * it creates a new array.
X */
sELEMENT(*vsensure());
X
/* sELEMENT(*vszap(sELEMENT(*vary),int pos,int n));
X * Destroy n elements from an array beginning at pos.  Is ok if pos/n go
X * past end of array.  This does not change the sLEN() value of the array.
X * This does nothing and returns 0 if 'vary' is 0.  Note that this
X * function does not actually write to the array.  This does not stop if
X * a sterm is encountered.
X */
sELEMENT(*vszap());
X
/* sELEMENT(*vstrunc(sELEMENT(*vary),int len));
X * Truncate array to indicated size.  This zaps or expands with blank elements
X * and sets the LEN() of the array.  A new array is created if 'vary' is 0.
X */
sELEMENT(*vstrunc());
X
/************************************/
/* Function which write to an array */
/************************************/
X
/* sELEMENT(*vsfill(sELEMENT(*vary),int pos,sELEMENT(el),int len));
X * Set 'len' element of 'vary' beginning at 'pos' to duplications of 'el'.
X * Ok, if pos/len are past end of array.  If 'vary' is 0, a new array is
X * created.
X *
X * This does not zap previous values.  If you need that to happen, call
X * vszap first.  It does move the terminator around properly though.
X */
sELEMENT(*vsfill());
X
/* sELEMENT(*vsncpy(sELEMENT(*vary),int pos,sELEMENT(*array),int len));
X * Copy 'len' elements from 'array' onto 'vary' beginning at position 'pos'.
X * 'array' can be a normal char array since the length is passed seperately.  The
X * elements are copied, not duplicated.  A new array is created if 'vary' is
X * 0.  This does not zap previous elements.
X */
sELEMENT(*vsncpy());
X
/* sELEMENT(*vsndup(sELEMENT(*vary),int pos,sELEMENT(*array),int len));
X * Duplicate 'len' elements from 'array' onto 'vary' beginning at position
X * 'pos'.  'array' can be a char array since its length is passed seperately.  A
X * new array is created if 'vary' is 0.
X */
sELEMENT(*vsndup());
X
/* sELEMENT(*vsfield(sELEMENT(*vary),int pos,int len));
X * Make sure a field exists at 'pos' of length 'len'.  If there isn't one,
X * 'vary' is extended with blank elements.  This does not eliminate elements
X * which already exist in the field.  Use vszap for that.
X */
sELEMENT(*vsfield());
X
/* sELEMENT(*vsdup(sELEMENT(*vary)));
X * Duplicate array.  This is just a functionalized version of:
X *
X *   vsndup(NULL,0,vary,sLEN(vary));
X *
X * but since you need to be able to refer to this particular function by
X * address often it's given here.
X *
X * (actually, there's bazillions of these simple combinations of the above
X * functions and the macros of the next section.  You'll probably want to make
X * functionalized instances of the ones you use most often - especially since
X * the macros aren't safe).
X */ 
sELEMENT(*vsdup());
X
/* sELEMENT(*vsset(sELEMENT(*vary),int pos,sELEMENT(element)));
X * Set an element in an array.  Any value of 'pos' is valid.  A new array
X * is created if 'vary' is 0.  The previous contents of the position is
X * deleted.    This does not duplicate 'element'.  If you need 'element'
X * duplicated, call: vsset(vary,pos,sdup(element));
X */
sELEMENT(*_vsset());
X
#define vsset(v,p,el)  \
X (!(v) || (p)>sLen(v) || (p)>=sSiz(v) ?  \
X  _vsset((v),(p),(el)) \
X : \
X  ((p)==sLen(v) ? \
X   ((v)[(p)+1]=0, sLen(v)=(p)+1, (v)[p]=(el), (v)) \
X  : \
X   ((v)[p]=(el), (v)) \
X  ) \
X )   
X
/* sELEMENT(*vsadd(sELEMENT(*vary),sELEMENT(element)));
X * Concatenate a single element to the end of 'vary'.  A new array is created
X * if 'vary' is 0.  This does not duplicate element: call
X * vsadd(vary,sdup(element));  If you need it duplicated.
X */
#define vsadd(v,el) \
X (!(v) || sLen(v)==sSiz(v) ? \
X  _vsset((v),sLEN(v),(el)) \
X : \
X  ((v)[sLen(v)+1]=0, (v)[sLen(v)]=(el), sLen(v)=sLen(v)+1, (v)) \
X )
X
/**************************************/
/* Functions which read from an array */
/**************************************/
X
/* These macros are used to generate the address/size pairs which get
X * passed to the functions of the previous section.
X */
X
/* { sELEMENT(*),int } sv(sELEMENT(*array));
X * Return array,size pair.  Uses sLEN to get size.
X */
#define sv(a) (a),sLEN(a)
X
/* { sELEMENT(*),int } sz(sELEMENT(*array));
X * Return array,size pair.  Uses slen to get size.
X */
#define sz(a) (a),slen(a)
X
/* { sELEMENT(*),int } sc(sELEMENT(*array));
X * Return array,size pair.  Uses 'sizeof' to get size.
X */
#define sc(a) (a),(sizeof(a)/sizeof(sCAST)-1)
X
/* { sELEMENT(*),int } srest(sELEMENT(*vary),int pos);
X * Return array,size pair of rest of array beginning at pos.  If
X * pos is past end of array, gives size of 0.
X */
#define srest(a,p) ((a)+(p)),(((p)>sLEN(a))?0:sLen(a)-(p))
X
/* { sELEMENT(*),int } spart(sELEMENT(*vary),int pos,int len);
X * Return array,size pair of 'len' elements of array beginning with pos.  If
X * pos is past end of array, gives size of 0.  If pos+len is past end of array,
X * returns number of elements to end of array.
X */
#define spart(a,p,l) \
X ((a)+(p)),((p)>=sLEN(a)?0:((p)+(l)>sLen(a)?sLen(a)-(p):(l)))
X
/* sELEMENT(vsget(sELEMENT(*vary),int pos));
X * Get an element from an array.  Any value of pos is valid; if it's past the
X * end of the array or if 'vary' is 0, the terminator is returned.  This
X * does not make a duplicate of the returned element.  If you want that, pass
X * the return value of this to sdup.
X */
#define vsget(a,p) ((p)>=sLEN(a)?sterm:(a)[p])
X
/**********************/
/* Insertion/Deletion */
/**********************/
X
/* sELEMENT(*vsins(sELEMENT(*vary),int pos,int n));
X * Insert n empty slots into the array.  If 'pos' >= the length of the array,
X * the array is simply extended.  The new slots are not set to anything.
X * This does not set the elements in the created hole to any particular
X * value: use vsfill if you need that to occur.
X */
sELEMENT(*vsins());
X
/* sELEMENT(*vsdel(sELEMENT(*vary),int pos,int n));
X * Delete n slots from the array.  This does not zap the elements first; call
X * vszap first if you need this to happen.
X */
sELEMENT(*vsdel());
X
/*************************/
/* Searching and Sorting */
/*************************/
X
/* sELEMENT(*vssort(sELEMENT(*ary),int len))
X * Sort the elements of an array (char or variable length) using qsort().
X */
sELEMENT(*vssort());
X
/* int vsbsearch(sELEMENT(*ary),int len,sELEMENT(element));
X * Do a binary search on a sorted variable length or char array.  Returns position
X * of matching element or the position where the element should be if it was
X * not found.  (You should test with scmp to find out which).
X *
X * Hmm... this should really indicate whether or not the element was found.
X */
int vsbsearch();
X
/* int vsfirst(sELEMENT(*ary),int len,sELEMENT(element));
X * Find offset to first matching element in 'vary' or return ~0 if not found.
X */
int vsfirst();
X
/* int vslast(sELEMENT(*ary),int len,sELEMENT(element));
X * Find offset to last matching element in 'vary' or return ~0 if none found.
X */
int vslast();
X
/* int vss(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
X * Do a substring search on 'a'.  Return offset from 'a' to first matching
X * occurance of 'b' in 'a' or return ~0 if none found.
X */
int vss();
X
/* int vscmpn(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
X *
X * Compare two arrays using scmp.  If 'a' > 'b', return 1.  If 'a' == 'b',
X * return 0.  If 'a' < 'b', return -1.  Longer strings are > shorter ones if
X * their beginning match.
X */
int vscmpn();
X
/* int vscmp(sELEMENT(*a),sELEMENT(*b));
X *
X * Functionalized version of: vscmpn(sv(a),sv(b));
X */
int vscmp();
X
/* int vsicmpn(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
X *
X * Compare two arrays using sicmp.  If 'a' > 'b', return 1.  If 'a' == 'b',
X * return 0.  If 'a' < 'b', return -1.  Longer strings are > shorter ones if
X * their beginning match.
X *
X * This is same as vscmpn except that it is case insensitive.
X */
int vsicmpn();
X
/* int vsicmp(sELEMENT(*a),sELEMENT(*b));
X *
X * Functionalized version of: vsicmpn(sv(a),sv(b));
X */
int vsicmp();
X
/* int vsscan(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
X * Find offset of first matching element in 'a' which matches any
X * of the elements passed in 'b'.  Array 'b' must be sorted.
X *
X * Hmm... this really needs to return what the found element is.
X */
int vsscan();
X
/* int vsspan(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
X * Find offset of first matching element in 'a' which does not match any
X * of the elements passed in 'b'.  Array 'b' must be sorted.
X */
int vsspan();
X
/***************/
/* Other stuff */
/***************/
X
/* char *vsread(char *d,int p,int (*getC)(void *ptr),void *ptr);
X * Replace 'd' with next line read from read-character function 'getC'.  If 
X * 'd' is 0, a new string is allocated.  If there is no more input, the string
X * is freed and 0 is returned.  The \n is deleted from the entered line.
X *
X * 'ptr' is passed as the first arg to 'getC'.  'getC' should return -1 if
X * there is no more input.
X */
char *vsread();
X
/* char *vwords(char *s,char **a,int len,char t);
X *
X * Generate a 't'-seperated word list from the words in the zero-terminated
X * array of zero-terminated strings 'a'.  For example a simple 'echo.c':
X *
X * main(argc,argv)
X * char *argv[];
X * {
X * printf("%s\n",vwords(NULL,argv,argc,' ')):
X * }
X *
X */
char *vswords();
X
/* char *vsfmt(char *s,char *fmt,...);
X *
X * (Yeah, yeah.. I really need to make this printf compatible, I know.)
X *
X * Printf (almost) to a variable length string.  If 's' is zero, a string is
X * created.  All chars from 'fmt' are copied to string except for these '%'
X * sequences:
X *
X *    % [' '|'+'|'-'] Base _ FieldWidth . Precision [l] {d|D|u|U|c|s}
X *    %% generates %
X *
X *    '+' means leading + needed for zero and positive numbers
X *    ' ' means leading space needed for zero and positive numbers
X *    '-' means left justified within field instead of right justified
X *    FieldWidth is minimum field width
X *
X *    s     Means insert next zero-terminated string from argument list
X *          Precision means maximum string size
X *
X *    c     Means insert next character from argument list.  The character is
X *          normally passed as an int.  If 'l' is given, the character is
X *          passed as a long.
X *
X *    d signed integer, use lower case letters for digits above 9
X *    D signed integer, use upper case letters for digits above 9
X *    u unsigned integer, use lower case letters for digits above 9
X *    U unsigned integer, use upper case letters for digits above 9
X *          If 'l' is give, a long or unsigned long is requested instead.
X *          Precision is minimum number of digits to generate in number.
X *          Default base is decimal.
X */
char *vsfmt();
X
X
#endif
SHAR_EOF
chmod 0600 vs.h ||
echo 'restore of vs.h failed'
Wc_c="`wc -c < 'vs.h'`"
test 13819 -eq "$Wc_c" ||
	echo 'vs.h: original size 13819, current size' "$Wc_c"
fi
# ============= w.c ==============
if test -f 'w.c' -a X"$1" != X"-c"; then
	echo 'x - skipping w.c (File already exists)'
else
echo 'x - extracting w.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'w.c' &&
/* Window system
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "config.h"
#include "heap.h"
#include "vfile.h"
#include "toomany.h"
#include "b.h"
#include "termcap.h"
#include "scrn.h"
#include "tty.h"
#include "queue.h"
#include "kbd.h"
#include "main.h"
#include "poshist.h"
#include "w.h"
X
/* Redraw a window */
X
void wredraw(w)
W *w;
{
msetI(w->t->t->updtab+w->y,1,w->h);
}
X
/* Scroll an update array */
X
void scrldn(ary,top,bot,amnt)
int *ary,top,bot,amnt;
{
if(!amnt || top>=bot || amnt>bot-top) return;
if(bot>25)
X {
X signal(0,5);
X }
/* mbkwd(ary+top+amnt,ary+top,(bot-top-amnt)*sizeof(int)); */
msetI(ary+top,1,amnt);
}
X
void scrlup(ary,top,bot,amnt)
int *ary,top,bot,amnt;
{
if(!amnt || top>=bot || amnt>bot-top) return;
if(bot>25)
X {
X signal(0,5);
X }
/* mfwrd(ary+top,ary+top+amnt,(bot-top-amnt)*sizeof(int)); */
msetI(ary+bot-amnt,1,amnt);
}
X
/* Find first window in a group */
X
W *findtopw(w)
W *w;
{
W *x;
for(x=w;x->link.prev->main==w->main && x->link.prev!=w;x=x->link.prev);
return x;
}
X
/* Determine height of a family of windows */
X
int getgrouph(w)
W *w;
{
W *x;
int h;
X
/* Find first window in family */
x=findtopw(w);
X
/* Add heights of all windows in family */
for(w=x, h=(w->reqh?w->reqh:w->hh);
X    w->link.next!=x && w->link.next->main==x->main;
X    w=w->link.next, h+=(w->reqh?w->reqh:w->hh));
X
return h;
}
X
/* Determine minimum height of a family */
X
int getminh(w)
W *w;
{
W *x;
int h;
x=findtopw(w);
for(w=x, h=(w->win?1:2);
X    w->link.next!=x && w->link.next->main==x->main;
X    w=w->link.next, h+=(w->win?1:2));
X
return h;
}
X
/* Find last window in a group */
X
W *findbotw(w)
W *w;
{
W *x;
for(x=w;x->link.next->main==w->main && x->link.next!=w;x=x->link.next);
return x;
}
X
/* Find last window on the screen */
X
W *lastw(t)
SCREEN *t;
{
W *x;
for(x=t->topwin;x->link.next!=t->topwin && x->link.next->y>=0;x=x->link.next);
return x;
}
X
/* Create a screen object */
X
SCREEN *scr;
X
SCREEN *screate(scrn)
SCRN *scrn;
{
SCREEN *t=(SCREEN *)malloc(sizeof(SCREEN));
t->pattern=0;
t->replace=0;
t->t=scrn;
t->w=scrn->co;
t->h=scrn->li;
t->topwin=0;
t->curwin=0;
t->wind=0;
t->markb=0;
t->markk=0;
t->arg=0;
scr=t;
return t;
}
X
void chsize(t,mul,div)
SCREEN *t;
{
W *w;
w=t->topwin; do
X if(!w->win)
X  {
X  w->reqh=getgrouph(w)*mul;
X  w->reqh=w->reqh/div+(w->reqh%div>=div/2?1:0);
X  if(w->reqh<FITHEIGHT) w->reqh=FITHEIGHT;
X  w->reqh-=getminh(w)-2;
X  if(w->reqh<2) w->reqh=2;
X  if(w->reqh>t->h-t->wind) w->reqh=t->h-t->wind;
X  }
X while(w=w->link.next, w!=t->topwin);
wfit(t);
}
X
void sresize(t)
SCREEN *t;
{
SCRN *scrn=t->t;
W *w;
int osize=t->h-t->wind;
t->w=scrn->co;
t->h=scrn->li;
if(t->h-t->wind<FITHEIGHT) t->wind=t->h-FITHEIGHT;
if(t->wind<0) t->wind=0;
w=t->topwin; do
X w->y= -1, w->w=t->w-1;
X while(w=w->link.next, w!=t->topwin);
chsize(t,t->h-t->wind,osize);
updall();
}
X
void updall()
{
int y;
for(y=0;y!=scr->h;++y) scr->t->updtab[y]=1;
}
X
void scrins(b,l,n,flg)
B *b;
long l,n;
int flg;
{
W *w;
if(w=scr->topwin) do
X if(w->y>=0) w->watom->ins(w,b,l,n,flg);
X while(w=w->link.next, w!=scr->topwin);
}
X
void scrdel(b,l,n,flg)
B *b;
long l,n;
int flg;
{
W *w;
if(w=scr->topwin) do
X if(w->y>=0) w->watom->del(w,b,l,n,flg);
X while(w=w->link.next, w!=scr->topwin);
}
X
/* Fit as many windows on the screen as is possible beginning with the window
X * at topwin.  Give any extra space which couldn't be used to fit in another
X * window to the last text window on the screen.  This function guarentees
X * to fit on the window with the cursor in it (moves topwin to next group
X * of windows until window with cursor fits on screen).
X */
X
static int doabort();
X
void wfit(t)
SCREEN *t;
{
int y;		/* Where next window goes */
int left;	/* Lines left on screen */
W *w;		/* Current window we're fitting */
W *pw;		/* Main window of previous family */
int req;	/* Amount this family needs */
int adj;	/* Amount family needs to be adjusted */
int flg=0;	/* Set if cursor window was placed on screen */
X
tryagain:
y=t->wind; left=t->h-y; pw=0;
X
w=t->topwin; do
X w->ny= -1, w->hh=w->nh=(w->reqh?w->reqh:w->hh);
X while((w=w->link.next)!=t->topwin);
X
/* Fit a group of windows on the screen */
w=t->topwin; do
X {
X req=getgrouph(w);
X if(req>left)		/* If group is taller than lines left */
X  adj=req-left;		/* then family gets shorter */
X else adj=0;
X 
X /* Fit a family of windows on the screen */
X do
X  {
X  w->ny=y;			/* Set window's y position */
X  if(!w->win) pw=w, w->nh-=adj;	/* Adjust main window of the group */
X  if(!w->win && w->nh<2) while(w->nh<2) w->nh+=doabort(w->link.next);
X  if(w==t->curwin) flg=1;	/* Set if we got window with cursor */
X  y+=w->nh; left-=w->nh;	/* Increment y value by height of window */
X  w=w->link.next;		/* Next window */
X  } while(w!=t->topwin && w->main==w->link.prev->main);
X } while(w!=t->topwin && left>=FITHEIGHT);
X
/* We can't use extra space to fit a new family on, so give space to parent of
X * previous family */
pw->nh+=left;
X
/* Adjust that family's children which are below the parent */
while((pw=pw->link.next)!=w) pw->ny+=left;
X
/* Make sure the cursor window got on the screen */
if(!flg)
X {
X t->topwin=findbotw(t->topwin)->link.next;
X goto tryagain;
X }
X
/* All of the windows are now on the screen.  Scroll the screen to reflect what
X * happened
X */
w=t->topwin; do
X if(w->y>=0 && w->ny>=0)
X  if(w->ny>w->y)
X   {
X   W *l=pw=w;
X   while(pw->link.next!=t->topwin &&
X         (pw->link.next->y<0 || pw->link.next->ny<0 ||
X         pw->link.next->ny>pw->link.next->y))
X    {
X    pw=pw->link.next;
X    if(pw->ny>=0 && pw->y>=0) l=pw;
X    }
X   /* Scroll windows between l and w */
X   loop1:
X   if(l->ny>=0 && l->y>=0)
X    {
X    nscrldn(t->t,l->y,l->ny+Umin(l->h,l->nh),l->ny-l->y);
X    scrldn(t->t->updtab,l->y,l->ny+Umin(l->h,l->nh),l->ny-l->y);
X    }
X   if(w!=l)
X    {
X    l=l->link.prev;
X    goto loop1;
X    }
X   w=pw->link.next;
X   }
X  else if(w->ny<w->y)
X   {
X   W *l=pw=w;
X   while(pw->link.next!=t->topwin &&
X         (pw->link.next->y<0 || 
X         pw->link.next->ny<0 || 
X         pw->link.next->ny<pw->link.next->y))
X    {
X    pw=pw->link.next;
X    if(pw->ny>=0 && pw->y>=0) l=pw;
X    }
X   /* Scroll windows between l and w */
X   loop0:
X   if(w->ny>=0 && w->y>=0)
X    {
X    nscrlup(t->t,w->ny,w->y+Umin(w->h,w->nh),w->y-w->ny);
X    scrlup(t->t->updtab,w->ny,w->y+Umin(w->h,w->nh),w->y-w->ny);
X    }
X   if(w!=l)
X    {
X    w=w->link.next;
X    goto loop0;
X    }
X   w=pw->link.next;
X   }
X  else w=w->link.next;
X else w=w->link.next;
X while(w!=t->topwin);
X
/* Update current height and position values */
w=t->topwin; do
X {
X if(w->ny>=0)
X  {
X  if(w->object) w->watom->move(w,w->x,w->ny),
X                w->watom->resize(w,w->w,w->nh);
X  if(w->y== -1) msetI(t->t->updtab+w->ny,1,w->nh);
X  w->y=w->ny;
X  }
X else w->y= -1;
X w->h=w->nh;
X w->reqh=0;
X }
X while(w=w->link.next, w!=t->topwin);
}
X
/* Goto next window */
X
int wnext(t)
SCREEN *t;
{
if(t->curwin->link.next!=t->curwin)
X {
X t->curwin=t->curwin->link.next;
X if(t->curwin->y== -1) wfit(t);
X return 0;
X }
else return -1;
}
X
/* Goto previous window */
X
int wprev(t)
SCREEN *t;
{
if(t->curwin->link.prev!=t->curwin)
X {
X t->curwin=t->curwin->link.prev;
X if(t->curwin->y== -1)
X  {
X  t->topwin=findtopw(t->curwin);
X  wfit(t);
X  }
X return 0;
X }
else return -1;
}
X
/* Grow window */
X
int wgrow(w)
W *w;
{
W *nextw, *z;
/* Is there enough space to grow window? */
for(nextw=w->link.next;
X    nextw->win && nextw!=w->t->topwin;
X    nextw=nextw->link.next);
if(nextw==w->t->topwin) return -1;
if(nextw->y== -1 || nextw->hh<=FITHEIGHT) return -1;
X
w->reqh=w->hh+1;	/* Increase this window's height */
nextw->reqh=nextw->hh-1;/* Decrease this window's height and move it down */
X
wfit(w->t);
X
return 0;
}
X
/* Shrink window */
X
int wshrink(w)
W *w;
{
W *nextw, *z;
/* Is this window too small already? */
if(w->hh<=FITHEIGHT) return -1;
X
/* Is there a window we can grow with this window's space? */
for(nextw=w->link.next;
X    nextw!=w->t->topwin && nextw->win;
X    nextw=nextw->link.next);
if(nextw==w->t->topwin) return -1;
X
w->reqh=w->hh-1;		/* Decrease window size */
nextw->reqh=nextw->hh+1;	/* Give space to this window */
X
wfit(w->t);
return 0;
}
X
/* Show all windows */
X
void wshowall(t)
SCREEN *t;
{
int n=0;
int set;
W *w=t->topwin; do
X if(!w->win) ++n;
X while(w=w->link.next, w!=t->topwin);
if((t->h-t->wind)/n>=FITHEIGHT) set=(t->h-t->wind)/n;
else set=FITHEIGHT;
w=t->topwin; do
X if(!w->win)
X  {
X  int h=getminh(w);
X  if(h>=set) w->reqh=2;
X  else w->reqh=set-(h-2);
X  w->orgwin=0;
X  }
X while(w=w->link.next, w!=t->topwin);
wfit(t);
}
X
void wspread(t)
SCREEN *t;
{
int n=0;
W *w=t->topwin; do
X if(w->y>=0 && !w->win) ++n;
X while(w=w->link.next, w!=t->topwin);
if(!n)
X {
X wfit(t);
X return;
X }
if((t->h-t->wind)/n>=FITHEIGHT) n=(t->h-t->wind)/n;
else n=FITHEIGHT;
w=t->topwin; do
X if(!w->win)
X  {
X  int h=getminh(w);
X  if(h>=n) w->reqh=2;
X  else w->reqh=n-(h-2);
X  w->orgwin=0;
X  }
X while(w=w->link.next, w!=t->topwin);
wfit(t);
}
X
/* Show just one family of windows */
X
void wshowone(w)
W *w;
{
W *q=w->t->topwin; do
X if(!q->win)
X  q->reqh=w->t->h-(getgrouph(q)-q->hh), q->orgwin=0;
X while(q=q->link.next, q!=w->t->topwin);
wfit(w->t);
}
X
/* Create a window */
X
W *wcreate(t,watom,where,target,original,height,huh)
SCREEN *t;
WATOM *watom;
W *where, *target, *original;
int height;
char *huh;
{
W *new;
X
if(height<1) return 0;
X
/* Create the window */
new=(W *)malloc(sizeof(W));
new->t=t;
new->w=t->w-1;
new->hh=new->h=height;
new->y= -1;
new->ny=0; new->nh=0; new->reqh=0;
new->x=0;
new->huh=huh;
new->orgwin=original;
new->watom=watom;
new->object=0;
new->msgb=0;
new->msgt=0;
X
/* Set window's target and family */
if(new->win=target) new->main=target->main;
else new->main=new;
X
/* Get space for window */
if(original)
X if(original->hh-height<=2)
X  {
X  /* Not enough space for window */
X  free(new);
X  return 0;
X  }
X else original->hh-=height;
X
/* Create new keyboard handler for window */
if(watom->context) new->kbd=mkkbd(watom->context,new);
else new->kbd=0;
X
/* Put window on the screen */
if(where) enquef(W,link,where,new);
else
X {
X if(t->topwin) enqueb(W,link,t->topwin,new);
X else izque(W,link,new), t->curwin=t->topwin=new;
X }
X
wfit(t);
return new;
}
X
/* Abort group of windows */
X
static int doabort(w)
W *w;
{
int amnt=w->hh;
W *z, *zn;
w->y= -2;
if(w->t->topwin==w) w->t->topwin=w->link.next;
loop:
z=w->t->topwin; do
X {
X if(z->orgwin==w) z->orgwin=0;
X if((z->win==w || z->main==w) && z->y!= -2)
X  {
X  amnt+=doabort(z);
X  goto loop;
X  }
X }
X while(z=z->link.next, z!=w->t->topwin);
if(w->orgwin)
X {
X if(w->orgwin->reqh) w->orgwin->reqh+=(w->reqh?w->reqh:w->hh);
X else w->orgwin->reqh=w->orgwin->hh+(w->reqh?w->reqh:w->hh);
X }
if(w->t->curwin==w)
X if(w->t->curwin->win) w->t->curwin=w->t->curwin->win;
X else
X  if(w->orgwin) w->t->curwin=w->orgwin;
X  else w->t->curwin=w->link.next;
if(qempty(W,link,w))
X {
X leave=1;
X amnt=0;
X }
deque(W,link,w);
w->watom->kill(w);
rmkbd(w->kbd);
free(w);
windie(w);
return amnt;
}
X
/* Abort a window and its children */
X
void wabort(w)
W *w;
{
SCREEN *t=w->t;
if(w!=w->main)
X {
X doabort(w);
X if(!leave) wfit(t);
X }
else
X {
X doabort(w);
X if(!leave)
X  {
X  if(lastw(t)->link.next!=t->topwin) wfit(t);
X  else wspread(t);
X  }
X }
}
X
/* Generate text with formatting escape sequences */
X
void genfmt(t,x,y,ofst,s,flg)
SCRN *t;
char *s;
{
int *scrn=t->scrn+y*t->co+x;
int atr=0;
int col=0;
while(*s)
X {
X int c;
X if(*s=='\\')
X  {
X  ++s;
X  if(!*s) break;
X  if(*s=='\\') if(col++>=ofst) c= (unsigned char)*s++ + atr; else { ++s; continue; }
X  else if(*s=='u' || *s=='U') { atr^=UNDERLINE; ++s; continue; }
X  else if(*s=='i' || *s=='I') { atr^=INVERSE; ++s; continue; }
X  else { ++s; continue; }
X  }
X else if(col++>=ofst) c= (unsigned char)*s++ + atr; else { ++s; continue; }
X if(c!=*scrn) *scrn=c, outatr(t,col-ofst+x-1,y,c);
X ++scrn;
X }
if(flg) eraeol(t,col-ofst+x,y);
}
X
/* Determine column width of string with format codes */
X
int fmtlen(s)
char *s;
{
int col=0;
while(*s)
X {
X if(*s=='\\')
X  {
X  ++s;
X  if(!*s) break;
X  if(*s=='\\') { ++col; ++s; continue; }
X  if(*s=='u' || *s=='U') { ++s; continue; }
X  if(*s=='i' || *s=='I') { ++s; continue; }
X  ++s; continue;
X  }
X ++col; ++s;
X }
return col;
}
X
/* Display a message and skip the next key */
X
int msgout(t,y,s)
SCRN *t;
char *s;
{
int ofst;
int len;
len=fmtlen(s);
if(len<=(t->co-1)) ofst=0;
else ofst=len-(t->co-1);
genfmt(t,0,y,ofst,s,1);
return len-ofst;
}
X
void msg(w,s)
W *w;
char *s;
{
cpos(w->t->t,msgout(w->t->t,w->y+w->h-1,s),w->y+w->h-1);
w->t->t->updtab[w->y+w->h-1]=1;
engetc(w->t->t);
}
X
/* Set temporary message */
X
void msgnw(w,s)
W *w;
char *s;
{
w->msgb=s;
}
X
void msgnwt(w,s)
W *w;
char *s;
{
w->msgt=s;
}
X
/* Single key query */
X
int query(w,s)
W *w;
char *s;
{
int ofst;
int c;
int len;
len=fmtlen(s);
if(len<=w->w-2) ofst=0;
else ofst=len-(w->w-2);
genfmt(w->t->t,w->x,w->y+w->h-1,ofst,s,1);
cpos(w->t->t,w->x+len-ofst,w->y+w->h-1);
c=engetc(w->t->t);
w->t->t->updtab[w->y+w->h-1]=1;
return c;
}
X
/* Single key query - leave cursor in curwin */
X
static void dumb()
{
}
X
static WATOM dummy=
{
0,dumb,dumb,dumb,dumb,dumb,dumb,dumb
};
X
int queryn(w,s)
W *w;
char *s;
{
int ofst;
int len;
int c;
W *new=wcreate(w->t,&dummy,w,w,w,1,NULL);
if(!new) return MAXINT;
len=fmtlen(s);
if(len<=w->w-1) ofst=0;
else ofst=len-(w->w-1);
genfmt(w->t->t,w->x,new->y,ofst,s,1);
c=edgetc();
wabort(new);
return c;
}
SHAR_EOF
chmod 0600 w.c ||
echo 'restore of w.c failed'
Wc_c="`wc -c < 'w.c'`"
test 13930 -eq "$Wc_c" ||
	echo 'w.c: original size 13930, current size' "$Wc_c"
fi
# ============= w.h ==============
if test -f 'w.h' -a X"$1" != X"-c"; then
	echo 'x - skipping w.h (File already exists)'
else
echo 'x - extracting w.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'w.h' &&
/* Window management
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Iw
#define _Iw 1
X
#include "config.h"
#include "queue.h"
#include "kbd.h"
#include "scrn.h"
#include "b.h"
X
typedef struct watom WATOM;
typedef struct screen SCREEN;
typedef struct window W;
X
struct watom
X {
X CONTEXT *context;
X void (*disp)();
X void (*follow)();
X void (*kill)();
X void (*resize)();
X void (*move)();
X void (*ins)();
X void (*del)();
X int what;		/* Type of this thing */
X };
X
struct screen
X {
X SCRN *t;			/* Screen data on this screen is output to */
X
X int wind;			/* Number of help lines on this screen */
X 
X W *topwin;			/* Top-most window showing on screen */
X W *curwin;			/* Window cursor is in */
X
X int w,h;			/* Width and height of this screen */
X 
X char *pattern;			/* pattern being searched for */
X char *replace;			/* what to replace with */
X int options;			/* Search/Replace options */
X int repeat;
X int foundlen;
X 
X P *markb;			/* Beginning and end of marked block */
X P *markk;
X
X int arg;
X };
X
struct window
X {
X LINK(W) link;			/* Linked list of windows in order they
X 				   appear on the screen */
X SCREEN *t;			/* Screen this thing is on */
X int x,y,w,h;			/* Position and size of window */
X                                /* Currently, x=0, w=width or screen. */
X                                /* y== -1 if window is not on screen */
X int ny,nh;			/* Temporary values for wfit */
X int reqh;			/* Requested new height or 0 for same */
X 				/* This is an argument for wfit */
X int hh;			/* Natural height */
X W *win;			/* Window this one operates on */
X W *main;			/* Main window of this family */
X W *orgwin;			/* Window where space from this window came */
X int curx, cury;		/* Cursor position within window */
X KBD *kbd;			/* Keyboard handler for this window */
X WATOM *watom;			/* The type of this window */
X void *object;			/* Object which inherits this */
X
X char *msgt;			/* Message at top of window */
X
X char *msgb;			/* Message at bottom of window */
X
X char *huh;			/* Name of window for context sensitive hlp */
X };
X
/* Minimum text window height */
#define FITHEIGHT 4
X
/***************/
/* Subroutines */
/***************/
X
void scrlup();
void scrldn();
void prming();
void updall();
X
/* int getgrouph(W *);
X * Get height of a family of windows
X */
int getgrouph();
X
/* W *findtopw(W *);
X * Find first (top-most) window of a family
X */
W *findtopw();
X
/* W *findbotw(W *);
X * Find last (bottom-most) window a family
X */
W *findbotw();
X
W *lastw();
X
/* void wfit(SCREEN *);
X *
X * Fit all of the windows onto the screen
X */
void wfit();
X
/*****************/
/* Main routines */
/*****************/
X
/* SCREEN *screate(SCRN *);
X *
X * Create a screen
X */
SCREEN *screate();
X
/* void sresize(SCREEN *t);
X * Screen size changed
X */
void sresize();
X
void chsize();
X
/* W *wcreate(SCREEN *t,WATOM *watom,W *where,W *target,W *original,int height);
X *
X * Try to create a window
X *
X * 't'		Is the screen the window is placed on
X * 'watom'	Type of new window
X * 'where'	The window placed after this window, or if 'where'==0, the
X *		window is placed on the end of the screen
X * 'target'	The window operates on this window.  The window becomes a
X *		member of 'target's family or starts a new family if
X *		'target'==0.
X * 'original'	Attempt to get 'height' from this window.  When the window is
X *              aborted, the space gets returned to 'original' if it still
X *		exists.  If 'original'==0, the window will force other
X *		windows to go off of the screen.
X * 'height'	The height of the window
X *
X * Returns the new window or returns 0 if there was not enough space to
X * create the window and maintain family integrity.
X */
W *wcreate();
X
/* void wabort(W *w);
X *
X * Kill a window and it's children
X */
void wabort();
X
/* int wnext(SCREEN *);
X *
X * Switch to next window
X */
int wnext();
X
/* int wprev(SCREEN *);
X *
X * Switch to previous window
X */
int wprev();
X
/* int wgrow(W *);
X *
X * increase size of window.  Return 0 for success, -1 for fail.
X */
int wgrow();
X
/* int wshrink(W *);
X *
X * Decrease size of window.  Returns 0 for success, -1 for fail.
X */
int wshrink();
X
/* void wshowone(W *);
X *
X * Show only one window on the screen
X */
void wshowone();
X
/* void wshowall(SCREEN *);
X *
X * Show all windows on the screen, including the given one
X */
void wshowall();
X
/* void wredraw(W *);
X *
X * Force complete redraw of window
X */
void wredraw();
X
/* void wsquish(SCREEN *,int h);
X *
X * Squish all of the windows on the screen so that h lines can fit
X */
void wsquish();
X
/* void wrestore(SCREEN *);
X *
X * Restore windows to their original heights
X */
void wrestore();
X
/* void msg(W *w,char *text);
X * Display a message and then continue editing after the next keypress.
X * The message is placed in the last line of 'w'
X */
int msgout();
void msg();
X
void msgnw();
void msgnwt();
X
/* int query(W *w,char *text);
X * Single-key query.  'func' gets the key as it's first arg.  The message is
X * displayed on the last line of 'w'.
X */
int query();
X
/* int queryn(W *w,char *text);
X * As above, but leave cursor in current window
X */
int queryn();
X
#endif
SHAR_EOF
chmod 0600 w.h ||
echo 'restore of w.h failed'
Wc_c="`wc -c < 'w.h'`"
test 5765 -eq "$Wc_c" ||
	echo 'w.h: original size 5765, current size' "$Wc_c"
fi
# ============= zstr.c ==============
if test -f 'zstr.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zstr.c (File already exists)'
else
echo 'x - extracting zstr.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zstr.c' &&
/* Zero terminated strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#include "heap.h"
#include "zstr.h"
X
int toup(a) { return (a>='a' && a<='z')?a+'A'-'a':a; }
unsigned Umin(a,b) unsigned a,b; { return a<b?a:b; }
unsigned Umax(a,b) unsigned a,b; { return a>b?a:b; }
int Imin(a,b) { return a<b?a:b; }
int Imax(a,b) { return a>b?a:b; }
int Iabs(a) { return a>=0?a:-a; }
X
int cword(c)
{
return c>='A' && c<='Z' || c>='a' && c<='z' || c>='0' && c<='9' || c=='_';
}
X
int cwhitel(c)
{
return c==' ' || c=='\t' || c=='\n';
}
X
int cwhite(c)
{
return c==' ' || c=='\t';
}
X
int zlen(s)
char *s;
{
char *os=s;
while(*s) ++s;
return s-os;
}
X
char *zcpy(d,s)
char *d,*s;
{
char *od=d;
while(*d++= *s++);
return od;
}
X
char *zcat(d,s)
char *d,*s;
{
char *od=d;
while(*d) ++d;
while(*d++= *s++);
return od;
}
X
char *zdup(s)
char *s;
{
return zcpy((char *)malloc(zlen(s)+1),s);
}
X
int zcmp(l,r)
char *l, *r;
{
while(*l && *l==*r) ++l, ++r;
if(*l>*r) return 1;
if(*l<*r) return -1;
return 0;
}
X
int fields(s,fields,sep)
char *s, **fields, sep;
{
int y=1;
fields[0]=s;
while(*s)
X {
X if(*s==sep) fields[y++]=s+1, *s=0;
X ++s;
X }
return y;
}
X
int nfields(s,sep)
char *s, sep;
{
int y=1;
while(*s) if(*s++==sep) ++y;
return y;
}
SHAR_EOF
chmod 0600 zstr.c ||
echo 'restore of zstr.c failed'
Wc_c="`wc -c < 'zstr.c'`"
test 1902 -eq "$Wc_c" ||
	echo 'zstr.c: original size 1902, current size' "$Wc_c"
fi
# ============= zstr.h ==============
if test -f 'zstr.h' -a X"$1" != X"-c"; then
	echo 'x - skipping zstr.h (File already exists)'
else
echo 'x - extracting zstr.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zstr.h' &&
/* Zero terminated strings
X   Copyright (C) 1992 Joseph H. Allen
X
This file is part of JOE (Joe's Own Editor)
X
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
X
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
X
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
X
#ifndef _Izstr
#define _Izstr 1
X
#include "config.h"
X
int cword();
int cwhite();
int cwhitel();
int Iabs();
int toup();
unsigned Umin();
unsigned Umax();
int Imin();
int Imax();
char *zcpy();
char *zdup();
char *zcat();
int zcmp();
int zlen();
int fields();
int nfields();
X
#endif
SHAR_EOF
chmod 0600 zstr.h ||
echo 'restore of zstr.h failed'
Wc_c="`wc -c < 'zstr.h'`"
test 1044 -eq "$Wc_c" ||
	echo 'zstr.h: original size 1044, current size' "$Wc_c"
fi
# ============= .joerc ==============
if test -f '.joerc' -a X"$1" != X"-c"; then
	echo 'x - skipping .joerc (File already exists)'
else
echo 'x - extracting .joerc (Text)'
sed 's/^X//' << 'SHAR_EOF' > '.joerc' &&
X                         Initialization file for JOE
X
X JOE looks for this file in:
X	1 - .joerc
X	2 - $HOME/.joerc
X	3 - /usr/local/lib/joerc
X
X FIRST SECTION: Default global options:
X
X Put each option you want set in the first column:
X
X -mid		Cursor is recentered when scrolling is necessary
X -asis		Characters 160 - 254 shown as-is
X -stacol	Column number in status line
X -starow	Row number in status line
X -force		Force final newline when files are saved
X -help		Start with help on
X -pg nnn	No. lines to keep for PgUp/PgDn
X -gtab nnn	Default tab width for prompt windows
X
X SECOND SECTION: File name dependant local option settings:
X
X Each line with '*' in the first column indicates the modes which should be
X files which match the regular expression.  If more than one regular
X expression matches the file name, than the last matching one is chosen.
X
X Here is a list of modes which can be set:
X
X	-wordwrap		Wordwrap
X	-autoindent		Auto indent
X	-overwrite		Overtype mode
X	-lmargin nnn		Left margin
X	-rmargin nnn		Right margin
X	-tab nnn		Tab width
X	-indentc nnn		Indentation character (32 for space, 9 for tab)
X	-istep nnn		Number of indentation columns
*
-wordwrap
X
*.c
-autoindent
X
*.h
-autoindent
X
*akefile
*AKEFILE
*joerc
X
*.p
-autoindent
X
X THIRD SECTION: Named help screens:
X
X Use \i to turn on/off inverse video
X Use \u to turn on/off underline
X
{Basic
\i   Help Screen    turn off with ^KH                                            \i
\i \i\uCURSOR\u           \uGO TO\u            \uBLOCK\u      \uDELETE\u   \uMISC\u         \uEXIT\u      \i \i
\i \i^B left ^F right ^U  prev. screen ^KB begin  ^D char. ^KJ reformat ^KX save  \i \i
\i \i^P up   ^N down  ^V  next screen  ^KK end    ^Y line  ^TT overtype ^C  abort \i \i
\i \i^Z previous word ^A  beg. of line ^KM move   ^W >word `   Ctrl-    ^KZ shell \i \i
\i \i^X next word     ^E  end of line  ^KC copy   ^O word< ^\\  Meta-    \uFILE\u      \i \i
\i \i\uSEARCH\u           ^KU top of file  ^KW file   ^J >line ^R  retype   ^KE new   \i \i
\i \i^KF find text    ^KV end of file  ^KY delete ^_ undo  ^@  insert   ^KR insert\i \i
\i \i^L  find next    ^KL to line No.  ^K/ filter ^^ redo               ^KD save  \i \i
}
X
{Windows
\i   Help Screen    turn off with ^KH                                            \i
\i \i^KO Split the window into two.  You can then use ^KE to load a file into the \i \i
\i \i    new window.                                                              \i \i
\i \i^KG Make current window bigger         ^KT Make current window smaller       \i \i
\i \i^KN Go to the window below             ^KP Go to the window above            \i \i
\i \i^C  Eliminate the current window       ^KI Show all windows / Show one window\i \i
}
X
{Advanced
\i   Help Screen    turn off with ^KH                                            \i
\i \i ESC nn   repeat next command nn times     ^G   goto matching ( [ {          \i \i
\i \i ^K SPACE show position status             ^K-  goto prevous place in        \i \i
\i \i ^K [ 0-9 begin recording macro n               position history             \i \i
\i \i ^K ]     stop recording                   ^K=  goto next place              \i \i
\i \i ^K 0-9   play macro n                     ^K,  indent marked block less     \i \i
\i \i ^K A     center line                      ^K.  indent marked block more     \i \i
\i \i ^T X     rectangle mode                   ^K;  tag search                   \i \i
}
X
{Options
\i   Help Screen    turn off with ^KH                                            \i
\i \i                                Mode Settings                                \i \i
\i \i                                                                             \i \i
\i \i ^TT Insert/Overtype             ^TM Recenter cursor when it goes off window \i \i
\i \i ^TA Autoindent on/off           ^TF Force final NL when files are written   \i \i
\i \i ^TW Wordwrap on/off             ^TH Display characters above 127 as-is      \i \i
\i \i ^TL Left margin                 ^TN Show line number on status line         \i \i
\i \i ^TR Right margin                ^TC Show column number on status line       \i \i
\i \i ^TP No. PgUp/PgDn Lines         ^TD Tab width                               \i \i
\i \i ^TK Indent character            ^TI Indent step column width                \i \i
\i \i ^TX Rectangle mode                                                          \i \i
}
X
{Search
\i   Help Screen    turn off with ^KH                                            \i
\i \iSpecial search sequences:                                                    \i \i
\i \i    \\^     matches beginning of line     \\$     matches end of line          \i \i
\i \i    \\<     matches beginning of word     \\>     matches end of word          \i \i
\i \i    \\?     matches any single character  \\*     matches 0 or more characters \i \i
\i \i    \\c     matches balanced C expression \\\\     matches a \\                  \i \i
\i \i    \\[..]  matches one of a set          \\n     matches a newline            \i \i
\i \i    \\+     matches 0 or more of the character which follows the \\+           \i \i
\i \iSpecial replace sequences:                                                   \i \i
\i \i    \\&     replaced with text which matched search string                    \i \i
\i \i    \\0 - 9 replaced with text which matched Nth \\*, \\?, \\c, \\+, or \\[..]     \i \i
\i \i    \\\\     replaced with \\               \\n     replaced with newline        \i \i
}
X
{Names
\i   Help Screen    turn off with ^KH                                            \i
\i \i Hit TAB at file name prompts to generate menu of file names                 \i \i
\i \i Or use up/down keys to access history of previously entered names           \i \i
\i \i Special file names:                                                         \i \i
\i \i      !command                 Pipe in/out of a shell command                \i \i
\i \i      >>filename               Append to a file                              \i \i
\i \i      -                        Read/Write to/from standard I/O               \i \i
\i \i      filename,START,SIZE      Read/Write a part of a file/device            \i \i
\i \i          Give START/SIZE in decimal (255), octal (0377) or hex (0xFF)       \i \i
}
X
{Joe
\i   Help Screen    turn off with ^KH                                            \i
\i \i Joe Allen's email address:  'jhallen@world.std.com' or                      \i \i
\i \i 'rcarter' on the VWIS Linux BBS (508)793-9568                               \i \i
}
X
X FOURTH SECTION: Key bindings:
X
X :main are the main editing bindings
X :fprompt are file name prompt bindings
X :prompt are other prompt bindings
X :tab are file menu bindings
X :help are help menu bindings
X
X Use ^@ through ^_ and ^? for Ctrl chars
X Use SP for space
X Use a TO b to generate a range of characters
X Use UP DOWN RIGHT LEFT HOME END INS DEL PGUP PGDN
X     F1 F2 F3 F4 F5 F6 F7 F8 F9 F0
X     for the corresponding termcap key sequence definitions
X
X Simple macros can be made by comma seperating 2 or more command names.  For
X example:
X
X bof,bol	^T Z		Goto beginning of last line
X
X Also quoted matter is typed in literally:
X
X bol,">",dnarw	F1		Quote news article line
X
:main
X
type		^I		Tab
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abort		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtn		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:prompt
X
type		^I		Tab
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abortpw		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtnpw		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:fprompt
X
complete	^I		Complete file name
quote8		^\		Quote Meta chars
type		SP TO ~		Typeable characters
quote		`		Quote Ctrl chars
X
abortpw		^C		Abort window
arg		^[ 1 TO 9	Repeat count
backs		^?		Backspace
backs		^H
backw		^O		Backspace word
blkcpy		^K C		Copy marked block
blkcpy		^K ^C
blkcpy		^K c
blkdel		^K Y		Delete marked block
blkdel		^K ^Y
blkdel		^K y
blkmove		^K M		Move marked block
blkmove		^K ^M
blkmove		^K m
blksave		^K W		Save marked block
blksave		^K ^W
blksave		^K w
bof		^K U		Goto beginning of file
bof		^K ^U
bof		^K u
bol		HOME		Goto beginning of line
bol		^A
center		^K A		Center line
center		^K ^A
center		^K a
delch		DEL		Delete character
delch		^D
deleol		^J		Delete to end of line
dellin		^Y		Delete entire line
delw		^W		Delete word to right
dnarw		DOWN		Go down
dnarw		^N
dnarw		^[ O B
dnarw		^[ [ B
edit		^K E		Edit a file
edit		^K ^E
edit		^K e
eof		^K V		Go to end of file
eof		^K ^V
eof		^K v
eol		END		Go to end of line
eol		^E
explode		^K I		Show one window / Show all windows
explode		^K ^I
explode		^K i
exsave		^K X		Save and exit
exsave		^K ^X
exsave		^K x
ffirst		^K F		Find first
ffirst		^K ^F
ffirst		^K f
filt		^K /		Filter block
fnext		^L		Find next
format		^K J		Format paragraph
format		^K ^J
format		^K j
groww		^K G		Grow window
groww		^K ^G
groww		^K g
help		^K H		Help
help		^K ^H
help		^K h
iasis		^T H		Characters 160-254 shown as-is
iasis		^T ^H
iasis		^T h
iforce		^T F		Force final newline
iforce		^T ^F
iforce		^T f
iindent		^T A		Autoindent on/off
iindent		^T ^A
iindent		^T a
iindentc	^T k
iindentc	^T K
iindentc	^T ^K
ilmargin	^T L		Set left margin
ilmargin	^T ^L
ilmargin	^T l
imid		^T M		Center cursor when scrolling
imid		^T ^M
imid		^T m
insc		INS		Insert a space
insc		^@
insf		^K R		Insert a file
insf		^K ^R
insf		^K r
ipgamnt		^T P		No. lines to keep for PGUP/PGDN
ipgamnt		^T ^P
ipgamnt		^T p
irmargin	^T R		Set right margin
irmargin	^T ^R
irmargin	^T r
istacol		^T C		Column number on status line
istacol		^T ^C
istacol		^T c
istarow		^T N		Row number on status line
istarow		^T ^N
istarow		^T n
iistep		^T i
iistep		^T I
iistep		^T ^I
isquare		^T x
isquare		^T X
isquare		^T ^X
itab		^T D
itab		^T ^D
itab		^T d
itype		^T T		Insert/Overtype
itype		^T ^T
itype		^T t
iwrap		^T W		Word wrap
iwrap		^T ^W
iwrap		^T w
lindent		^K ,		Indent to left
line		^K L		Goto line no.
line		^K ^L
line		^K l
ltarw		LEFT		Go left
ltarw		^B
ltarw		^[ O D
ltarw		^[ [ D
markb		^K B		Set beginning of marked block
markb		^K ^B
markb		^K b
markk		^K K		Set end of marked block
markk		^K ^K
markk		^K k
nextpos		^K =		Goto next position in position history
nextw		^K N		Goto window below
nextw		^K ^N
nextw		^K n
nextword	^X		Goto next word
open		^]		Split line
pgdn		PGDN		Screen down
pgdn		^V
pgup		PGUP		Screen up
pgup		^U
play		^K 0 TO 9	Execute macro
prevpos		^K -
prevw		^K P		Window above
prevw		^K ^P
prevw		^K p
prevword	^Z		Previous word
record		^K [		Record macro
redo		^^		Redo changes
retype		^R		Refresh screen
rindent		^K .		Indent to right
rtarw		RIGHT		Go right
rtarw		^F
rtarw		^[ O C
rtarw		^[ [ C
rtnpw		^M		Return
save		^K D		Save file
save		^K S
save		^K ^D
save		^K ^S
save		^K d
save		^K s
shell		^K Z		Shell escape/Suspend
shell		^K ^Z
shell		^K z
shrinkw		^K T		Shrink window
shrinkw		^K ^T
shrinkw		^K t
splitw		^K O		Split window
splitw		^K ^O
splitw		^K o
stat		^K SP		Show status
stop		^K ]		Stop recording macro
tag		^K ;
tomatch		^G		Goto matching parenthasis
undo		^_		Undo changes
uparw		UP		Go up
uparw		^P
uparw		^[ O A
uparw		^[ [ A
X
:tab
X
aborttab	^C
arg		^[ 1 TO 9
backstab	^?
backstab	^H
boftab		^K U
boftab		^K ^U
boftab		^K u
boltab		HOME
boltab		^A
dnarwtab	DOWN
dnarwtab	^N
dnarwtab	^[ [ B
dnarwtab	^[ O B
eoftab		^K V
eoftab		^K ^V
eoftab		^K v
eoltab		END
eoltab		^E
explode		^K I
explode		^K ^I
explode		^K i
help		^K H
help		^K ^H
help		^K h
ltarwtab	LEFT
ltarwtab	^B
ltarwtab	^[ [ D
ltarwtab	^[ O D
nextw		^K N
nextw		^K ^N
nextw		^K n
play		^K 0 TO 9
prevw		^K P
prevw		^K ^P
prevw		^K p
record		^K [
retype		^R
rtarwtab	RIGHT
rtarwtab	^F
rtarwtab	^[ [ C
rtarwtab	^[ O C
rtntab		SP
rtntab		^M
shell		^K Z
shell		^K ^Z
shell		^K z
stop		^K ]
uparwtab	UP
uparwtab	^P
uparwtab	^[ [ A
uparwtab	^[ O A
X
:help
X
aborthelp	^C
arg		^[ 1 TO 9
bofhelp		^K U
bofhelp		^K ^U
bofhelp		^K u
bolhelp		HOME
bolhelp		^A
dnarwhelp	DOWN
dnarwhelp	^N
dnarwhelp	^[ [ B
dnarwhelp	^[ O B
eofhelp		^K V
eofhelp		^K ^V
eofhelp		^K v
eolhelp		END
eolhelp		^E
explode		^K I
explode		^K ^I
explode		^K i
ltarwhelp	LEFT
ltarwhelp	^B
ltarwhelp	^[ [ D
ltarwhelp	^[ O D
nextw		^K N
nextw		^K ^N
nextw		^K n
play		^K 0 TO 9
prevw		^K P
prevw		^K ^P
prevw		^K p
record		^K [
retype		^R
rtarwhelp	RIGHT
rtarwhelp	^F
rtarwhelp	^[ [ C
rtarwhelp	^[ O C
rtnhelp		SP
rtnhelp		^M
rtnhelp		^K H
rtnhelp		^K ^H
rtnhelp		^K h
shell		^K Z
shell		^K ^Z
shell		^K z
stop		^K ]
uparwhelp	UP
uparwhelp	^P
uparwhelp	^[ [ A
uparwhelp	^[ O A
SHAR_EOF
chmod 0600 .joerc ||
echo 'restore of .joerc failed'
Wc_c="`wc -c < '.joerc'`"
test 19130 -eq "$Wc_c" ||
	echo '.joerc: original size 19130, current size' "$Wc_c"
fi
exit 0
