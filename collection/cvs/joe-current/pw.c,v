head	1.44;
access;
symbols
	joe_3_5:1.36
	joe-3_4:1.34
	help:1.34
	joe_3_1:1.18
	joe_3_0:1.15
	joe_2_9_8:1.12
	joe_2_9_8_pre1:1.10
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2008.10.29.22.58.48;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.04.01.13.32;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.31.02.31.55;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.21.04.57.23;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.05.04.50.00;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.05.04.17.53;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.30.04.40.48;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.28.15.13.13;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.21.19.31.27;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.20.03.50.59;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.20.03.31.26;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.18.03.29.32;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.17.23.54.46;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.02.06.16.16;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.21.14.47.36;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.08.04.42.41;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.07.19.43.29;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.23.02.14.08;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.04.17.39.06;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.12.09.38;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.56;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.56;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Turn off UTF-8 when we enter hex
@
text
@/*
 *	Prompt windows
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* The current directory */

int bg_prompt;
int nocurdir;
unsigned char *current_dir;

void set_current_dir(unsigned char *s,int simp)
{
	if (s[0]=='!' || (s[0]=='>' && s[1]=='>'))
		return;
	obj_free(current_dir);
	if (s) {
		current_dir=dirprt(s);
		if (simp) {
			current_dir = simplify_prefix(current_dir);
		}
	}
	else
		current_dir = 0;
	obj_perm(current_dir);
}

static void disppw(BW *bw, int flg)
{
	unsigned char *bf;
	int i;
	W *w = bw->parent;
	PW *pw = (PW *) bw->object;

	if (!flg) {
		return;
	}

	/* Try a nice graphics separator */
	bf = joe_malloc(w->w + 1);
	for (i = 0; i != w->w; ++i)
		bf[i] = '-';
	bf[i] = 0;
	genfmt(w->t->t, w->x, w->y, 0, bf, bg_stalin, 0);
	joe_free(bf);

	/* Scroll buffer and position prompt */
	if (pw->promptlen > w->w - 5) {
		pw->promptofst = pw->promptlen - w->w / 2;
		if (piscol(bw->cursor) < w->w - (pw->promptlen - pw->promptofst)) {
			bw->offset = 0;
		} else {
			bw->offset = piscol(bw->cursor) - (w->w - (pw->promptlen - pw->promptofst) - 1);
		}
	} else {
		if (piscol(bw->cursor) < w->w - pw->promptlen) {
			pw->promptofst = 0;
			bw->offset = 0;
		} else if (piscol(bw->cursor) >= w->w) {
			pw->promptofst = pw->promptlen;
			bw->offset = piscol(bw->cursor) - (w->w - 1);
		} else {
			pw->promptofst = pw->promptlen - (w->w - piscol(bw->cursor) - 1);
			bw->offset = piscol(bw->cursor) - (w->w - (pw->promptlen - pw->promptofst) - 1);
		}
	}

	/* Set cursor position */
	w->curx = piscol(bw->cursor) - bw->offset + pw->promptlen - pw->promptofst;
	w->cury = bw->cursor->line - bw->top->line + 1;
	/* w->cury = w->h - 1; */

	/* Generate prompt */
	w->t->t->updtab[w->y + w->cury] = 1;
	if (w->cury != pw->oldcury) {
		int n;
		for (n = 0; n != w->h; ++n)
			w->t->t->updtab[w->y + n] = 1;
		pw->oldcury = w->cury;
	}
	/* w->t->t->updtab[w->y + w->h - 1] = 1;
	genfmt(w->t->t, w->x, w->y + w->h - 1, pw->promptofst, pw->prompt, BG_COLOR(bg_prompt), 0); */

	/* Position and size buffer */
	/* bwmove(bw, w->x + pw->promptlen - pw->promptofst, w->y);
	bwresz(bw, w->w - (pw->promptlen - pw->promptofst), w->h); */
	bwmove(bw, w->x, w->y + 1);
	bwresz(bw, w->w, w->h - 1);

	/* Generate buffer */
	bwgen(bw, 0);
}

/* History functions */

void setup_history(B **history)
{
	if (!*history) {
		*history = bmk(NULL);
	}
}

/* Add line to history buffer */

void append_history(B *hist,unsigned char *s,int len)
{
	P *q = pdup(hist->eof, USTR "append_history");
	binsm(q, s, len);
	p_goto_eof(q);
	binsc(q, '\n');
	prm(q);
}

/* Promote line to end of history buffer */

void promote_history(B *hist, long line)
{
	P *q = pdup(hist->bof, USTR "promote_history");
	P *r;
	P *t;

	pline(q, line);
	r = pdup(q, USTR "promote_history");
	pnextl(r);
	t = pdup(hist->eof, USTR "promote_history");
	binsb(t, bcpy(q, r));
	bdel(q, r);
	prm(q);
	prm(r);
	prm(t);
}

/* When user hits return in a prompt window */

static int rtnpw(BW *bw)
{
	W *w = bw->parent;
	PW *pw = (PW *) bw->object;
	unsigned char *s;
	W *win;
	int (*pfunc) ();
	void *object;
	long byte;

	/* Extract entered text from buffer */
	p_goto_eol(bw->cursor);
	byte = bw->cursor->byte;
	p_goto_bol(bw->cursor);
	s = brvs(NULL, bw->cursor, (int) (byte - bw->cursor->byte));

	/* Save text into history buffer */
	if (pw->hist) {
		if (bw->b->changed) {
			append_history(pw->hist, sv(s));
		} else {
			promote_history(pw->hist, bw->cursor->line);
		}
	}

	/* Do ~ expansion and set new current directory */
	if (pw->file_prompt&2) {
		set_current_dir(s,1);
	}

	if (pw->file_prompt) {
		s = canonical(s);
	}

	win = w->win;
	pfunc = pw->pfunc;
	object = pw->object;
	bwrm(bw);
	joe_free(pw->prompt);
	joe_free(pw);
	w->object = NULL;
	wabort(w);
	dostaupd = 1;

	/* Call callback function */
	if (pfunc) {
		return pfunc(win->object, s, object);
	} else {
		return -1;
	}
}

int ucmplt(BW *bw, int k)
{
	PW *pw = (PW *) bw->object;

	if (pw->tab) {
		return pw->tab(bw, k);
	} else {
		return -1;
	}
}

static void inspw(BW *bw, B *b, long l, long n, int flg)
{
	if (b == bw->b) {
		bwins(bw, l, n, flg);
	}
}

static void delpw(BW *bw, B *b, long l, long n, int flg)
{
	if (b == bw->b) {
		bwdel(bw, l, n, flg);
	}
}

static int abortpw(BW *b)
{
	PW *pw = b->object;
	void *object = pw->object;
	int (*abrt) () = pw->abrt;

	W *win = b->parent->win;

	bwrm(b);
	joe_free(pw->prompt);
	joe_free(pw);
	if (abrt) {
		return abrt(win->object, object);
	} else {
		return -1;
	}
}

WATOM watompw = {
	USTR "prompt",
	disppw,
	bwfllwt,
	abortpw,
	rtnpw,
	utypebw,
	NULL,
	NULL,
	inspw,
	delpw,
	TYPEPW
};

/* Create a prompt window */

BW *wmkpw(W *w, unsigned char *prompt, B **history, int (*func) (), unsigned char *huh, int (*abrt) (), int (*tab) (), void *object, struct charmap *map,int file_prompt)
{
	W *new;
	PW *pw;
	BW *bw;

	new = wcreate(w->t, &watompw, w, w, w->main, 2, huh);
	if (!new) {
		return NULL;
	}
	new->fixed = 0;
	wfit(new->t);
	new->object = (void *) (bw = bwmk(new, bmk(NULL), 0, prompt));
	bw->b->o.charmap = map;
	bw->object = (void *) (pw = (PW *) joe_malloc(sizeof(PW)));
	pw->abrt = abrt;
	pw->oldcury = -1;
	pw->tab = tab;
	pw->object = object;
	pw->prompt = zdup(prompt);
	pw->promptlen = fmtlen(prompt);
	pw->promptofst = 0;
	pw->pfunc = func;
	pw->file_prompt = file_prompt;
	if (history) {
		setup_history(history);
		pw->hist = *history;
		binsb(bw->cursor, bcpy(pw->hist->bof, pw->hist->eof));
		bw->b->changed = 0;
		p_goto_eof(bw->cursor);
		/* p_goto_eof(bw->top);
		p_goto_bol(bw->top); */
	} else {
		pw->hist = NULL;
	}
	/* Install current directory */
	if ((file_prompt&4) && !nocurdir) {
		binsm (bw->cursor, sv(current_dir));
		p_goto_eof(bw->cursor);
		bw->cursor->xcol = piscol(bw->cursor);
	}
	w->t->curwin = new;
	return bw;
}

/* Tab completion functions */

unsigned char **regsub(unsigned char **z, int len, unsigned char *s)
{
	unsigned char **lst = NULL;
	int x;

	for (x = 0; x != len; ++x)
		if (rmatch(s, z[x]))
			lst = vaadd(lst, vsncpy(NULL, 0, sz(z[x])));
	return lst;
}

void cmplt_ins(BW *bw, unsigned char *line)
{
	P *p = pdup(bw->cursor, USTR "cmplt_ins");

	p_goto_bol(p);
	p_goto_eol(bw->cursor);
	bdel(p, bw->cursor);
	binsm(bw->cursor, sv(line));
	p_goto_eol(bw->cursor);
	prm(p);
	bw->cursor->xcol = piscol(bw->cursor);
}

int cmplt_abrt(BW *bw, int x, unsigned char *line)
{
	if (line) {
		/* cmplt_ins(bw, line); */
		obj_free(line);
	}
	return -1;
}

int cmplt_rtn(MENU *m, int x, unsigned char *line)
{
	cmplt_ins(m->parent->win->object, m->list[x]);
	obj_free(line);
	m->object = NULL;
	wabort(m->parent);
	return 0;
}

int simple_cmplt(BW *bw,unsigned char **list)
{
	MENU *m;
	P *p, *q;
	unsigned char *line;
	unsigned char *line1;
	unsigned char **lst;

	p = pdup(bw->cursor, USTR "simple_cmplt");
	p_goto_bol(p);
	q = pdup(bw->cursor, USTR "simple_cmplt");
	p_goto_eol(q);
	line = brvs(NULL, p, (int) (q->byte - p->byte));	/* Assumes short lines :-) */
	prm(p);
	prm(q);

	line1 = vsncpy(NULL, 0, sv(line));
	line1 = vsadd(line1, '*');
	lst = regsub(av(list), line1);

	if (!lst) {
		ttputc(7);
		return -1;
	}

	if (menu_above) {
		if (bw->parent->link.prev->watom==&watommenu) {
			wabort(bw->parent->link.prev);
		}
	} else {
		if (bw->parent->link.next->watom==&watommenu) {
			wabort(bw->parent->link.next);
		}
	}

	obj_perm(line);
	vaperm(lst);
	m = mkmenu((menu_above ? bw->parent->link.prev : bw->parent), bw->parent, lst, cmplt_rtn, cmplt_abrt, NULL, 0, line);
	if (!m) {
		return -1;
	}
	if (valen(lst) == 1)
		return cmplt_rtn(m, 0, line);
	else if (smode || isreg(line)) {
		if (!menu_jump)
			bw->parent->t->curwin=bw->parent;
		return 0;
	} else {
		unsigned char *com = mcomplete(m);

		obj_free(m->object);
		m->object = com;
		obj_perm(com);
		
		cmplt_ins(bw, com);
		wabort(m->parent);
		smode = 2;
		ttputc(7);
		return 0;
	}
}

/* Simplified prompting... convert original event-driven style to
 * coroutine model */

struct prompt_result {
	Coroutine t;
	unsigned char *answer;
};

int prompt_cont(BW *bw, unsigned char *s, void *object)
{
	struct prompt_result *r = (struct prompt_result *)object;
	r->answer = s;

	/* move answer to original coroutine's obj_stack */
	obj_perm(r->answer);

	co_resume(&r->t, 0);

	return 0;
}

int prompt_abrt(BW *bw, void *object)
{
	struct prompt_result *r = (struct prompt_result *)object;
	r->answer = 0;
	co_resume(&r->t, -1);
	return -1;
}

unsigned char *ask(W *w,			/* Prompt goes below this window */
                   unsigned char *prompt,	/* Prompt text */
                   B **history,			/* History buffer to use */
                   unsigned char *huh,		/* Name of help screen for this prompt */
                   int (*tab)(),		/* Called when tab key is pressed */
                   struct charmap *map,		/* Character map for prompt */
                   int file_prompt,		/* Set for file-name tilde expansion */
                   int retrieve_last,		/* Set for cursor to go on last line of history */
                   unsigned char *preload)	/* Text to preload into prompt */
{
	struct prompt_result t;
	BW *bw = wmkpw(w, prompt, history, prompt_cont, huh, prompt_abrt, tab, 
	               &t, map, file_prompt);
	if (!bw)
		return 0;

	bw->parent->coro = &t.t;
	if (preload) {
		/* Load hint, put cursor after it */
		binss(bw->cursor, preload);
		pset(bw->cursor, bw->b->eof);
		bw->cursor->xcol = piscol(bw->cursor);
	} else if (retrieve_last) {
		/* One step back through history */
		uuparw(bw);
		u_goto_eol(bw);
		bw->cursor->xcol = piscol(bw->cursor);
	}

	/* We get woken up when user hits return */
	if (!co_yield(&t.t, 0)) {
		/* Moving answer to original coroutine's stack */
		obj_temp(t.answer);
		return t.answer;
	} else {
		return 0;
	}
}
@


1.43
log
@More work on coroutine refactoring.
@
text
@d234 1
a234 1
static WATOM watompw = {
@


1.42
log
@more work on coroutine refactor
prompt window experiment
@
text
@a144 1
	int *notify;
a179 2
	notify = w->notify;
	w->notify = 0;
d185 1
a185 1
		return pfunc(win->object, s, object, notify);
d250 1
a250 1
BW *wmkpw(W *w, unsigned char *prompt, B **history, int (*func) (), unsigned char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify,struct charmap *map,int file_prompt)
d256 1
a256 1
	new = wcreate(w->t, &watompw, w, w, w->main, 2, huh, notify);
a257 3
		if (notify) {
			*notify = 1;
		}
d376 1
a376 1
	m = mkmenu((menu_above ? bw->parent->link.prev : bw->parent), bw->parent, lst, cmplt_rtn, cmplt_abrt, NULL, 0, line, NULL);
d409 1
a409 1
int prompt_cont(BW *bw, unsigned char *s, void *object, int *notify)
a418 4
	/* This can't be right: caller must decide when to set notify */
	if (notify)
		*notify = 1;

d442 1
a442 1
	               &t, NULL, map, file_prompt);
@


1.41
log
@get uquery to use coroutines: eliminates recursive edloop calls.
@
text
@d34 2
d43 8
d74 2
a75 1
	w->cury = 0;
d78 9
a86 2
	w->t->t->updtab[w->y] = 1;
	genfmt(w->t->t, w->x, w->y, pw->promptofst, pw->prompt, BG_COLOR(bg_prompt), 0);
d89 4
a92 2
	bwmove(bw, w->x + pw->promptlen - pw->promptofst, w->y);
	bwresz(bw, w->w - (pw->promptlen - pw->promptofst), 1);
d259 1
a259 1
	new = wcreate(w->t, &watompw, w, w, w->main, 1, huh, notify);
d266 1
d268 1
a268 1
	new->object = (void *) (bw = bwmk(new, bmk(NULL), 1));
d272 1
d286 2
a287 2
		p_goto_eof(bw->top);
		p_goto_bol(bw->top);
@


1.40
log
@more refactoring
@
text
@d434 1
@


1.39
log
@fix obj_stack leak during coroutine switch
@
text
@a422 1
                   int *notify,			/* Set when prompt is done (for macros) */
d430 1
a430 1
	               &t, notify, map, file_prompt);
@


1.38
log
@coroutines
@
text
@d385 2
a386 1
/* Simplified prompting... */
d388 4
a391 1
unsigned char *answer;
d395 5
a399 3
	Coroutine *t = (Coroutine *)object;
	answer = s;
	obj_perm(answer);
d401 1
a401 1
	co_resume(t, 0);
d403 1
d412 3
a414 3
	Coroutine *t = (Coroutine *)object;
	answer = 0;
	co_resume(t, -1);
d418 10
a427 3
unsigned char *ask(W *w, unsigned char *prompt, B **history,
                   unsigned char *huh, int (*tab)(), int *notify,
                   struct charmap *map, int file_prompt)
d429 1
a429 1
	Coroutine t;
d435 12
d448 4
a451 3
	if (!co_yield(&t, 0)) {
		obj_temp(answer);
		return answer;
@


1.37
log
@semiautomatic variables
@
text
@d384 45
@


1.36
log
@UC -> USTR
@
text
@d20 1
a20 1
	vsrm(current_dir);
d24 1
a24 3
			unsigned char *tmp = simplify_prefix(current_dir);
			vsrm(current_dir);
			current_dir = tmp;
d29 1
d134 1
a134 1
	s = brvs(bw->cursor, (int) (byte - bw->cursor->byte));
d309 1
a309 1
		vsrm(line);
d317 1
a317 1
	vsrm(line);
d335 1
a335 1
	line = brvs(p, (int) (q->byte - p->byte));	/* Assumes short lines :-) */
d341 1
a341 2
	lst = regsub(list, aLEN(list), line1);
	vsrm(line1);
a344 1
		vsrm(line);
d358 2
a361 2
		varm(lst);
		vsrm(line);
d364 1
a364 1
	if (aLEN(lst) == 1)
d373 1
a373 1
		vsrm(m->object);
d375 1
@


1.35
log
@change US to UC
@
text
@d92 1
a92 1
	P *q = pdup(hist->eof, UC "append_history");
d103 1
a103 1
	P *q = pdup(hist->bof, UC "promote_history");
d108 1
a108 1
	r = pdup(q, UC "promote_history");
d110 1
a110 1
	t = pdup(hist->eof, UC "promote_history");
d219 1
a219 1
	UC "prompt",
d295 1
a295 1
	P *p = pdup(bw->cursor, UC "cmplt_ins");
d332 1
a332 1
	p = pdup(bw->cursor, UC "simple_cmplt");
d334 1
a334 1
	q = pdup(bw->cursor, UC "simple_cmplt");
@


1.34
log
@A option for search
Restore cursor to old position
@
text
@d92 1
a92 1
	P *q = pdup(hist->eof, US "append_history");
d103 1
a103 1
	P *q = pdup(hist->bof, US "promote_history");
d108 1
a108 1
	r = pdup(q, US "promote_history");
d110 1
a110 1
	t = pdup(hist->eof, US "promote_history");
d219 1
a219 1
	US "prompt",
d295 1
a295 1
	P *p = pdup(bw->cursor, US "cmplt_ins");
d332 1
a332 1
	p = pdup(bw->cursor, US "simple_cmplt");
d334 1
a334 1
	q = pdup(bw->cursor, US "simple_cmplt");
@


1.33
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d43 1
a43 1
	if (pw->promptlen > w->w / 2 + w->w / 4) {
@


1.32
log
@add joe_debug
@
text
@a7 1
#include "config.h"
a9 22
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include "b.h"
#include "bw.h"
#include "help.h"
#include "kbd.h"
#include "pw.h"
#include "scrn.h"
#include "tab.h"
#include "termcap.h"
#include "tw.h"
#include "uedit.h"
#include "undo.h"
#include "utils.h"
#include "vfile.h"
#include "menu.h"
#include "va.h"
#include "path.h"
#include "w.h"

d18 1
a18 1
	if (s[0]=='!' || s[0]=='>' && s[1]=='>')
a32 3
extern int smode;
extern int joe_beep;

a119 2
extern volatile int dostaupd;

a238 2
	unsigned char *s;
	unsigned char *t;
a323 5
extern int menu_jump;
extern WATOM watommenu;

extern int menu_above;

@


1.31
log
@menu_above option
@
text
@d118 1
a118 1
	P *q = pdup(hist->eof);
d129 1
a129 1
	P *q = pdup(hist->bof);
d134 1
a134 1
	r = pdup(q);
d136 1
a136 1
	t = pdup(hist->eof);
d325 1
a325 1
	P *p = pdup(bw->cursor);
d367 1
a367 1
	p = pdup(bw->cursor);
d369 1
a369 1
	q = pdup(bw->cursor);
@


1.30
log
@File selection menu is now above prompt instead of below it.
@
text
@d357 2
d386 8
a393 2
	if (bw->parent->link.next->watom==&watommenu) {
		wabort(bw->parent->link.next);
d396 1
a396 1
	m = mkmenu(bw->parent, bw->parent, lst, cmplt_rtn, cmplt_abrt, NULL, 0, line, NULL);
@


1.29
log
@fix gcc-4.0.0 warnings
@
text
@d388 1
a388 1
	m = mkmenu(bw->parent, lst, cmplt_rtn, cmplt_abrt, NULL, 0, line, NULL);
@


1.28
log
@fix mouse & hex bugs
@
text
@a10 1
#include <string.h>
d284 1
a284 1
	pw->prompt = joe_strdup(prompt);
@


1.27
log
@Background color for screen item
@
text
@d250 1
a250 1
	bwfllw,
@


1.26
log
@Fix paths beginning with !
@
text
@d36 1
d96 1
a96 1
	genfmt(w->t->t, w->x, w->y, pw->promptofst, pw->prompt, 0);
@


1.25
log
@Get current directory from files on command line
@
text
@d41 2
@


1.24
log
@Current directory stuff
@
text
@d39 15
d174 1
a174 2
		vsrm(current_dir);
		current_dir=dirprt(s);
@


1.23
log
@Save file names from command line in state file
@
text
@d12 3
d31 1
d34 5
d157 7
a163 2
	/* Do ~ expansion */
	if (pw->file_prompt)
d165 1
d251 2
d284 6
@


1.22
log
@Get joe to compile on irix
@
text
@d79 39
d133 1
d138 2
d142 1
a142 6
			P *q = pdup(pw->hist->eof);

			binsm(q, s, (int) (byte - bw->cursor->byte));
			p_goto_eof(q);
			binsc(q, '\n');
			prm(q);
d144 1
a144 13
			P *q = pdup(pw->hist->bof);
			P *r;
			P *t;

			pline(q, bw->cursor->line);
			r = pdup(q);
			pnextl(r);
			t = pdup(pw->hist->eof);
			binsb(t, bcpy(q, r));
			bdel(q, r);
			prm(q);
			prm(r);
			prm(t);
d164 1
a164 1

d257 1
a257 3
		if (!*history) {
			*history = bmk(NULL);
		}
@


1.21
log
@Fix ~ expansion insanity
@
text
@d31 1
a31 1
extern int beep;
@


1.20
log
@jump_menu applies to all menus
@
text
@d122 5
d138 2
d206 1
a206 1
BW *wmkpw(W *w, unsigned char *prompt, B **history, int (*func) (), unsigned char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify,struct charmap *map)
d230 1
@


1.19
log
@Fix -pedantic warnings.
@
text
@d269 1
a269 1
		cmplt_ins(bw, line);
d284 3
d314 4
d326 3
a328 1
	else if (smode || isreg(line))
d330 1
a330 1
	else {
d335 2
@


1.18
log
@Tab completion insanity!  Completion in ^K F plus ESC-TAB in text windows.
@
text
@d219 1
a219 1
	pw->prompt = (unsigned char *)strdup((char *)prompt);
@


1.17
log
@joe a b c, now windows are in order a, b, c.

TAB completion now works on last path in prompt window:
for example '!ls foo', tab will complete the foo.

Added menu_explorer option.  When set: menu stays up when
a directory is seleted.  When clear: directory is added
to path and menu is closed.

Menus are now 40% of window size (or smaller if they are
not filled).

Cursor is now position after selected menu entry.
@
text
@d306 1
a306 2
		if (beep)
			ttputc(7);
d328 1
a328 2
		if(beep)
			ttputc(7);
@


1.16
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d299 1
a299 3
	m = mkmenu(bw->parent, NULL, cmplt_rtn, cmplt_abrt, NULL, 0, line, NULL);
	if (!m)
		return -1;
d304 1
a304 1
	ldmenu(m, lst, 0);
d306 21
d328 1
d331 1
a331 17
		return -1;
	} else {
		if (aLEN(lst) == 1)
			return cmplt_rtn(m, 0, line);
		else if (smode || isreg(line))
			return 0;
		else {
			unsigned char *com = mcomplete(m);

			vsrm(m->object);
			m->object = com;
			wabort(m->parent);
			smode = 2;
			if(beep)
				ttputc(7);
			return 0;
		}
@


1.15
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@a197 4
/* wide=-1: use default
   wide=0: use 8-bit chars
   wide=1: use UTF-8
*/
d199 1
a199 1
BW *wmkpw(W *w, unsigned char *prompt, B **history, int (*func) (), unsigned char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify,int wide)
d214 1
a214 2
	if (wide!=-1)
		bw->b->o.utf8= wide;
@


1.14
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d26 2
d30 3
d244 91
@


1.13
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d193 4
d198 1
a198 1
BW *wmkpw(W *w, unsigned char *prompt, B **history, int (*func) (), unsigned char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify)
d213 2
@


1.12
log
@change 0 to NULL where we're talking about pointers
@
text
@d82 1
a82 1
	char *s;
d179 1
a179 1
	"prompt",
d194 1
a194 1
BW *wmkpw(W *w, char *prompt, B **history, int (*func) (), char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify)
d213 1
a213 1
	pw->prompt = strdup(prompt);
@


1.11
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d123 1
a123 1
	w->object = 0;
d185 2
a186 2
	0,
	0,
d205 1
a205 1
		return 0;
d228 1
a228 1
		pw->hist = 0;
@


1.10
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d47 2
a48 1
			pw->promptofst = 0, bw->offset = 0;
d50 2
a51 1
			pw->promptofst = pw->promptlen, bw->offset = piscol(bw->cursor) - (w->w - 1);
d53 2
a54 1
			pw->promptofst = pw->promptlen - (w->w - piscol(bw->cursor) - 1), bw->offset = piscol(bw->cursor) - (w->w - (pw->promptlen - pw->promptofst) - 1);
@


1.9
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@a11 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d24 1
d118 2
a119 2
	free(pw->prompt);
	free(pw);
d166 2
a167 2
	free(pw->prompt);
	free(pw);
d206 1
a206 1
	bw->object = (void *) (pw = (PW *) malloc(sizeof(PW)));
@


1.8
log
@include only headers which are needed
@
text
@d30 1
a30 1
static void disppw(BW * bw, int flg)
d77 1
a77 1
static int rtnpw(BW * bw)
d134 1
a134 1
int ucmplt(BW * bw, int k)
d145 1
a145 1
static void inspw(BW * bw, B * b, long l, long n, int flg)
d152 1
a152 1
static void delpw(BW * bw, B * b, long l, long n, int flg)
d159 1
a159 1
static int abortpw(BW * b)
d193 1
a193 1
BW *wmkpw(W * w, char *prompt, B ** history, int (*func) (), char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify)
@


1.7
log
@put struct definitions and other goodies into types.h
@
text
@d15 1
a15 4
#include "w.h"
#include "tw.h"
#include "vfile.h"
#include "termcap.h"
d17 2
d20 1
a21 2
#include "bw.h"
#include "help.h"
d23 3
d27 2
a28 2
#include "uedit.h"
#include "pw.h"
@


1.6
log
@version 2.9.7-pre3
@
text
@d2 8
a9 5
	Prompt windows
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d74 1
a74 1
int rtnpw(BW * bw)
@


1.4
log
@changed as of joe-2.9.6
@
text
@d8 1
d10 3
a12 1
#include "config.h"
d27 2
a28 1
static void disppw (BW *bw, int flg) {
d39 1
a39 1
		if (piscol (bw->cursor) < w->w - (pw->promptlen - pw->promptofst)) {
d42 1
a42 1
			bw->offset = piscol (bw->cursor) - (w->w - (pw->promptlen - pw->promptofst) - 1);
d45 1
a45 1
		if (piscol (bw->cursor) < w->w - pw->promptlen) {
d47 2
a48 2
		} else if (piscol (bw->cursor) >= w->w) {
			pw->promptofst = pw->promptlen, bw->offset = piscol (bw->cursor) - (w->w - 1);
d50 1
a50 1
			pw->promptofst = pw->promptlen - (w->w - piscol (bw->cursor) - 1), bw->offset = piscol (bw->cursor) - (w->w - (pw->promptlen - pw->promptofst) - 1);
d55 1
a55 1
	w->curx = piscol (bw->cursor) - bw->offset + pw->promptlen - pw->promptofst;
d60 1
a60 1
	genfmt (w->t->t, w->x, w->y, pw->promptofst, pw->prompt, 0);
d63 2
a64 2
	bwmove (bw, w->x + pw->promptlen - pw->promptofst, w->y);
	bwresz (bw, w->w - (pw->promptlen - pw->promptofst), 1);
d67 1
a67 1
	bwgen (bw, 0);
d74 2
a75 1
int rtnpw (BW *bw) {
d85 1
a85 1
	p_goto_eol (bw->cursor);
d87 2
a88 2
	p_goto_bol (bw->cursor);
	s = brvs (bw->cursor, (int) (byte - bw->cursor->byte));
d91 6
a96 5
			  P *q = pdup (pw->hist->eof);
			  binsm (q, s, (int) (byte - bw->cursor->byte));
			  p_goto_eof (q);
			  binsc (q, '\n');
			  prm (q);
d98 13
a110 12
			  P *q = pdup (pw->hist->bof);
			  P *r;
			  P *t;
			  pline (q, bw->cursor->line);
			  r = pdup (q);
			  pnextl (r);
			  t = pdup (pw->hist->eof);
			  binsb (t, bcpy (q, r));
			  bdel (q, r);
			  prm (q);
			  prm (r);
			  prm (t);
d116 3
a118 3
	bwrm (bw);
	free (pw->prompt);
	free (pw);
d122 1
a122 1
	wabort (w);
d125 1
a125 1
		return pfunc (win->object, s, object, notify);
d131 2
a132 1
int ucmplt (BW *bw, int k) {
d136 1
a136 1
		return pw->tab (bw, k);
d142 2
a143 1
static void inspw (BW *bw, B *b, long l, long n, int flg) {
d145 1
a145 1
		bwins (bw, l, n, flg);
d149 2
a150 1
static void delpw (BW *bw, B *b, long l, long n, int flg) {
d152 1
a152 1
		bwdel (bw, l, n, flg);
d156 2
a157 1
static int abortpw (BW *b) {
d163 4
a166 3
	bwrm (b);
	free (pw->prompt);
	free (pw);
d168 1
a168 1
		return abrt (win->object, object);
d190 2
a191 1
BW *wmkpw (W *w, char *prompt, B **history, int (*func) (), char *huh, int (*abrt) (), int (*tab) (), void *object, int *notify) {
d196 1
a196 1
	new = wcreate (w->t, &watompw, w, w, w->main, 1, huh, notify);
d199 1
a199 1
			  *notify = 1;
d203 3
a205 3
	wfit (new->t);
	new->object = (void *) (bw = bwmk (new, bmk (NULL), 1));
	bw->object = (void *) (pw = (PW *) malloc (sizeof (PW)));
d209 2
a210 2
	pw->prompt = strdup (prompt);
	pw->promptlen = fmtlen (prompt);
d215 1
a215 1
			  *history = bmk (NULL);
d218 1
a218 1
		binsb (bw->cursor, bcpy (pw->hist->bof, pw->hist->eof));
d220 3
a222 3
		p_goto_eof (bw->cursor);
		p_goto_eof (bw->top);
		p_goto_bol (bw->top);
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Prompt windows
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d24 41
a64 40
static void disppw(bw,flg)
BW *bw;
 {
 W *w=bw->parent;
 PW *pw=(PW *)bw->object;
 if(!flg) return;
 /* Scroll buffer and position prompt */
 if(pw->promptlen>w->w/2+w->w/4)
  {
  pw->promptofst=pw->promptlen-w->w/2;
  if(piscol(bw->cursor)<w->w-(pw->promptlen-pw->promptofst))
   bw->offset=0;
  else
   bw->offset=piscol(bw->cursor)-(w->w-(pw->promptlen-pw->promptofst)-1);
  }
 else
  { 
  if(piscol(bw->cursor)<w->w-pw->promptlen) pw->promptofst=0, bw->offset=0;
  else if(piscol(bw->cursor)>=w->w)
   pw->promptofst=pw->promptlen, bw->offset=piscol(bw->cursor)-(w->w-1);
  else
   pw->promptofst=pw->promptlen-(w->w-piscol(bw->cursor)-1),
   bw->offset=piscol(bw->cursor)-(w->w-(pw->promptlen-pw->promptofst)-1);
  }

 /* Set cursor position */
 w->curx=piscol(bw->cursor)-bw->offset+pw->promptlen-pw->promptofst;
 w->cury=0;

 /* Generate prompt */
 w->t->t->updtab[w->y]=1;
 genfmt(w->t->t,w->x,w->y,pw->promptofst,pw->prompt,0);

 /* Position and size buffer */
 bwmove(bw,w->x+pw->promptlen-pw->promptofst,w->y);
 bwresz(bw,w->w-(pw->promptlen-pw->promptofst),1);

 /* Generate buffer */
 bwgen(bw,0);
 }
d68 1
a68 1
extern int dostaupd;
d70 105
a174 106
int rtnpw(bw)
BW *bw;
 {
 W *w=bw->parent;
 PW *pw=(PW *)bw->object;
 char *s;
 W *win;
 int *notify;
 int (*pfunc)();
 void *object;
 long byte;
 peol(bw->cursor);
 byte=bw->cursor->byte;
 pbol(bw->cursor);
 s=brvs(bw->cursor,(int)(byte-bw->cursor->byte));
 if(pw->hist)
  if(bw->b->changed)
   {
   P *q=pdup(pw->hist->eof);
   binsm(q,s,(int)(byte-bw->cursor->byte));
   peof(q);
   binsc(q,'\n');
   prm(q);
   }
  else
   {
   P *q=pdup(pw->hist->bof);
   P *r;
   P *t;
   pline(q,bw->cursor->line);
   r=pdup(q);
   pnextl(r);
   t=pdup(pw->hist->eof);
   binsb(t,bcpy(q,r));
   bdel(q,r);
   prm(q); prm(r); prm(t);
   }
 win=w->win;
 pfunc=pw->pfunc;
 object=pw->object;
 bwrm(bw);
 free(pw->prompt);
 free(pw);
 w->object=0;
 notify=w->notify;
 w->notify=0;
 wabort(w);
 dostaupd=1;
 if(pfunc) return pfunc(win->object,s,object,notify);
 else return -1;
 }

int ucmplt(bw,k)
BW *bw;
 {
 PW *pw=(PW *)bw->object;
 if(pw->tab) return pw->tab(bw,k);
 else return -1;
 }

static void inspw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwins(bw,l,n,flg);
 }

static void delpw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwdel(bw,l,n,flg);
 }

static int abortpw(b)
BW *b;
 {
 PW *pw=b->object;
 void *object=pw->object;
 int (*abrt)()=pw->abrt;
 W *win=b->parent->win;
 bwrm(b);
 free(pw->prompt);
 free(pw);
 if(abrt) return abrt(win->object,object);
 else return -1;
 }

static WATOM watompw=
 {
 "prompt",
 disppw,
 bwfllw,
 abortpw,
 rtnpw,
 utypebw,
 0,
 0,
 inspw,
 delpw,
 TYPEPW
 };
d178 38
a215 43
BW *wmkpw(obw,prompt,history,func,huh,abrt,tab,object,notify)
BASE *obw;
char *prompt;
B **history;
int (*func)();
char *huh;
int (*abrt)();
int (*tab)();
void *object;
int *notify;
 {
 W *new;
 PW *pw;
 BW *bw;
 W *w=obw->parent;
 new=wcreate(w->t,&watompw,w,w,w->main,1,huh,notify);
 if(!new)
  {
  if(notify) *notify=1;
  return 0;
  }
 wfit(new->t);
 new->object=(void *)(bw=bwmk(new,bmk(NULL),1));
 bw->object=(void *)(pw=(PW *)malloc(sizeof(PW)));
 pw->abrt=abrt;
 pw->tab=tab;
 pw->object=object;
 pw->prompt=strdup(prompt);
 pw->promptlen=fmtlen(prompt);
 pw->promptofst=0;
 pw->pfunc=func;
 if(history)
  {
  if(!*history) *history=bmk(NULL);
  pw->hist= *history;
  binsb(bw->cursor,bcpy(pw->hist->bof,pw->hist->eof));
  bw->b->changed=0;
  peof(bw->cursor); peof(bw->top); pbol(bw->top);
  }
 else pw->hist=0;
 w->t->curwin=new;
 return bw;
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@a28 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d19 1
d217 1
a217 1
 pw->prompt=zdup(prompt);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
