head	1.41;
access;
symbols
	joe_3_5:1.37
	joe-3_4:1.33
	help:1.33
	joe_3_1:1.22
	joe_3_0:1.17
	joe_2_9_8:1.13
	joe_2_9_8_pre1:1.10
	joe_2_9_7:1.5
	joe_2_9_7_pre3:1.5
	joe_2_9_7_pre2:1.4
	joe_2_9_6:1.3
	joe_2_9_5:1.2
	joe_2_9_4:1.2
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.23.05.27.50;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.20.20.56.18;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.02.15.01.26;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.21.18.03.34;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.05.20.36.26;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.05.20.20.17;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.24.04.30.52;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.21.20.40.14;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.19.01.22.49;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.16.21.37.37;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.19.20.22.40;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.18.01.42.31;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.14.04.23.09;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.17.13.13.17;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.20.20.26.43;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.20.16.42.29;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.04.17.39.31;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.15.09.24.38;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.53.40;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.41
log
@More work on coroutine refactoring.
@
text
@/*
 *	Shell-window functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Executed when shell process terminates */

static void cdone(B *b)
{
	b->pid = 0;
	close(b->out);
	b->out = -1;
}

static void cdone_parse(B *b)
{
	b->pid = 0;
	close(b->out);
	b->out = -1;
	parserrb(b);
}

/* Executed for each chunk of data we get from the shell */

static void cfollow(B *b,long byte)
{
	W *w;
	 if ((w = maint->topwin) != NULL) {
	 	do {
	 		if ((w->watom->what&TYPETW) && ((BW *)w->object)->b==b && ((BW *)w->object)->cursor->byte==byte) {
	 			BW *bw = (BW *)w->object;
	 			p_goto_eof(bw->cursor);
				bw->cursor->xcol = piscol(bw->cursor);
	 		}
		w = w->link.next;
	 	} while (w != maint->topwin);
	 }
}

static void cdata(B *b, unsigned char *dat, int siz)
{
	P *q = pdup(b->eof, USTR "cdata");
	P *r = pdup(b->eof, USTR "cdata");
	long byte = q->byte;
	unsigned char bf[1024];
	int x, y;

	for (x = y = 0; x != siz; ++x) {
		if (dat[x] == 13 || dat[x] == 0) {
			;
		} else if (dat[x] == 8 || dat[x] == 127) {
			if (y) {
				--y;
			} else {
				pset(q, r);
				prgetc(q);
				bdel(q, r);
				--byte;
			}
		} else if (dat[x] == 7) {
			ttputc(7);
		} else {
			bf[y++] = dat[x];
		}
	}
	if (y) {
		binsm(r, bf, y);
	}
	prm(r);
	prm(q);

	cfollow(b,byte);
}

int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int build, int out_only)
{
#ifdef __MSDOS__
	varm(s);
	msgnw(bw->parent, joe_gettext(_("Sorry, no sub-processes in DOS (yet)")));
	return -1;
#else
	MPX *m;

	if (bw->b->pid) {
		msgnw(bw->parent, joe_gettext(_("Program already running in this window")));
		varm(s);
		return -1;
	}
	/* p_goto_eof(bw->cursor); */

	if (!(m = mpxmk(&bw->b->out, name, s, cdata, bw->b, build ? cdone_parse : cdone, bw->b, out_only))) {
		varm(s);
		msgnw(bw->parent, joe_gettext(_("No ptys available")));
		return -1;
	} else {
		bw->b->pid = m->pid;
	}
	return 0;
#endif
}

int ubknd(BW *bw)
{
	unsigned char **a;
	unsigned char *s;
        unsigned char *sh;

        if (!modify_logic(bw,bw->b))
        	return -1;

        sh=(unsigned char *)getenv("SHELL");

        if (file_exists(sh) && zcmp(sh,USTR "/bin/sh")) goto ok;
        if (file_exists(sh=USTR "/bin/bash")) goto ok;
        if (file_exists(sh=USTR "/usr/bin/bash")) goto ok;
        if (file_exists(sh=USTR "/bin/sh")) goto ok;

        msgnw(bw->parent, joe_gettext(_("\"SHELL\" environment variable not defined or exported")));
        return -1;

        ok:
	a = vamk(3);
	vaperm(a);
	s = vsncpy(NULL, 0, sz(sh));
	a = vaadd(a, s);
	s = vsncpy(NULL, 0, sc("-i"));
	a = vaadd(a, s);
	return cstart(bw, sh, a, NULL, 0, 0);
}

/* Run a program in a window */

B *runhist = NULL;

int urun(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("Program to run: ")), &runhist, USTR "Run",
	                       utypebw, locale_map, 0, 0, NULL);

	if (s) {
		unsigned char **a;
		unsigned char *cmd;

		if (!modify_logic(bw,bw->b))
			return -1;

		a = vamk(10);
		cmd = vsncpy(NULL, 0, sc("/bin/sh"));

		a = vaadd(a, cmd);
		cmd = vsncpy(NULL, 0, sc("-c"));
		a = vaadd(a, cmd);
		a = vaadd(a, s);
		return cstart(bw, USTR "/bin/sh", a, NULL, 0, 0);
	} else {
		return -1;
	}
}

B *buildhist = NULL;

int ubuild(BW *bw)
{
	unsigned char *s;
	int prev = 0;
	if (buildhist) {
		s = joe_gettext(_("Build command: "));
		prev = 1;
	} else {
		s = joe_gettext(_("Enter build command (for example, 'make'): "));
	}
	/* "file prompt" was set for this... */
	s = ask(bw->parent, s, &buildhist, USTR "Run", utypebw, locale_map, 0, prev, NULL);
	if (s) {
		unsigned char **a = vamk(10);
		unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));

		a = vaadd(a, cmd);
		cmd = vsncpy(NULL, 0, sc("-c"));
		a = vaadd(a, cmd);
		a = vaadd(a, s);
		return cstart(bw, USTR "/bin/sh", a, NULL, 1, 0);
	} else {
		return -1;
	}
}

B *grephist = NULL;

int ugrep(BW *bw)
{
	unsigned char *s;
	int prev = 0;
	if (grephist) {
		s = joe_gettext(_("Grep command: "));
		prev = 1;
	} else {
		s = joe_gettext(_("Enter grep command (for example, 'grep -n foo *.c'): "));
	}
	/* "file prompt" was set for this... */
	s = ask(bw->parent, s, &grephist, USTR "Run", utypebw, locale_map, 0, prev, NULL);
	if (s) {
		unsigned char **a = vamk(10);
		unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));

		a = vaadd(a, cmd);
		cmd = vsncpy(NULL, 0, sc("-c"));
		a = vaadd(a, cmd);
		a = vaadd(a, s);
		return cstart(bw, USTR "/bin/sh", a, NULL, 1, 0);
	} else {
		return -1;
	}
}

/* Kill program */

int ukillpid(BW *bw)
{
	if (bw->b->pid) {
		int c = query(bw->parent, sz(joe_gettext(_("Kill program (y,n,^C)?"))), 0);
		if (bw->b->pid && (c == YES_CODE || yncheck(yes_key, c)))
			kill(bw->b->pid, 1);
		return -1;
	} else {
		return 0;
	}
}
@


1.40
log
@more refactoring
@
text
@d79 1
a79 1
int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int *notify, int build, int out_only)
a81 3
	if (notify) {
		*notify = 1;
	}
a87 3
	if (notify) {
		*notify = 1;
	}
d132 1
a132 1
	return cstart(bw, sh, a, NULL, NULL, 0, 0);
d158 1
a158 1
		return cstart(bw, USTR "/bin/sh", a, NULL, NULL /* notify*/, 0, 0);
d186 1
a186 1
		return cstart(bw, USTR "/bin/sh", a, NULL, NULL /* notify */, 1, 0);
d214 1
a214 1
		return cstart(bw, USTR "/bin/sh", a, NULL, NULL /*notify */, 1, 0);
@


1.39
log
@more wmkpw elimination
@
text
@d148 1
a148 1
	                       utypebw, NULL, locale_map, 0, 0, NULL);
d183 1
a183 1
	s = ask(bw->parent, s, &buildhist, USTR "Run", utypebw, NULL, locale_map, 0, prev, NULL);
d211 1
a211 1
	s = ask(bw->parent, s, &grephist, USTR "Run", utypebw, NULL, locale_map, 0, prev, NULL);
d228 1
a228 1
static int pidabort(BW *bw, int c, void *object, int *notify)
a229 6
	if (notify) {
		*notify = 1;
	}
	if (c != YES_CODE && !yncheck(yes_key, c)) {
		return -1;
	}
d231 3
a233 1
		kill(bw->b->pid, 1);
a235 13
		return -1;
	}
}

int ukillpid(BW *bw)
{
	if (bw->b->pid) {
		if (mkqw(bw->parent, sz(joe_gettext(_("Kill program (y,n,^C)?"))), pidabort, NULL, NULL, NULL)) {
			return 0;
		} else {
			return -1;
		}
	} else {
@


1.38
log
@semiautomatic variables
@
text
@d143 3
a145 1
static int dorun(BW *bw, unsigned char *s, void *object, int *notify)
d147 2
a148 2
	unsigned char **a;
	unsigned char *cmd;
d150 3
a152 2
        if (!modify_logic(bw,bw->b))
        	return -1;
d154 2
a155 2
	a = vamk(10);
	cmd = vsncpy(NULL, 0, sc("/bin/sh"));
d157 2
a158 8
	a = vaadd(a, cmd);
	cmd = vsncpy(NULL, 0, sc("-c"));
	a = vaadd(a, cmd);
	a = vaadd(a, s);
	return cstart(bw, USTR "/bin/sh", a, NULL, notify, 0, 0);
}

B *runhist = NULL;
d160 5
a164 4
int urun(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Program to run: ")), &runhist, dorun, USTR "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
		return 0;
a169 12
static int dobuild(BW *bw, unsigned char *s, void *object, int *notify)
{
	unsigned char **a = vamk(10);
	unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));

	a = vaadd(a, cmd);
	cmd = vsncpy(NULL, 0, sc("-c"));
	a = vaadd(a, cmd);
	a = vaadd(a, s);
	return cstart(bw, USTR "/bin/sh", a, NULL, notify, 1, 0);
}

d174 2
d177 16
a192 8
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Build command: ")), &buildhist, dobuild, USTR "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
			uuparw(bw);
			u_goto_eol(bw);
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else {
		return -1;
		}
a193 3
		if (wmkpw(bw->parent, joe_gettext(_("Enter build command (for example, 'make'): ")), &buildhist, dobuild, USTR "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
			return 0;
		} else {
a194 1
		}
d202 2
a203 2
	/* Set parser to grep */
	bw->b->parseone = parseone_grep;
d205 16
a220 8
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Grep command: ")), &grephist, dobuild, USTR "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
			uuparw(bw);
			u_goto_eol(bw);
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else {
		return -1;
		}
a221 3
		if (wmkpw(bw->parent, joe_gettext(_("Enter grep command (for example, 'grep -n foo *.c'): ")), &grephist, dobuild, USTR "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
			return 0;
		} else {
a222 1
		}
@


1.37
log
@UC -> USTR
@
text
@d133 1
@


1.36
log
@change US to UC
@
text
@d46 2
a47 2
	P *q = pdup(b->eof, UC "cdata");
	P *r = pdup(b->eof, UC "cdata");
d123 4
a126 4
        if (file_exists(sh) && zcmp(sh,UC "/bin/sh")) goto ok;
        if (file_exists(sh=UC "/bin/bash")) goto ok;
        if (file_exists(sh=UC "/usr/bin/bash")) goto ok;
        if (file_exists(sh=UC "/bin/sh")) goto ok;
d157 1
a157 1
	return cstart(bw, UC "/bin/sh", a, NULL, notify, 0, 0);
d164 1
a164 1
	if (wmkpw(bw->parent, joe_gettext(_("Program to run: ")), &runhist, dorun, UC "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d180 1
a180 1
	return cstart(bw, UC "/bin/sh", a, NULL, notify, 1, 0);
d188 1
a188 1
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Build command: ")), &buildhist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d197 1
a197 1
		if (wmkpw(bw->parent, joe_gettext(_("Enter build command (for example, 'make'): ")), &buildhist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d212 1
a212 1
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Grep command: ")), &grephist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d221 1
a221 1
		if (wmkpw(bw->parent, joe_gettext(_("Enter grep command (for example, 'grep -n foo *.c'): ")), &grephist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
@


1.35
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d46 2
a47 2
	P *q = pdup(b->eof, US "cdata");
	P *r = pdup(b->eof, US "cdata");
d123 4
a126 4
        if (file_exists(sh) && zcmp(sh,US "/bin/sh")) goto ok;
        if (file_exists(sh=US "/bin/bash")) goto ok;
        if (file_exists(sh=US "/usr/bin/bash")) goto ok;
        if (file_exists(sh=US "/bin/sh")) goto ok;
d157 1
a157 1
	return cstart(bw, US "/bin/sh", a, NULL, notify, 0, 0);
d164 1
a164 1
	if (wmkpw(bw->parent, joe_gettext(_("Program to run: ")), &runhist, dorun, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d180 1
a180 1
	return cstart(bw, US "/bin/sh", a, NULL, notify, 1, 0);
d188 1
a188 1
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Build command: ")), &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d197 1
a197 1
		if (wmkpw(bw->parent, joe_gettext(_("Enter build command (for example, 'make'): ")), &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d212 1
a212 1
		if ((bw=wmkpw(bw->parent, joe_gettext(_("Grep command: ")), &grephist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d221 1
a221 1
		if (wmkpw(bw->parent, joe_gettext(_("Enter grep command (for example, 'grep -n foo *.c'): ")), &grephist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
@


1.34
log
@i18n yes/no
@
text
@d236 1
a236 1
	if (c != YES_CODE && !yncheck(yes_string, c)) {
@


1.33
log
@gettext()
@
text
@d236 1
a236 1
	if (c != 'y' && c != 'Y') {
@


1.32
log
@Better grep-find
@
text
@d86 1
a86 1
	msgnw(bw->parent, "Sorry, no sub-processes in DOS (yet)");
d95 1
a95 1
		msgnw(bw->parent, US "Program already running in this window");
d103 1
a103 1
		msgnw(bw->parent, US "No ptys available");
d128 1
a128 1
        msgnw(bw->parent, US "\"SHELL\" environment variable not defined or exported");
d164 1
a164 1
	if (wmkpw(bw->parent, US "Program to run: ", &runhist, dorun, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d188 1
a188 1
		if ((bw=wmkpw(bw->parent, US "Build command: ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d197 1
a197 1
		if (wmkpw(bw->parent, US "Enter build command (for example, 'make'): ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d212 1
a212 1
		if ((bw=wmkpw(bw->parent, US "Grep command: ", &grephist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1))) {
d221 1
a221 1
		if (wmkpw(bw->parent, US "Enter grep command (for example, 'grep -n foo *.c'): ", &grephist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d250 1
a250 1
		if (mkqw(bw->parent, sc("Kill program (y,n,^C)?"), pidabort, NULL, NULL, NULL)) {
@


1.31
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d99 1
a99 1
	p_goto_eof(bw->cursor);
d209 2
@


1.30
log
@minor redirection fix
@
text
@a7 1
#include "config.h"
a9 24
#include <unistd.h>
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "b.h"
#include "main.h"
#include "pw.h"
#include "qw.h"
#include "tty.h"
#include "ufile.h"
#include "va.h"
#include "vs.h"
#include "utf8.h"
#include "w.h"

extern int orphan;

d188 1
a188 1
		if (bw=wmkpw(bw->parent, US "Build command: ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
d210 1
a210 1
		if (bw=wmkpw(bw->parent, US "Grep command: ", &grephist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map, 1)) {
@


1.29
log
@fix input redirection
@
text
@d104 1
a104 1
static int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int *notify, int build, int out_only)
d167 1
a167 1
int dorun(BW *bw, unsigned char *s, void *object, int *notify)
d182 1
a182 1
	return cstart(bw, US "/bin/sh", a, NULL, notify, 0, 1);
@


1.28
log
@add joe_debug
@
text
@d104 1
a104 1
static int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int *notify, int build)
d126 1
a126 1
	if (!(m = mpxmk(&bw->b->out, name, s, cdata, bw->b, build ? cdone_parse : cdone, bw->b))) {
d162 1
a162 1
	return cstart(bw, sh, a, NULL, NULL, 0);
d167 1
a167 1
static int dorun(BW *bw, unsigned char *s, void *object, int *notify)
d169 2
a170 2
	unsigned char **a = vamk(10);
	unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));
d175 3
d182 1
a182 1
	return cstart(bw, US "/bin/sh", a, NULL, notify, 0);
d205 1
a205 1
	return cstart(bw, US "/bin/sh", a, NULL, notify, 1);
@


1.27
log
@fix gcc-4.0.0 warnings
@
text
@d71 2
a72 2
	P *q = pdup(b->eof);
	P *r = pdup(b->eof);
@


1.26
log
@Grep find improvements
@
text
@d148 1
a148 1
        if (file_exists(sh) && strcmp((char *)sh,"/bin/sh")) goto ok;
@


1.25
log
@fix locks bug, jmacs improvements
@
text
@d227 22
@


1.24
log
@prefer bash over sh for cygwin
@
text
@d143 3
d172 3
@


1.23
log
@Fix ~ expansion insanity
@
text
@d141 1
a141 6
        unsigned char *sh=(unsigned char *)getenv("SHELL");
        if (!sh) {
        	msgnw(bw->parent, US "\"SHELL\" environment variable not defined or exported");
        	/* return -1; */
        	sh = US "/bin/sh";
        }
d143 11
@


1.22
log
@More fixes for Cygwin: shell windows now work properly.
@
text
@d174 1
a174 1
	if (wmkpw(bw->parent, US "Program to run: ", &runhist, dorun, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
d198 1
a198 1
		if (bw=wmkpw(bw->parent, US "Build command: ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
d207 1
a207 1
		if (wmkpw(bw->parent, US "Enter build command (for example, 'make'): ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
@


1.21
log
@Fix backspace handling in shell windows.
Ring bell when we get ^G.
@
text
@d144 2
a145 1
        	return -1;
@


1.20
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d87 1
d89 2
@


1.19
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d37 1
a37 1
static void cdone(BW *bw)
d39 3
a41 13
	bw->pid = 0;
	close(bw->out);
	bw->out = -1;
	if (piseof(bw->cursor)) {
		binss(bw->cursor, US "** Program finished **\n");
		p_goto_eof(bw->cursor);
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		P *q = pdup(bw->b->eof);

		binss(q, US "** Program finished **\n");
		prm(q);
	}
d44 1
a44 1
static void cdone_parse(BW *bw)
d46 4
a49 14
	bw->pid = 0;
	close(bw->out);
	bw->out = -1;
	if (piseof(bw->cursor)) {
		binss(bw->cursor, US "** Program finished **\n");
		p_goto_eof(bw->cursor);
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		P *q = pdup(bw->b->eof);

		binss(q, US "** Program finished **\n");
		prm(q);
	}
	uparserr(bw);
d54 1
a54 1
static void cdata(BW *bw, unsigned char *dat, int siz)
d56 18
a73 2
	P *q = pdup(bw->cursor);
	P *r = pdup(bw->b->eof);
a82 5
			} else if (piseof(bw->cursor)) {
				pset(q, bw->cursor);
				prgetc(q);
				bdel(q, bw->cursor);
				bw->cursor->xcol = piscol(bw->cursor);
d93 1
a93 7
		if (piseof(bw->cursor)) {
			binsm(bw->cursor, bf, y);
			p_goto_eof(bw->cursor);
			bw->cursor->xcol = piscol(bw->cursor);
		} else {
			binsm(r, bf, y);
		}
d97 2
d116 1
a116 1
	if (bw->pid && orphan) {
a120 6
/*
	if (doedit(bw, vsncpy(NULL, 0, sc("")), NULL, NULL)) {
		varm(s);
		return -1;
	}
*/
d122 2
a123 4
/*
	bw = (BW *) maint->curwin->object;
*/
	if (!(m = mpxmk(&bw->out, name, s, cdata, bw, build ? cdone_parse : cdone, bw))) {
d128 1
a128 1
		bw->pid = m->pid;
d193 9
a201 2
	if (wmkpw(bw->parent, US "Build command (for example, 'make'): ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
		return 0;
d203 3
d207 1
d221 2
a222 2
	if (bw->pid) {
		kill(bw->pid, 1);
d231 1
a231 1
	if (bw->pid) {
@


1.18
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d54 18
d114 1
a114 1
static int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int *notify)
d134 1
d139 3
d143 2
a144 1
	if (!(m = mpxmk(&bw->out, name, s, cdata, bw, cdone, bw))) {
d170 1
a170 1
	return cstart(bw, sh, a, NULL, NULL);
d184 1
a184 1
	return cstart(bw, US "/bin/sh", a, NULL, notify);
d198 23
@


1.17
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d30 1
d168 1
a168 1
	if (wmkpw(bw->parent, US "Program to run: ", &runhist, dorun, US "Run", NULL, NULL, NULL, NULL, -1)) {
@


1.16
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d167 1
a167 1
	if (wmkpw(bw->parent, US "Program to run: ", &runhist, dorun, US "Run", NULL, NULL, NULL, NULL)) {
@


1.15
log
@
Better fix for missing SHELL variable
@
text
@d42 1
a42 1
		binss(bw->cursor, "** Program finished **\n");
d48 1
a48 1
		binss(q, "** Program finished **\n");
d55 1
a55 1
static void cdata(BW *bw, char *dat, int siz)
d59 1
a59 1
	char bf[1024];
d95 1
a95 1
static int cstart(BW *bw, char *name, char **s, void *obj, int *notify)
d111 1
a111 1
		msgnw(bw->parent, "Program already running in this window");
d122 1
a122 1
		msgnw(bw->parent, "No ptys available");
d133 3
a135 3
	char **a;
	char *s;
        char *sh=getenv("SHELL");
d137 1
a137 1
        	msgnw(bw->parent, "\"SHELL\" environment variable not defined or exported");
d151 1
a151 1
static int dorun(BW *bw, char *s, void *object, int *notify)
d153 2
a154 2
	char **a = vamk(10);
	char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));
d160 1
a160 1
	return cstart(bw, "/bin/sh", a, NULL, notify);
d167 1
a167 1
	if (wmkpw(bw->parent, "Program to run: ", &runhist, dorun, "Run", NULL, NULL, NULL, NULL)) {
@


1.14
log
@Improve shell windows for Cygwin.
@
text
@d136 4
a139 2
        if (!sh)
        	sh = "/usr/bin/bash";
@


1.13
log
@change 0 to NULL where we're talking about pointers
@
text
@d135 3
d140 1
a140 1
	s = vsncpy(NULL, 0, sz(getenv("SHELL")));
d144 1
a144 1
	return cstart(bw, getenv("SHELL"), a, NULL, NULL);
@


1.12
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d158 1
a158 1
B *runhist = 0;
@


1.11
log
@cleanup signals handling (sigaction() / sigvec() / signal())
@
text
@d69 3
a71 1
				pset(q, bw->cursor), prgetc(q), bdel(q, bw->cursor);
d74 3
a76 1
				pset(q, r), prgetc(q), bdel(q, r);
@


1.10
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d15 1
d17 1
@


1.9
log
@include only headers which are needed
@
text
@d34 1
a34 1
static void cdone(BW * bw)
d53 1
a53 1
static void cdata(BW * bw, char *dat, int siz)
d89 1
a89 1
static int cstart(BW * bw, char *name, char **s, void *obj, int *notify)
d125 1
a125 1
int ubknd(BW * bw)
d140 1
a140 1
static int dorun(BW * bw, char *s, void *object, int *notify)
d154 1
a154 1
int urun(BW * bw)
d165 1
a165 1
static int pidabort(BW * bw, int c, void *object, int *notify)
d181 1
a181 1
int ukillpid(BW * bw)
@


1.8
log
@put struct definitions and other goodies into types.h
@
text
@d12 3
d19 1
d21 1
a21 2
#include "bw.h"
#include "w.h"
d24 3
d28 1
a28 4
#include "va.h"
#include "ufile.h"
#include "main.h"
#include "ushell.h"
@


1.7
log
@use mkqw(W *, ...) instead of mkqw(BASE *, ...) (ditto. mkqwna() and mkqwnsr())
@
text
@d2 8
a9 5
	Shell-window functions
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.6
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d179 1
a179 1
		if (mkqw(bw, sc("Kill program (y,n,^C)?"), pidabort, NULL, NULL, NULL)) {
@


1.5
log
@version 2.9.7-pre3
@
text
@d91 1
a91 1
	msgnw(bw, "Sorry, no sub-processes in DOS (yet)");
d100 1
a100 1
		msgnw(bw, "Program already running in this window");
d111 1
a111 1
		msgnw(bw, "No ptys available");
@


1.4
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d160 1
a160 1
int pidabort(BW * bw, int c, void *object, int *notify)
@


1.3
log
@changed as of joe-2.9.6
@
text
@d9 5
a23 2
#include <unistd.h>
#include <signal.h>
d29 2
a30 1
static void cdone (BW * bw) {
d32 1
a32 1
	close (bw->out);
d34 4
a37 4
	if (piseof (bw->cursor)) {
		binss (bw->cursor, "** Program finished **\n");
		p_goto_eof (bw->cursor);
		bw->cursor->xcol = piscol (bw->cursor);
d39 4
a42 3
		P *q = pdup (bw->b->eof);
		binss (q, "** Program finished **\n");
		prm (q);
d48 4
a51 3
static void cdata (BW * bw, char *dat, int siz) {
	P *q = pdup (bw->cursor);
	P *r = pdup (bw->b->eof);
d61 3
a63 3
			} else if (piseof (bw->cursor)) {
				pset (q, bw->cursor), prgetc (q), bdel (q, bw->	cursor);
				bw->cursor->xcol = piscol (bw->cursor);
d65 1
a65 1
				pset (q, r), prgetc (q), bdel (q, r);
d72 4
a75 4
		if (piseof (bw->cursor)) {
			  binsm (bw->cursor, bf, y);
			  p_goto_eof (bw->cursor);
			  bw->cursor->xcol = piscol (bw->cursor);
d77 1
a77 1
			binsm (r, bf, y);
d80 2
a81 2
	prm (r);
	prm (q);
d84 2
a85 1
static int cstart (BW *bw, char *name, char **s, void *obj, int *notify) {
d90 2
a91 2
	varm (s);
	msgnw (bw, "Sorry, no sub-processes in DOS (yet)");
d100 2
a101 2
		msgnw (bw, "Program already running in this window");
		varm (s);
d104 2
a105 2
	if (doedit (bw, vsncpy (NULL, 0, sc ("")), NULL, NULL)) {
		varm (s);
d109 3
a111 3
	if (!(m = mpxmk (&bw->out, name, s, cdata, bw, cdone, bw))) {
		varm (s);
		msgnw (bw, "No ptys available");
d120 2
a121 1
int ubknd (BW *bw) {
d125 6
a130 6
	a = vamk (3);
	s = vsncpy (NULL, 0, sz (getenv ("SHELL")));
	a = vaadd (a, s);
	s = vsncpy (NULL, 0, sc ("-i"));
	a = vaadd (a, s);
	return cstart (bw, getenv ("SHELL"), a, NULL, NULL);
d135 10
a144 9
static int dorun (BW *bw, char *s, void *object, int *notify) {
	char **a = vamk (10);
	char *cmd = vsncpy (NULL, 0, sc ("/bin/sh"));

	a = vaadd (a, cmd);
	cmd = vsncpy (NULL, 0, sc ("-c"));
	a = vaadd (a, cmd);
	a = vaadd (a, s);
	return cstart (bw, "/bin/sh", a, NULL, notify);
d149 3
a151 2
int urun (BW *bw) {
	if (wmkpw (bw->parent, "Program to run: ", &runhist, dorun, "Run", NULL, NULL, NULL, NULL)) {
d160 2
a161 1
int pidabort (BW *bw, int c, void *object, int *notify) {
d169 1
a169 1
		kill (bw->pid, 1);
d176 2
a177 1
int ukillpid (BW *bw) {
d179 1
a179 1
		if (mkqw (bw->parent, sc ("Kill program (y,n,^C)?"), pidabort, NULL, NULL, NULL)) { 
d182 1
a182 1
			  return -1;
@


1.2
log
@changed as of joe-2.9.4
@
text
@d19 2
d26 1
a26 1
static void cdone (BW *bw) {
d32 1
a32 1
		peof (bw->cursor);
d43 1
a43 1
static void cdata (BW *bw, char *dat, int siz) {
d49 30
a78 35
for (x = y = 0; x != siz; ++x)
    if (dat[x] == 13 || dat[x] == 0);
    else if (dat[x] == 8 || dat[x] == 127)
      if (y)
	--y;
      else if (piseof (bw->cursor))
	{
	  pset (q, bw->cursor), prgetc (q), bdel (q, bw->cursor);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      else
	pset (q, r), prgetc (q), bdel (q, r);
    else
      bf[y++] = dat[x];
  if (y)
    if (piseof (bw->cursor))
      {
	binsm (bw->cursor, bf, y);
	peof (bw->cursor);
	bw->cursor->xcol = piscol (bw->cursor);
      }
    else
      binsm (r, bf, y);
  prm (r);
  prm (q);
}

static int
cstart (bw, name, s, obj, notify)
     BW *bw;
     char *name;
     char **s;
     void *obj;
     int *notify;
{
d80 6
a85 5
  if (notify)
    *notify = 1;
  varm (s);
  msgnw (bw, "Sorry, no sub-processes in DOS (yet)");
  return -1;
d87 23
a109 24
  MPX *m;
  if (notify)
    *notify = 1;
  if (bw->pid && orphan)
    {
      msgnw (bw, "Program already running in this window");
      varm (s);
      return -1;
    }
  if (doedit (bw, vsncpy (NULL, 0, sc ("")), NULL, NULL))
    {
      varm (s);
      return -1;
    }
  bw = (BW *) maint->curwin->object;
  if (!(m = mpxmk (&bw->out, name, s, cdata, bw, cdone, bw)))
    {
      varm (s);
      msgnw (bw, "No ptys available");
      return -1;
    }
  else
    bw->pid = m->pid;
  return 0;
d113 10
a122 12
int
ubknd (bw)
     BW *bw;
{
  char **a;
  char *s;
  a = vamk (3);
  s = vsncpy (NULL, 0, sz (getenv ("SHELL")));
  a = vaadd (a, s);
  s = vsncpy (NULL, 0, sc ("-i"));
  a = vaadd (a, s);
  return cstart (bw, getenv ("SHELL"), a, NULL, NULL);
d127 9
a135 14
static int
dorun (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
  char **a = vamk (10);
  char *cmd = vsncpy (NULL, 0, sc ("/bin/sh"));
  a = vaadd (a, cmd);
  cmd = vsncpy (NULL, 0, sc ("-c"));
  a = vaadd (a, cmd);
  a = vaadd (a, s);
  return cstart (bw, "/bin/sh", a, NULL, notify);
d140 6
a145 10
int
urun (bw)
     BW *bw;
{
  if (wmkpw
      (bw, "Program to run: ", &runhist, dorun, "Run", NULL, NULL, NULL,
       NULL))
    return 0;
  else
    return -1;
d150 25
a174 33
int
pidabort (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  if (notify)
    *notify = 1;
  if (c != 'y' && c != 'Y')
    return -1;
  if (bw->pid)
    {
      kill (bw->pid, 1);
      return -1;
    }
  else
    return -1;
}

int
ukillpid (bw)
     BW *bw;
{
  if (bw->pid)
    {
      if (mkqw
	  (bw, sc ("Kill program (y,n,^C)?"), pidabort, NULL, NULL,
	   NULL)) return 0;
      else
	return -1;
    }
  else
    return 0;
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
/* Shell-window functions
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d24 14
a37 18
static void cdone(bw)
BW *bw;
 {
 bw->pid=0;
 close(bw->out); bw->out= -1;
 if(piseof(bw->cursor))
  {
  binss(bw->cursor,"** Program finished **\n");
  peof(bw->cursor);
  bw->cursor->xcol=piscol(bw->cursor);
  }
 else
  {
  P *q=pdup(bw->b->eof);
  binss(q,"** Program finished **\n");
  prm(q);
  }
 }
d41 41
a81 39
static void cdata(bw,dat,siz)
BW *bw;
char *dat;
 {
 P *q=pdup(bw->cursor);
 P *r=pdup(bw->b->eof);
 char bf[1024];
 int x, y;
 for(x=y=0;x!=siz;++x)
  if(dat[x]==13 || dat[x]==0);
  else if(dat[x]==8 || dat[x]==127)
   if(y) --y;
   else
    if(piseof(bw->cursor))
     {
     pset(q,bw->cursor), prgetc(q), bdel(q,bw->cursor);
     bw->cursor->xcol=piscol(bw->cursor);
     }
    else pset(q,r), prgetc(q), bdel(q,r);
  else bf[y++]=dat[x];
 if(y)
  if(piseof(bw->cursor))
   {
   binsm(bw->cursor,bf,y);
   peof(bw->cursor);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else binsm(r,bf,y);
 prm(r);
 prm(q);
 }

static int cstart(bw,name,s,obj,notify)
BW *bw;
char *name;
char **s;
void *obj;
int *notify;
 {
d83 5
a87 4
 if(notify) *notify=1;
 varm(s);
 msgnw(bw,"Sorry, no sub-processes in DOS (yet)");
 return -1;
d89 24
a112 22
 MPX *m;
 if(notify) *notify=1;
 if(bw->pid && orphan)
  {
  msgnw(bw,"Program already running in this window");
  varm(s);
  return -1;
  }
 if(doedit(bw,vsncpy(NULL,0,sc("")),NULL,NULL))
  {
  varm(s);
  return -1;
  }
 bw=(BW *)maint->curwin->object;
 if(!(m=mpxmk(&bw->out,name,s,cdata,bw,cdone,bw)))
  {
  varm(s);
  msgnw(bw,"No ptys available");
  return -1;
  }
 else bw->pid= m->pid;
 return 0;
d114 1
a114 1
 }
d116 13
a128 10
int ubknd(bw)
BW *bw;
 {
 char **a;
 char *s;
 a=vamk(3);
 s=vsncpy(NULL,0,sz(getenv("SHELL"))); a=vaadd(a,s);
 s=vsncpy(NULL,0,sc("-i")); a=vaadd(a,s);
 return cstart(bw,getenv("SHELL"),a,NULL,NULL);
 }
d132 29
a160 24
static int dorun(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 char **a=vamk(10);
 char *cmd=vsncpy(NULL,0,sc("/bin/sh"));
 a=vaadd(a,cmd);
 cmd=vsncpy(NULL,0,sc("-c"));
 a=vaadd(a,cmd);
 a=vaadd(a,s);
 return cstart(bw,"/bin/sh",a,NULL,notify);
 }

B *runhist=0;

int urun(bw)
BW *bw;
 {
 if(wmkpw(bw,"Program to run: ",&runhist,dorun,"Run",NULL,NULL,NULL,NULL))
  return 0;
 else return -1;
 }
d164 34
a197 21
int pidabort(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c!='y' && c!='Y') return -1;
 if(bw->pid) { kill(bw->pid,1); return -1; }
 else return -1;
 }

int ukillpid(bw)
BW *bw;
 {
 if(bw->pid)
  {
  if(mkqw(bw,sc("Kill program (y,n,^C)?"),pidabort,NULL,NULL,NULL)) return 0;
  else return -1;
  }
 else return 0;
 }
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
