head	1.47;
access;
symbols
	joe_3_5:1.40
	joe-3_4:1.37
	help:1.37
	joe_3_1:1.19
	joe_3_0:1.17
	joe_2_9_8:1.15
	joe_2_9_8_pre1:1.12
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2008.11.23.23.35.10;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.23.14.06.35;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.18.19.32.08;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.19.21.10.11;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.16.21.37.37;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.16.19.27.32;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.14.16.35.54;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.14.03.21.37;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.13.05.01.23;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.04.16.24.40;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.04.05.33.09;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.03.05.29.51;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.05.24.27;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.03.02.42.55;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.27.05.29.33;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.21.14.47.43;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.17.13.13.17;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.04.17.39.26;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.15.09.24.38;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Check for math functions.
@
text
@/*
 *	Math
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

unsigned char *merr;

int mode_hex;
int mode_eng;
int mode_ins;

double vzero = 0.0;

static RETSIGTYPE fperr(int unused)
{
	if (!merr) {
		merr = joe_gettext(_("Float point exception"));
	}
	REINSTALL_SIGHANDLER(SIGFPE, fperr);
}

struct var {
	unsigned char *name;
	double (*func)(double n);
	int set;
	double val;
	struct var *next;
} *vars = NULL;

static struct var *get(unsigned char *str)
{
	struct var *v;

	for (v = vars; v; v = v->next) {
		if (!zcmp(v->name, str)) {
			return v;
		}
	}
	v = (struct var *) joe_malloc(sizeof(struct var));

	v->set = 0;
	v->func = 0;
	v->val = 0;
	v->next = vars;
	vars = v;
	v->name = zdup(str);
	return v;
}

unsigned char *ptr;
struct var *dumb;
static double eval(unsigned char *s);

int recur=0;

/* en means enable evaluation */

static double expr(int prec, int en,struct var **rtv)
{
	double x = 0.0, y, z;
	struct var *v = NULL;

	while (*ptr == ' ' || *ptr == '\t') {
		++ptr;
	}
	if ((*ptr >= 'a' && *ptr <= 'z') || (*ptr >= 'A' && *ptr <= 'Z')
	    || *ptr == '_') {
		unsigned char *s = ptr, c;

		while ((*ptr >= 'a' && *ptr <= 'z')
		       || (*ptr >= 'A' && *ptr <= 'Z')
		       || *ptr == '_' || (*ptr >= '0' && *ptr <= '9')) {
			++ptr;
		}
		c = *ptr;
		*ptr = 0;
		if (!zcmp(s,USTR "joe")) {
			*ptr = c;
			v = 0;
			x = 0.0;
			while (*ptr==' ' || *ptr=='\t')
				++ptr;
			if (*ptr=='(') {
				unsigned char *q = ++ptr;
				MACRO *m;
				int sta;
				while (*q && *q!=')')
					++q;
				if (*q!=')') {
					if (!merr)
						merr = joe_gettext(_("Missing )"));
				} else
					*q++ = 0;
				if (en) {
					m = mparse(NULL,ptr,&sta);
					ptr = q;
					if (m) {
						x = !exmacro(m,1);
						rmmacro(m);
					} else {
						if (!merr)
							merr = joe_gettext(_("Syntax error in macro"));
					}
				} else {
					ptr = q;
				}
			} else {
				if (!merr)
					merr = joe_gettext(_("Missing ("));
			}
			c = *ptr;
		} else if (!en) {
			v = 0;
			x = 0.0;
		} else if (!zcmp(s,USTR "hex")) {
			mode_hex = 1;
			mode_eng = 0;
			v = get(USTR "ans");
			x = v->val;
		} else if (!zcmp(s,USTR "dec")) {
			mode_hex = 0;
			mode_eng = 0;
			v = get(USTR "ans");
			x = v->val;
		} else if (!zcmp(s,USTR "eng")) {
			mode_hex = 0;
			mode_eng = 1;
			v = get(USTR "ans");
			x = v->val;
		} else if (!zcmp(s,USTR "ins")) {
			mode_ins = 1;
			v = get(USTR "ans");
			x = v->val;
		} else if (!zcmp(s,USTR "sum")) {
			double xsq;
			int cnt = blksum(&x, &xsq);
			if (!merr && cnt<=0)
				merr = joe_gettext(_("No numbers in block"));
			v = 0;
		} else if (!zcmp(s,USTR "cnt")) {
			double xsq;
			int cnt = blksum(&x, &xsq);
			if (!merr && cnt<=0)
				merr = joe_gettext(_("No numbers in block"));
			v = 0;
			x = cnt;
		} else if (!zcmp(s,USTR "avg")) {
			double xsq;
			int cnt = blksum(&x, &xsq);
			if (!merr && cnt<=0)
				merr = joe_gettext(_("No numbers in block"));
			v = 0;
			if (cnt)
				x /= (double)cnt;
		} else if (!zcmp(s,USTR "dev")) {
			double xsq;
			double avg;
			int cnt = blksum(&x, &xsq);
			if (!merr && cnt<=0)
				merr = joe_gettext(_("No numbers in block"));
			v = 0;
			if (cnt) {
				avg = x / (double)cnt;
				x = sqrt(xsq + (double)cnt*avg*avg - 2.0*avg*x);
			}
		} else if (!zcmp(s,USTR "eval")) {
			unsigned char *save = ptr;
			unsigned char *e = blkget();
			if (e) {
				v = 0;
				x = eval(e);
				joe_free(e);
				ptr = save;
			} else if (!merr) {
				merr = joe_gettext(_("No block"));
			}
		} else {
			v = get(s);
			x = v->val;
		}
		*ptr = c;
	} else if ((*ptr >= '0' && *ptr <= '9') || *ptr == '.') {
		if (ptr[0] == '0' && ptr[1] == 'x') {
			x = 0.0;
			ptr += 2;
			while ((*ptr >= '0' && *ptr <= '9') || (*ptr >= 'a' && *ptr <='f') ||
			       (*ptr >= 'A' && *ptr <= 'F'))
				if (*ptr >= '0' && *ptr <= '9')
					x = x * 16.0 + *ptr++ - '0';
				else if (*ptr >= 'a' && *ptr <= 'f')
					x = x * 16.0 + *ptr++ - 'a' + 10;
				else
					x = x * 16.0 + *ptr++ - 'A' + 10;
		} else {
			char *eptr;
			x = strtod((char *)ptr,&eptr);
			ptr = (unsigned char *)eptr;
		}
	} else if (*ptr == '(') {
		++ptr;
		x = expr(0, en, &v);
		if (*ptr == ')')
			++ptr;
		else {
			if (!merr)
				merr = joe_gettext(_("Missing )"));
		}
	} else if (*ptr == '-') {
		++ptr;
		x = -expr(10, en, &dumb);
	} else if (*ptr == '!') {
		++ptr;
		x = !expr(10, en, &dumb);
	}
      loop:
	while (*ptr == ' ' || *ptr == '\t')
		++ptr;
	if (*ptr == '(' && 11 > prec) {
		++ptr;
		y = expr(0, en, &dumb);
		if (*ptr == ')')
			++ptr;
		else {
			if (!merr)
				merr = joe_gettext(_("Missing )"));
		}
		if (v && v->func)
			x = v->func(y);
		else {
			if (!merr)
				merr = joe_gettext(_("Called object is not a function"));
		}
		goto loop;
	} else if (*ptr == '!' && ptr[1]!='=' && 10 >= prec) {
		++ptr;
		if (x == (int)x && x>=1.0 && x<70.0) {
			y = 1.0;
			while (x>1.0) {
				y *= x;
				x -= 1.0;
			}
			x = y;
		} else {
			if (!merr)
				merr = joe_gettext(_("Factorial can only take positive integers"));
		}
		v = 0;
		goto loop;
	} else if (*ptr == '*' && ptr[1] == '*' && 8 > prec) {
		ptr+=2;
		x = pow(x, expr(8, en, &dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '^' && 8 > prec) {
		++ptr;
		x = pow(x, expr(8, en, &dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '*' && 7 > prec) {
		++ptr;
		x *= expr(7, en, &dumb);
		v = 0;
		goto loop;
	} else if (*ptr == '/' && 7 > prec) {
		++ptr;
		x /= expr(7, en, &dumb);
		v = 0;
		goto loop;
	} else if(*ptr=='%' && 7>prec) {
		++ptr;
		y = expr(7, en, &dumb);
		if ((int)y == 0) x = 1.0/vzero;
		else x = ((int) x) % (int)y;
		v = 0;
		goto loop;
	} else if (*ptr == '+' && 6 > prec) {
		++ptr;
		x += expr(6, en, &dumb);
		v = 0;
		goto loop;
	} else if (*ptr == '-' && 6 > prec) {
		++ptr;
		x -= expr(6, en, &dumb);
		v = 0;
		goto loop;
	} else if (*ptr == '<' && 5 > prec) {
		++ptr;
		if (*ptr == '=') ++ptr, x = (x <= expr(5, en, &dumb));
		else x = (x < expr(5,en,&dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '>' && 5 > prec) {
		++ptr;
		if (*ptr == '=') ++ptr, x=(x >= expr(5,en,&dumb));
		else x = (x > expr(5,en,&dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '=' && ptr[1] == '=' && 5 > prec) {
		++ptr, ++ptr;
		x = (x == expr(5,en,&dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '!' && ptr[1] == '=' && 5 > prec) {
		++ptr, ++ptr;
		x = (x != expr(5,en,&dumb));
		v = 0;
		goto loop;
	} else if (*ptr == '&' && ptr[1] == '&' && 3 > prec) {
		++ptr, ++ptr;
		y = expr(3,x!=0.0 && en,&dumb);
		x = (int)x && (int)y;
		v = 0;
		goto loop;
	} else if (*ptr=='|' && ptr[1]=='|' &&  3 > prec) {
		++ptr, ++ptr;
		y = expr(3,x==0.0 && en,&dumb);
		x = (int)x || (int)y;
		v= 0;
		goto loop;
	} else if (*ptr=='?' && 2 >= prec) {
		++ptr;
		y = expr(2,x!=0.0 && en,&dumb);
		if (*ptr==':') {
			++ptr;
			z = expr(2,x==0.0 && en,&dumb);
			if (x != 0.0)
				x = y;
			else
				x = z;
			v = 0;  
		} else if (!merr) {
			merr = USTR ": missing after ?";
		}
		goto loop;
	} else if (*ptr == '=' && 1 >= prec) {
		++ptr;
		x = expr(1, en,&dumb);
		if (v) {
			v->val = x;
			v->set = 1;
		} else {
			if (!merr)
				merr = joe_gettext(_("Left side of = is not an l-value"));
		}
		v = 0;
		goto loop;
	}
	*rtv = v;
	return x;
}

static double eval(unsigned char *s)
{
	double result = 0.0;
	struct var *v;
	if(++recur==1000) {
		merr = joe_gettext(_("Recursion depth exceeded"));
		--recur;
		return 0.0;
	}
	ptr = s;
	while (!merr && *ptr) {
		result = expr(0, 1, &dumb);
		v = get(USTR "ans");
		v->val = result;
		v->set = 1;
		if (!merr) {
			while (*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n') {
				++ptr;
			}
			if (*ptr == ':') {
				++ptr;
				while (*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n') {
					++ptr;
				}
			} else if (*ptr) {
				merr = joe_gettext(_("Extra junk after end of expr"));
			}
		}
	}
	--recur;
	return result;
}

/* These don't all exist on some systems... */

#ifdef HAVE_SIN
double m_sin(double n) { return sin(n); }
#else
#ifdef sin
double m_sin(double n) { return sin(n); }
#endif
#endif

#ifdef HAVE_COS
double m_cos(double n) { return cos(n); }
#else
#ifdef cos
double m_cos(double n) { return cos(n); }
#endif
#endif

#ifdef HAVE_TAN
double m_tan(double n) { return tan(n); }
#else
#ifdef tan
double m_tan(double n) { return tan(n); }
#endif
#endif

#ifdef HAVE_EXP
double m_exp(double n) { return exp(n); }
#else
#ifdef exp
double m_exp(double n) { return exp(n); }
#endif
#endif

#ifdef HAVE_SQRT
double m_sqrt(double n) { return sqrt(n); }
#else
#ifdef sqrt
double m_sqrt(double n) { return sqrt(n); }
#endif
#endif

#ifdef HAVE_CBRT
double m_cbrt(double n) { return cbrt(n); }
#else
#ifdef cbrt
double m_cbrt(double n) { return cbrt(n); }
#endif
#endif

#ifdef HAVE_LOG
double m_log(double n) { return log(n); }
#else
#ifdef log
double m_log(double n) { return log(n); }
#endif
#endif

#ifdef HAVE_LOG10
double m_log10(double n) { return log10(n); }
#else
#ifdef log10
double m_log10(double n) { return log10(n); }
#endif
#endif

#ifdef HAVE_ASIN
double m_asin(double n) { return asin(n); }
#else
#ifdef asin
double m_asin(double n) { return asin(n); }
#endif
#endif

#ifdef HAVE_ACOS
double m_acos(double n) { return acos(n); }
#else
#ifdef acos
double m_acos(double n) { return acos(n); }
#endif
#endif

#ifdef HAVE_ATAN
double m_atan(double n) { return atan(n); }
#else
#ifdef atan
double m_atan(double n) { return atan(n); }
#endif
#endif

#ifdef HAVE_SINH
double m_sinh(double n) { return sinh(n); }
#else
#ifdef sinh
double m_sinh(double n) { return sinh(n); }
#endif
#endif

#ifdef HAVE_COSH
double m_cosh(double n) { return cosh(n); }
#else
#ifdef cosh
double m_cosh(double n) { return cosh(n); }
#endif
#endif

#ifdef HAVE_TANH
double m_tanh(double n) { return tanh(n); }
#else
#ifdef tanh
double m_tanh(double n) { return tanh(n); }
#endif
#endif

#ifdef HAVE_ASINH
double m_asinh(double n) { return asinh(n); }
#else
#ifdef asinh
double m_asinh(double n) { return asinh(n); }
#endif
#endif

#ifdef HAVE_ACOSH
double m_acosh(double n) { return acosh(n); }
#else
#ifdef acosh
double m_acosh(double n) { return acosh(n); }
#endif
#endif

#ifdef HAVE_ATANH
double m_atanh(double n) { return atanh(n); }
#else
#ifdef atanh
double m_atanh(double n) { return atanh(n); }
#endif
#endif

#ifdef HAVE_FLOOR
double m_floor(double n) { return floor(n); }
#else
#ifdef floor
double m_floor(double n) { return floor(n); }
#endif
#endif

#ifdef HAVE_CEIL
double m_ceil(double n) { return ceil(n); }
#else
#ifdef ceil
double m_ceil(double n) { return ceil(n); }
#endif
#endif

#ifdef HAVE_FABS
double m_fabs(double n) { return fabs(n); }
#else
#ifdef fabs
double m_fabs(double n) { return fabs(n); }
#endif
#endif

#ifdef HAVE_ERF
double m_erf(double n) { return erf(n); }
#else
#ifdef erf
double m_erf(double n) { return erf(n); }
#endif
#endif

#ifdef HAVE_ERFC
double m_erfc(double n) { return erfc(n); }
#else
#ifdef erfc
double m_erfc(double n) { return erfc(n); }
#endif
#endif

#ifdef HAVE_J0
double m_j0(double n) { return j0(n); }
#else
#ifdef j0
double m_j0(double n) { return j0(n); }
#endif
#endif

#ifdef HAVE_J1
double m_j1(double n) { return j1(n); }
#else
#ifdef j1
double m_j1(double n) { return j1(n); }
#endif
#endif

#ifdef HAVE_Y0
double m_y0(double n) { return y0(n); }
#else
#ifdef y0
double m_y0(double n) { return y0(n); }
#endif
#endif

#ifdef HAVE_Y1
double m_y1(double n) { return y1(n); }
#else
#ifdef y1
double m_y1(double n) { return y1(n); }
#endif
#endif


double m_int(double n) { return (int)(n); }


double calc(BW *bw, unsigned char *s)
{
	/* BW *tbw = bw->parent->main->object; */
	BW *tbw = bw;
	struct var *v;
	int c = brch(bw->cursor);

	if (!vars) {
#ifdef HAVE_SIN
		v = get(USTR "sin"); v->func = m_sin;
#else
#ifdef sin
		v = get(USTR "sin"); v->func = m_sin;
#endif
#endif
#ifdef HAVE_COS
		v = get(USTR "cos"); v->func = m_cos;
#else
#ifdef cos
		v = get(USTR "cos"); v->func = m_cos;
#endif
#endif
#ifdef HAVE_TAN
		v = get(USTR "tan"); v->func = m_tan;
#else
#ifdef tan
		v = get(USTR "tan"); v->func = m_tan;
#endif
#endif
#ifdef HAVE_EXP
		v = get(USTR "exp"); v->func = m_exp;
#else
#ifdef exp
		v = get(USTR "exp"); v->func = m_exp;
#endif
#endif
#ifdef HAVE_SQRT
		v = get(USTR "sqrt"); v->func = m_sqrt;
#else
#ifdef sqrt
		v = get(USTR "sqrt"); v->func = m_sqrt;
#endif
#endif
#ifdef HAVE_CBRT
		v = get(USTR "cbrt"); v->func = m_cbrt;
#else
#ifdef cbrt
		v = get(USTR "cbrt"); v->func = m_cbrt;
#endif
#endif
#ifdef HAVE_LN
		v = get(USTR "ln"); v->func = m_log;
#else
#ifdef ln
		v = get(USTR "ln"); v->func = m_log;
#endif
#endif
#ifdef HAVE_LOG
		v = get(USTR "log"); v->func = m_log10;
#else
#ifdef log
		v = get(USTR "log"); v->func = m_log10;
#endif
#endif
#ifdef HAVE_ASIN
		v = get(USTR "asin"); v->func = m_asin;
#else
#ifdef asin
		v = get(USTR "asin"); v->func = m_asin;
#endif
#endif
#ifdef HAVE_ACOS
		v = get(USTR "acos"); v->func = m_acos;
#else
#ifdef acos
		v = get(USTR "acos"); v->func = m_acos;
#endif
#endif
#ifdef HAVE_ATAN
		v = get(USTR "atan"); v->func = m_atan;
#else
#ifdef atan
		v = get(USTR "atan"); v->func = m_atan;
#endif
#endif
#ifdef HAVE_M_PI
		v = get(USTR "pi"); v->val = M_PI; v->set = 1;
#else
#ifdef m_pi
		v = get(USTR "pi"); v->val = M_PI; v->set = 1;
#endif
#endif
#ifdef HAVE_M_E
		v = get(USTR "e"); v->val = M_E; v->set = 1;
#else
#ifdef m_e
		v = get(USTR "e"); v->val = M_E; v->set = 1;
#endif
#endif
#ifdef HAVE_SINH
		v = get(USTR "sinh"); v->func = m_sinh;
#else
#ifdef sinh
		v = get(USTR "sinh"); v->func = m_sinh;
#endif
#endif
#ifdef HAVE_COSH
		v = get(USTR "cosh"); v->func = m_cosh;
#else
#ifdef cosh
		v = get(USTR "cosh"); v->func = m_cosh;
#endif
#endif
#ifdef HAVE_TANH
		v = get(USTR "tanh"); v->func = m_tanh;
#else
#ifdef tanh
		v = get(USTR "tanh"); v->func = m_tanh;
#endif
#endif
#ifdef HAVE_ASINH
		v = get(USTR "asinh"); v->func = m_asinh;
#else
#ifdef asinh
		v = get(USTR "asinh"); v->func = m_asinh;
#endif
#endif
#ifdef HAVE_ACOSH
		v = get(USTR "acosh"); v->func = m_acosh;
#else
#ifdef acosh
		v = get(USTR "acosh"); v->func = m_acosh;
#endif
#endif
#ifdef HAVE_ATANH
		v = get(USTR "atanh"); v->func = m_atanh;
#else
#ifdef atanh
		v = get(USTR "atanh"); v->func = m_atanh;
#endif
#endif
#ifdef HAVE_FLOOR
		v = get(USTR "floor"); v->func = m_floor;
#else
#ifdef floor
		v = get(USTR "floor"); v->func = m_floor;
#endif
#endif
#ifdef HAVE_CEIL
		v = get(USTR "ceil"); v->func = m_ceil;
#else
#ifdef ceil
		v = get(USTR "ceil"); v->func = m_ceil;
#endif
#endif
#ifdef HAVE_ABS
		v = get(USTR "abs"); v->func = m_fabs;
#else
#ifdef abs
		v = get(USTR "abs"); v->func = m_fabs;
#endif
#endif
#ifdef HAVE_ERF
		v = get(USTR "erf"); v->func = m_erf;
#else
#ifdef erf
		v = get(USTR "erf"); v->func = m_erf;
#endif
#endif
#ifdef HAVE_ERFC
		v = get(USTR "erfc"); v->func = m_erfc;
#else
#ifdef erfc
		v = get(USTR "erfc"); v->func = m_erfc;
#endif
#endif
#ifdef HAVE_J0
		v = get(USTR "j0"); v->func = m_j0;
#else
#ifdef j0
		v = get(USTR "j0"); v->func = m_j0;
#endif
#endif
#ifdef HAVE_J1
		v = get(USTR "j1"); v->func = m_j1;
#else
#ifdef j1
		v = get(USTR "j1"); v->func = m_j1;
#endif
#endif
#ifdef HAVE_Y0
		v = get(USTR "y0"); v->func = m_y0;
#else
#ifdef y0
		v = get(USTR "y0"); v->func = m_y0;
#endif
#endif
#ifdef HAVE_Y1
		v = get(USTR "y1"); v->func = m_y1;
#else
#ifdef y1
		v = get(USTR "y1"); v->func = m_y1;
#endif
#endif
		v = get(USTR "int"); v->func = m_int;
	}

	v = get(USTR "top");
	v->val = tbw->top->line + 1;
	v->set = 1;
	v = get(USTR "lines");
	v->val = tbw->b->eof->line + 1;
	v->set = 1;
	v = get(USTR "line");
	v->val = tbw->cursor->line + 1;
	v->set = 1;
	v = get(USTR "col");
	v->val = tbw->cursor->col + 1;
	v->set = 1;
	v = get(USTR "byte");
	v->val = tbw->cursor->byte + 1;
	v->set = 1;
	v = get(USTR "size");
	v->val = tbw->b->eof->byte;
	v->set = 1;
	v = get(USTR "height");
	v->val = tbw->h;
	v->set = 1;
	v = get(USTR "width");
	v->val = tbw->w;
	v->set = 1;
	v = get(USTR "char");
	v->val = (c == NO_MORE_DATA ? -1.0 : c);
	v->set = 1;
	v = get(USTR "markv");
	v->val = markv(1) ? 1.0 : 0.0;
	v->set = 1;
	v = get(USTR "rdonly");
	v->val = tbw->b->rdonly;
	v->set = 1;
	v = get(USTR "arg");
	v->val = current_arg;
	v->set = 1;
	v = get(USTR "argset");
	v->val = current_arg_set;
	v->set = 1;
	v = get(USTR "no_windows");
	v->val = countmain(bw->parent->t);
	v->set = 1;
	merr = 0;
	return eval(s);
}

/* Main user interface */

B *mathhist = NULL;

int umath(BW *bw)
{
	unsigned char *s;
	joe_set_signal(SIGFPE, fperr);
	again:
	s = ask(bw->parent, USTR "=", &mathhist, USTR "Math", utypebw, locale_map, 0, 0, NULL);
	if (s) {
		unsigned char buf[128];
		double result = calc(bw, s);

		if (merr) {
			msgnw(bw->parent, merr);
			return -1;
		}
		if (mode_hex)
			joe_snprintf_1(buf, sizeof(buf), "0x%lX", (long)result);
		else if (mode_eng)
			joe_snprintf_1(buf, sizeof(buf), "%.16G", result);
		else
			joe_snprintf_1(buf, sizeof(buf), "%.16G", result);
		if (bw->parent->watom->what != TYPETW || mode_ins) {
			binsm(bw->cursor, sz(buf));
			pfwrd(bw->cursor, zlen(buf));
			bw->cursor->xcol = piscol(bw->cursor);
		} else {
			msgnw(bw->parent, buf);
		}
		mode_ins = 0;
		goto again;
		return 0;
	} else {
		return -1;
	}
}
@


1.46
log
@More work on coroutine refactoring.
@
text
@d389 6
d396 4
d401 10
d412 7
d420 4
d425 7
d433 10
d444 7
d452 4
d457 10
d468 7
d476 7
d484 4
d489 10
d500 7
d508 4
d513 7
d521 10
a530 1
double m_int(double n) { return (int)(n); }
d532 7
d540 7
d548 4
d553 7
d561 10
d572 7
d580 4
d585 10
d596 6
d611 4
d616 3
d620 9
d630 6
d637 3
d641 9
d651 6
d658 3
d662 9
d672 3
d676 9
d686 6
d693 3
d697 9
d707 6
d714 3
d718 9
d728 6
d735 3
d739 9
a747 1
		v = get(USTR "int"); v->func = m_int;
d749 6
d756 6
d763 3
d767 9
d777 3
d781 9
d791 6
d798 3
d802 6
@


1.45
log
@more work on coroutine refactor
prompt window experiment
@
text
@a515 3
		/* if (notify) {
			*notify = 1;
		} */
@


1.44
log
@more refactoring
@
text
@d510 1
d537 1
@


1.43
log
@fix tags.
switch more wmkpw to ask
@
text
@d510 1
a510 1
	s = ask(bw->parent, USTR "=", &mathhist, USTR "Math", utypebw, NULL, locale_map, 0, 0, NULL);
@


1.42
log
@fix option menu problem
@
text
@a502 28
static int domath(BW *bw, unsigned char *s, void *object, int *notify)
{
	unsigned char buf[128];
	double result = calc(bw, s);

	if (notify) {
		*notify = 1;
	}
	if (merr) {
		msgnw(bw->parent, merr);
		return -1;
	}
	if (mode_hex)
		joe_snprintf_1(buf, sizeof(buf), "0x%lX", (long)result);
	else if (mode_eng)
		joe_snprintf_1(buf, sizeof(buf), "%.16G", result);
	else
		joe_snprintf_1(buf, sizeof(buf), "%.16G", result);
	if (bw->parent->watom->what != TYPETW || mode_ins) {
		binsm(bw->cursor, sz(buf));
		pfwrd(bw->cursor, zlen(buf));
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		msgnw(bw->parent, buf);
	}
	mode_ins = 0;
	return 0;
}
d508 1
d510 26
a535 1
	if (wmkpw(bw->parent, USTR "=", &mathhist, domath, USTR "Math", NULL, NULL, NULL, NULL, locale_map, 0)) {
@


1.41
log
@semiautomatic variables
@
text
@d187 16
a202 3
		char *eptr;
		x = strtod((char *)ptr,&eptr);
		ptr = (unsigned char *)eptr;
@


1.40
log
@UC -> USTR
@
text
@d492 1
a501 1
	vsrm(s);
d503 1
a503 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, "0x%lX", (long)result);
d505 1
a505 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, "%.16G", result);
d507 1
a507 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, "%.16G", result);
d509 2
a510 2
		binsm(bw->cursor, sz(msgbuf));
		pfwrd(bw->cursor, zlen(msgbuf));
d513 1
a513 1
		msgnw(bw->parent, msgbuf);
@


1.39
log
@change US to UC
@
text
@d81 1
a81 1
		if (!zcmp(s,UC "joe")) {
d119 1
a119 1
		} else if (!zcmp(s,UC "hex")) {
d122 1
a122 1
			v = get(UC "ans");
d124 1
a124 1
		} else if (!zcmp(s,UC "dec")) {
d127 1
a127 1
			v = get(UC "ans");
d129 1
a129 1
		} else if (!zcmp(s,UC "eng")) {
d132 1
a132 1
			v = get(UC "ans");
d134 1
a134 1
		} else if (!zcmp(s,UC "ins")) {
d136 1
a136 1
			v = get(UC "ans");
d138 1
a138 1
		} else if (!zcmp(s,UC "sum")) {
d144 1
a144 1
		} else if (!zcmp(s,UC "cnt")) {
d151 1
a151 1
		} else if (!zcmp(s,UC "avg")) {
d159 1
a159 1
		} else if (!zcmp(s,UC "dev")) {
d170 1
a170 1
		} else if (!zcmp(s,UC "eval")) {
d323 1
a323 1
			merr = UC ": missing after ?";
d355 1
a355 1
		v = get(UC "ans");
d412 29
a440 29
		v = get(UC "sin"); v->func = m_sin;
		v = get(UC "cos"); v->func = m_cos;
		v = get(UC "tan"); v->func = m_tan;
		v = get(UC "exp"); v->func = m_exp;
		v = get(UC "sqrt"); v->func = m_sqrt;
		v = get(UC "cbrt"); v->func = m_cbrt;
		v = get(UC "ln"); v->func = m_log;
		v = get(UC "log"); v->func = m_log10;
		v = get(UC "asin"); v->func = m_asin;
		v = get(UC "acos"); v->func = m_acos;
		v = get(UC "atan"); v->func = m_atan;
		v = get(UC "pi"); v->val = M_PI; v->set = 1;
		v = get(UC "e"); v->val = M_E; v->set = 1;
		v = get(UC "sinh"); v->func = m_sinh;
		v = get(UC "cosh"); v->func = m_cosh;
		v = get(UC "tanh"); v->func = m_tanh;
		v = get(UC "asinh"); v->func = m_asinh;
		v = get(UC "acosh"); v->func = m_acosh;
		v = get(UC "atanh"); v->func = m_atanh;
		v = get(UC "int"); v->func = m_int;
		v = get(UC "floor"); v->func = m_floor;
		v = get(UC "ceil"); v->func = m_ceil;
		v = get(UC "abs"); v->func = m_fabs;
		v = get(UC "erf"); v->func = m_erf;
		v = get(UC "erfc"); v->func = m_erfc;
		v = get(UC "j0"); v->func = m_j0;
		v = get(UC "j1"); v->func = m_j1;
		v = get(UC "y0"); v->func = m_y0;
		v = get(UC "y1"); v->func = m_y1;
d443 1
a443 1
	v = get(UC "top");
d446 1
a446 1
	v = get(UC "lines");
d449 1
a449 1
	v = get(UC "line");
d452 1
a452 1
	v = get(UC "col");
d455 1
a455 1
	v = get(UC "byte");
d458 1
a458 1
	v = get(UC "size");
d461 1
a461 1
	v = get(UC "height");
d464 1
a464 1
	v = get(UC "width");
d467 1
a467 1
	v = get(UC "char");
d470 1
a470 1
	v = get(UC "markv");
d473 1
a473 1
	v = get(UC "rdonly");
d476 1
a476 1
	v = get(UC "arg");
d479 1
a479 1
	v = get(UC "argset");
d482 1
a482 1
	v = get(UC "no_windows");
d524 1
a524 1
	if (wmkpw(bw->parent, UC "=", &mathhist, domath, UC "Math", NULL, NULL, NULL, NULL, locale_map, 0)) {
@


1.38
log
@fix compiler warnings
@
text
@d81 1
a81 1
		if (!zcmp(s,US "joe")) {
d119 1
a119 1
		} else if (!zcmp(s,US "hex")) {
d122 1
a122 1
			v = get(US "ans");
d124 1
a124 1
		} else if (!zcmp(s,US "dec")) {
d127 1
a127 1
			v = get(US "ans");
d129 1
a129 1
		} else if (!zcmp(s,US "eng")) {
d132 1
a132 1
			v = get(US "ans");
d134 1
a134 1
		} else if (!zcmp(s,US "ins")) {
d136 1
a136 1
			v = get(US "ans");
d138 1
a138 1
		} else if (!zcmp(s,US "sum")) {
d144 1
a144 1
		} else if (!zcmp(s,US "cnt")) {
d151 1
a151 1
		} else if (!zcmp(s,US "avg")) {
d159 1
a159 1
		} else if (!zcmp(s,US "dev")) {
d170 1
a170 1
		} else if (!zcmp(s,US "eval")) {
d323 1
a323 1
			merr = US ": missing after ?";
d355 1
a355 1
		v = get(US "ans");
d412 29
a440 29
		v = get(US "sin"); v->func = m_sin;
		v = get(US "cos"); v->func = m_cos;
		v = get(US "tan"); v->func = m_tan;
		v = get(US "exp"); v->func = m_exp;
		v = get(US "sqrt"); v->func = m_sqrt;
		v = get(US "cbrt"); v->func = m_cbrt;
		v = get(US "ln"); v->func = m_log;
		v = get(US "log"); v->func = m_log10;
		v = get(US "asin"); v->func = m_asin;
		v = get(US "acos"); v->func = m_acos;
		v = get(US "atan"); v->func = m_atan;
		v = get(US "pi"); v->val = M_PI; v->set = 1;
		v = get(US "e"); v->val = M_E; v->set = 1;
		v = get(US "sinh"); v->func = m_sinh;
		v = get(US "cosh"); v->func = m_cosh;
		v = get(US "tanh"); v->func = m_tanh;
		v = get(US "asinh"); v->func = m_asinh;
		v = get(US "acosh"); v->func = m_acosh;
		v = get(US "atanh"); v->func = m_atanh;
		v = get(US "int"); v->func = m_int;
		v = get(US "floor"); v->func = m_floor;
		v = get(US "ceil"); v->func = m_ceil;
		v = get(US "abs"); v->func = m_fabs;
		v = get(US "erf"); v->func = m_erf;
		v = get(US "erfc"); v->func = m_erfc;
		v = get(US "j0"); v->func = m_j0;
		v = get(US "j1"); v->func = m_j1;
		v = get(US "y0"); v->func = m_y0;
		v = get(US "y1"); v->func = m_y1;
d443 1
a443 1
	v = get(US "top");
d446 1
a446 1
	v = get(US "lines");
d449 1
a449 1
	v = get(US "line");
d452 1
a452 1
	v = get(US "col");
d455 1
a455 1
	v = get(US "byte");
d458 1
a458 1
	v = get(US "size");
d461 1
a461 1
	v = get(US "height");
d464 1
a464 1
	v = get(US "width");
d467 1
a467 1
	v = get(US "char");
d470 1
a470 1
	v = get(US "markv");
d473 1
a473 1
	v = get(US "rdonly");
d476 1
a476 1
	v = get(US "arg");
d479 1
a479 1
	v = get(US "argset");
d482 1
a482 1
	v = get(US "no_windows");
d524 1
a524 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "Math", NULL, NULL, NULL, NULL, locale_map, 0)) {
@


1.37
log
@gettext()
@
text
@d16 2
d263 1
a263 1
		if ((int)y == 0) x = 1.0/0.0;
@


1.36
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d19 1
a19 1
		merr = US "Float point exception";
d93 1
a93 1
						merr = US "Missing )";
d104 1
a104 1
							merr = US "Syntax error in macro";
d111 1
a111 1
					merr = US "Missing (";
d140 1
a140 1
				merr = US "No numbers in block";
d146 1
a146 1
				merr = US "No numbers in block";
d153 1
a153 1
				merr = US "No numbers in block";
d162 1
a162 1
				merr = US "No numbers in block";
d177 1
a177 1
				merr = US "No block";
d195 1
a195 1
				merr = US "Missing )";
d214 1
a214 1
				merr = US "Missing )";
d220 1
a220 1
				merr = US "Called object is not a function";
d234 1
a234 1
				merr = US "Factorial can only take positive integers";
d332 1
a332 1
				merr = US "Left side of = is not an l-value";
d346 1
a346 1
		merr = US "Recursion depth exceeded";
d366 1
a366 1
				merr = US "Extra junk after end of expr";
d501 1
a501 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "0x%lX", (long)result);
d503 1
a503 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%.16G", result);
d505 1
a505 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%.16G", result);
@


1.35
log
@fix gcc-4.0.0 warnings
@
text
@a7 1
#include "config.h"
a9 14
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#include "b.h"
#include "pw.h"
#include "utils.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "ublock.h"
#include "macro.h"
#include "w.h"

a11 3
extern int current_arg;
extern int current_arg_set;

d185 3
a187 1
		x = strtod((char *)ptr,(char **)&ptr);
d343 1
a343 1
	double result;
@


1.34
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@a11 1
#include <string.h>
d55 1
a55 1
		if (!strcmp(v->name, str)) {
d66 1
a66 1
	v->name = joe_strdup(str);
d97 1
a97 1
		if (!strcmp(s,"joe")) {
d135 1
a135 1
		} else if (!strcmp(s,"hex")) {
d140 1
a140 1
		} else if (!strcmp(s,"dec")) {
d145 1
a145 1
		} else if (!strcmp(s,"eng")) {
d150 1
a150 1
		} else if (!strcmp(s,"ins")) {
d154 1
a154 1
		} else if (!strcmp(s,"sum")) {
d160 1
a160 1
		} else if (!strcmp(s,"cnt")) {
d167 1
a167 1
		} else if (!strcmp(s,"avg")) {
d175 1
a175 1
		} else if (!strcmp(s,"dev")) {
d186 1
a186 1
		} else if (!strcmp(s,"eval")) {
d524 1
a524 1
		pfwrd(bw->cursor, strlen((char *)msgbuf));
@


1.33
log
@fix locks bug, jmacs improvements
@
text
@d139 1
a139 1
			v = get("ans");
d144 1
a144 1
			v = get("ans");
d149 1
a149 1
			v = get("ans");
d153 1
a153 1
			v = get("ans");
d204 1
a204 1
		x = strtod(ptr,(char **)&ptr);
@


1.32
log
@Enhance macros again.  Improve jmacs.  Fix != in math.
@
text
@d497 3
@


1.31
log
@Fix ~ expansion insanity
@
text
@d28 3
d240 1
a240 1
	} else if (*ptr == '!' && 10 >= prec) {
d491 6
@


1.30
log
@add ! operator
@
text
@d527 1
a527 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "Math", NULL, NULL, NULL, NULL, locale_map)) {
@


1.29
log
@FIx some math and first change bugs.
@
text
@d214 3
d237 15
@


1.28
log
@Perforce macro and support for it.
@
text
@d95 36
a130 1
		if (!en) {
a194 31
		} else if (!strcmp(s,"joe")) {
			*ptr = c;
			v = 0;
			x = 0.0;
			while (*ptr==' ' || *ptr=='\t')
				++ptr;
			if (*ptr=='(') {
				unsigned char *q = ++ptr;
				MACRO *m;
				int sta;
				while (*q && *q!=')')
					++q;
				if (*q!=')') {
					if (!merr)
						merr = US "Missing )";
				} else
					*q++ = 0;
				m = mparse(NULL,ptr,&sta);
				ptr = q;
				if (m) {
					x = !exmacro(m,1);
					rmmacro(m);
				} else {
					if (!merr)
						merr = US "Syntax error in macro";
				}
			} else {
				if (!merr)
					merr = US "Missing (";
			}
			c = *ptr;
@


1.27
log
@Fix ^X a and ^X i in jmacs
@
text
@d23 1
d160 31
d463 3
@


1.26
log
@Add eval to math.
@
text
@d364 2
a365 1
	BW *tbw = bw->parent->main->object;
d416 3
d428 3
@


1.25
log
@Statistics functions
@
text
@d69 1
d71 5
a75 1
static double expr(int prec, struct var **rtv)
d77 1
a77 1
	double x = 0.0, y;
d94 4
a97 1
		if (!strcmp(s,"hex")) {
d148 11
d168 1
a168 1
		x = expr(0, &v);
d177 1
a177 1
		x = -expr(10, &dumb);
d184 1
a184 1
		y = expr(0, &dumb);
d200 1
a200 1
		x = pow(x, expr(8, &dumb));
d205 1
a205 1
		x = pow(x, expr(8, &dumb));
d210 1
a210 1
		x *= expr(7, &dumb);
d215 1
a215 1
		x /= expr(7, &dumb);
d220 1
a220 1
		y = expr(7, &dumb);
d227 1
a227 1
		x += expr(6, &dumb);
d232 1
a232 1
		x -= expr(6, &dumb);
d237 2
a238 2
		if (*ptr == '=') ++ptr, x = (x <= expr(5,&dumb));
		else x = (x < expr(5,&dumb));
d243 2
a244 2
		if (*ptr == '=') ++ptr, x=(x >= expr(5,&dumb));
		else x = (x > expr(5,&dumb));
d249 1
a249 1
		x = (x == expr(5,&dumb));
d254 1
a254 1
		x = (x != expr(5,&dumb));
d257 1
a257 1
	} else if(*ptr == '&' && ptr[1] == '&' && 3 > prec) {
d259 1
a259 1
		y = expr(3,&dumb);
d263 1
a263 1
	} else if(*ptr=='|' && ptr[1]=='|' &&  3 > prec) {
d265 1
a265 1
		y = expr(3,&dumb);
d269 1
a269 1
	} else if (*ptr == '=' && 2 >= prec) {
d271 16
a286 1
		x = expr(2, &dumb);
d301 33
d364 1
a364 1
	double result;
a365 1
	BW *tbw = bw->parent->main->object;
a423 1
	ptr = s;
d425 1
a425 22
      up:
	result = expr(0, &dumb);
	v = get(US "ans");
	v->val = result;
	v->set = 1;
	if (!merr) {
		while (*ptr == ' ' || *ptr == '\t') {
			++ptr;
		}
		if (*ptr == ':') {
			++ptr;
			while (*ptr == ' ' || *ptr == '\t') {
				++ptr;
			}
			if (*ptr) {
				goto up;
			}
		} else if (*ptr) {
			merr = US "Extra junk after end of expr";
		}
	}
	return result;
@


1.24
log
@fix minor bug
@
text
@d22 1
d108 32
@


1.23
log
@Help screen for math mode
@
text
@d145 1
@


1.22
log
@Improve math
@
text
@d28 1
d103 4
a240 1
double m_exp10(double n) { return exp10(n); }
d250 1
a250 1
double m_int(double n) { return rint(n); }
d272 1
a272 1
		v = get(US "exp"); v->func = m_tan;
a276 1
		v = get(US "exp10"); v->func = m_exp10;
d335 1
a335 1
		if (*ptr == ';') {
d369 1
a369 1
	if (bw->parent->watom->what != TYPETW) {
d376 1
d385 1
a385 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "math", NULL, NULL, NULL, NULL, locale_map)) {
@


1.21
log
@Jesse McGrew's xterm mouse support.
@
text
@d13 2
d26 3
d39 1
d57 1
d87 19
a105 2
		v = get(s);
		x = v->val;
d108 1
a108 3
		sscanf((char *)ptr, "%lf", &x);
		while ((*ptr >= '0' && *ptr <= '9') || *ptr == '.' || *ptr == 'e' || *ptr == 'E')
			++ptr;
d125 26
a150 1
	if (*ptr == '*' && 7 > prec) {
d153 1
d158 1
d165 1
d170 1
d175 1
d181 1
d187 1
d192 1
d197 1
d203 1
d209 1
d221 1
d228 29
d264 33
d325 3
d360 6
a365 1
	joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%G", result);
@


1.20
log
@Fix -pedantic warnings.
@
text
@d51 1
d63 1
a63 1
	double x = 0.0;
d103 1
a103 1
	if (*ptr == '*' && 5 > prec) {
d105 1
a105 1
		x *= expr(5, &dumb);
d107 1
a107 1
	} else if (*ptr == '/' && 5 > prec) {
d109 1
a109 1
		x /= expr(5, &dumb);
d111 1
a111 1
	} else if (*ptr == '+' && 4 > prec) {
d113 3
a115 1
		x += expr(4, &dumb);
d117 1
a117 1
	} else if (*ptr == '-' && 4 > prec) {
d119 33
a151 1
		x -= expr(4, &dumb);
d174 1
d197 3
@


1.19
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d53 1
a53 1
	v->name = (unsigned char *)strdup((char *)str);
@


1.18
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d197 1
a197 1
	snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "%G", result);
@


1.17
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d18 2
d213 1
a213 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "math", NULL, NULL, NULL, NULL, -1)) {
@


1.16
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d211 1
a211 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "math", NULL, NULL, NULL, NULL)) {
@


1.15
log
@change 0 to NULL where we're talking about pointers
@
text
@d20 1
a20 1
char *merr;
d25 1
a25 1
		merr = "Float point exception";
d31 1
a31 1
	char *name;
d37 1
a37 1
static struct var *get(char *str)
d51 1
a51 1
	v->name = strdup(str);
d55 1
a55 1
char *ptr;
d68 1
a68 1
		char *s = ptr, c;
d81 1
a81 1
		sscanf(ptr, "%lf", &x);
d91 1
a91 1
				merr = "Missing )";
d124 1
a124 1
				merr = "Left side of = is not an l-value";
d132 1
a132 1
double calc(BW *bw, char *s)
d138 1
a138 1
	v = get("top");
d141 1
a141 1
	v = get("lines");
d144 1
a144 1
	v = get("line");
d147 1
a147 1
	v = get("col");
d150 1
a150 1
	v = get("byte");
d153 1
a153 1
	v = get("height");
d156 1
a156 1
	v = get("width");
d176 1
a176 1
			merr = "Extra junk after end of expr";
d183 1
a183 1
static int domath(BW *bw, char *s, void *object, int *notify)
d195 1
a195 1
	snprintf(msgbuf, JOE_MSGBUFSIZE, "%G", result);
d198 1
a198 1
		pfwrd(bw->cursor, strlen(msgbuf));
d211 1
a211 1
	if (wmkpw(bw->parent, "=", &mathhist, domath, "math", NULL, NULL, NULL, NULL)) {
@


1.14
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d35 1
a35 1
} *vars = 0;
d61 1
a61 1
	struct var *v = 0;
d206 1
a206 1
B *mathhist = 0;
@


1.13
log
@cleanup signals handling (sigaction() / sigvec() / signal())
@
text
@d119 4
a122 3
		if (v)
			v->val = x, v->set = 1;
		else {
@


1.12
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@a11 1
#include <signal.h>
d27 1
a27 1
	signal(SIGFPE, fperr);
d209 1
a209 1
	signal(SIGFPE, fperr);
@


1.11
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@a12 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d17 1
d47 1
a47 1
	v = (struct var *) malloc(sizeof(struct var));
@


1.10
log
@include only headers which are needed
@
text
@d134 1
a134 1
double calc(BW * bw, char *s)
d185 1
a185 1
static int domath(BW * bw, char *s, void *object, int *notify)
d210 1
a210 1
int umath(BW * bw)
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@d13 3
d17 2
a18 2
#include "w.h"
#include "bw.h"
a19 1
#include "tw.h"
d21 1
a21 1
#include "umath.h"
@


1.8
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d1 7
a7 2
/* Math */

d9 1
@


1.7
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d189 1
a189 1
	snprintf(msgbuf, MSGBUFSIZE, "%G", result);
@


1.6
log
@version 2.9.7-pre3
@
text
@d185 1
a185 1
		msgnw(bw, merr);
d195 1
a195 1
		msgnw(bw, msgbuf);
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d17 1
a17 1
RETSIGTYPE fperr(int unused)
d32 1
a32 1
struct var *get(char *str)
d53 1
a53 1
double expr(int prec, struct var **rtv)
d177 1
a177 1
int domath(BW * bw, char *s, void *object, int *notify)
@


1.4
log
@changed as of joe-2.9.6
@
text
@d3 2
d17 2
a18 1
void fperr (int i) {
d22 1
a22 1
	signal (SIGFPE, fperr);
d30 1
a30 3
}

*vars = 0;
d32 2
a33 1
struct var *get (char *str) {
d37 1
a37 1
		if (!strcmp (v->name, str)) {
d41 2
a42 1
	v = (struct var *) malloc (sizeof (struct var));
d46 1
a46 1
	v->name = strdup (str);
d53 2
a54 1
double expr (int prec, struct var **rtv) {
d61 2
a62 1
	if ((*ptr >= 'a' && *ptr <= 'z') || (*ptr >= 'A' && *ptr <= 'Z') || *ptr == '_') {
d64 4
a67 1
		while ((*ptr >= 'a' && *ptr <= 'z') || (*ptr >= 'A' && *ptr <= 'Z') || *ptr == '_' || (*ptr >= '0' && *ptr <= '9')) {
d72 1
a72 1
		v = get (s);
d75 16
a91 23
	else if ((*ptr >= '0' && *ptr <= '9') || *ptr == '.')
	  {
		  sscanf (ptr, "%lf", &x);
		  while ((*ptr >= '0' && *ptr <= '9') || *ptr == '.' || *ptr == 'e' || *ptr == 'E')
			  ++ptr;
	  }
	else if (*ptr == '(')
	  {
		  ++ptr;
		  x = expr (0, &v);
		  if (*ptr == ')')
			  ++ptr;
		  else
		    {
			    if (!merr)
				    merr = "Missing )";
		    }
	  }
	else if (*ptr == '-')
	  {
		  ++ptr;
		  x = -expr (10, &dumb);
	  }
d95 27
a121 37
	if (*ptr == '*' && 5 > prec)
	  {
		  ++ptr;
		  x *= expr (5, &dumb);
		  goto loop;
	  }
	else if (*ptr == '/' && 5 > prec)
	  {
		  ++ptr;
		  x /= expr (5, &dumb);
		  goto loop;
	  }
	else if (*ptr == '+' && 4 > prec)
	  {
		  ++ptr;
		  x += expr (4, &dumb);
		  goto loop;
	  }
	else if (*ptr == '-' && 4 > prec)
	  {
		  ++ptr;
		  x -= expr (4, &dumb);
		  goto loop;
	  }
	else if (*ptr == '=' && 2 >= prec)
	  {
		  ++ptr;
		  x = expr (2, &dumb);
		  if (v)
			  v->val = x, v->set = 1;
		  else
		    {
			    if (!merr)
				    merr = "Left side of = is not an l-value";
		    }
		  goto loop;
	  }
d126 2
a127 1
double calc (BW *bw, char *s) {
d132 1
a132 1
	v = get ("top");
d135 1
a135 1
	v = get ("lines");
d138 1
a138 1
	v = get ("line");
d141 1
a141 1
	v = get ("col");
d144 1
a144 1
	v = get ("byte");
d147 1
a147 1
	v = get ("height");
d150 1
a150 1
	v = get ("width");
d156 1
a156 1
      	result = expr (0, &dumb);
d177 3
a179 2
int domath (BW *bw, char *s, void *object, int *notify) {
	double result = calc (bw, s);
d185 1
a185 1
		msgnw (bw, merr);
d188 2
a189 2
	vsrm (s);
	snprintf (msgbuf, MSGBUFSIZE, "%G", result);
d191 3
a193 3
		binsm (bw->cursor, sz (msgbuf));
		pfwrd (bw->cursor, strlen (msgbuf));
		bw->cursor->xcol = piscol (bw->cursor);
d195 1
a195 1
		msgnw (bw, msgbuf);
d202 4
a205 3
int umath (BW *bw) {
	signal (SIGFPE, fperr);
	if (wmkpw (bw->parent, "=", &mathhist, domath, "math", NULL, NULL, NULL, NULL)) {
@


1.3
log
@changed as of joe-2.9.5
@
text
@d3 1
d15 31
a45 26
void fperr()
 {
 if(!merr) merr="Float point exception";
 signal(SIGFPE,fperr);
 }

struct var
 {
 char *name;
 int set;
 double val;
 struct var *next;
 } *vars=0;

struct var *get(str)
char *str;
 {
 struct var *v;
 for(v=vars;v;v=v->next) if(!strcmp(v->name,str)) return v;
 v=(struct var *)malloc(sizeof(struct var));
 v->set=0;
 v->next=vars;
 vars=v;
 v->name=strdup(str);
 return v;
 }
d50 167
a216 132
double expr(prec,rtv)
struct var **rtv;
 {
 double x=0.0;
 struct var *v=0;
 while(*ptr==' ' || *ptr=='\t') ++ptr;
 if(*ptr>='a' && *ptr<='z' || *ptr>='A' && *ptr<='Z' || *ptr=='_')
  {
  char *s=ptr, c;
  while(*ptr>='a' && *ptr<='z' || *ptr>='A' && *ptr<='Z' || *ptr=='_' ||
        *ptr>='0' && *ptr<='9') ++ptr;
  c= *ptr; *ptr=0;
  v=get(s);
  x=v->val;
  *ptr=c;
  }
 else if(*ptr>='0' && *ptr<='9' || *ptr=='.')
  {
  sscanf(ptr,"%lf",&x);
  while(*ptr>='0' && *ptr<='9' || *ptr=='.' || *ptr=='e' || *ptr=='E') ++ptr;
  }
 else if(*ptr=='(')
  {
  ++ptr;
  x=expr(0,&v);
  if(*ptr==')') ++ptr;
  else { if(!merr) merr="Missing )"; }
  }
 else if(*ptr=='-')
  {
  ++ptr;
  x= -expr(10,&dumb);
  }
 loop:
 while(*ptr==' ' || *ptr=='\t') ++ptr;
 if(*ptr=='*' && 5>prec)
  {
  ++ptr;
  x*=expr(5,&dumb);
  goto loop;
  }
 else if(*ptr=='/' && 5>prec)
  {
  ++ptr;
  x/=expr(5,&dumb);
  goto loop;
  }
 else if(*ptr=='+' && 4>prec)
  {
  ++ptr;
  x+=expr(4,&dumb);
  goto loop;
  }
 else if(*ptr=='-' && 4>prec)
  {
  ++ptr;
  x-=expr(4,&dumb);
  goto loop;
  }
 else if(*ptr=='=' && 2>=prec)
  {
  ++ptr;
  x=expr(2,&dumb);
  if(v) v->val=x, v->set=1;
  else { if(!merr) merr="Left side of = is not an l-value"; }
  goto loop;
  }
 *rtv=v;
 return x;
 }

double calc(bw,s)
BW *bw;
char *s;
 {
 double result;
 struct var *v;
 BW *tbw=bw->parent->main->object;
 v=get("top"); v->val=tbw->top->line+1; v->set=1;
 v=get("lines"); v->val=tbw->b->eof->line+1; v->set=1;
 v=get("line"); v->val=tbw->cursor->line+1; v->set=1;
 v=get("col"); v->val=tbw->cursor->col+1; v->set=1;
 v=get("byte"); v->val=tbw->cursor->byte+1; v->set=1;
 v=get("height"); v->val=tbw->h; v->set=1;
 v=get("width"); v->val=tbw->w; v->set=1;
 ptr=s;
 merr=0;
 up: result=expr(0,&dumb);
 if(!merr)
  {
  while(*ptr==' ' || *ptr=='\t') ++ptr;
  if(*ptr==';')
   {
   ++ptr;
   while(*ptr==' ' || *ptr=='\t') ++ptr;
   if(*ptr) goto up;
   }
  else if(*ptr) merr="Extra junk after end of expr";
  }
 return result;
 }

int domath(bw,s,object,notify)		/* Main user interface */
BW *bw;
char *s;
void *object;
int *notify;
 {
 double result=calc(bw,s);
 if(notify) *notify=1;
 if(merr) { msgnw(bw,merr); return -1; }
 vsrm(s);
 sprintf(msgbuf,"%lg",result);
 if(bw->parent->watom->what!=TYPETW)
  {
  binsm(bw->cursor,sz(msgbuf));
  pfwrd(bw->cursor,strlen(msgbuf));
  bw->cursor->xcol=piscol(bw->cursor);
  }
 else msgnw(bw,msgbuf);
 return 0;
 }

B *mathhist=0;

int umath(bw)
BW *bw;
 {
 signal(SIGFPE,fperr);
 if(wmkpw(bw,"=",&mathhist,domath,"math",NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@a9 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d4 1
d33 1
a33 1
 for(v=vars;v;v=v->next) if(!zcmp(v->name,str)) return v;
d38 1
a38 1
 v->name=zdup(str);
d161 1
a161 1
  pfwrd(bw->cursor,zlen(msgbuf));
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
