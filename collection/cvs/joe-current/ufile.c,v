head	1.77;
access;
symbols
	joe_3_5:1.64
	joe-3_4:1.56
	help:1.56
	joe_3_1:1.33
	joe_3_0:1.24
	joe_2_9_8:1.21
	joe_2_9_8_pre1:1.16
	joe_2_9_7:1.8
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.77
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.01.02.07.46;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.29.02.06.05;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2008.10.29.01.45.38;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2008.10.28.22.55.41;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2008.10.27.17.18.22;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2008.10.26.23.00.54;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2008.10.25.23.01.27;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.13.13.53.55;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.07.05.17.09;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.03.23.37.01;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.02.17.04.00;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.02.15.01.26;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.24.22.19.00;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.22.20.45.40;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.12.02.07.06;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.05.04.17.53;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.27.21.59.00;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.01.15.27.00;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.20.03.31.26;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.16.22.03.44;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.16.21.37.36;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.16.00.00.58;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.14.03.21.37;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.14.00.07.50;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.13.05.01.23;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.09.21.01.55;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.26.05.14.42;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.21.14.47.42;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.14.07.30.39;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.14.04.23.09;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.11.20.02.51;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.11.13.56.10;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.05.00.09.15;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.15.19.40.05;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.04.17.39.24;	author vsamel;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.05.15.02.41;	author vsamel;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.10.12.13.32;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.10.12.11.13;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.12.16.00.24;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.12.15.55.00;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.07.13.47.40;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.13.39.27;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.77
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/*
 * 	User file operations
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef HAVE_UTIME_H
#include <utime.h>
#else
#ifdef HAVE_SYS_UTIME_H
#include <sys/utime.h>
#endif
#endif

#ifdef WITH_SELINUX
int copy_security_context(const char *from_file, const char *to_file);
#endif

int orphan;
unsigned char *backpath = NULL;		/* Place to store backup files */
B *filehist = NULL;	/* History of file names */
int nobackups = 0;
int exask = 0;

/* Ending message generator */
/**** message which is shown after closing joe (CTRL+x; CTRL+k) *****/
void genexmsg(BW *bw, int saved, unsigned char *name)
{
	unsigned char *s;
	unsigned char *m;

	if (bw->b->name && bw->b->name[0]) {
		s = bw->b->name;
	} else {
		s = joe_gettext(_("(Unnamed)"));
	}

	if (name) {
		if (saved) {
			m = vsfmt(NULL, 0, joe_gettext(_("File %s saved")), name);
		} else {
			m = vsfmt(NULL, 0, joe_gettext(_("File %s not saved")), name);
		}
	} else if (bw->b->changed && bw->b->count == 1) {
		m = vsfmt(NULL, 0, joe_gettext(_("File %s not saved")), s);
	} else if (saved) {
		m = vsfmt(NULL, 0, joe_gettext(_("File %s saved")), s);
	} else {
		m = vsfmt(NULL, 0, joe_gettext(_("File %s not changed so no update needed")), s);
	}
	if (exmsg)
		obj_free(exmsg);

	exmsg = m;
	obj_perm(exmsg);
	msgnw(bw->parent, m);
}

/* For ^X ^C */
void genexmsgmulti(BW *bw, int saved, int skipped)
{
	unsigned char *m;
	if (saved)
		if (skipped)
			m = vsdupz(joe_gettext(_("Some files have not been saved.")));
		else
			m = vsdupz(joe_gettext(_("All modified files have been saved.")));
	else
		m = vsdupz(joe_gettext(_("No modified files, so no updates needed.")));

	msgnw(bw->parent, m);

	if (exmsg)
		obj_free(exmsg);
	exmsg = m;
	obj_perm(exmsg);
}

/* Shell escape */

int ushell(BW *bw)
{
	nescape(bw->parent->t->t);
	ttsusp();
	nreturn(bw->parent->t->t);
	return 0;
}

/* Execute shell command */

int usys(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("System (^C to abort): ")), NULL, NULL, utypebw, bw->b->o.charmap, 1, 0, NULL);
	if (s) {
		int rtn;
		nescape(bw->parent->t->t);
		rtn=ttshell(s);
		nreturn(bw->parent->t->t);
		return rtn;
	} else {
		return -1;
	}
}

/* Copy a file */

static int cp(unsigned char *from, unsigned char *to)
{
	int f, g, amnt;
	struct stat sbuf;
	char buf[8192];

#ifdef HAVE_UTIME
#ifdef NeXT
	time_t utbuf[2];
#else
	struct utimbuf utbuf;
#endif
#endif

	f = open((char *)from, O_RDONLY);
	if (f < 0) {
		return -1;
	}
	if (fstat(f, &sbuf) < 0) {
		return -1;
	}
	g = creat((char *)to, sbuf.st_mode & ~(S_ISUID | S_ISGID));
	if (g < 0) {
		close(f);
		return -1;
	}
	while ((amnt = read(f, buf, sizeof(buf))) > 0) {
		if (amnt != joe_write(g, buf, amnt)) {
			break;
		}
	}
	close(f);
	close(g);
	if (amnt) {
		return -1;
	}

#ifdef HAVE_UTIME
#ifdef NeXT
	utbuf[0] = (time_t) sbuf.st_atime;
	utbuf[1] = (time_t) sbuf.st_mtime;
#else
	utbuf.actime = sbuf.st_atime;
	utbuf.modtime = sbuf.st_mtime;
#endif
	utime((char *)to, &utbuf);
#endif

#ifdef WITH_SELINUX
	copy_security_context(from,to);
#endif

	return 0;
}

/* Make backup file if it needs to be made
 * Returns 0 if backup file was made or didn't need to be made
 * Returns 1 for error
 */

static int backup(BW *bw)
{
	if (!bw->b->backup && !nobackups && !bw->o.nobackup && bw->b->name && bw->b->name[0]) {
		unsigned char *name = 0;

#ifdef __MSDOS__
		int x;

		if (backpath) {
			unsigned char *t = vsncpy(NULL,0,sz(backpath));
			t = canonical(t);
			name = vsfmt(name, 0, USTR "%s/%s", t, namepart(tmp, dequote(bw->b->name)));
		} else {
			name = vsfmt(name, 0, USTR "%s", dequote(bw->b->name));
		}

		for (x = vslen(name); name[--x] != '.';) {
			if (name[x] == '\\' || (name[x] == ':' && x == 1) || x == 0) {
				x = vslen(name);
				break;
			}
		}

		name = vsncpy(name, x, sc(".bak"));
		name = vstrunc(name, x + 4);

#else

		/* Create backup file name */
		unsigned char *simple_backup_suffix = (unsigned char *)getenv("SIMPLE_BACKUP_SUFFIX");
		
		if (simple_backup_suffix == NULL) {
			simple_backup_suffix = USTR "~";
		}
		if (backpath) {
			unsigned char *t = vsncpy(NULL, 0, sz(backpath));
			t = canonical(t);
			name = vsfmt(name, 0, USTR "%s/%s%s", t, namprt(bw->b->name), simple_backup_suffix);
		} else {
			name = vsfmt(name, 0, USTR "%s%s", bw->b->name, simple_backup_suffix);
		}
		
		/* Attempt to delete backup file first */
		unlink((char *)name);

#endif

		/* Copy original file to backup file */
		if (cp(dequote(bw->b->name), name)) {
			return 1;
		} else {
			bw->b->backup = 1;
			return 0;
		}
	} else {
		return 0;
	}
}

/* Write file */

/* Continuation structure */

struct savereq {
	int (*callback) ();
	unsigned char *name;
	B *first;
	int not_saved;	/* Set if a modified file was not saved */
	int rename;	/* Set if we're renaming the file during save */
	int block_save; /* Flag, if we want to save a block# */
	unsigned char *message; /* String for messages to be shown to the user */
};

struct savereq *mksavereq(int (*callback)(), unsigned char *name, B *first,int rename, int block_save)
{
	struct savereq *req = (struct savereq *) joe_malloc(sizeof(struct savereq));
	req->callback = callback;
	req->name = name;
	req->first = first;
	req->not_saved = 0;
	req->rename = rename;
	req->block_save = block_save;
	return req;
}

static void rmsavereq(struct savereq *req)
{
	obj_free(req->name);
	joe_free(req);
}

/* Check if character 'c' is in the set.
 * 'c' should be unicode if the locale is UTF-8, otherwise it's
 * an 8-bit character.  'set' should be of this format: "xxxx<>yyyy".  xxxx
 * is a list of 8-bit characters. yyyy is a list of UTF-8 characters.
 */

unsigned char *yes_key = (unsigned char *) _("|yes|yY");
unsigned char *no_key = (unsigned char *) _("|no|nN");

int yncheck(unsigned char *key_set, int c)
{
	unsigned char *set = joe_gettext(key_set);
	if (locale_map->type) {
		/* 'c' is unicode */
		while (*set) {
			if (c == utf8_decode_fwrd(&set, NULL))
				return 1;
		}
		return 0;
	} else {
		/* 'c' is 8-bit */
		while (set[0]) {
			if (set[0] == c)
				return 1;
			++set;
		}
		return 0;
	}
}

int ynchecks(unsigned char *set, unsigned char *s)
{
	if (locale_map->type)
		return yncheck(set, utf8_decode_fwrd(&s, NULL));
	else
		return yncheck(set, s[0]);
}

static int saver(BW *bw, int c, struct savereq *req)
{
	int fl;
	again:
	if (c == NO_CODE || yncheck(no_key, c)) {
		msgnw(bw->parent, joe_gettext(_("Couldn't make backup file... file not saved")));
		if (req->callback) {
			return req->callback(bw, req, -1);
		} else {
			rmsavereq(req);
			return -1;
		}
	}
	if (c != YES_CODE && !yncheck(yes_key, c)) {
		c = query(bw->parent, sz(joe_gettext(_("Could not make backup file.  Save anyway (y,n,^C)? "))), 0);
		if (c == -1) {
			rmsavereq(req);
			return -1;
		} else
			goto again;
	}
	if (bw->b->er == -1 && bw->o.msnew) {
		exmacro(bw->o.msnew,1);
		bw->b->er = -3;
	}
	if (bw->b->er == 0 && bw->o.msold) {
		exmacro(bw->o.msold,1);
	}
	if ((fl = bsave(bw->b->bof, req->name, bw->b->eof->byte, req->rename ? 2 : 1)) != 0) {
		msgnw(bw->parent, joe_gettext(msgs[-fl]));
		if (req->callback) {
			return req->callback(bw, req, -1);
		} else {
			rmsavereq(req);
			return -1;
		}
	} else {
		if (req->rename) {
			bw_unlock(bw);
			joe_free(bw->b->name);
			bw->b->name = 0;
		}
		if (!bw->b->name && req->name[0]!='!' && req->name[0]!='>')
			bw->b->name = joesep(zdup(req->name));
		if (bw->b->name && !zcmp(bw->b->name, req->name)) {
			bw_unlock(bw);
			bw->b->changed = 0;
			saverr(bw->b->name);
		}
		{
			/* Last UNDOREC which wasn't modified will be changed
			 * to modified. And because this block is
			 * executed after each 'save', there can't be more
			 * than one record which is not modified
			 *		24 Apr 2001, Marx
			 */
			UNDO *u = bw->b->undo;
			UNDOREC *rec, *rec_start;

			rec = rec_start = &u->recs;

			do {
				rec = rec->link.prev;
			} while (rec != rec_start && rec->changed);
			if(rec->changed == 0)
				rec->changed = 1;

		}
		genexmsg(bw, 1, req->name);
		if (req->callback) {
			return req->callback(bw, req, 0);
		} else {
			rmsavereq(req);
			return 0;
		}
	}
}

static int dosave(BW *bw, struct savereq *req)
{
	if (req->block_save)
	{
		if (markv(1)) {
			if (square) {
				int fl;
				int ret = 0;
				B *tmp = pextrect(markb,
						  markk->line - markb->line + 1,
						  markk->xcol);
						  
				if ((fl = bsave(tmp->bof, req->name, tmp->eof->byte, 0)) != 0) {
					msgnw(bw->parent, joe_gettext(msgs[-fl]));
					ret = -1;
				}
				brm(tmp);
				if (!ret) {
					msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Block written to file %s")), req->name));
				}
				if (lightoff)
					unmark(bw);
				rmsavereq(req);
				return ret;
			} else {
				int fl;
				int ret = 0;

				if ((fl = bsave(markb, req->name, markk->byte - markb->byte, 0)) != 0) {
					msgnw(bw->parent, joe_gettext(msgs[-fl]));
					ret = -1;
				}
				if (!ret) {
					msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Block written to file %s")), req->name));
				}
				if (lightoff)
					unmark(bw);
				rmsavereq(req);
				return ret;
			}
		} else {
			rmsavereq(req);
			msgnw(bw->parent, joe_gettext(_("No block")));
			return -1;
		}
	}
	else
	{
		if (backup(bw)) {
			return saver(bw, 0, req);
		} else {
			return saver(bw, YES_CODE, req);
		}
	}
}

static int dosave2(BW *bw, int c, struct savereq *req)
{
	again:
	if (c == YES_CODE || yncheck(yes_key, c)) {
		return dosave(bw, req);
	} else if (c == NO_CODE || yncheck(no_key, c)) {
		genexmsg(bw, 0, req->name);
		rmsavereq(req);
		return -1;
	} else if (-1 != (c = query(bw->parent, sz(req->message), 0))) {
		goto again;
	} else {
		/* Should be in abort function */
		rmsavereq(req);
		return -1;
	}
}

/* Checks if file exists. */

static int dosave1(BW *bw, unsigned char *s, struct savereq *req)
{
	int f;

	if (req->name)
		obj_free(req->name);
	req->name = s;
	obj_perm(req->name);

	if (s[0] != '!' && !(s[0] == '>' && s[1] == '>')) {
		/* It's a normal file: not a pipe or append */
		if (!bw->b->name || zcmp(s, bw->b->name)) {
			/* Newly named file or name is different than buffer */
			f = open((char *)dequote(s), O_RDONLY);
			if (f != -1) {
				close(f);
				req->message = joe_gettext(_("File exists. Overwrite (y,n,^C)? "));
				return dosave2(bw, 0, req);
			}
		}
		else {
			/* We're saving a newer version of the same file */
			if (check_mod(bw->b)) {
				req->message = joe_gettext(_("File on disk is newer. Overwrite (y,n,^C)? "));
				return dosave2(bw, 0, req);
			}
		}
	}

	return dosave(bw, req);
}

/* User command: ^K D */

int usave(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, USTR "Names", cmplt,
	                       locale_map, bw->b->name ? 1 : 7, 0, bw->b->name);
	if (s) {
		return dosave1(bw, s, mksavereq(NULL,NULL,NULL,1, 0));
	} else {
		return -1;
	}
}

int usavenow(BW *bw)
{
	if (bw->b->name) {
		return dosave1(bw,vsncpy(NULL,0,sz(bw->b->name)),mksavereq(NULL,NULL,NULL,0,0));
	} else
		return usave(bw);
}

/* Write highlighted block to a file */

int ublksave(BW *bw)
{
	if (markb && markk && markb->b == markk->b && (markk->byte - markb->byte) > 0 && (!square || piscol(markk) > piscol(markb))) {
		unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to write (^C to abort): ")), &filehist, USTR "Names", cmplt,
				       locale_map, 3, 0, bw->b->name);
		if (s) {
			return dosave1(bw, s, mksavereq(NULL,NULL,NULL,0, 1));
		} else {
			return -1;
		}
	} else {
		return usave(bw);
	}
}


/* Load file to edit */

int doedit(BW *bw,int c,unsigned char *s)
{
	int omid;
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;
	again:
	if (c == YES_CODE || yncheck(yes_key, c)) {
		/* Reload from file */

		b = bfind_reload(s);
		er = berror;
		if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
			if (orphan) {
				orphit(bw);
			} else {
				if (uduptw(bw)) {
					brm(b);
					return -1;
				}
				bw = (BW *) maint->curwin->object;
			}
		}
		if (er) {
			msgnwt(bw->parent, joe_gettext(msgs[-er]));
			if (er != -1) {
				ret = -1;
			}
		}
		object = bw->object;
		w = bw->parent;
		bwrm(bw);
		w->object = (void *) (bw = bwmk(w, b, 0, NULL));
		wredraw(bw->parent);
		bw->object = object;
		if (er == -1 && bw->o.mnew) {
			exmacro(bw->o.mnew,1);
		}
		if (er == 0 && bw->o.mold) {
			exmacro(bw->o.mold,1);
		}
		/* Restore cursor line */
		pline(bw->cursor, get_file_pos(bw->b->name));
		omid = mid;
		mid = 1;
		dofollows();
		mid = omid;
		
		return ret;
	} else if (c == NO_CODE || yncheck(no_key, c)) {
		/* Edit already loaded buffer */

		b = bfind(s);
		er = berror;
		if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
			if (orphan) {
				orphit(bw);
			} else {
				if (uduptw(bw)) {
					brm(b);
					return -1;
				}
				bw = (BW *) maint->curwin->object;
			}
		}
		if (er) {
			msgnwt(bw->parent, joe_gettext(msgs[-er]));
			if (er != -1) {
				ret = -1;
			}
		}
		object = bw->object;
		w = bw->parent;
		bwrm(bw);
		w->object = (void *) (bw = bwmk(w, b, 0, NULL));
		wredraw(bw->parent);
		bw->object = object;
		if (er == -1 && bw->o.mnew) {
			exmacro(bw->o.mnew,1);
		}
		if (er == 0 && bw->o.mold) {
			exmacro(bw->o.mold,1);
		}
		/* Restore cursor line */
		pline(bw->cursor, get_file_pos(bw->b->name));
		omid = mid;
		mid = 1;
		dofollows();
		mid = omid;
		return ret;
	} else {
		/* FIXME: need abort handler to prevent leak */
		c = query(bw->parent, sz(joe_gettext(_("Load original file from disk (y,n,^C)? "))), 0);
		if (c == -1)
			return -1;
		goto again;
	}
}

int okrepl(BW *bw)
{
	if (bw->b->count == 1 && bw->b->changed) {
		msgnw(bw->parent, joe_gettext(_("Can't replace modified file")));
		return -1;
	} else {
		return 0;
	}
}

/* Edit a file.  If file is already loaded, ask the original should be loaded or to just switch to buffer */

int uedit(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to edit (^C to abort): ")), &filehist,
	                       USTR "Names", cmplt, locale_map, 7, 0, NULL);
	if (s) {
		B *b;

		b = bcheck_loaded(s);

		if (b) {
			if (b->changed && !b->scratch)
				/* Modified buffer exists, so ask */
				return doedit(bw, 0, s);
			else
				/* Buffer not modified- just use it as is */
				return doedit(bw, NO_CODE, s);
		} else
			/* File not in buffer: don't ask */
			return doedit(bw, YES_CODE, s);
	} else {
		return -1;
	}
}

/* Switch to another buffer.  If it doesn't exist, load file. */

int doswitch(BW *bw, unsigned char *s)
{
	return doedit(bw, NO_CODE, s);
}

int uswitch(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &filehist,
	                       USTR "Names", cmplt, locale_map, 1, 0, NULL);
	if(s) {
		return doswitch(bw, s);
	} else {
		return -1;
	}
}

int uscratch(BW *bw)
{
	unsigned char *s;
	s = ask(bw->parent, joe_gettext(_("Name of scratch buffer to edit (^C to abort): ")), &filehist, USTR "Names", cmplt, locale_map, 1, 0, NULL);
	if (s) {
		int ret = 0;
		int er;
		void *object;
		W *w;
		B *b;

		b = bfind_scratch(s);
		er = berror;
		if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
			if (orphan) {
				orphit(bw);
			} else {
				if (uduptw(bw)) {
					brm(b);
					return -1;
				}
				bw = (BW *) maint->curwin->object;
			}
		}
		if (er) {
			msgnwt(bw->parent, joe_gettext(msgs[-er]));
			if (er != -1) {
				ret = -1;
			}
		}
		object = bw->object;
		w = bw->parent;
		bwrm(bw);
		w->object = (void *) (bw = bwmk(w, b, 0, NULL));
		wredraw(bw->parent);
		bw->object = object;
		if (er == -1 && bw->o.mnew) {
			exmacro(bw->o.mnew,1);
		}
		if (er == 0 && bw->o.mold) {
			exmacro(bw->o.mold,1);
		}
		return ret;
	} else {
		return -1;
	}
}

/* Load file into buffer: can result in an orphaned buffer */

static int dorepl(BW *bw, unsigned char *s, void *obj)
{
	void *object = bw->object;
	int omid;
	int ret = 0;
	int er;
	W *w = bw->parent;
	B *b;

	b = bfind(s);
	er = berror;
	if (berror) {
		msgnwt(bw->parent, joe_gettext(msgs[-berror]));
		if (berror != -1) {
			ret = -1;
		}
	}
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
		orphit(bw);
	}
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, b, 0, NULL));
	wredraw(bw->parent);
	bw->object = object;
	if (er == -1 && bw->o.mnew) {
		exmacro(bw->o.mnew,1);
	}
	if (er == 0 && bw->o.mold) {
		exmacro(bw->o.mold,1);
	}
	/* Restore cursor line */
	pline(bw->cursor, get_file_pos(bw->b->name));
	omid = mid;
	mid = 1;
	dofollows();
	mid = omid;
	return ret;
}

/* Switch to a particular buffer */

int get_buffer_in_window(BW *bw, B *b)
{
	void *object = bw->object;
	W *w = bw->parent;
	if (b == bw->b) {
		return 0;
		/* return -1; this helps with querysave (no error when only one buffer) */
	}
	if (!b->orphan) {
		++b->count;
	} else {
		b->orphan = 0;
	}
	if (bw->b->count == 1) {
		orphit(bw);
	}
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, b, 0, NULL));
	wredraw(bw->parent);
	bw->object = object;
	return 0;
}

/* Switch to next buffer in window */

int unbuf(BW *bw)
{
	B *b;
	b = bnext();
	if (b == bw->b) {
		b = bnext();
	}
	return get_buffer_in_window(bw,b);
}

int upbuf(BW *bw)
{
	B *b;
	b = bprev();
	if (b == bw->b) {
		b = bprev();
	}
	return get_buffer_in_window(bw, b);
}

/* Save and exit */

static int exdone(BW *bw, struct savereq *req,int flg)
{
	rmsavereq(req);
	if (flg) {
		return -1;
	} else {
		bw_unlock(bw);
		bw->b->changed = 0;
		saverr(bw->b->name);
		return uabort1(bw, -1);
	}
}

int uexsve(BW *bw)
{
	if (!bw->b->changed || bw->b->scratch) {
		/* It didn't change or it's just a scratch buffer: don't save */
		uabort(bw, -1);
		return 0;
	} else if (bw->b->name && !exask) {
		/* It changed, it's not a scratch buffer and it's named */
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), mksavereq(exdone,NULL,NULL,0,0));
	} else {
		unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist,
				       USTR "Names", cmplt, locale_map, 1, 0, bw->b->name);
		if (s) {
			return dosave1(bw, s, mksavereq(NULL, NULL, NULL, 0, 0));
		} else {
			return -1;
		}
	}
}

/* If buffer is modified, prompt for saving: if user types 'n', uabort(), otherwise just return. */
/* If buffer is not modified, just return. */

int uask(BW *bw)
{
	if (bw->b->count == 1 && bw->b->changed && !bw->b->scratch) {
		for (;;) {
			int c = query(bw->parent, sz(joe_gettext(_("Save changes to this file (y,n,^C)? "))), 0);
			/* what happens when ^C is hit? */
			if (c == -1) {
				return -1;
			} else if (c == YES_CODE || yncheck(yes_key, c)) {
				return 0;
			} else if (c == NO_CODE || yncheck(no_key, c)) {
				genexmsg(bw, 0, NULL);
				abortit(bw);
				return -1;
			}
		}
	} else {
		return 0;
	}
}

/* Kill a buffer: any windows which have it get their buffer replaced with a
 * a scratch buffer */

int ulose(BW *bw)
{
	W *w;
	B *b, *new_b;
	int cnt;
	msgnw(bw->parent, NULL);
	if (bw->b->count==1 && bw->b->pid) {
		return ukillpid(bw);
	}
	if (bw->b->changed && !bw->b->scratch) {
		int c = query(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), 0);
		if (c != YES_CODE && !yncheck(yes_key, c)) {
			return -1;
		}
	}
	b=bw->b;
	cnt = b->count;
	b->count = 1;
	genexmsg(bw, 0, NULL);
	b->count = cnt;
	if ((w = maint->topwin) != NULL) {
		do {
			if ((w->watom->what&TYPETW) && ((BW *)w->object)->b==b) {
				if ((new_b = borphan()) != NULL) {
					BW *bw = (BW *)w->object;
					void *object = bw->object;
					/* FIXME: Shouldn't we wabort() and wcreate here to kill
					   any prompt windows? */

					bwrm(bw);
					w->object = (void *) (bw = bwmk(w, new_b, 0, NULL));
					wredraw(w);
					bw->object = object;
				} else {
					BW *bw = (BW *)w->object;
					void *object = bw->object;
					bwrm(bw);
					w->object = (void *) (bw = bwmk(w, bfind(USTR ""), 0, NULL));
					wredraw(w);
					bw->object = object;
					if (bw->o.mnew)
						exmacro(bw->o.mnew,1);
				}
			}
		w = w->link.next;
		} while (w != maint->topwin);
	}
	return 0;
}

/* Buffer list */

unsigned char **sbufs = NULL;

static int bufedcmplt(BW *bw)
{
	if (sbufs) {
		varm(sbufs);
		sbufs = 0;
	}
	if (!sbufs) {
		sbufs = getbufs();
		vaperm(sbufs);
	}
	return simple_cmplt(bw,sbufs);
}

B *bufhist = NULL;

int ubufed(BW *bw)
{
	unsigned char *s;
	s = ask(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &bufhist, USTR "bufed", bufedcmplt, locale_map, 0, 0, NULL);
	if (s) {
		return dorepl(bw, s, NULL);
	} else {
		return -1;
	}
}


/* Query save loop */

static int doquerysave(BW *bw,int c,struct savereq *req)
{
	W *w = bw->parent;
	again:
	if (c == YES_CODE || yncheck(yes_key, c)) {
		if (bw->b->name && bw->b->name[0])
			return dosave1(bw, vsncpy(NULL,0,sz(bw->b->name)), req);
		else {
			unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")),
			                       &filehist, USTR "Names", cmplt, locale_map, 7, 0, NULL);

			if (s) {
				return dosave1(bw, s, req);
			} else {
				joe_free(req);
				return -1;
			}
		}
	} else if (c == NO_CODE || yncheck(no_key, c)) {
		/* Find next buffer to save */
		if (bw->b->changed)
			req->not_saved = 1;
		next:
		if (unbuf(bw)) {
			rmsavereq(req);
			return -1;
		}
		bw = w->object;
		if (bw->b==req->first) {
			rmsavereq(req);
			genexmsgmulti(bw,1,req->not_saved);
			return 0;
		}
		if (!bw->b->changed || bw->b->scratch)
			goto next;

		return doquerysave(bw,0,req);
	} else {
		unsigned char *buf = 0;
		buf = vsfmt(buf, 0, joe_gettext(_("File %s has been modified.  Save it (y,n,^C)? ")),bw->b->name ? bw->b->name : USTR "(Unnamed)" );
		c = query(bw->parent, sv(buf), 0);
		if (c == -1) {
			rmsavereq(req);
			return -1;
		}
		goto again;
	}
}

static int query_next(BW *bw, struct savereq *req,int flg)
{
	if (flg) {
		rmsavereq(req);
		return -1;
	} else
		return doquerysave(bw,NO_CODE,req);
}

int uquerysave(BW *bw)
{
	W *w = bw->parent;
	B *first;

	/* Get synchronized with buffer ring */
	unbuf(bw);
	bw = w->object;
	first = bw->b;

	/* Find a modified buffer */
	do {
		if (bw->b->changed && !bw->b->scratch)
			return doquerysave(bw,0,mksavereq(query_next,NULL,first,0,0));
		else if (unbuf(bw))
			return -1;
		bw = w->object;
	} while(bw->b!=first);

	genexmsgmulti(bw,0,0);

	return 0;
}

int ukilljoe(BW *bw)
{
	/* Save file positions */
	set_file_pos_all(bw->parent->t);
	/* FIXME: emacs checks for unsaved modified buffers at this point */
	leave = 1;
	return 0;
}

int ureload(BW *bw)
{
	B *n;
	if (!plain_file(bw->b)) {
		msgnw(bw->parent, joe_gettext(_("Can only reload plain files")));
		return -1;
	}
	if (bw->b->changed) {
		int c = query(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), 0);
		if (c != YES_CODE && !yncheck(yes_key, c)) {
			return -1;
		}
	}
	n = bload(bw->b->name);
	if (berror) {
		brm(n);
		msgnw(bw->parent, joe_gettext(msgs[-berror]));
		return -1;
	}
	breplace(bw->b, n);
	nredraw(bw->parent->t->t);
	msgnw(bw->parent, joe_gettext(_("File reloaded")));
	return 0;
}

int ureload_all(BW *bw)
{
	int count = 0;
	int er = 0;
	B *b;
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (!b->changed && plain_file(b)) {
			B *n = bload(b->name);
			if (berror) {
				msgnw(bw->parent, joe_gettext(msgs[-berror]));
				er = -1;
				brm(n);
			} else {
				breplace(b, n);
				++count;
			}
		}
	nredraw(bw->parent->t->t);
	if (!er) {
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%d files reloaded")), count));
	}
	return er;
}
@


1.76
log
@quoting fixes
@
text
@d155 1
a155 1
	utime(to, &utbuf);
d1053 1
a1053 1
ureload(BW *bw)
@


1.75
log
@Add reloadall command.
@
text
@d181 1
a181 1
			name = vsfmt(name, 0, USTR "%s/%s", t, namepart(tmp, bw->b->name));
d183 1
a183 1
			name = vsfmt(name, 0, USTR "%s", bw->b->name);
d218 1
a218 1
		if (cp(bw->b->name, name)) {
d466 1
a466 1
			f = open((char *)s, O_RDONLY);
@


1.74
log
@Reload command now prompts to lose changes to modified files.  Should call it revert.
@
text
@d1077 24
@


1.73
log
@Add reload command
@
text
@d1061 4
a1064 2
		msgnw(bw->parent, joe_gettext(_("Can only reload if buffer is not modifed")));
		return -1;
@


1.72
log
@Fix file rename bugs.
@
text
@d1052 23
@


1.71
log
@Fix problem where backup file did not get time of original file.
@
text
@d327 1
a327 1
	if ((fl = bsave(bw->b->bof, req->name, bw->b->eof->byte, 1)) != 0) {
d337 1
@


1.70
log
@^KD renames file
@
text
@d10 1
a10 1
#ifdef UTIME
a11 1
#define HAVEUTIME 1
d13 1
a13 1
#ifdef SYSUTIME
a14 1
#define HAVEUTIME 1
d116 1
a116 1
#ifdef HAVEUTIME
d147 1
a147 1
#ifdef HAVEUTIME
@


1.69
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d493 1
a493 1
		return dosave1(bw, s, mksavereq(NULL,NULL,NULL,0, 0));
@


1.68
log
@More work on coroutine refactoring.
@
text
@d174 1
a174 1
	if (!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0]) {
@


1.67
log
@more work on coroutine refactor
prompt window experiment
@
text
@a83 1

a103 2
		/* if (notify)
			*notify = 1; */
d301 1
a301 1
static int saver(BW *bw, int c, struct savereq *req, int *notify)
d304 1
d308 1
a308 1
			return req->callback(bw, req, -1, notify);
a309 3
			if (notify) {
				*notify = 1;
			}
d315 2
a316 3
		if (mkqw(bw->parent, sz(joe_gettext(_("Could not make backup file.  Save anyway (y,n,^C)? "))), saver, NULL, req, notify)) {
			return 0;
		} else {
a317 2
			if (notify)
				*notify = 1;
d319 2
a320 1
		}
d332 1
a332 1
			return req->callback(bw, req, -1, notify);
a334 3
			if (notify) {
				*notify = 1;
			}
d370 1
a370 1
			return req->callback(bw, req, 0, notify);
d378 1
a378 1
static int dosave(BW *bw, struct savereq *req, int *notify)
a381 2
		if (notify)
			*notify = 1;
d427 1
a427 1
			return saver(bw, 0, req, notify);
d429 1
a429 1
			return saver(bw, YES_CODE, req, notify);
d434 1
a434 1
static int dosave2(BW *bw, int c, struct savereq *req, int *notify)
d436 1
d438 1
a438 1
		return dosave(bw, req, notify);
a439 3
		if (notify) {
			*notify = 1;
		}
d443 2
a444 2
	} else if (mkqw(bw->parent, sz(req->message), dosave2, NULL, req, notify)) {
		return 0;
d454 1
a454 1
static int dosave1(BW *bw, unsigned char *s, struct savereq *req, int *notify)
d471 1
a471 1
				return dosave2(bw, 0, req, notify);
d478 1
a478 1
				return dosave2(bw, 0, req, notify);
d483 1
a483 1
	return dosave(bw, req, notify);
d493 1
a493 1
		return dosave1(bw, s, mksavereq(NULL,NULL,NULL,0, 0), /* notify */ NULL);
d502 1
a502 1
		return dosave1(bw,vsncpy(NULL,0,sz(bw->b->name)),mksavereq(NULL,NULL,NULL,0,0),NULL);
d515 1
a515 1
			return dosave1(bw, s, mksavereq(NULL,NULL,NULL,0, 1), /* notify */ NULL);
d527 1
a527 1
int doedit(BW *bw,int c,unsigned char *s,int *notify)
d535 1
a538 4
		if (notify) {
			*notify = 1;
		}

a580 4
		if (notify) {
			*notify = 1;
		}

d621 2
a622 3
		if (mkqw(bw->parent, sz(joe_gettext(_("Load original file from disk (y,n,^C)? "))), doedit, NULL, s, notify))
			return 0;
		else {
d624 1
a624 1
		}
d652 1
a652 1
				return doedit(bw, 0, s, NULL /* notify */);
d655 1
a655 1
				return doedit(bw, NO_CODE, s, NULL /*notify*/);
d658 1
a658 1
			return doedit(bw, YES_CODE, s, NULL /* notify */);
d668 1
a668 1
	return doedit(bw, NO_CODE, s, NULL /* notify */);
a692 3
		/* if (notify) {
			*notify = 1;
		} */
d732 1
a732 1
static int dorepl(BW *bw, unsigned char *s, void *obj, int *notify)
a740 3
	if (notify) {
		*notify = 1;
	}
d820 1
a820 1
static int exdone(BW *bw, struct savereq *req,int flg,int *notify)
a821 2
	if (notify)
		*notify = 1;
d841 1
a841 1
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), mksavereq(exdone,NULL,NULL,0,0), NULL);
d846 1
a846 1
			return dosave1(bw, s, mksavereq(NULL, NULL, NULL, 0, 0), /* notify */ NULL);
d856 1
a856 1
static int nask(BW *bw, int c, void *object, int *notify)
d858 13
a870 16
	if (c == YES_CODE || yncheck(yes_key, c)) {
		/* uexsve macro should be here... */
		if(notify)
			*notify = 1;
		return 0;
	} else if (c == NO_CODE || yncheck(no_key, c)) {
		if(notify)
			*notify = -1;
		genexmsg(bw, 0, NULL);
		abortit(bw);
		return -1;
	} else if (bw->b->count == 1 && bw->b->changed && !bw->b->scratch) {
		if (mkqw(bw->parent, sz(joe_gettext(_("Save changes to this file (y,n,^C)? "))), nask, NULL, object, notify)) {
			return 0;
		} else {
			return -1;
a872 3
		if (notify) {
			*notify = 1;
		}
a876 5
int uask(BW *bw)
{
	return nask(bw, 0, NULL, NULL);
}

d880 1
a880 1
static int dolose(BW *bw, int c, void *object, int *notify)
d885 3
a887 3

	if (notify) {
		*notify = 1;
d889 5
a893 2
	if (c != YES_CODE && !yncheck(yes_key, c)) {
		return -1;
a894 1

a899 1

d915 1
a915 1
					object = bw->object;
a929 17
int ulose(BW *bw)
{
	msgnw(bw->parent, NULL);
	if (bw->b->count==1 && bw->b->pid) {
		return ukillpid(bw);
	}
	if (bw->b->changed && !bw->b->scratch) {
		if (mkqw(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), dolose, NULL, NULL, NULL)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		return dolose(bw, YES_CODE, NULL, NULL);
	}
}

d954 1
a954 1
		return dorepl(bw, s, NULL, /* notify */ NULL);
d963 1
a963 1
static int doquerysave(BW *bw,int c,struct savereq *req,int *notify)
d966 1
d969 1
a969 1
			return dosave1(bw, vsncpy(NULL,0,sz(bw->b->name)), req, notify);
d975 1
a975 1
				return dosave1(bw, s, req, notify);
a986 2
			if (notify)
				*notify = 1;
a991 2
			if (notify)
				*notify = 1;
d999 1
a999 1
		return doquerysave(bw,0,req,notify);
d1003 2
a1004 4
		if (mkqw(bw->parent, sv(buf), doquerysave, NULL, req, notify)) {
			return 0;
			} else {
			/* Should be in abort function */
d1008 1
d1012 1
a1012 1
static int query_next(BW *bw, struct savereq *req,int flg,int *notify)
a1014 2
		if (notify)
			*notify = 1;
d1018 1
a1018 1
		return doquerysave(bw,NO_CODE,req,notify);
d1034 1
a1034 1
			return doquerysave(bw,0,mksavereq(query_next,NULL,first,0,0),NULL);
@


1.66
log
@more refactoring
@
text
@d578 1
a578 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d624 1
a624 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d740 1
a740 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d781 1
a781 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d818 1
a818 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d950 1
a950 1
					w->object = (void *) (bw = bwmk(w, new_b, 0));
d957 1
a957 1
					w->object = (void *) (bw = bwmk(w, bfind(USTR ""), 0));
@


1.65
log
@semiautomatic variables
@
text
@a96 13
static int dosys(BW *bw, unsigned char *s, void *object, int *notify)
{
	int rtn;

	nescape(bw->parent->t->t);
	rtn=ttshell(s);
	nreturn(bw->parent->t->t);

	if (notify)
		*notify = 1;
	return rtn;
}

d99 10
a108 3
	if (wmkpw(bw->parent, joe_gettext(_("System (^C to abort): ")), NULL, dosys, NULL, NULL, NULL, NULL, NULL, bw->b->o.charmap, 1))
		return 0;
	else
d110 1
a483 2
				/* char *msg = "File exists. Overwrite (y,n,^C)? ";
				   req->message = msg; */
d504 4
a507 12
	BW *pbw;
	
	pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, USTR "Names", NULL, cmplt,
	            mksavereq(NULL,NULL,NULL,0, 0), NULL, locale_map, bw->b->name ? 1 : 7);

	if (pbw && bw->b->name) {
		binss(pbw->cursor, bw->b->name);
		pset(pbw->cursor, pbw->b->eof);
		pbw->cursor->xcol = piscol(pbw->cursor);
	}
	if (pbw) {
		return 0;
d526 4
a529 2
		if (wmkpw(bw->parent, joe_gettext(_("Name of file to write (^C to abort): ")), &filehist, dosave1, USTR "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map, 3)) {
			return 0;
d541 1
a541 1
int doedit1(BW *bw,int c,unsigned char *s,int *notify)
d642 1
a642 1
		if (mkqw(bw->parent, sz(joe_gettext(_("Load original file from disk (y,n,^C)? "))), doedit1, NULL, s, notify))
a649 18
int doedit(BW *bw, unsigned char *s, void *obj, int *notify)
{
	B *b;

	b = bcheck_loaded(s);

	if (b) {
		if (b->changed && !b->scratch)
			/* Modified buffer exists, so ask */
			return doedit1(bw, 0, s, notify);
		else
			/* Buffer not modified- just use it as is */
			return doedit1(bw, NO_CODE, s, notify);
	} else
		/* File not in buffer: don't ask */
		return doedit1(bw, YES_CODE, s, notify);
}

d660 2
d664 17
a680 2
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to edit (^C to abort): ")), &filehist, doedit, USTR "Names", NULL, cmplt, NULL, NULL, locale_map,7)) {
		return 0;
d686 3
a688 1
int doswitch(BW *bw, unsigned char *s, void *obj, int *notify)
d690 1
a690 2
	/* Try buffer, then file */
	return doedit1(bw, NO_CODE, s, notify);
d695 4
a698 2
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &filehist, doswitch, USTR "Names", NULL, cmplt, NULL, NULL, locale_map,1)) {
		return 0;
d704 1
a704 1
int doscratch(BW *bw, unsigned char *s, void *obj, int *notify)
d706 8
a713 5
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;
d715 20
a734 13
	if (notify) {
		*notify = 1;
	}

	b = bfind_scratch(s);
	er = berror;
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
		if (orphan) {
			orphit(bw);
		} else {
			if (uduptw(bw)) {
				brm(b);
				return -1;
a735 1
			bw = (BW *) maint->curwin->object;
d737 11
a747 5
	}
	if (er) {
		msgnwt(bw->parent, joe_gettext(msgs[-er]));
		if (er != -1) {
			ret = -1;
d749 1
a749 20
	}
	object = bw->object;
	w = bw->parent;
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, b, 0));
	wredraw(bw->parent);
	bw->object = object;
	if (er == -1 && bw->o.mnew) {
		exmacro(bw->o.mnew,1);
	}
	if (er == 0 && bw->o.mold) {
		exmacro(bw->o.mold,1);
	}
	return ret;
}

int uscratch(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Name of scratch buffer to edit (^C to abort): ")), &filehist, doscratch, USTR "Names", NULL, cmplt, NULL, NULL, locale_map, 1)) {
		return 0;
a845 9
int uinsf(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to insert (^C to abort): ")), &filehist, doinsf, USTR "Names", NULL, cmplt, NULL, NULL, locale_map, 3)) {
		return 0;
	} else {
		return -1;
	}
}

d873 4
a876 11
		BW *pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist,
		                dosave1, USTR "Names", NULL, cmplt,
		                mksavereq(exdone,NULL,NULL,1,0), NULL, locale_map, 1);

		if (pbw && bw->b->name) {
			binss(pbw->cursor, bw->b->name);
			pset(pbw->cursor, pbw->b->eof);
			pbw->cursor->xcol = piscol(pbw->cursor);
		}
		if (pbw) {
			return 0;
d989 1
a989 37
#ifdef junk

static int dobuf(MENU *m, int x, unsigned char **s)
{
	unsigned char *name;
	BW *bw = m->parent->win->object;
	int *notify = m->parent->notify;

	m->parent->notify = 0;
	name = vsdup(s[x]);
	wabort(m->parent);
	return dorepl(bw, name, NULL, notify);
}

static int abrtb(MENU *m, int x, unsigned char **s)
{
	varm(s);
	return -1;
}

int ubufed(BW *bw)
{
	unsigned char **s = getbufs();
	vaperm(s);

	vasort(av(s));
	if (mkmenu(bw->parent, bw->parent, s, dobuf, abrtb, NULL, 0, s, NULL))
		return 0;
	else {
		varm(s);
		return -1;
	}
}

#endif

unsigned char **sbufs = NULL;	/* Array of command names */
a1003 11
static int dobufed(BW *bw, unsigned char *s, void *object, int *notify)
{
/* not understanding this...
	int *notify = bw->parent->notify;

	bw->parent->notify = 0;
	wabort(bw->parent);
*/
	return dorepl(bw, s, NULL, notify);
}

d1008 4
a1011 2
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &bufhist, dobufed, USTR "bufed", NULL, bufedcmplt, NULL, NULL, locale_map, 0)) {
		return 0;
d1027 2
a1028 2
			BW *pbw;
			pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, USTR "Names", NULL, cmplt, req, notify, locale_map, 7);
d1030 2
a1031 2
			if (pbw) {
				return 0;
@


1.64
log
@UC -> USTR
@
text
@d35 1
d45 1
a45 1
			joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("File %s saved")), name);
d47 1
a47 1
			joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("File %s not saved")), name);
d50 1
a50 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("File %s not saved")), s);
d52 1
a52 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("File %s saved")), s);
d54 1
a54 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("File %s not changed so no update needed")), s);
d57 1
a57 1
		vsrm(exmsg);
d59 3
a61 2
	exmsg = vsncpy(NULL,0,sz(msgbuf));
	msgnw(bw->parent, msgbuf);
d67 1
d70 1
a70 1
			joe_snprintf_0(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Some files have not been saved.")));
d72 1
a72 1
			joe_snprintf_0(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("All modified files have been saved.")));
d74 1
a74 1
		joe_snprintf_0(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("No modified files, so no updates needed.")));
d76 1
a76 1
	msgnw(bw->parent, msgbuf);
d78 4
a81 1
	exmsg = vsncpy(NULL,0,sz(msgbuf));
a106 1
	vsrm(s);
d124 1
d146 2
a147 2
	while ((amnt = read(f, stdbuf, stdsiz)) > 0) {
		if (amnt != joe_write(g, stdbuf, amnt)) {
d183 1
a183 2
		unsigned char tmp[1024];
		unsigned char name[1024];
d191 1
a191 2
			joe_snprintf_2(name, sizeof(name), "%s/%s", t, namepart(tmp, bw->b->name));
			vsrm(t);
d193 1
a193 1
			joe_snprintf_1(name, sizeof(name), "%s", bw->b->name);
d196 1
a196 1
		for (x = zlen(name); name[--x] != '.';) {
d198 1
a198 1
				x = zlen(name);
d203 2
a204 1
		zcpy(name + x, USTR ".bak");
d217 1
a217 2
			joe_snprintf_3(name, sizeof(name), "%s/%s%s", t, namepart(tmp, bw->b->name), simple_backup_suffix);
			vsrm(t);
d219 1
a219 1
			joe_snprintf_2(name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
d267 1
a267 1
	vsrm(req->name);
d413 1
a413 2
					joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Block written to file %s")), req->name);
					msgnw(bw->parent, msgbuf);
d417 1
a417 1
				vsrm(req->name);
d428 1
a428 2
					joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Block written to file %s")), req->name);
					msgnw(bw->parent, msgbuf);
d432 1
a432 1
					vsrm(req->name);
d436 1
a436 1
			vsrm(req->name);
d478 1
a478 1
		vsrm(req->name);
d480 1
a593 1
		vsrm(s);
a639 1
		vsrm(s);
a657 1
			vsrm(s);
a751 1
	vsrm(s);
a798 1
	vsrm(s);
d1043 1
d1064 1
a1064 1
	if (!sbufs)
d1066 2
d1137 3
a1139 3
		unsigned char buf[1024];
		joe_snprintf_1(buf,1024,joe_gettext(_("File %s has been modified.  Save it (y,n,^C)? ")),bw->b->name ? bw->b->name : USTR "(Unnamed)" );
		if (mkqw(bw->parent, sz(buf), doquerysave, NULL, req, notify)) {
@


1.63
log
@change US to UC
@
text
@d199 1
a199 1
		zcpy(name + x, UC ".bak");
d207 1
a207 1
			simple_backup_suffix = UC "~";
d510 1
a510 1
	pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, UC "Names", NULL, cmplt,
d538 1
a538 1
		if (wmkpw(bw->parent, joe_gettext(_("Name of file to write (^C to abort): ")), &filehist, dosave1, UC "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map, 3)) {
d693 1
a693 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to edit (^C to abort): ")), &filehist, doedit, UC "Names", NULL, cmplt, NULL, NULL, locale_map,7)) {
d708 1
a708 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &filehist, doswitch, UC "Names", NULL, cmplt, NULL, NULL, locale_map,1)) {
d764 1
a764 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of scratch buffer to edit (^C to abort): ")), &filehist, doscratch, UC "Names", NULL, cmplt, NULL, NULL, locale_map, 1)) {
d865 1
a865 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to insert (^C to abort): ")), &filehist, doinsf, UC "Names", NULL, cmplt, NULL, NULL, locale_map, 3)) {
d900 1
a900 1
		                dosave1, UC "Names", NULL, cmplt,
d990 1
a990 1
					w->object = (void *) (bw = bwmk(w, bfind(UC ""), 0));
d1085 1
a1085 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &bufhist, dobufed, UC "bufed", NULL, bufedcmplt, NULL, NULL, locale_map, 0)) {
d1103 1
a1103 1
			pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, UC "Names", NULL, cmplt, req, notify, locale_map, 7);
d1137 1
a1137 1
		joe_snprintf_1(buf,1024,joe_gettext(_("File %s has been modified.  Save it (y,n,^C)? ")),bw->b->name ? bw->b->name : UC "(Unnamed)" );
@


1.62
log
@querysave bug
@
text
@d199 1
a199 1
		zcpy(name + x, US ".bak");
d207 1
a207 1
			simple_backup_suffix = US "~";
d510 1
a510 1
	pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, US "Names", NULL, cmplt,
d538 1
a538 1
		if (wmkpw(bw->parent, joe_gettext(_("Name of file to write (^C to abort): ")), &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map, 3)) {
d693 1
a693 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to edit (^C to abort): ")), &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, locale_map,7)) {
d708 1
a708 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &filehist, doswitch, US "Names", NULL, cmplt, NULL, NULL, locale_map,1)) {
d764 1
a764 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of scratch buffer to edit (^C to abort): ")), &filehist, doscratch, US "Names", NULL, cmplt, NULL, NULL, locale_map, 1)) {
d865 1
a865 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of file to insert (^C to abort): ")), &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, locale_map, 3)) {
d900 1
a900 1
		                dosave1, US "Names", NULL, cmplt,
d990 1
a990 1
					w->object = (void *) (bw = bwmk(w, bfind(US ""), 0));
d1085 1
a1085 1
	if (wmkpw(bw->parent, joe_gettext(_("Name of buffer to edit (^C to abort): ")), &bufhist, dobufed, US "bufed", NULL, bufedcmplt, NULL, NULL, locale_map, 0)) {
d1103 1
a1103 1
			pbw = wmkpw(bw->parent, joe_gettext(_("Name of file to save (^C to abort): ")), &filehist, dosave1, US "Names", NULL, cmplt, req, notify, locale_map, 7);
d1137 1
a1137 1
		joe_snprintf_1(buf,1024,joe_gettext(_("File %s has been modified.  Save it (y,n,^C)? ")),bw->b->name ? bw->b->name : US "(Unnamed)" );
@


1.61
log
@more key set comments
@
text
@d1166 1
@


1.60
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d273 2
a274 2
unsigned char *yes_key = (unsigned char *) _("yY");
unsigned char *no_key = (unsigned char *) _("nN");
@


1.59
log
@hash table
@
text
@d273 2
a274 2
unsigned char *yes_string = (unsigned char *) _("yY");
unsigned char *no_string = (unsigned char *) _("nN");
d276 1
a276 1
int yncheck(unsigned char *set, int c)
d278 1
d308 1
a308 1
	if (c == NO_CODE || yncheck(no_string, c)) {
d320 1
a320 1
	if (c != YES_CODE && !yncheck(yes_string, c)) {
d451 1
a451 1
	if (c == YES_CODE || yncheck(yes_string, c)) {
d453 1
a453 1
	} else if (c == NO_CODE || yncheck(no_string, c)) {
d559 1
a559 1
	if (c == YES_CODE || yncheck(yes_string, c)) {
d606 1
a606 1
	} else if (c == NO_CODE || yncheck(no_string, c)) {
d921 1
a921 1
	if (c == YES_CODE || yncheck(yes_string, c)) {
d926 1
a926 1
	} else if (c == NO_CODE || yncheck(no_string, c)) {
d963 1
a963 1
	if (c != YES_CODE && !yncheck(yes_string, c)) {
d1098 1
a1098 1
	if (c == YES_CODE || yncheck(yes_string, c)) {
d1112 1
a1112 1
	} else if (c == NO_CODE || yncheck(no_string, c)) {
@


1.58
log
@get rid of <> stupidity
@
text
@d273 2
a274 2
unsigned char *yes_string = _("yY");
unsigned char *no_string = _("nN");
@


1.57
log
@i18n yes/no
@
text
@d273 2
a274 2
unsigned char *yes_string = _("yY<>yY");
unsigned char *no_string = _("nN<>nN");
d280 3
a282 8
		while (set[0] && !(set[0] == '<' && set[1] == '>'))
			++set;
		if (set[0] == '<') {
			set += 2;
			while (*set) {
				if (c == utf8_decode_fwrd(&set, NULL))
					return 1;
			}
d287 1
a287 1
		while (set[0] && !(set[0] == '<' && set[1] == '>')) {
@


1.56
log
@transpose menus
@
text
@d267 42
d312 1
a312 1
	if (c == 'n' || c == 'N') {
d324 1
a324 1
	if (c != 'y' && c != 'Y') {
d448 1
a448 1
			return saver(bw, 'y', req, notify);
d455 1
a455 1
	if (c == 'y' || c == 'Y') {
d457 1
a457 1
	} else if (c == 'n' || c == 'N') {
d563 1
a563 1
	if (c=='y' || c=='Y') {
d610 1
a610 1
	} else if(c=='n' || c=='N') {
d679 1
a679 1
			return doedit1(bw, 'n', s, notify);
d682 1
a682 1
		return doedit1(bw, 'y', s, notify);
d707 1
a707 1
	return doedit1(bw, 'n', s, notify);
d925 1
a925 1
	if (c == 'y' || c == 'Y') {
d930 1
a930 1
	} else if (c == 'n' || c == 'N') {
d967 1
a967 1
	if (c != 'y' && c != 'Y') {
d1020 1
a1020 1
		return dolose(bw, 'y', NULL, NULL);
d1102 1
a1102 1
	if (c == 'y' || c == 'Y') {
d1116 1
a1116 1
	} else if (c == 'n' || c == 'N') {
d1160 1
a1160 1
		return doquerysave(bw,'N',req,notify);
@


1.55
log
@-help_is_utf8 option
@
text
@d1146 3
@


1.54
log
@fix querysave bug: it was not saving all files.
@
text
@d515 1
d560 7
d607 6
d738 1
d769 6
@


1.53
log
@gettext()
@
text
@d1103 5
a1107 1
	B *first = bw->b;
@


1.52
log
@A option for search
Restore cursor to old position
@
text
@d39 1
a39 1
		s = US "(Unnamed)";
d44 1
a44 1
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", name);
d46 1
a46 1
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", name);
d49 1
a49 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", s);
d51 1
a51 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", s);
d53 1
a53 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not changed so no update needed", s);
a54 2
	msgnw(bw->parent, msgbuf);

d58 2
a59 13
	if (bw->b->changed && bw->b->count == 1) {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" not saved."));
	} else if (saved) {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" saved."));
	} else {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" not changed so no update needed."));
	}
d67 1
a67 1
			joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "Some files have not been saved.");
d69 1
a69 1
			joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "All modified files have been saved.");
d71 1
a71 1
		joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "No modified files, so no updates needed.");
d107 1
a107 1
	if (wmkpw(bw->parent, US "System (^C to abort): ", NULL, dosys, NULL, NULL, NULL, NULL, NULL, bw->b->o.charmap, 1))
d212 1
a212 1
			joe_snprintf_3((char *)name, sizeof(name), "%s/%s%s", t, namepart(tmp, bw->b->name), simple_backup_suffix);
d215 1
a215 1
			joe_snprintf_2((char *)name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
d271 1
a271 1
		msgnw(bw->parent, US "Couldn't make backup file... file not saved");
d283 1
a283 1
		if (mkqw(bw->parent, sc("Could not make backup file.  Save anyway (y,n,^C)? "), saver, NULL, req, notify)) {
d300 1
a300 1
		msgnw(bw->parent, msgs[-fl]);
d366 1
a366 1
					msgnw(bw->parent, msgs[-fl]);
d371 1
a371 1
					joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Block written to file %s", req->name);
d383 1
a383 1
					msgnw(bw->parent, msgs[-fl]);
d387 1
a387 1
					joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Block written to file %s", req->name);
d397 1
a397 1
			msgnw(bw->parent, US "No block");
d450 1
a450 1
				req->message = US "File exists. Overwrite (y,n,^C)? ";
d457 1
a457 1
				req->message = US "File on disk is newer. Overwrite (y,n,^C)? ";
d472 1
a472 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt,
d500 1
a500 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map, 3)) {
d541 1
a541 1
			msgnwt(bw->parent, msgs[-er]);
d581 1
a581 1
			msgnwt(bw->parent, msgs[-er]);
d602 1
a602 1
		if (mkqw(bw->parent, sc("Load original file from disk (y,n,^C)? "), doedit1, NULL, s, notify))
d632 1
a632 1
		msgnw(bw->parent, US "Can't replace modified file");
d641 1
a641 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, locale_map,7)) {
d656 1
a656 1
	if (wmkpw(bw->parent, US "Name of buffer to edit (^C to abort): ", &filehist, doswitch, US "Names", NULL, cmplt, NULL, NULL, locale_map,1)) {
d689 1
a689 1
		msgnwt(bw->parent, msgs[-er]);
d712 1
a712 1
	if (wmkpw(bw->parent, US "Name of scratch buffer to edit (^C to abort): ", &filehist, doscratch, US "Names", NULL, cmplt, NULL, NULL, locale_map, 1)) {
d735 1
a735 1
		msgnwt(bw->parent, msgs[-berror]);
d806 1
a806 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, locale_map, 3)) {
d840 1
a840 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist,
d874 1
a874 1
		if (mkqw(bw->parent, sc("Save changes to this file (y,n,^C)? "), nask, NULL, object, notify)) {
d951 1
a951 1
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), dolose, NULL, NULL, NULL)) {
d1026 1
a1026 1
	if (wmkpw(bw->parent, US "Name of buffer to edit (^C to abort): ", &bufhist, dobufed, US "bufed", NULL, bufedcmplt, NULL, NULL, locale_map, 0)) {
d1044 1
a1044 1
			pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, req, notify, locale_map, 7);
d1078 1
a1078 1
		joe_snprintf_1((char *)buf,1024,"File %s has been modified.  Save it (y,n,^C)? ",bw->b->name ? bw->b->name : US "(Unnamed)" );
@


1.51
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d770 1
a770 1
/* Switch to next buffer in window */
d772 1
a772 1
int unbuf(BW *bw)
a775 5
	B *b;
	b = bnext();
	if (b == bw->b) {
		b = bnext();
	}
d795 12
a808 2
	void *object = bw->object;
	W *w = bw->parent;
d814 1
a814 17
	if (b == bw->b) {
		return 0;
		/* return -1; */
	}
	if (!b->orphan) {
		++b->count;
	} else {
		b->orphan = 0;
	}
	if (bw->b->count == 1) {
		orphit(bw);
	}
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, b, 0));
	wredraw(bw->parent);
	bw->object = object;
	return 0;
@


1.50
log
@new cvs server
@
text
@a7 1
#include "config.h"
a9 15
#include <stdio.h>
#include <unistd.h>
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

d24 1
a24 24
#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "menu.h"
#include "path.h"
#include "pw.h"
#include "qw.h"
#include "scrn.h"
#include "tab.h"
#include "tty.h"
#include "tw.h"
#include "ublock.h"
#include "uerror.h"
#include "ufile.h"
#include "ushell.h"
#include "utils.h"
#include "va.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"

extern int orphan;
a501 2
	BW *pbw;

d541 1
a541 1
		er = error;
d581 1
a581 1
		er = error;
a625 4
	int ret = 0;
	int er;
	void *object;
	W *w;
a662 6
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;

d689 1
a689 1
	er = error;
d746 4
a749 4
	er = error;
	if (error) {
		msgnwt(bw->parent, msgs[-error]);
		if (error != -1) {
a1036 1
	BW *target_bw = bw->parent->win->object;
@


1.49
log
@File selection menu is now above prompt instead of below it.
@
text
@d676 1
a676 1
		if (b->changed)
@


1.48
log
@
Allow entry of replacement blank replacement strings when search
prompting is enabled (basically eliminate automatic replace-string
prompting).

"bufed" now works like other file name commands (it prompts for a
buffer name, and allows completion).

H-scroll jumps left ~ 10 cols (this needs more work: it should be an
option).
@
text
@d1063 1
a1063 1
	if (mkmenu(bw->parent, s, dobuf, abrtb, NULL, 0, s, NULL))
@


1.47
log
@fix gcc-4.0.0 warnings
@
text
@d1038 2
d1071 39
@


1.46
log
@Fix ^X ^S bug
@
text
@d244 1
a244 1
		for (x = strlen(name); name[--x] != '.';) {
d246 1
a246 1
				x = strlen(name);
d251 1
a251 1
		strcpy(name + x, ".bak");
d368 2
a369 2
			bw->b->name = joesep(joe_strdup(req->name));
		if (bw->b->name && !strcmp(bw->b->name, req->name)) {
d495 1
a495 1
		if (!bw->b->name || strcmp(s, bw->b->name)) {
@


1.45
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d544 1
a544 1
		return dosave1(bw,vsdup(bw->b->name),mksavereq(NULL,NULL,NULL,0,0),NULL);
@


1.44
log
@Current directory stuff
@
text
@d297 2
a298 2
	int block_save; // Flag, if we want to save a block#
	char *message; // String for messages to be shown to the user
d500 3
a502 3
				//char *msg = "File exists. Overwrite (y,n,^C)? ";
				//req->message = msg;
				req->message = "File exists. Overwrite (y,n,^C)? ";
d509 1
a509 1
				req->message = "File on disk is newer. Overwrite (y,n,^C)? ";
@


1.43
log
@Allow ~ expansion in -backpath
@
text
@d524 2
a525 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL,0, 0), NULL, locale_map, 1);
d539 10
d554 1
a554 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map, 1)) {
d699 1
a699 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, locale_map,1)) {
d881 1
a881 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, locale_map, 1)) {
d915 3
a917 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL,1,0), NULL, locale_map, 1);
d1079 1
a1079 1
			pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, req, notify, locale_map, 1);
@


1.42
log
@Fix ~ expansion insanity
@
text
@d236 4
a239 1
			joe_snprintf_2(name, sizeof(name), "%s/%s", backpath, namepart(tmp, bw->b->name));
d262 4
a265 1
			joe_snprintf_3((char *)name, sizeof(name), "%s/%s%s", backpath, namepart(tmp, bw->b->name), simple_backup_suffix);
@


1.41
log
@File changed check.
@
text
@d159 1
a159 1
	if (wmkpw(bw->parent, US "System (^C to abort): ", NULL, dosys, NULL, NULL, NULL, NULL, NULL, bw->b->o.charmap))
d518 1
a518 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL,0, 0), NULL, locale_map);
d537 1
a537 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL, NULL, NULL, 0, 1), NULL, locale_map)) {
d682 1
a682 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d703 1
a703 1
	if (wmkpw(bw->parent, US "Name of buffer to edit (^C to abort): ", &filehist, doswitch, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d759 1
a759 1
	if (wmkpw(bw->parent, US "Name of scratch buffer to edit (^C to abort): ", &filehist, doscratch, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d864 1
a864 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d898 1
a898 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL,1,0), NULL, locale_map);
d1060 1
a1060 1
			pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, req, notify, locale_map);
@


1.40
log
@Perforce macro and support for it.
@
text
@d502 3
a504 8
			struct stat sbuf;
			if (!stat((char *)s,&sbuf)) {
				if (sbuf.st_mtime>bw->b->mod_time) {
					//char *msg = "File on disk is newer. Overwrite (y,n,^C)? ";
					//req->message = msg;
					req->message = "File on disk is newer. Overwrite (y,n,^C)? ";
					return dosave2(bw, 0, req, notify);
				}
@


1.39
log
@file locking.
@
text
@d141 24
d339 1
a339 1
		exemac(bw->o.msnew);
d343 1
a343 1
		exemac(bw->o.msold);
d596 1
a596 1
			exemac(bw->o.mnew);
d599 1
a599 1
			exemac(bw->o.mold);
d636 1
a636 1
			exemac(bw->o.mnew);
d639 1
a639 1
			exemac(bw->o.mold);
d754 1
a754 1
		exemac(bw->o.mnew);
d757 1
a757 1
		exemac(bw->o.mold);
d801 1
a801 1
		exemac(bw->o.mnew);
d804 1
a804 1
		exemac(bw->o.mold);
d996 1
a996 1
						exemac(bw->o.mnew);
@


1.38
log
@Fix ^X a and ^X i in jmacs
@
text
@d340 1
d862 1
@


1.37
log
@^KW prints a message
Perl highlighter fixes
@
text
@d337 1
a337 1
		if (!bw->b->name)
d339 1
a339 1
		if (!strcmp(bw->b->name, req->name)) {
d423 1
a423 1
	{	
@


1.36
log
@Apply patches, improve verilog syntax.
@
text
@d391 4
d407 4
@


1.35
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@a129 14
/* Write highlighted block to a file */

int ublksave(BW *bw)
{
	if (markb && markk && markb->b == markk->b && (markk->byte - markb->byte) > 0 && (!square || piscol(markk) > piscol(markb))) {
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dowrite, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		return usave(bw);
	}
}
d267 2
d271 1
a271 1
struct savereq *mksavereq(int (*callback)(), unsigned char *name, B *first,int rename)
d279 1
d374 47
a420 4
	if (backup(bw)) {
		return saver(bw, 0, req, notify);
	} else {
		return saver(bw, 'y', req, notify);
d435 1
a435 1
	} else if (mkqw(bw->parent, sc("File exists.  Overwrite (y,n,^C)? "), dosave2, NULL, req, notify)) {
a443 19
static int dosave2a(BW *bw, int c, struct savereq *req, int *notify)
{
	if (c == 'y' || c == 'Y') {
		return dosave(bw, req, notify);
	} else if (c == 'n' || c == 'N') {
		if (notify) {
			*notify = 1;
		}
		genexmsg(bw, 0, req->name);
		rmsavereq(req);
		return -1;
	} else if (mkqw(bw->parent, sc("File on disk is newer.  Overwrite (y,n,^C)? "), dosave2a, NULL, req, notify)) {
		return 0;
	} else {
		rmsavereq(req);
		return -1;
	}
}

d461 3
d472 4
a475 1
					return dosave2a(bw, 0, req, notify);
d490 1
a490 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL,0), NULL, locale_map);
d504 16
d867 1
a867 1
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), mksavereq(exdone,NULL,NULL,0), NULL);
d869 1
a869 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL,1), NULL, locale_map);
d1095 1
a1095 1
			return doquerysave(bw,0,mksavereq(query_next,NULL,first,0),NULL);
@


1.34
log
@Fix -pedantic warnings.
@
text
@d65 1
a65 1
static B *filehist = NULL;	/* History of file names */
@


1.33
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d349 1
a349 1
			bw->b->name = joesep((unsigned char *)strdup((char *)req->name));
d1030 1
a1030 1
		joe_snprintf_1(buf,1024,"File %s has been modified.  Save it (y,n,^C)? ",bw->b->name ? bw->b->name : US "(Unnamed)" );
@


1.32
log
@Many jpicorc.in improvements.
@
text
@d83 1
a83 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", name);
d85 1
a85 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", name);
d88 1
a88 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", s);
d90 1
a90 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", s);
d92 1
a92 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not changed so no update needed", s);
d119 1
a119 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Some files have not been saved.");
d121 1
a121 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "All modified files have been saved.");
d123 1
a123 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "No modified files, so no updates needed.");
d226 1
a226 1
			snprintf(name, sizeof(name), "%s/%s", backpath, namepart(tmp, bw->b->name));
d228 1
a228 1
			snprintf(name, sizeof(name), "%s", bw->b->name);
d249 1
a249 1
			snprintf((char *)name, sizeof(name), "%s/%s%s", backpath, namepart(tmp, bw->b->name), simple_backup_suffix);
d251 1
a251 1
			snprintf((char *)name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
d1030 1
a1030 1
		snprintf(buf,1024,"File %s has been modified.  Save it (y,n,^C)? ",bw->b->name ? bw->b->name : US "(Unnamed)" );
@


1.31
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d890 1
a890 1
	B *b;
d909 20
a928 8
				BW *bw = (BW *)w->object;
				object = bw->object;
				bwrm(bw);
				w->object = (void *) (bw = bwmk(w, bfind(US ""), 0));
				wredraw(w);
				bw->object = object;
				if (bw->o.mnew)
					exemac(bw->o.mnew);
@


1.30
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d96 15
a110 14
	if (!exmsg) {
		if (bw->b->changed && bw->b->count == 1) {
			exmsg = vsncpy(NULL, 0, sc("File "));
			exmsg = vsncpy(sv(exmsg), sz(s));
			exmsg = vsncpy(sv(exmsg), sc(" not saved."));
		} else if (saved) {
			exmsg = vsncpy(NULL, 0, sc("File "));
			exmsg = vsncpy(sv(exmsg), sz(s));
			exmsg = vsncpy(sv(exmsg), sc(" saved."));
		} else {
			exmsg = vsncpy(NULL, 0, sc("File "));
			exmsg = vsncpy(sv(exmsg), sz(s));
			exmsg = vsncpy(sv(exmsg), sc(" not changed so no update needed."));
		}
d114 16
d279 2
d283 1
a283 1
struct savereq *mksavereq(int (*callback)(), unsigned char *name, B *first)
d289 2
d344 4
d442 1
d444 1
d452 1
d471 1
a471 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL), NULL, locale_map);
a592 5
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}

a633 5
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}

a654 5
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}

a715 4
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}
a747 4
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}
a775 4
	if (bw->pid) {
		msgnw(bw->parent, US "Process running in this window");
		return -1;
	}
a815 3
		if (bw->b->name)
			joe_free(bw->b->name);
		bw->b->name = 0;
d820 1
a820 1
		return uabort(bw, -1);
a823 20
static int exdone1(BW *bw, struct savereq *req,int flg,int *notify)
{
	if (notify)
		*notify = 1;
	rmsavereq(req);
	if (flg) {
		return -1;
	} else {
		bw->b->changed = 0;
		saverr(bw->b->name);
		return uabort(bw, -1);
	}
}

static int doex(BW *bw, unsigned char *s, struct savereq *req,int *notify)
{
	bw->b->name = joesep((unsigned char *)strdup((char *)s));
	return dosave1(bw, s, req, notify);
}

d827 1
d831 2
a832 1
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), mksavereq(exdone1,NULL,NULL), NULL);
d834 1
a834 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, doex, US "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL), NULL, locale_map);
d849 2
a850 1
/* If buffer is modified, prompt for saving */
d855 4
a858 11
		if (bw->b->name) {
			return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), object, notify);
		} else {
			BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, object, notify, locale_map);

			if (pbw) {
				return 0;
			} else {
				return -1;
			}
		}
d860 2
d863 2
a864 4
		if (notify) {
			*notify = 1;
		}
		return 0;
d884 2
a885 41
/* FIXME: unused ???? */
#if 0
/* Ask to save file if it is modified.  If user answers yes, run save */

static int nask2(BW *bw, int c, void *object, int *notify)
{
	if (c == 'y' || c == 'Y') {
		BW *pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, dosave1, "Names", NULL, cmplt, object, notify, locale_map);

		if (pbw) {
			return 0;
		} else {
			return -1;
		}
	} else if (c == 'n' || c == 'N') {
		genexmsg(bw, 0, NULL);
		if (notify) {
			*notify = 1;
		}
		return 0;
	} else if (bw->b->count == 1 && bw->b->changed) {
		if (mkqw(bw->parent, sc("Save changes to this file (y,n,^C)? "), nask, NULL, object, notify)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		if (notify) {
			*notify = 1;
		}
		return 0;
	}
}

static int uask2(BW *bw)
{
	return nask2(bw, 0, NULL, NULL);
}
#endif

/* If buffer is modified, ask if it's ok to lose changes */
d890 2
d899 4
d904 16
a919 11
	if (bw->b->count == 1) {
		bw->b->changed = 0;
	}
	object = bw->object;
	w = bw->parent;
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, bfind(US ""), 0));
	wredraw(bw->parent);
	bw->object = object;
	if (bw->o.mnew) {
		exemac(bw->o.mnew);
d927 1
a927 1
	if (bw->pid) {
d930 1
a930 1
	if (bw->b->count == 1 && bw->b->changed && !bw->b->scratch) {
d995 2
d1009 1
a1015 2
	} else if (mkqw(bw->parent, sc("Save this file (y,n,^C)? "), doquerysave, NULL, req, notify)) {
		return 0;
d1017 9
a1025 3
		/* Should be in abort function */
		rmsavereq(req);
		return -1;
d1048 1
a1048 1
			return doquerysave(bw,0,mksavereq(query_next,NULL,first),NULL);
d1054 2
@


1.29
log
@^K E prompts to load original file from disk.
@
text
@d256 2
d261 1
d264 15
a280 1
	int (*callback) ();
a281 2

	callback = req->callback;
a282 5
		vsrm(req->name);
		joe_free(req);
		if (notify) {
			*notify = 1;
		}
d284 2
a285 2
		if (callback) {
			return callback(bw, -1);
d287 4
d298 1
a303 3
	if (notify) {
		*notify = 1;
	}
d313 2
a314 4
		vsrm(req->name);
		joe_free(req);
		if (callback) {
			return callback(bw, -1);
d316 4
d349 2
a350 4
		vsrm(req->name);
		joe_free(req);
		if (callback) {
			return callback(bw, 0);
d352 1
d358 1
a358 1
static int dosave(BW *bw, unsigned char *s, int (*callback) (), int *notify)
a359 4
	struct savereq *req = (struct savereq *) joe_malloc(sizeof(struct savereq));

	req->name = s;
	req->callback = callback;
a368 3
	unsigned char *s = req->name;
	int (*callback)()= req->callback;

d370 1
a370 2
		joe_free(req);
		return dosave(bw, s, callback, notify);
d375 2
a376 3
		genexmsg(bw, 0, s);
		joe_free(req);
		vsrm(s);
d382 1
a382 2
		joe_free(req);
		vsrm(s);
a388 3
	unsigned char *s = req->name;
	int (*callback)() = req->callback;

d390 1
a390 2
		joe_free(req);
		return dosave(bw, s, callback, notify);
d395 2
a396 3
		genexmsg(bw, 0, s);
		joe_free(req);
		vsrm(s);
d401 1
a401 2
		joe_free(req);
		vsrm(s);
d408 1
a408 1
static int dosave1(BW *bw, unsigned char *s, int (*callback) (), int *notify)
a409 1
	struct savereq *req = (struct savereq *) joe_malloc(sizeof(struct savereq));
d412 2
a414 1
	req->callback = callback;
d434 1
a434 2
	joe_free(req);
	return dosave(bw, s, callback, notify);
d437 2
d443 1
a443 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, NULL, NULL, locale_map);
d629 61
a738 1

d748 2
a749 1
		return -1;
a770 1

d780 2
a781 1
		return -1;
d809 1
a809 1
static int exdone(BW *bw, int flg)
d811 3
d826 1
a826 1
static int exdone1(BW *bw, int flg)
d828 3
d840 1
a840 1
static int doex(BW *bw, unsigned char *s, void *object,int *notify)
d843 1
a843 1
	return dosave1(bw, s, exdone, notify);
d848 1
a848 1
	if (!bw->b->changed) {
d852 1
a852 1
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), exdone1, NULL);
d854 1
a854 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, doex, US "Names", NULL, cmplt, NULL, NULL, locale_map);
d891 1
a891 1
	} else if (bw->b->count == 1 && bw->b->changed) {
d984 1
a984 1
	if (bw->b->count == 1 && bw->b->changed) {
d1027 82
@


1.28
log
@Update file date on save.
@
text
@d461 98
a566 3
	if (notify) {
		*notify = 1;
	}
d571 13
a583 33
	b = bfind(s);
	er = error;
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
		if (orphan) {
			orphit(bw);
		} else {
			if (uduptw(bw)) {
				brm(b);
				return -1;
			}
			bw = (BW *) maint->curwin->object;
		}
	}
	if (er) {
		msgnwt(bw->parent, msgs[-er]);
		if (er != -1) {
			ret = -1;
		}
	}
	object = bw->object;
	w = bw->parent;
	bwrm(bw);
	w->object = (void *) (bw = bwmk(w, b, 0));
	wredraw(bw->parent);
	bw->object = object;
	vsrm(s);
	if (er == -1 && bw->o.mnew) {
		exemac(bw->o.mnew);
	}
	if (er == 0 && bw->o.mold) {
		exemac(bw->o.mold);
	}
	return ret;
d605 26
@


1.27
log
@Warn if file changed on save.
@
text
@d299 1
a299 1
	if ((fl = bsave(bw->b->bof, req->name, bw->b->eof->byte, 0)) != 0) {
@


1.26
log
@Checks ~/.joe/syntax for syntax files.
Applied new Selinux patch.
@
text
@d299 2
a300 2
	if ((fl = bsave(bw->b->bof, req->name, bw->b->eof->byte)) != 0) {
		msgnw(bw->parent, msgs[fl + 5]);
d358 1
a358 1
static int dosave2(BW *bw, int c, unsigned char *s, int *notify)
d360 29
d390 2
a391 1
		return dosave(bw, s, NULL, notify);
d397 1
d400 1
a400 1
	} else if (mkqw(bw->parent, sc("File exists.  Overwrite (y,n,^C)? "), dosave2, NULL, s, notify)) {
d403 2
d409 3
a411 1
static int dosave1(BW *bw, unsigned char *s, void *object, int *notify)
d413 1
d416 18
a433 5
	if (s[0] != '!' && !(s[0] == '>' && s[1] == '>') && (!bw->b->name || strcmp(s, bw->b->name))) {
		f = open((char *)s, O_RDONLY);
		if (f != -1) {
			close(f);
			return dosave2(bw, 0, s, notify);
d436 3
a438 1
	return dosave(bw, s, object, notify);
d490 1
a490 1
		msgnwt(bw->parent, msgs[er + 5]);
d550 1
a550 1
		msgnwt(bw->parent, msgs[error + 5]);
d677 1
a677 1
	return dosave(bw, s, exdone, notify);
d686 1
a686 1
		return dosave(bw, vsncpy(NULL, 0, sz(bw->b->name)), exdone1, NULL);
@


1.25
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d190 1
@


1.24
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d59 2
d118 1
a118 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dowrite, US "Names", NULL, cmplt, NULL, NULL, -1)) {
d393 1
a393 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, NULL, NULL, -1);
d471 1
a471 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, -1)) {
d588 1
a588 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, -1)) {
d636 1
a636 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, doex, US "Names", NULL, cmplt, NULL, NULL, -1);
d659 1
a659 1
			BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, object, notify, -1);
d699 1
a699 1
		BW *pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, dosave1, "Names", NULL, cmplt, object, notify, -1);
@


1.23
log
@First attempt at character set conversion iconv().
Now the file's coding can be different from the terminal's
coding.

Also, applied secure linux patch from RedHat.
@
text
@d116 1
a116 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dowrite, US "Names", NULL, cmplt, NULL, NULL)) {
d391 1
a391 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, NULL, NULL);
d469 1
a469 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL)) {
d586 1
a586 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL)) {
d634 1
a634 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, doex, US "Names", NULL, cmplt, NULL, NULL);
d657 1
a657 1
			BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, object, notify);
d697 1
a697 1
		BW *pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, dosave1, "Names", NULL, cmplt, object, notify);
@


1.22
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d36 4
d185 3
@


1.21
log
@change 0 to NULL where we're talking about pointers
@
text
@d58 1
a58 1
char *backpath = NULL;		/* Place to store backup files */
d65 1
a65 1
void genexmsg(BW *bw, int saved, char *name)
d67 1
a67 1
	char *s;
d72 1
a72 1
		s = "(Unnamed)";
d77 1
a77 1
			snprintf(msgbuf, JOE_MSGBUFSIZE, "File %s saved", name);
d79 1
a79 1
			snprintf(msgbuf, JOE_MSGBUFSIZE, "File %s not saved", name);
d82 1
a82 1
		snprintf(msgbuf, JOE_MSGBUFSIZE, "File %s not saved", s);
d84 1
a84 1
		snprintf(msgbuf, JOE_MSGBUFSIZE, "File %s saved", s);
d86 1
a86 1
		snprintf(msgbuf, JOE_MSGBUFSIZE, "File %s not changed so no update needed", s);
d112 1
a112 1
		if (wmkpw(bw->parent, "Name of file to write (^C to abort): ", &filehist, dowrite, "Names", NULL, cmplt, NULL, NULL)) {
d134 1
a134 1
static int cp(char *from, char *to)
d147 1
a147 1
	f = open(from, O_RDONLY);
d154 1
a154 1
	g = creat(to, sbuf.st_mode & ~(S_ISUID | S_ISGID));
d192 2
a193 2
		char tmp[1024];
		char name[1024];
d216 1
a216 1
		char *simple_backup_suffix = getenv("SIMPLE_BACKUP_SUFFIX");
d219 1
a219 1
			simple_backup_suffix = "~";
d222 1
a222 1
			snprintf(name, sizeof(name), "%s/%s%s", backpath, namepart(tmp, bw->b->name), simple_backup_suffix);
d224 1
a224 1
			snprintf(name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
d228 1
a228 1
		unlink(name);
d248 1
a248 1
	char *name;
d263 1
a263 1
		msgnw(bw->parent, "Couldn't make backup file... file not saved");
d300 1
a300 1
			bw->b->name = joesep(strdup(req->name));
d335 1
a335 1
static int dosave(BW *bw, char *s, int (*callback) (), int *notify)
d348 1
a348 1
static int dosave2(BW *bw, int c, char *s, int *notify)
d366 1
a366 1
static int dosave1(BW *bw, char *s, void *object, int *notify)
d371 1
a371 1
		f = open(s, O_RDONLY);
d384 1
a384 1
	pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, dosave1, "Names", NULL, cmplt, NULL, NULL);
d400 1
a400 1
int doedit(BW *bw, char *s, void *obj, int *notify)
d412 1
a412 1
		msgnw(bw->parent, "Process running in this window");
d453 1
a453 1
		msgnw(bw->parent, "Can't replace modified file");
d462 1
a462 1
	if (wmkpw(bw->parent, "Name of file to edit (^C to abort): ", &filehist, doedit, "Names", NULL, cmplt, NULL, NULL)) {
d471 1
a471 1
static int dorepl(BW *bw, char *s, void *obj, int *notify)
d483 1
a483 1
		msgnw(bw->parent, "Process running in this window");
d520 1
a520 1
		msgnw(bw->parent, "Process running in this window");
d552 1
a552 1
		msgnw(bw->parent, "Process running in this window");
d579 1
a579 1
	if (wmkpw(bw->parent, "Name of file to insert (^C to abort): ", &filehist, doinsf, "Names", NULL, cmplt, NULL, NULL)) {
d598 1
a598 1
		return uabort(bw, MAXINT);
d609 1
a609 1
		return uabort(bw, MAXINT);
d613 1
a613 1
static int doex(BW *bw, char *s, void *object,int *notify)
d615 1
a615 1
	bw->b->name = joesep(strdup(s));
d622 1
a622 1
		uabort(bw, MAXINT);
d627 1
a627 1
		BW *pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, doex, "Names", NULL, cmplt, NULL, NULL);
d650 1
a650 1
			BW *pbw = wmkpw(bw->parent, "Name of file to save (^C to abort): ", &filehist, dosave1, "Names", NULL, cmplt, object, notify);
d742 1
a742 1
	w->object = (void *) (bw = bwmk(w, bfind(""), 0));
d770 1
a770 1
static int dobuf(MENU *m, int x, char **s)
d772 1
a772 1
	char *name;
d782 1
a782 1
static int abrtb(MENU *m, int x, char **s)
d790 1
a790 1
	char **s = getbufs();
@


1.20
log
@drop suid and sgid bits (if set) when creating backup files
@
text
@d58 2
a59 2
char *backpath = 0;		/* Place to store backup files */
static B *filehist = 0;		/* History of file names */
@


1.19
log
@kill some warnings when compiled with -Wall
@
text
@d154 1
a154 1
	g = creat(to, sbuf.st_mode);
@


1.18
log
@change write() to joe_write() to avoid partly copied files
@
text
@d778 1
a778 1
	uabort(m, MAXINT);
@


1.17
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d160 1
a160 1
		if (amnt != write(g, stdbuf, amnt)) {
@


1.16
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d205 1
a205 2
			if (name[x] == '\\' || (name[x] == ':' && x == 1)
			    || x == 0) {
d283 2
a284 1
		exemac(bw->o.msnew), bw->b->er = -3;
@


1.15
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d52 1
d260 1
a260 1
		free(req);
d292 1
a292 1
		free(req);
d326 1
a326 1
		free(req);
d337 1
a337 1
	struct savereq *req = (struct savereq *) malloc(sizeof(struct savereq));
d592 1
a592 1
			free(bw->b->name);
@


1.14
log
@include only headers which are needed
@
text
@d64 1
a64 1
void genexmsg(BW * bw, int saved, char *name)
d108 1
a108 1
int ublksave(BW * bw)
d123 1
a123 1
int ushell(BW * bw)
d188 1
a188 1
static int backup(BW * bw)
@


1.13
log
@put struct definitions and other goodies into types.h
@
text
@d13 7
d21 1
a21 2
#include <sys/stat.h>
#include <string.h>
d38 1
a38 6
#include "scrn.h"
#include "tw.h"
#include "w.h"
#include "pw.h"
#include "qw.h"
#include "ublock.h"
a39 2
#include "vs.h"
#include "va.h"
d42 6
a48 2
#include "tty.h"
#include "tab.h"
a49 1
#include "macro.h"
a50 1
#include "undo.h"
d52 3
@


1.12
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d2 8
a9 5
	User file operations
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.11
log
@comment out unused functions (nask2()/uask2())
@
text
@d70 1
a70 1
			snprintf(msgbuf, MSGBUFSIZE, "File %s saved", name);
d72 1
a72 1
			snprintf(msgbuf, MSGBUFSIZE, "File %s not saved", name);
d75 1
a75 1
		snprintf(msgbuf, MSGBUFSIZE, "File %s not saved", s);
d77 1
a77 1
		snprintf(msgbuf, MSGBUFSIZE, "File %s saved", s);
d79 1
a79 1
		snprintf(msgbuf, MSGBUFSIZE, "File %s not changed so no update needed", s);
@


1.10
log
@use mkmenu(W *, ...) instead of mkmenu(BASE *, ...)
@
text
@d676 2
a709 2
/* FIXME: unused ???? */
#if 0
@


1.9
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d786 1
a786 1
	if (mkmenu(bw, s, dobuf, abrtb, NULL, 0, s, NULL))
@


1.8
log
@kill infinite loop when saving unmodified file (sourceforge.net BUG #478290)
@
text
@d81 1
a81 1
	msgnw(bw, msgbuf);
d257 1
a257 1
		msgnw(bw, "Couldn't make backup file... file not saved");
d283 1
a283 1
		msgnw(bw, msgs[fl + 5]);
d405 1
a405 1
		msgnw(bw, "Process running in this window");
d422 1
a422 1
		msgnwt(bw, msgs[er + 5]);
d446 1
a446 1
		msgnw(bw, "Can't replace modified file");
d476 1
a476 1
		msgnw(bw, "Process running in this window");
d482 1
a482 1
		msgnwt(bw, msgs[error + 5]);
d513 1
a513 1
		msgnw(bw, "Process running in this window");
d545 1
a545 1
		msgnw(bw, "Process running in this window");
d746 1
a746 1
	msgnw(bw, NULL);
@


1.7
log
@remove "feature" added in 2.9.7-pre1 so the user is always asked
of the filename saved (sourceforge.net BUG #449489)
@
text
@d306 5
a310 3
			UNDOREC *rec = u->recs.link.prev;
			
			while (rec->changed) {
d312 4
a315 2
			}		
			rec->changed = 1;
a316 1

@


1.6
log
@version 2.9.7-pre3
@
text
@a373 5
	if (!bw->b->changed) {
		/* there is no change */
		genexmsg (bw,0,NULL);
		return -1;
	}
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@a16 1
#include "undo.h"
d47 1
d127 1
a127 1
int cp(char *from, char *to)
d466 1
a466 1
int dorepl(BW *bw, char *s, void *obj, int *notify)
d710 3
a712 1
int uask2(BW *bw)
d716 1
d720 1
a720 1
int dolose(BW *bw, int c, void *object, int *notify)
d765 1
a765 1
int dobuf(MENU *m, int x, char **s)
d777 1
a777 1
int abrtb(MENU *m, int x, char **s)
@


1.4
log
@changed as of joe-2.9.6
@
text
@d8 1
a12 1
#include "config.h"
d14 4
d48 1
d58 1
a58 2
void
genexmsg (BW * bw, int saved, char *name)
d62 1
a62 1
	if (bw->b->name && bw->b->name[0])
d64 1
a64 1
	else
d66 1
d68 30
a97 36
	if (name)
		if (saved)
			snprintf (msgbuf, MSGBUFSIZE, "File %s saved", name);
		else
			snprintf (msgbuf, MSGBUFSIZE, "File %s not saved", name);
	else if (bw->b->changed && bw->b->count == 1)
		snprintf (msgbuf, MSGBUFSIZE, "File %s not saved", s);
	else if (saved)
		snprintf (msgbuf, MSGBUFSIZE, "File %s saved", s);
	else
		snprintf (msgbuf, MSGBUFSIZE, "File %s not changed so no update needed",
			 s);
	msgnw (bw, msgbuf);

	if (!exmsg)
		if (bw->b->changed && bw->b->count == 1)
		  {
			  exmsg = vsncpy (NULL, 0, sc ("File "));
			  exmsg = vsncpy (sv (exmsg), sz (s));
			  exmsg = vsncpy (sv (exmsg), sc (" not saved."));
		  }
		else if (saved)
		  {
			  exmsg = vsncpy (NULL, 0, sc ("File "));
			  exmsg = vsncpy (sv (exmsg), sz (s));
			  exmsg = vsncpy (sv (exmsg), sc (" saved."));
		  }
		else
		  {
			  exmsg = vsncpy (NULL, 0, sc ("File "));
			  exmsg = vsncpy (sv (exmsg), sz (s));
			  exmsg =
				  vsncpy (sv (exmsg),
					  sc
					  (" not changed so no update needed."));
		  }
d102 1
a102 2
int
ublksave (BW * bw)
d104 9
a112 14
	if (markb && markk && markb->b == markk->b
	    && (markk->byte - markb->byte) > 0 && (!square
						   || piscol (markk) >
						   piscol (markb)))
	  {
		  if (wmkpw
		      (bw->parent, "Name of file to write (^C to abort): ", &filehist,
		       dowrite, "Names", NULL, cmplt, NULL, NULL))
			  return 0;
		  else
			  return -1;
	  }
	else
		return usave (bw);
d117 1
a117 2
int
ushell (BW * bw)
d119 3
a121 3
	nescape (bw->parent->t->t);
	ttsusp ();
	nreturn (bw->parent->t->t);
d127 1
a127 2
int
cp (char *from, char *to)
d140 2
a141 2
	f = open (from, O_RDONLY);
	if (f < 0)
d143 2
a144 1
	if (fstat (f, &sbuf) < 0)
d146 8
a153 8
	g = creat (to, sbuf.st_mode);
	if (g < 0)
	  {
		  close (f);
		  return -1;
	  }
	while ((amnt = read (f, stdbuf, stdsiz)) > 0)
		if (amnt != write (g, stdbuf, amnt))
d155 5
a159 3
	close (f);
	close (g);
	if (amnt)
d161 1
d171 1
a171 1
	utime (to, &utbuf);
d182 1
a182 2
static int
backup (BW * bw)
d184 3
a186 5
	if (!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0])
	  {
		  char tmp[1024];
		  char name[1024];
		  int x;
d189 1
d191 13
a203 15
		  if (backpath)
			  snprintf (name, sizeof(name), "%s/%s", backpath,
				   namepart (tmp, bw->b->name));
		  else
			  snprintf (name, sizeof(name), "%s", bw->b->name);

		  ossep (name);

		  for (x = strlen (name); name[--x] != '.';)
			  if (name[x] == '\\' || (name[x] == ':' && x == 1)
			      || x == 0)
			    {
				    x = strlen (name);
				    break;
			    }
d205 1
a205 1
		  strcpy (name + x, ".bak");
d209 14
a222 9
		  /* Create backup file name */
		  if (backpath)
			  snprintf (name, sizeof(name), "%s/%s~", backpath,
				   namepart (tmp, bw->b->name));
		  else
			  snprintf (name, sizeof(name), "%s~", bw->b->name);

		  /* Attempt to delete backup file first */
		  unlink (name);
d226 8
a233 12
		  /* Copy original file to backup file */
		  if (cp (bw->b->name, name))
		    {
			    return 1;
		    }
		  else
		    {
			    bw->b->backup = 1;
			    return 0;
		    }
	  }
	else
d235 1
d240 1
a240 2
struct savereq
{
d245 1
a245 6
static int
saver (bw, c, req, notify)
     BW *bw;
     int c;
     struct savereq *req;
     int *notify;
d249 1
d251 15
a265 18
	if (c == 'n' || c == 'N')
	  {
		  vsrm (req->name);
		  free (req);
		  if (notify)
			  *notify = 1;
		  msgnw (bw, "Couldn't make backup file... file not saved");
		  if (callback)
			  return callback (bw, -1);
		  else
			  return -1;
	  }
	if (c != 'y' && c != 'Y')
		if (mkqw
		    (bw->parent,
		     sc
		     ("Could not make backup file.  Save anyway (y,n,^C)? "),
		     saver, NULL, req, notify))
d267 7
a273 7
		else
		  {
			  if (notify)
				  *notify = 1;
			  return -1;
		  }
	if (notify)
d275 51
a325 39
	if (bw->b->er == -1 && bw->o.msnew)
		exemac (bw->o.msnew), bw->b->er = -3;
	if (bw->b->er == 0 && bw->o.msold)
		exemac (bw->o.msold);
	if (fl = bsave (bw->b->bof, req->name, bw->b->eof->byte))
	  {
		  msgnw (bw, msgs[fl + 5]);
		  vsrm (req->name);
		  free (req);
		  if (callback)
			  return callback (bw, -1);
		  else
			  return -1;
	  }
	else
	  {
		  if (!bw->b->name)
			  bw->b->name = joesep (strdup (req->name));
		  if (!strcmp (bw->b->name, req->name))
		    {
			    bw->b->changed = 0;
			    saverr (bw->b->name);
		    }
		  genexmsg (bw, 1, req->name);
		  vsrm (req->name);
		  free (req);
		  if (callback)
			  return callback (bw, 0);
		  else
			  return 0;
	  }
}

static int
dosave (bw, s, callback, notify)
     BW *bw;
     char *s;
     int (*callback) ();
     int *notify;
d327 2
a328 2
	struct savereq *req =
		(struct savereq *) malloc (sizeof (struct savereq));
d331 21
a351 27
	if (backup (bw))
		saver (bw, 0, req, notify);
	else
		saver (bw, 'y', req, notify);
}

static int
dosave2 (bw, c, s, notify)
     BW *bw;
     char *s;
     int *notify;
{
	if (c == 'y' || c == 'Y')
		return dosave (bw, s, NULL, notify);
	else if (c == 'n' || c == 'N')
	  {
		  if (notify)
			  *notify = 1;
		  genexmsg (bw, 0, s);
		  vsrm (s);
		  return -1;
	  }
	else
		if (mkqw
		    (bw->parent, sc ("File exists.  Overwrite (y,n,^C)? "), dosave2,
		     NULL, s, notify)) return 0;
	else
d353 1
d356 1
a356 6
static int
dosave1 (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d359 28
a386 28
	if (s[0] != '!' && !(s[0] == '>' && s[1] == '>')
	    && (!bw->b->name || strcmp (s, bw->b->name)))
	  {
		  f = open (s, O_RDONLY);
		  if (f != -1)
		    {
			    close (f);
			    return dosave2 (bw, 0, s, notify);
		    }
	  }
	return dosave (bw, s, object, notify);
}

int
usave (bw)
     BW *bw;
{
	BW *pbw = wmkpw (bw->parent,
			 "Name of file to save (^C to abort): ", &filehist,
			 dosave1,
			 "Names", NULL, cmplt, NULL, NULL);
	if (pbw && bw->b->name)
	  {
		  binss (pbw->cursor, bw->b->name);
		  pset (pbw->cursor, pbw->b->eof);
		  pbw->cursor->xcol = piscol (pbw->cursor);
	  }
	if (pbw)
d388 1
a388 1
	else
d390 1
d395 1
a395 5
int doedit (bw, s, obj, notify)
     BW *bw;
     char *s;
     void *obj;
     int *notify;
d402 2
a403 1
	if (notify)
d405 6
a410 6
	if (bw->pid)
	  {
		  msgnw (bw, "Process running in this window");
		  return -1;
	  }
	b = bfind (s);
d412 17
a428 18
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name))
		if (orphan)
			orphit (bw);
		else
		  {
			  if (uduptw (bw))
			    {
				    brm (b);
				    return -1;
			    }
			  bw = (BW *) maint->curwin->object;
		  }
	if (er)
	  {
		  msgnwt (bw, msgs[er + 5]);
		  if (er != -1)
			  ret = -1;
	  }
d431 3
a433 3
	bwrm (bw);
	w->object = (void *) (bw = bwmk (w, b, 0));
	wredraw (bw->parent);
d435 7
a441 5
	vsrm (s);
	if (er == -1 && bw->o.mnew)
		exemac (bw->o.mnew);
	if (er == 0 && bw->o.mold)
		exemac (bw->o.mold);
d445 1
a445 3
int
okrepl (bw)
     BW *bw;
d447 4
a450 6
	if (bw->b->count == 1 && bw->b->changed)
	  {
		  msgnw (bw, "Can't replace modified file");
		  return -1;
	  }
	else
d452 1
d455 1
a455 3
int
uedit (bw)
     BW *bw;
d457 1
a457 3
	if (wmkpw
	    (bw->parent, "Name of file to edit (^C to abort): ", &filehist, doedit,
	     "Names", NULL, cmplt, NULL, NULL))
d459 1
a459 1
	else
d461 1
d466 1
a466 6
int
dorepl (bw, s, obj, notify)
     BW *bw;
     char *s;
     void *obj;
     int *notify;
d473 2
a474 1
	if (notify)
d476 6
a481 6
	if (bw->pid)
	  {
		  msgnw (bw, "Process running in this window");
		  return -1;
	  }
	b = bfind (s);
d483 12
a494 11
	if (error)
	  {
		  msgnwt (bw, msgs[error + 5]);
		  if (error != -1)
			  ret = -1;
	  }
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name))
		orphit (bw);
	bwrm (bw);
	w->object = (void *) (bw = bwmk (w, b, 0));
	wredraw (bw->parent);
d496 7
a502 5
	vsrm (s);
	if (er == -1 && bw->o.mnew)
		exemac (bw->o.mnew);
	if (er == 0 && bw->o.mold)
		exemac (bw->o.mold);
d508 1
a508 3
int
unbuf (bw)
     BW *bw;
d513 3
a515 9
	if (bw->pid)
	  {
		  msgnw (bw, "Process running in this window");
		  return -1;
	  }
	b = bnext ();
	if (b == bw->b)
		b = bnext ();
	if (b == bw->b)
d517 9
a525 1
	if (!b->orphan)
d527 1
a527 1
	else
d529 7
a535 5
	if (bw->b->count == 1)
		orphit (bw);
	bwrm (bw);
	w->object = (void *) (bw = bwmk (w, b, 0));
	wredraw (bw->parent);
d540 1
a540 3
int
upbuf (bw)
     BW *bw;
d545 10
a554 9
	if (bw->pid)
	  {
		  msgnw (bw, "Process running in this window");
		  return -1;
	  }
	b = bprev ();
	if (b == bw->b)
		b = bprev ();
	if (b == bw->b)
d556 2
a557 1
	if (!b->orphan)
d559 1
a559 1
	else
d561 7
a567 5
	if (bw->b->count == 1)
		orphit (bw);
	bwrm (bw);
	w->object = (void *) (bw = bwmk (w, b, 0));
	wredraw (bw->parent);
d572 3
a574 7
int
uinsf (bw)
     BW *bw;
{
	if (wmkpw (bw->parent,
		   "Name of file to insert (^C to abort): ", &filehist,
		   doinsf, "Names", NULL, cmplt, NULL, NULL))
d576 1
a576 1
	else
d578 1
d583 52
a634 77
static int
exdone (bw, flg)
     BW *bw;
{
	if (flg)
	  {
		  if (bw->b->name)
			  free (bw->b->name);
		  bw->b->name = 0;
		  return -1;
	  }
	else
	  {
		  bw->b->changed = 0;
		  saverr (bw->b->name);
		  return uabort (bw, MAXINT);
	  }
}

static int
exdone1 (bw, flg)
     BW *bw;
{
	if (flg)
	  {
		  return -1;
	  }
	else
	  {
		  bw->b->changed = 0;
		  saverr (bw->b->name);
		  return uabort (bw, MAXINT);
	  }
}

static int
doex (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
	bw->b->name = joesep (strdup (s));
	return dosave (bw, s, exdone, notify);
}

int
uexsve (bw)
     BW *bw;
{
	if (!bw->b->changed)
	  {
		  uabort (bw, MAXINT);
		  return 0;
	  }
	else if (bw->b->name && !exask)
	  {
		  return dosave (bw, vsncpy (NULL, 0, sz (bw->b->name)),
				 exdone1, NULL);
	  }
	else
	  {
		  BW *pbw = wmkpw (bw->parent,
				   "Name of file to save (^C to abort): ",
				   &filehist,
				   doex, "Names", NULL, cmplt, NULL, NULL);
		  if (pbw && bw->b->name)
		    {
			    binss (pbw->cursor, bw->b->name);
			    pset (pbw->cursor, pbw->b->eof);
			    pbw->cursor->xcol = piscol (pbw->cursor);
		    }
		  if (pbw)
			  return 0;
		  else
			  return -1;
	  }
d639 1
a639 5
static int
nask (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
d641 33
a673 44
	if (c == 'y' || c == 'Y')
		if (bw->b->name)
			return dosave1 (bw,
					vsncpy (NULL, 0, sz (bw->b->name)),
					object, notify);
		else
		  {
			  BW *pbw = wmkpw (bw->parent,
					   "Name of file to save (^C to abort): ",
					   &filehist,
					   dosave1, "Names", NULL, cmplt,
					   object, notify);
			  if (pbw)
				  return 0;
			  else
				  return -1;
		  }
	else if (c == 'n' || c == 'N')
	  {
		  genexmsg (bw, 0, NULL);
		  if (notify)
			  *notify = 1;
		  return 0;
	  }
	else if (bw->b->count == 1 && bw->b->changed)
	  {
		  if (mkqw
		      (bw->parent, sc ("Save changes to this file (y,n,^C)? "), nask,
		       NULL, object, notify))
			  return 0;
		  else
			  return -1;
	  }
	else
	  {
		  if (notify)
			  *notify = 1;
		  return 0;
	  }
}

int
uask (bw)
     BW *bw;
d675 1
a675 1
	return nask (bw, 0, NULL, NULL);
d680 31
a710 45
static int
nask2 (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
	if (c == 'y' || c == 'Y')
	  {
		  BW *pbw = wmkpw (bw->parent,
				   "Name of file to save (^C to abort): ",
				   &filehist,
				   dosave1, "Names", NULL, cmplt, object,
				   notify);
		  if (pbw)
			  return 0;
		  else
			  return -1;
	  }
	else if (c == 'n' || c == 'N')
	  {
		  genexmsg (bw, 0, NULL);
		  if (notify)
			  *notify = 1;
		  return 0;
	  }
	else if (bw->b->count == 1 && bw->b->changed)
	  {
		  if (mkqw
		      (bw->parent, sc ("Save changes to this file (y,n,^C)? "), nask,
		       NULL, object, notify))
			  return 0;
		  else
			  return -1;
	  }
	else
	  {
		  if (notify)
			  *notify = 1;
		  return 0;
	  }
}

int
uask2 (bw)
     BW *bw;
d712 1
a712 1
	return nask2 (bw, 0, NULL, NULL);
d717 1
a717 5
int
dolose (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
d720 2
a721 1
	if (notify)
d723 2
a724 1
	if (c != 'y' && c != 'Y')
d726 3
a728 2
	genexmsg (bw, 0, NULL);
	if (bw->b->count == 1)
d730 1
d733 3
a735 3
	bwrm (bw);
	w->object = (void *) (bw = bwmk (w, bfind (""), 0));
	wredraw (bw->parent);
d737 3
a739 2
	if (bw->o.mnew)
		exemac (bw->o.mnew);
d743 8
a750 11
int
ulose (bw)
     BW *bw;
{
	msgnw (bw, NULL);
	if (bw->pid)
		return ukillpid (bw);
	if (bw->b->count == 1 && bw->b->changed)
		if (mkqw
		    (bw->parent, sc ("Lose changes to this file (y,n,^C)? "), dolose,
		     NULL, NULL, NULL))
d752 1
a752 1
		else
d754 4
a757 2
	else
		return dolose (bw, 'y', NULL, NULL);
d762 1
a762 4
int
dobuf (m, x, s)
     MENU *m;
     char **s;
d767 1
d769 3
a771 3
	name = vsdup (s[x]);
	uabort (m, MAXINT);
	return dorepl (bw, name, NULL, notify);
d774 1
a774 4
int
abrtb (m, x, s)
     MENU *m;
     char **s;
d776 1
a776 1
	varm (s);
d780 11
a790 13
int
ubufed (bw)
     BW *bw;
{
	char **s = getbufs ();
	vasort (av (s));
	if (mkmenu (bw, s, dobuf, abrtb, NULL, 0, s, NULL))
		return 0;
	else
	  {
		  varm (s);
		  return -1;
	  }
@


1.3
log
@changed as of joe-2.9.5
@
text
@d9 1
d53 3
a55 1
void genexmsg (BW *bw, int saved, char *name) {
d65 1
a65 1
			sprintf (msgbuf, "File %s saved", name);
d67 1
a67 1
			sprintf (msgbuf, "File %s not saved", name);
d69 1
a69 1
		sprintf (msgbuf, "File %s not saved", s);
d71 1
a71 1
		sprintf (msgbuf, "File %s saved", s);
d73 2
a74 1
		sprintf (msgbuf, "File %s not changed so no update needed", s);
d78 21
a98 13
		if (bw->b->changed && bw->b->count == 1) {
			exmsg = vsncpy (NULL, 0, sc ("File "));
			exmsg = vsncpy (sv (exmsg), sz (s));
			exmsg = vsncpy (sv (exmsg), sc (" not saved."));
		} else if (saved) {
			exmsg = vsncpy (NULL, 0, sc ("File "));
			exmsg = vsncpy (sv (exmsg), sz (s));
			exmsg = vsncpy (sv (exmsg), sc (" saved."));
		} else {
			exmsg = vsncpy (NULL, 0, sc ("File "));
			exmsg = vsncpy (sv (exmsg), sz (s));
			exmsg = vsncpy (sv (exmsg), sc (" not changed so no update needed."));
		}
d103 16
a118 7
int ublksave (BW *bw) {
	if (markb && markk && markb->b == markk->b && (markk->byte - markb->byte) > 0 && (!square || piscol (markk) > piscol (markb))) {
		if (wmkpw (bw, "Name of file to write (^C to abort): ", &filehist, dowrite, "Names", NULL, cmplt, NULL, NULL))
			return 0;
		else
			return -1;
	} else
d124 3
a126 1
int ushell (BW *bw) {
d135 3
a137 1
int cp (char *from, char *to) {
d155 5
a159 4
	if (g < 0) {
		close (f);
		return -1;
	}
d187 8
a194 5
static int backup (BW *bw) {
	if (!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0]) {
		char tmp[1024];
		char name[1024];
		int x;
d198 15
a212 4
      if (backpath)
	sprintf (name, "%s/%s", backpath, namepart (tmp, bw->b->name));
      else
	sprintf (name, "%s", bw->b->name);
d214 1
a214 10
      ossep (name);

      for (x = strlen (name); name[--x] != '.';)
	if (name[x] == '\\' || (name[x] == ':' && x == 1) || x == 0)
	  {
	    x = strlen (name);
	    break;
	  }

      strcpy (name + x, ".bak");
d218 6
a223 5
      /* Create backup file name */
      if (backpath)
	sprintf (name, "%s/%s~", backpath, namepart (tmp, bw->b->name));
      else
	sprintf (name, "%s~", bw->b->name);
d225 2
a226 2
      /* Attempt to delete backup file first */
      unlink (name);
d230 13
a242 13
      /* Copy original file to backup file */
      if (cp (bw->b->name, name))
	{
	  return 1;
	}
      else
	{
	  bw->b->backup = 1;
	  return 0;
	}
    }
  else
    return 0;
d249 2
a250 2
  int (*callback) ();
  char *name;
d260 28
a287 22
  int (*callback) ();
  int fl;
  callback = req->callback;
  if (c == 'n' || c == 'N')
    {
      vsrm (req->name);
      free (req);
      if (notify)
	*notify = 1;
      msgnw (bw, "Couldn't make backup file... file not saved");
      if (callback)
	return callback (bw, -1);
      else
	return -1;
    }
  if (c != 'y' && c != 'Y')
    if (mkqw
	(bw, sc ("Could not make backup file.  Save anyway (y,n,^C)? "),
	 saver, NULL, req, notify))
      return 0;
    else
      {
d289 32
a320 36
	  *notify = 1;
	return -1;
      }
  if (notify)
    *notify = 1;
  if (bw->b->er == -1 && bw->o.msnew)
    exemac (bw->o.msnew), bw->b->er = -3;
  if (bw->b->er == 0 && bw->o.msold)
    exemac (bw->o.msold);
  if (fl = bsave (bw->b->bof, req->name, bw->b->eof->byte))
    {
      msgnw (bw, msgs[fl + 5]);
      vsrm (req->name);
      free (req);
      if (callback)
	return callback (bw, -1);
      else
	return -1;
    }
  else
    {
      if (!bw->b->name)
	bw->b->name = joesep (strdup (req->name));
      if (!strcmp (bw->b->name, req->name))
	{
	  bw->b->changed = 0;
	  saverr (bw->b->name);
	}
      genexmsg (bw, 1, req->name);
      vsrm (req->name);
      free (req);
      if (callback)
	return callback (bw, 0);
      else
	return 0;
    }
d330 8
a337 7
  struct savereq *req = (struct savereq *) malloc (sizeof (struct savereq));
  req->name = s;
  req->callback = callback;
  if (backup (bw))
    saver (bw, 0, req, notify);
  else
    saver (bw, 'y', req, notify);
d346 16
a361 16
  if (c == 'y' || c == 'Y')
    return dosave (bw, s, NULL, notify);
  else if (c == 'n' || c == 'N')
    {
      if (notify)
	*notify = 1;
      genexmsg (bw, 0, s);
      vsrm (s);
      return -1;
    }
  else
    if (mkqw
	(bw, sc ("File exists.  Overwrite (y,n,^C)? "), dosave2, NULL, s,
	 notify)) return 0;
  else
    return -1;
d371 12
a382 12
  int f;
  if (s[0] != '!' && !(s[0] == '>' && s[1] == '>')
      && (!bw->b->name || strcmp (s, bw->b->name)))
    {
      f = open (s, O_RDONLY);
      if (f != -1)
	{
	  close (f);
	  return dosave2 (bw, 0, s, notify);
	}
    }
  return dosave (bw, s, object, notify);
d389 14
a402 13
  BW *pbw = wmkpw (bw,
		   "Name of file to save (^C to abort): ", &filehist, dosave1,
		   "Names", NULL, cmplt, NULL, NULL);
  if (pbw && bw->b->name)
    {
      binss (pbw->cursor, bw->b->name);
      pset (pbw->cursor, pbw->b->eof);
      pbw->cursor->xcol = piscol (pbw->cursor);
    }
  if (pbw)
    return 0;
  else
    return -1;
d407 1
a407 2
int
doedit (bw, s, obj, notify)
d413 44
a456 44
  int ret = 0;
  int er;
  void *object;
  W *w;
  B *b;
  if (notify)
    *notify = 1;
  if (bw->pid)
    {
      msgnw (bw, "Process running in this window");
      return -1;
    }
  b = bfind (s);
  er = error;
  if (bw->b->count == 1 && (bw->b->changed || bw->b->name))
    if (orphan)
      orphit (bw);
    else
      {
	if (uduptw (bw))
	  {
	    brm (b);
	    return -1;
	  }
	bw = (BW *) maint->curwin->object;
      }
  if (er)
    {
      msgnwt (bw, msgs[er + 5]);
      if (er != -1)
	ret = -1;
    }
  object = bw->object;
  w = bw->parent;
  bwrm (bw);
  w->object = (void *) (bw = bwmk (w, b, 0));
  wredraw (bw->parent);
  bw->object = object;
  vsrm (s);
  if (er == -1 && bw->o.mnew)
    exemac (bw->o.mnew);
  if (er == 0 && bw->o.mold)
    exemac (bw->o.mold);
  return ret;
d463 7
a469 7
  if (bw->b->count == 1 && bw->b->changed)
    {
      msgnw (bw, "Can't replace modified file");
      return -1;
    }
  else
    return 0;
d476 6
a481 6
  if (wmkpw
      (bw, "Name of file to edit (^C to abort): ", &filehist, doedit, "Names",
       NULL, cmplt, NULL, NULL))
    return 0;
  else
    return -1;
d493 32
a524 32
  void *object = bw->object;
  int ret = 0;
  int er;
  W *w = bw->parent;
  B *b;
  if (notify)
    *notify = 1;
  if (bw->pid)
    {
      msgnw (bw, "Process running in this window");
      return -1;
    }
  b = bfind (s);
  er = error;
  if (error)
    {
      msgnwt (bw, msgs[error + 5]);
      if (error != -1)
	ret = -1;
    }
  if (bw->b->count == 1 && (bw->b->changed || bw->b->name))
    orphit (bw);
  bwrm (bw);
  w->object = (void *) (bw = bwmk (w, b, 0));
  wredraw (bw->parent);
  bw->object = object;
  vsrm (s);
  if (er == -1 && bw->o.mnew)
    exemac (bw->o.mnew);
  if (er == 0 && bw->o.mold)
    exemac (bw->o.mold);
  return ret;
d533 24
a556 24
  void *object = bw->object;
  W *w = bw->parent;
  B *b;
  if (bw->pid)
    {
      msgnw (bw, "Process running in this window");
      return -1;
    }
  b = bnext ();
  if (b == bw->b)
    b = bnext ();
  if (b == bw->b)
    return -1;
  if (!b->orphan)
    ++b->count;
  else
    b->orphan = 0;
  if (bw->b->count == 1)
    orphit (bw);
  bwrm (bw);
  w->object = (void *) (bw = bwmk (w, b, 0));
  wredraw (bw->parent);
  bw->object = object;
  return 0;
d563 24
a586 24
  void *object = bw->object;
  W *w = bw->parent;
  B *b;
  if (bw->pid)
    {
      msgnw (bw, "Process running in this window");
      return -1;
    }
  b = bprev ();
  if (b == bw->b)
    b = bprev ();
  if (b == bw->b)
    return -1;
  if (!b->orphan)
    ++b->count;
  else
    b->orphan = 0;
  if (bw->b->count == 1)
    orphit (bw);
  bwrm (bw);
  w->object = (void *) (bw = bwmk (w, b, 0));
  wredraw (bw->parent);
  bw->object = object;
  return 0;
d593 6
a598 6
  if (wmkpw (bw,
	     "Name of file to insert (^C to abort): ", &filehist, doinsf,
	     "Names", NULL, cmplt, NULL, NULL))
    return 0;
  else
    return -1;
d607 13
a619 13
  if (flg)
    {
      if (bw->b->name)
	free (bw->b->name);
      bw->b->name = 0;
      return -1;
    }
  else
    {
      bw->b->changed = 0;
      saverr (bw->b->name);
      return uabort (bw, MAXINT);
    }
d626 10
a635 10
  if (flg)
    {
      return -1;
    }
  else
    {
      bw->b->changed = 0;
      saverr (bw->b->name);
      return uabort (bw, MAXINT);
    }
d645 2
a646 2
  bw->b->name = joesep (strdup (s));
  return dosave (bw, s, exdone, notify);
d653 27
a679 25
  if (!bw->b->changed)
    {
      uabort (bw, MAXINT);
      return 0;
    }
  else if (bw->b->name && !exask)
    {
      return dosave (bw, vsncpy (NULL, 0, sz (bw->b->name)), exdone1, NULL);
    }
  else
    {
      BW *pbw = wmkpw (bw,
		       "Name of file to save (^C to abort): ", &filehist,
		       doex, "Names", NULL, cmplt, NULL, NULL);
      if (pbw && bw->b->name)
	{
	  binss (pbw->cursor, bw->b->name);
	  pset (pbw->cursor, pbw->b->eof);
	  pbw->cursor->xcol = piscol (pbw->cursor);
	}
      if (pbw)
	return 0;
      else
	return -1;
    }
d690 33
a722 10
  if (c == 'y' || c == 'Y')
    if (bw->b->name)
      return dosave1 (bw, vsncpy (NULL, 0, sz (bw->b->name)), object, notify);
    else
      {
	BW *pbw = wmkpw (bw,
			 "Name of file to save (^C to abort): ", &filehist,
			 dosave1, "Names", NULL, cmplt, object, notify);
	if (pbw)
	  return 0;
d724 5
a728 23
	  return -1;
      }
  else if (c == 'n' || c == 'N')
    {
      genexmsg (bw, 0, NULL);
      if (notify)
	*notify = 1;
      return 0;
    }
  else if (bw->b->count == 1 && bw->b->changed)
    {
      if (mkqw
	  (bw, sc ("Save changes to this file (y,n,^C)? "), nask, NULL,
	   object, notify)) return 0;
      else
	return -1;
    }
  else
    {
      if (notify)
	*notify = 1;
      return 0;
    }
d735 1
a735 1
  return nask (bw, 0, NULL, NULL);
d746 34
a779 31
  if (c == 'y' || c == 'Y')
    {
      BW *pbw = wmkpw (bw,
		       "Name of file to save (^C to abort): ", &filehist,
		       dosave1, "Names", NULL, cmplt, object, notify);
      if (pbw)
	return 0;
      else
	return -1;
    }
  else if (c == 'n' || c == 'N')
    {
      genexmsg (bw, 0, NULL);
      if (notify)
	*notify = 1;
      return 0;
    }
  else if (bw->b->count == 1 && bw->b->changed)
    {
      if (mkqw
	  (bw, sc ("Save changes to this file (y,n,^C)? "), nask, NULL,
	   object, notify)) return 0;
      else
	return -1;
    }
  else
    {
      if (notify)
	*notify = 1;
      return 0;
    }
d786 1
a786 1
  return nask2 (bw, 0, NULL, NULL);
d797 17
a813 17
  W *w;
  if (notify)
    *notify = 1;
  if (c != 'y' && c != 'Y')
    return -1;
  genexmsg (bw, 0, NULL);
  if (bw->b->count == 1)
    bw->b->changed = 0;
  object = bw->object;
  w = bw->parent;
  bwrm (bw);
  w->object = (void *) (bw = bwmk (w, bfind (""), 0));
  wredraw (bw->parent);
  bw->object = object;
  if (bw->o.mnew)
    exemac (bw->o.mnew);
  return 0;
d820 12
a831 11
  msgnw (bw, NULL);
  if (bw->pid)
    return ukillpid (bw);
  if (bw->b->count == 1 && bw->b->changed)
    if (mkqw
	(bw, sc ("Lose changes to this file (y,n,^C)? "), dolose, NULL, NULL,
	 NULL)) return 0;
    else
      return -1;
  else
    return dolose (bw, 'y', NULL, NULL);
d841 7
a847 7
  char *name;
  BW *bw = m->parent->win->object;
  int *notify = m->parent->notify;
  m->parent->notify = 0;
  name = vsdup (s[x]);
  uabort (m, MAXINT);
  return dorepl (bw, name, NULL, notify);
d855 2
a856 2
  varm (s);
  return -1;
d863 9
a871 9
  char **s = getbufs ();
  vasort (av (s));
  if (mkmenu (bw, s, dobuf, abrtb, NULL, 0, s, NULL))
    return 0;
  else
    {
      varm (s);
      return -1;
    }
@


1.2
log
@changed as of joe-2.9.2
@
text
@d1 3
a3 2
/* User file operations
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
a32 1
#include "zstr.h"
d45 4
a48 4
char *backpath=0;			/* Place to store backup files */
static B *filehist=0;			/* History of file names */
int nobackups=0;
int exask=0;
d51 37
a87 43

void genexmsg(bw,saved,name)
BW *bw;
char *name;
 {
 char *s;
 if(bw->b->name && bw->b->name[0]) s=bw->b->name;
 else s="(Unnamed)";

 if(name)
  if(saved)
   sprintf(msgbuf,"File %s saved",name);
  else
   sprintf(msgbuf,"File %s not saved",name);
 else
  if(bw->b->changed && bw->b->count==1)
   sprintf(msgbuf,"File %s not saved",s);
  else if(saved)
   sprintf(msgbuf,"File %s saved",s);
  else
   sprintf(msgbuf,"File %s not changed so no update needed",s);
 msgnw(bw,msgbuf);

 if(!exmsg)
  if(bw->b->changed && bw->b->count==1)
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" not saved."));
   }
  else if(saved)
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" saved."));
   }
  else
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" not changed so no update needed."));
   }
 }
d91 9
a99 13
int ublksave(bw)
BW *bw;
 {
 if(markb && markk && markb->b==markk->b &&
    (markk->byte-markb->byte)>0 &&
    (!square || piscol(markk)>piscol(markb)))
  {
  if(wmkpw(bw,
           "Name of file to write (^C to abort): ",&filehist,dowrite,"Names",NULL,cmplt,NULL,NULL)) return 0;
  else return -1;
  }
 else return usave(bw);
 }
d103 6
a108 8
int ushell(bw)
BW *bw;
 {
 nescape(bw->parent->t->t);
 ttsusp();
 nreturn(bw->parent->t->t);
 return 0;
 }
d112 3
a114 5
int cp(from,to)
char *from, *to;
 {
 int f, g, amnt;
 struct stat sbuf;
d118 1
a118 1
 time_t utbuf[2];
d120 1
a120 1
 struct utimbuf utbuf;
d124 17
a140 13
 f=open(from,O_RDONLY);
 if(f<0) return -1;
 if(fstat(f,&sbuf)<0) return -1;
 g=creat(to,sbuf.st_mode);
 if(g<0)
  {
  close(f);
  return -1;
  }
 while((amnt=read(f,stdbuf,stdsiz))>0)
  if(amnt!=write(g,stdbuf,amnt)) break;
 close(f); close(g);
 if(amnt) return -1;
d144 2
a145 2
 utbuf[0]=(time_t)sbuf.st_atime;
 utbuf[1]=(time_t)sbuf.st_mtime;
d147 2
a148 2
 utbuf.actime=sbuf.st_atime;
 utbuf.modtime=sbuf.st_mtime;
d150 1
a150 1
 utime(to,&utbuf);
d153 2
a154 2
 return 0;
 }
d161 5
a165 8
static int backup(bw)
BW *bw;
 {
 if(!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0])
  {
  char tmp[1024];
  char name[1024];
  int x;
d169 13
a181 13
  if(backpath)
   sprintf(name,"%s/%s",backpath,namepart(tmp,bw->b->name));
  else
   sprintf(name,"%s",bw->b->name);
  
  ossep(name);

  for(x=strlen(name);name[--x]!='.';)
   if(name[x]=='\\' || (name[x]==':' && x==1) || x==0)
    {
    x=strlen(name);
    break;
    }
d183 1
a183 1
  strcpy(name+x,".bak");
d187 5
a191 5
  /* Create backup file name */
  if(backpath)
   sprintf(name,"%s/%s~",backpath,namepart(tmp,bw->b->name));
  else
   sprintf(name,"%s~",bw->b->name);
d193 2
a194 2
  /* Attempt to delete backup file first */
  unlink(name);
d198 14
a211 13
  /* Copy original file to backup file */
  if(cp(bw->b->name,name))
   {
   return 1;
   }
  else
   {
   bw->b->backup=1;
   return 0;
   }
  }
 else return 0;
 }
d216 152
a367 122
 {
 int (*callback)();
 char *name;
 };

static int saver(bw,c,req,notify)
BW *bw;
int c;
struct savereq *req;
int *notify;
 {
 int (*callback)();
 int fl;
 callback=req->callback;
 if(c=='n' || c=='N')
  {
  vsrm(req->name);
  free(req);
  if(notify) *notify=1;
  msgnw(bw,"Couldn't make backup file... file not saved");
  if(callback) return callback(bw,-1);
  else return -1;
  }
 if(c!='y' && c!='Y')
  if(mkqw(bw,sc("Could not make backup file.  Save anyway (y,n,^C)? "),saver,NULL,req,notify))
   return 0;
  else
   {
   if(notify) *notify=1;
   return -1;
   }
 if(notify) *notify=1;
 if(bw->b->er== -1 && bw->o.msnew) exemac(bw->o.msnew), bw->b->er= -3;
 if(bw->b->er== 0 && bw->o.msold) exemac(bw->o.msold);
 if(fl=bsave(bw->b->bof,req->name,bw->b->eof->byte))
  {
  msgnw(bw,msgs[fl+5]);
  vsrm(req->name);
  free(req);
  if(callback) return callback(bw,-1);
  else return -1;
  }
 else
  {
  if(!bw->b->name) bw->b->name=joesep(strdup(req->name));
  if(!strcmp(bw->b->name,req->name))
   {
   bw->b->changed=0;
   saverr(bw->b->name);
   }
  genexmsg(bw,1,req->name);
  vsrm(req->name);
  free(req);
  if(callback) return callback(bw,0);
  else return 0;
  }
 }

static int dosave(bw,s,callback,notify)
BW *bw;
char *s;
int (*callback)();
int *notify;
 {
 struct savereq *req=(struct savereq *)malloc(sizeof(struct savereq));
 req->name=s;
 req->callback=callback;
 if(backup(bw)) saver(bw,0,req,notify);
 else saver(bw,'y',req,notify);
 }

static int dosave2(bw,c,s,notify)
BW *bw;
char *s;
int *notify;
 {
 if(c=='y' || c=='Y') return dosave(bw,s,NULL,notify);
 else if(c=='n' || c=='N')
  {
  if(notify) *notify=1;
  genexmsg(bw,0,s);
  vsrm(s);
  return -1;
  }
 else
  if(mkqw(bw,sc("File exists.  Overwrite (y,n,^C)? "),dosave2,NULL,s,notify)) return 0;
  else return -1;
 }

static int dosave1(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int f;
 if(s[0]!='!' && !(s[0]=='>' && s[1]=='>') && (!bw->b->name || strcmp(s,bw->b->name)))
  {
  f=open(s,O_RDONLY);
  if(f!= -1)
   {
   close(f);
   return dosave2(bw,0,s,notify);
   }
  }
 return dosave(bw,s,object,notify);
 }

int usave(bw)
BW *bw;
 {
 BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,NULL,NULL);
 if(pbw && bw->b->name)
  {
  binss(pbw->cursor,bw->b->name);
  pset(pbw->cursor,pbw->b->eof);
  pbw->cursor->xcol=piscol(pbw->cursor);
  }
 if(pbw) return 0;
 else return -1;
 }
d371 74
a444 21
int doedit(bw,s,obj,notify)
BW *bw;
char *s;
void *obj;
int *notify;
 {
 int ret=0;
 int er;
 void *object;
 W *w;
 B *b;
 if(notify) *notify=1;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bfind(s);
 er=error;
 if(bw->b->count==1 && (bw->b->changed || bw->b->name))
  if(orphan) orphit(bw);
a445 4
   {
   if(uduptw(bw))
    {
    brm(b);
d447 1
a447 39
    }
   bw=(BW *)maint->curwin->object;
   }
 if(er)
  {
  msgnwt(bw,msgs[er+5]);
  if(er!= -1) ret= -1;
  }
 object=bw->object;
 w=bw->parent;
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 vsrm(s);
 if(er== -1 && bw->o.mnew)
  exemac(bw->o.mnew);
 if(er==0 && bw->o.mold)
  exemac(bw->o.mold);
 return ret;
 }

int okrepl(bw)
BW *bw;
 {
 if(bw->b->count==1 && bw->b->changed)
  {
  msgnw(bw,"Can't replace modified file");
  return -1;
  }
 else return 0;
 }

int uedit(bw)
BW *bw;
 {
 if(wmkpw(bw,"Name of file to edit (^C to abort): ",&filehist,doedit,"Names",NULL,cmplt,NULL,NULL)) return 0;
 else return -1;
 }
d451 40
a490 37
int dorepl(bw,s,obj,notify)
BW *bw;
char *s;
void *obj;
int *notify;
 {
 void *object=bw->object;
 int ret=0;
 int er;
 W *w=bw->parent;
 B *b;
 if(notify) *notify=1;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bfind(s);
 er=error;
 if(error)
  {
  msgnwt(bw,msgs[error+5]);
  if(error!= -1) ret= -1;
  }
 if(bw->b->count==1 && (bw->b->changed || bw->b->name))
  orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 vsrm(s);
 if(er== -1 && bw->o.mnew)
  exemac(bw->o.mnew);
 if(er==0 && bw->o.mold)
  exemac(bw->o.mold);
 return ret;
 }
d494 71
a564 55
int unbuf(bw)
BW *bw;
 {
 void *object=bw->object;
 W *w=bw->parent;
 B *b;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bnext();
 if(b==bw->b) b=bnext();
 if(b==bw->b) return -1;
 if(!b->orphan) ++b->count;
 else b->orphan=0;
 if(bw->b->count==1) orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 return 0;
 }

int upbuf(bw)
BW *bw;
 {
 void *object=bw->object;
 W *w=bw->parent;
 B *b;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bprev();
 if(b==bw->b) b=bprev();
 if(b==bw->b) return -1;
 if(!b->orphan) ++b->count;
 else b->orphan=0;
 if(bw->b->count==1) orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 return 0;
 }

int uinsf(bw)
BW *bw;
 {
 if(wmkpw(bw,
           "Name of file to insert (^C to abort): ",&filehist,doinsf,"Names",NULL,cmplt,NULL,NULL)) return 0;
 else return -1;
 }
d568 76
a643 64
static int exdone(bw,flg)
BW *bw;
 {
 if(flg)
  {
  if(bw->b->name) free(bw->b->name);
  bw->b->name=0;
  return -1;
  }
 else
  {
  bw->b->changed=0;
  saverr(bw->b->name);
  return uabort(bw,MAXINT);
  }
 }

static int exdone1(bw,flg)
BW *bw;
 {
 if(flg)
  {
  return -1;
  }
 else
  {
  bw->b->changed=0;
  saverr(bw->b->name);
  return uabort(bw,MAXINT);
  }
 }

static int doex(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 bw->b->name=joesep(strdup(s)); 
 return dosave(bw,s,exdone,notify);
 }

int uexsve(bw)
BW *bw;
 {
 if(!bw->b->changed) { uabort(bw,MAXINT); return 0; }
 else if(bw->b->name && !exask)
  {
  return dosave(bw,vsncpy(NULL,0,sz(bw->b->name)),exdone1,NULL);
  } 
 else
  {
  BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,doex,"Names",NULL,cmplt,NULL,NULL);
  if(pbw && bw->b->name)
   {
   binss(pbw->cursor,bw->b->name);
   pset(pbw->cursor,pbw->b->eof);
   pbw->cursor->xcol=piscol(pbw->cursor);
   }
  if(pbw) return 0;
  else return -1;
  }
 }
d647 48
a694 38
static int nask(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='y' || c=='Y')
  if(bw->b->name) return dosave1(bw,vsncpy(NULL,0,sz(bw->b->name)),object,notify);
  else
   {
   BW *pbw=wmkpw(bw,
                 "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,object,notify);
   if(pbw) return 0;
   else return -1;
   }
 else if(c=='n' || c=='N')
  {
  genexmsg(bw,0,NULL);
  if(notify) *notify=1;
  return 0;
  }
 else
  if(bw->b->count==1 && bw->b->changed)
   {
   if(mkqw(bw,sc("Save changes to this file (y,n,^C)? "),nask,NULL,object,notify)) return 0;
   else return -1;
   }
  else
   {
   if(notify) *notify=1;
   return 0;
   }
 }

int uask(bw)
BW *bw;
 {
 return nask(bw,0,NULL,NULL);
 }
d698 45
a742 36
static int nask2(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='y' || c=='Y')
  {
  BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,object,notify);
  if(pbw) return 0;
  else return -1;
  }
 else if(c=='n' || c=='N')
  {
  genexmsg(bw,0,NULL);
  if(notify) *notify=1;
  return 0;
  }
 else
  if(bw->b->count==1 && bw->b->changed)
   {
   if(mkqw(bw,sc("Save changes to this file (y,n,^C)? "),nask,NULL,object,notify)) return 0;
   else return -1;
   }
  else
   {
   if(notify) *notify=1;
   return 0;
   }
 }

int uask2(bw)
BW *bw;
 {
 return nask2(bw,0,NULL,NULL);
 }
d746 41
a786 29
int dolose(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 W *w;
 if(notify) *notify=1;
 if(c!='y' && c!='Y') return -1;
 genexmsg(bw,0,NULL);
 if(bw->b->count==1) bw->b->changed=0;
 object=bw->object; w=bw->parent;
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,bfind(""),0));
 wredraw(bw->parent);
 bw->object=object;
 if(bw->o.mnew) exemac(bw->o.mnew);
 return 0;
 }

int ulose(bw)
BW *bw;
 {
 msgnw(bw,NULL);
 if(bw->pid) return ukillpid(bw);
 if(bw->b->count==1 && bw->b->changed)
  if(mkqw(bw,sc("Lose changes to this file (y,n,^C)? "),dolose,NULL,NULL,NULL)) return 0;
  else return -1;
 else return dolose(bw,'y',NULL,NULL);
 }
d790 20
a809 30
int dobuf(m,x,s)
MENU *m;
char **s;
 {
 char *name;
 BW *bw=m->parent->win->object;
 int *notify=m->parent->notify;
 m->parent->notify=0;
 name=vsdup(s[x]);
 uabort(m,MAXINT);
 return dorepl(bw,name,NULL,notify);
 }

int abrtb(m,x,s)
MENU *m;
char **s;
 {
 varm(s);
 return -1;
 }

int ubufed(bw)
BW *bw;
 {
 char **s=getbufs();
 vasort(av(s));
 if(mkmenu(bw,s,dobuf,abrtb,NULL,0,s,NULL)) return 0;
 else
  {
  varm(s);
d811 16
a826 2
  }
 }
@


1.1
log
@Initial revision
@
text
@d23 1
d201 1
a201 1
  for(x=zlen(name);name[--x]!='.';)
d204 1
a204 1
    x=zlen(name);
d208 1
a208 1
  zcpy(name+x,".bak");
d284 2
a285 2
  if(!bw->b->name) bw->b->name=joesep(zdup(req->name));
  if(!zcmp(bw->b->name,req->name))
d336 1
a336 1
 if(s[0]!='!' && !(s[0]=='>' && s[1]=='>') && (!bw->b->name || zcmp(s,bw->b->name)))
d570 1
a570 1
 bw->b->name=joesep(zdup(s)); 
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
