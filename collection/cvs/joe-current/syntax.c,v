head	1.47;
access;
symbols
	joe_3_5:1.41
	joe-3_4:1.35
	help:1.35
	joe_3_1:1.21
	joe_3_0:1.10;
locks; strict;
comment	@ * @;


1.47
date	2008.11.23.20.45.12;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.30.22.30.03;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.28.02.34.35;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.05.02.23.14;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.03.23.37.01;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.01.18.17.15;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.01.03.08.20;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.19.17.00.56;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.16.05.04.20;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.12.02.07.05;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.05.18.18.45;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.03.21.01.31;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.28.23.36.52;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.12.15.00.55;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.11.21.03.22;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.10.15.42.26;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.21.14.47.42;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.07.19.59.51;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.24.20.57.26;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.20.02.59.08;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.06.03.47.29;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.05.00.09.15;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.03.18.29.00;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.02.23.45.00;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.29.15.41.14;	author jhallen;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.28.23.29.41;	author jhallen;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.28.03.37.05;	author jhallen;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.23.02.14.08;	author jhallen;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.18.04.36.12;	author jhallen;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.15.14.29.08;	author jhallen;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.14.18.09.23;	author jhallen;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.13.20.41.33;	author jhallen;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.08.14.05.24;	author jhallen;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.07.00.19.20;	author jhallen;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.30.05.10.15;	author jhallen;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Stack reset fix to coroutine versions.
@
text
@/*
 *	Syntax highlighting DFA interpreter
 *	Copyright
 *		(C) 2004 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */

#include "types.h"

/* Parse one line.  Returns new state.
   'syntax' is the loaded syntax definition for this buffer.
   'line' is advanced to start of next line.
   Global array 'attr_buf' end up with coloring for each character of line.
   'state' is initial parser state for the line (0 is initial state).
*/

int *attr_buf = 0;
int attr_size = 0;

int stack_count = 0;

HIGHLIGHT_STATE parse(struct high_syntax *syntax,P *line,HIGHLIGHT_STATE h_state)
{
	struct high_frame *stack = h_state.stack;
	struct high_state *h = (stack ? stack->syntax : syntax)->states[h_state.state];
			/* Current state */
	unsigned char buf[24];		/* Name buffer (trunc after 23 characters) */
	unsigned char lbuf[24];		/* Lower case version of name buffer */
	unsigned char lsaved_s[24];	/* Lower case version of delimiter match buffer */
	int buf_idx=0;	/* Index into buffer */
	int c;		/* Current character */
	int *attr = attr_buf;
	int *attr_end = attr_buf+attr_size;
	int buf_en = 0;	/* Set for name buffering */
	int ofst = 0;	/* record offset after we've stopped buffering */
	int mark1 = 0;  /* offset to mark start from current pos */
	int mark2 = 0;  /* offset to mark end from current pos */
	int mark_en = 0;/* set if marking */
	int recolor_delimiter_or_keyword;

	buf[0]=0;	/* Forgot this originally... took 5 months to fix! */

	/* Get next character */
	while((c=pgetc(line))!=NO_MORE_DATA) {
		struct high_cmd *cmd, *kw_cmd;
		int x;

		/* Hack so we can have UTF-8 characters without crashing */
		if (c < 0 || c > 255)
			c = 0x1F;

		/* Create or expand attribute array if necessary */
		if(attr==attr_end) {
			if(!attr_buf) {
				attr_size = 1024;
				attr_buf = joe_malloc(sizeof(int)*attr_size);
				attr = attr_buf;
			} else {
				attr_buf = joe_realloc(attr_buf,sizeof(int)*(attr_size*2));
				attr = attr_buf + attr_size;
				attr_size *= 2;
			}
			attr_end = attr_buf + attr_size;
		}

		/* Advance to next attribute position (note attr[-1] below) */
		attr++;

		/* Loop while noeat */
		do {
			/* Color with current state */
			attr[-1] = h->color;

			/* Get command for this character */
			if (h->delim && c == h_state.saved_s[0] && h_state.saved_s[1] == 0)
				cmd = h->delim;
			else
				cmd = h->cmd[c];

			/* Lowerize strings for case-insensitive matching */
			if (cmd->ignore) {
				zcpy(lbuf,buf);
				lowerize(lbuf);
				if (cmd->delim) {
					zcpy(lsaved_s,h_state.saved_s);
					lowerize(lsaved_s);
				}
			}

			/* Check for delimiter or keyword matches */
			recolor_delimiter_or_keyword = 0;
			if (cmd->delim && (cmd->ignore ? !zcmp(lsaved_s,lbuf) : !zcmp(h_state.saved_s,buf))) {
				cmd = cmd->delim;
				recolor_delimiter_or_keyword = 1;
			} else if (cmd->keywords && (cmd->ignore ? (kw_cmd=htfind(cmd->keywords,lbuf)) : (kw_cmd=htfind(cmd->keywords,buf)))) {
				cmd = kw_cmd;
				recolor_delimiter_or_keyword = 1;
			}

			/* Determine new state */
			if (cmd->call) {
				/* Call */
				struct high_frame **frame_ptr = stack ? &stack->child : &syntax->stack_base;
				/* Search for an existing stack frame for this call */
				while (*frame_ptr && !((*frame_ptr)->syntax == cmd->call && (*frame_ptr)->return_state == cmd->new_state))
					frame_ptr = &(*frame_ptr)->sibling;
				if (*frame_ptr)
					stack = *frame_ptr;
				else {
					struct high_frame *frame = joe_malloc(sizeof(struct high_frame));
					frame->parent = stack;
					frame->child = 0;
					frame->sibling = 0;
					frame->syntax = cmd->call;
					frame->return_state = cmd->new_state;
					*frame_ptr = frame;
					stack = frame;
					++stack_count;
				}
				h = stack->syntax->states[0];
			} else if (cmd->rtn) {
				/* Return */
				if (stack) {
					h = stack->return_state;
					stack = stack->parent;
				} else
					/* Not in a subroutine, so ignore the return */
					h = cmd->new_state;
			} else if (cmd->reset) {
				/* Reset the state and call stack */
				h = syntax->states[0];
				stack = 0;
			} else {
				/* Normal edge */
				h = cmd->new_state;
			}

			/* Recolor if necessary */
			if (recolor_delimiter_or_keyword)
				for(x= -(buf_idx+1);x<-1;++x)
					attr[x-ofst] = h->color;
			for(x=cmd->recolor;x<0;++x)
				if (attr + x >= attr_buf)
					attr[x] = h->color;

			/* Mark recoloring */
			if (cmd->recolor_mark)
				for(x= -mark1;x<-mark2;++x)
					attr[x] = h->color;

			/* Save string? */
			if (cmd->save_s)
				zcpy(h_state.saved_s,buf);

			/* Save character? */
			if (cmd->save_c) {
				h_state.saved_s[1] = 0;
				if (c=='<')
					h_state.saved_s[0] = '>';
				else if (c=='(')
					h_state.saved_s[0] = ')';
				else if (c=='[')
					h_state.saved_s[0] = ']';
				else if (c=='{')
					h_state.saved_s[0] = '}';
				else if (c=='`')
					h_state.saved_s[0] = '\'';
				else
					h_state.saved_s[0] = c;
			}

			/* Start buffering? */
			if (cmd->start_buffering) {
				buf_idx = 0;
				buf_en = 1;
				ofst = 0;
			}

			/* Stop buffering? */
			if (cmd->stop_buffering)
				buf_en = 0;

			/* Set mark begin? */
			if (cmd->start_mark)
			{
				mark2 = 1;
				mark1 = 1;
				mark_en = 1;
			}

			/* Set mark end? */
			if(cmd->stop_mark)
			{
				mark_en = 0;
				mark2 = 1;
			}
		} while(cmd->noeat);

		/* Save character in buffer */
		if (buf_idx<23 && buf_en)
			buf[buf_idx++]=c;
		if (!buf_en)
			++ofst;
		buf[buf_idx] = 0;

		/* Update mark pointers */
		++mark1;
		if(!mark_en)
			++mark2;

		if(c=='\n')
			break;
	}
	/* Return new state */
	h_state.stack = stack;
	h_state.state = h->no;
	return h_state;
}

/* Subroutines for load_dfa() */

static struct high_state *find_state(struct high_syntax *syntax,unsigned char *name)
{
	struct high_state *state;

	/* Find state */
	state = htfind(syntax->ht_states, name);

	/* It doesn't exist, so create it */
	if(!state) {
		int y;
		state=joe_malloc(sizeof(struct high_state));
		state->name=zdup(name);
		state->no=syntax->nstates;
		state->color=FG_WHITE;
		/* Expand the state table if necessary */
		if(syntax->nstates==syntax->szstates)
			syntax->states=joe_realloc(syntax->states,sizeof(struct high_state *)*(syntax->szstates*=2));
		syntax->states[syntax->nstates++]=state;
		for(y=0; y!=256; ++y)
			state->cmd[y] = &syntax->default_cmd;
		state->delim = 0;
		htadd(syntax->ht_states, state->name, state);
	}
	return state;
}

/* Create empty command */

static void iz_cmd(struct high_cmd *cmd)
{
	cmd->noeat = 0;
	cmd->recolor = 0;
	cmd->start_buffering = 0;
	cmd->stop_buffering = 0;
	cmd->save_c = 0;
	cmd->save_s = 0;
	cmd->new_state = 0;
	cmd->keywords = 0;
	cmd->delim = 0;
	cmd->ignore = 0;
	cmd->start_mark = 0;
	cmd->stop_mark = 0;
	cmd->recolor_mark = 0;
	cmd->rtn = 0;
	cmd->reset = 0;
	cmd->call = 0;
}

static struct high_cmd *mkcmd()
{
	struct high_cmd *cmd = joe_malloc(sizeof(struct high_cmd));
	iz_cmd(cmd);
	return cmd;
}

/* Globally defined colors */

struct high_color *global_colors;

struct high_color *find_color(struct high_color *colors,unsigned char *name,unsigned char *syn)
{
	unsigned char *bf = vsmk(128);
	struct high_color *color;
	bf = vsfmt(bf, 0, USTR "%s.%s", syn, name);
	for (color = colors; color; color = color->next)
		if (!zcmp(color->name,bf)) break;
	if (color)
		return color;
	for (color = colors; color; color = color->next)
		if (!zcmp(color->name,name)) break;
	obj_free(bf);
	return color;
}

void parse_color_def(struct high_color **color_list,unsigned char *p,unsigned char *name,int line)
{
	unsigned char *bf = 0;
	if(!parse_tows(&p, &bf)) {
		struct high_color *color, *gcolor;

		/* Find color */
		color=find_color(*color_list,bf,name);

		/* If it doesn't exist, create it */
		if(!color) {
			color = joe_malloc(sizeof(struct high_color));
			color->name = zdup(bf);
			color->color = 0;
			color->next = *color_list;
			*color_list = color;
		} else {
			i_printf_2((char *)joe_gettext(_("%s %d: Class already defined\n")),name,line);
		}

		/* Find it in global list */
		if (color_list != &global_colors && (gcolor=find_color(global_colors,bf,name))) {
			color->color = gcolor->color;
		} else {
			/* Parse color definition */
			while(parse_ws(&p,'#'), !parse_ident(&p,&bf)) {
				color->color |= meta_color(bf);
			}
		}
	} else {
		i_printf_2((char *)joe_gettext(_("%s %d: Missing class name\n")),name,line);
	}
}

/* Load syntax file */

struct high_syntax *syntax_list;

/* Dump sytnax file */

void dump_syntax(BW *bw)
{
	struct high_syntax *syntax;
	struct high_param *params;
	unsigned char *buf = 0;
	buf = vsfmt(buf, 0, USTR "Allocated %d stack frames\n", stack_count);
	binss(bw->cursor, buf);
	pnextl(bw->cursor);
	for (syntax = syntax_list; syntax; syntax = syntax->next) {
		int x;
		buf = vsfmt(buf, 0, USTR "Syntax name=%s, subr=%s, nstates=%d\n",syntax->name,syntax->subr,syntax->nstates);
		binss(bw->cursor, buf);
		pnextl(bw->cursor);
		buf = vsdupz(USTR "params=(");
		for(params = syntax->params; params; params = params->next) {
			buf = vscatz(buf, USTR " ");
			buf = vscatz(buf, params->name);
		}
		buf = vscatz(buf, USTR " )\n");
		binss(bw->cursor, buf);
		pnextl(bw->cursor);
		for(x=0;x!=syntax->nstates;++x) {
			int y;
			int f = -1;
			struct high_state *s = syntax->states[x];
			buf = vsfmt(buf, 0, USTR "   state %s %x\n",s->name,s->color);
			binss(bw->cursor, buf);
			pnextl(bw->cursor);
			for (y = 0; y != 256; ++y) {
				if (f == -1)
					f = y;
				else if (s->cmd[f]->new_state != s->cmd[y]->new_state) {
					buf = vsfmt(buf, 0, USTR "     [%d-%d] -> %s %d\n",f,y-1,(s->cmd[f]->new_state ? s->cmd[f]->new_state->name : USTR "ERROR! Unknown state!"),s->cmd[f]->recolor);
					binss(bw->cursor, buf);
					pnextl(bw->cursor);
					f = y;
				}
			}
			buf = vsfmt(buf, 0, USTR "     [%d-%d] -> %s %d\n",f,y-1,(s->cmd[f]->new_state ? s->cmd[f]->new_state->name : USTR "ERROR! Unknown state!"),s->cmd[f]->recolor);
			binss(bw->cursor, buf);
			pnextl(bw->cursor);
		}
	}
}

struct high_param *parse_params(struct high_param *current_params,unsigned char **ptr,unsigned char *name,int line)
{
	unsigned char *p = *ptr;
	unsigned char *bf = 0;
	struct high_param *params;
	struct high_param **param_ptr;

	/* Propagate currently defined parameters */
	param_ptr = &params;
	while (current_params) {
		*param_ptr = joe_malloc(sizeof(struct high_param));
		(*param_ptr)->name = zdup(current_params->name);
		param_ptr = &(*param_ptr)->next;
		current_params = current_params->next;
	}
	*param_ptr = 0;

	parse_ws(&p, '#');
	if (!parse_char(&p, '(')) {
		for (;;) {
			parse_ws(&p, '#');
			if (!parse_char(&p, ')'))
				break;
			else if (!parse_char(&p, '-')) {
				if (!parse_ident(&p,&bf)) {
					int cmp = 0;
					param_ptr = &params;
					/* Parameters are sorted */
					while (*param_ptr && (cmp = zcmp(bf,(*param_ptr)->name)) > 0)
						param_ptr = &(*param_ptr)->next;
					if (*param_ptr && !cmp) {
						/* Remove this parameter */
						struct high_param *param = *param_ptr;
						*param_ptr = param->next;
						joe_free(param);
					}
				} else {
					i_printf_2((char *)joe_gettext(_("%s %d: Missing parameter name\n")),name,line);
				}
			} else if (!parse_ident(&p,&bf)) {
				int cmp = 0;
				param_ptr = &params;
				/* Keep parameters sorted */
				while (*param_ptr && (cmp = zcmp(bf,(*param_ptr)->name)) > 0)
					param_ptr = &(*param_ptr)->next;
				/* Discard duplicates */
				if (!*param_ptr || cmp) {
					struct high_param *param = joe_malloc(sizeof(struct high_param));
					param->name = zdup(bf);
					param->next = *param_ptr;
					*param_ptr = param;
				}
			} else {
				i_printf_2((char *)joe_gettext(_("%s %d: Missing )\n")),name,line);
				break;
			}
		}
	}

	obj_free(bf);
	*ptr = p;
	return params;
}


struct high_syntax *load_syntax_subr(unsigned char *name,unsigned char *subr,struct high_param *params);

/* Parse options */

void parse_options(struct high_syntax *syntax,struct high_cmd *cmd,FILE *f,unsigned char *p,int parsing_strings,unsigned char *name,int line)
{
	unsigned char *buf = vsmk(128);
	unsigned char *bf = 0;
	unsigned char *bf1 = 0;

	while (parse_ws(&p,'#'), !parse_ident(&p,&bf))
		if(!zcmp(bf,USTR "buffer")) {
			cmd->start_buffering = 1;
		} else if(!zcmp(bf,USTR "hold")) {
			cmd->stop_buffering = 1;
		} else if(!zcmp(bf,USTR "save_c")) {
			cmd->save_c = 1;
		} else if(!zcmp(bf,USTR "save_s")) {
			cmd->save_s = 1;
		} else if(!zcmp(bf,USTR "recolor")) {
			parse_ws(&p,'#');
			if(!parse_char(&p,'=')) {
				parse_ws(&p,'#');
				if(parse_int(&p,&cmd->recolor))
					i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
			} else
				i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
		} else if(!zcmp(bf,USTR "call")) {
			parse_ws(&p,'#');
			if(!parse_char(&p,'=')) {
				parse_ws(&p,'#');
				if (!parse_char(&p,'.')) {
					bf = vsdupz(syntax->name);
					goto subr;
				} else if (parse_ident(&p,&bf))
					i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
				else {
					if (!parse_char(&p,'.')) {
						subr:
						if (parse_ident(&p,&bf1))
							i_printf_2((char *)joe_gettext(_("%s %d: Missing subroutine name\n")),name,line);
					} else
						bf1 = 0;
					cmd->call = load_syntax_subr(bf,bf1,parse_params(syntax->params,&p,name,line));
				}
			} else
				i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
		} else if(!zcmp(bf,USTR "return")) {
			cmd->rtn = 1;
		} else if(!zcmp(bf,USTR "reset")) {
			cmd->reset = 1;
		} else if(!parsing_strings && (!zcmp(bf,USTR "strings") || !zcmp(bf,USTR "istrings"))) {
			if (bf[0]=='i')
				cmd->ignore = 1;
			while(vsgets(&buf,f)) {
				++line;
				p = buf;
				parse_ws(&p,'#');
				if (*p) {
					if(!parse_field(&p,USTR "done"))
						break;
					if(parse_string(&p,&bf) >= 0) {
						parse_ws(&p,'#');
						if (cmd->ignore)
							lowerize(bf);
						if(!parse_ident(&p,&bf1)) {
							struct high_cmd *kw_cmd=mkcmd();
							kw_cmd->noeat=1;
							kw_cmd->new_state = find_state(syntax,bf1);
							if (!zcmp(bf, USTR "&")) {
								cmd->delim = kw_cmd;
							} else {
								if(!cmd->keywords)
									cmd->keywords = htmk(64);
								htadd(cmd->keywords,zdup(bf),kw_cmd);
							}
							parse_options(syntax,kw_cmd,f,p,1,name,line);
						} else
							i_printf_2((char *)joe_gettext(_("%s %d: Missing state name\n")),name,line);
					} else
						i_printf_2((char *)joe_gettext(_("%s %d: Missing string\n")),name,line);
				}
			}
		} else if(!zcmp(bf,USTR "noeat")) {
			cmd->noeat = 1;
		} else if(!zcmp(bf,USTR "mark")) {
			cmd->start_mark = 1;
		} else if(!zcmp(bf,USTR "markend")) {
			cmd->stop_mark = 1;
		} else if(!zcmp(bf,USTR "recolormark")) {
			cmd->recolor_mark = 1;
		} else
			i_printf_2((char *)joe_gettext(_("%s %d: Unknown option\n")),name,line);
	obj_free(buf);
}

struct ifstack {
	struct ifstack *next;
	int ignore;	/* Ignore input lines if set */
	int skip;	/* Set to skip the else part */
	int else_part;	/* Set if we're in the else part */
	int line;
};

/* Load dfa */

struct high_state *load_dfa(struct high_syntax *syntax)
{
	unsigned char *name = vsmk(128);
	unsigned char *buf = vsmk(128);
	unsigned char *bf = 0;
	int clist[256];
	unsigned char *p;
	int c;
	FILE *f = 0;
	struct ifstack *stack=0;
	struct high_state *state=0;	/* Current state */
	struct high_state *first=0;	/* First state */
	int line = 0;
	int this_one = 0;
	int inside_subr = 0;

	/* Load it */
	p = (unsigned char *)getenv("HOME");
	if (p) {
		name = vsfmt(name, 0, USTR "%s/.joe/syntax/%s.jsf",p,syntax->name);
		f = fopen((char *)name,"r");
	}

	if (!f) {
		name = vsfmt(name, 0, USTR "%ssyntax/%s.jsf",JOEDATA,syntax->name);
		f = fopen((char *)name,"r");
	}
	if(!f) {
		obj_free(name);
		return 0;
	}

	/* Parse file */
	while(vsgets(&buf,f)) {
		++line;
		p = buf;
		c = parse_ws(&p,'#');
		if (!parse_char(&p, '.')) {
			if (!parse_ident(&p, &bf)) {
				if (!zcmp(bf, USTR "ifdef")) {
					struct ifstack *st = joe_malloc(sizeof(struct ifstack));
					st->next = stack;
					st->else_part = 0;
					st->ignore = 1;
					st->skip = 1;
					st->line = line;
					if (!stack || !stack->ignore) {
						parse_ws(&p,'#');
						if (!parse_ident(&p, &bf)) {
							struct high_param *param;
							for (param = syntax->params; param; param = param->next)
								if (!zcmp(param->name, bf)) {
									st->ignore = 0;
									break;
								}
							st->skip = 0;
						} else {
							i_printf_2((char *)joe_gettext(_("%s %d: missing parameter for ifdef\n")),name,line);
						}
					}
					stack = st;
				} else if (!zcmp(bf, USTR "else")) {
					if (stack && !stack->else_part) {
						stack->else_part = 1;
						if (!stack->skip)
							stack->ignore = !stack->ignore;
					} else
						i_printf_2((char *)joe_gettext(_("%s %d: else with no matching if\n")),name,line);
				} else if (!zcmp(bf, USTR "endif")) {
					if (stack) {
						struct ifstack *st = stack;
						stack = st->next;
						joe_free(st);
					} else
						i_printf_2((char *)joe_gettext(_("%s %d: endif with no matching if\n")),name,line);
				} else if (!zcmp(bf, USTR "subr")) {
					parse_ws(&p, '#');
					if (parse_ident(&p, &bf)) {
						i_printf_2((char *)joe_gettext(_("%s %d: Missing subroutine name\n")),name,line);
					} else {
						if (!stack || !stack->ignore) {
							inside_subr = 1;
							this_one = 0;
							if (syntax->subr && !zcmp(bf, syntax->subr))
								this_one = 1;
						}
					}
				} else if (!zcmp(bf, USTR "end")) {
					if (!stack || !stack->ignore) {
						this_one = 0;
						inside_subr = 0;
					}
				} else {
					i_printf_2((char *)joe_gettext(_("%s %d: Unknown control statement\n")),name,line);
				}
			} else {
				i_printf_2((char *)joe_gettext(_("%s %d: Missing control statement name\n")),name,line);
			}
		} else if (stack && stack->ignore) {
			/* Ignore this line because of ifdef */
		} else if(!parse_char(&p, '=')) {
			/* Parse color */
			parse_color_def(&syntax->color,p,name,line);
		} else if ((syntax->subr && !this_one) || (!syntax->subr && inside_subr)) {
			/* Ignore this line because it's not the code we want */
		} else if(!parse_char(&p, ':')) {
			if(!parse_ident(&p, &bf)) {

				state = find_state(syntax,bf);

				if (!first)
					first = state;

				parse_ws(&p,'#');
				if(!parse_tows(&p,&bf)) {
					struct high_color *color;
					for(color=syntax->color;color;color=color->next)
						if(!zcmp(color->name,bf))
							break;
					if(color)
						state->color=color->color;
					else {
						state->color=0;
						i_printf_2((char *)joe_gettext(_("%s %d: Unknown class\n")),name,line);
					}
				} else
					i_printf_2((char *)joe_gettext(_("%s %d: Missing color for state definition\n")),name,line);
			} else
				i_printf_2((char *)joe_gettext(_("%s %d: Missing state name\n")),name,line);
		} else if(!parse_char(&p, '-')) {
			/* No. sync lines ignored */
		} else {
			c = parse_ws(&p,'#');

			if (!c) {
			} else if (c=='"' || c=='*' || c=='&') {
				if (state) {
					struct high_cmd *cmd;
					int delim = 0;
					if(!parse_field(&p, USTR "*")) {
						int z;
						for(z=0;z!=256;++z)
							clist[z] = 1;
					} else if(!parse_field(&p, USTR "&")) {
						delim = 1;
					} else {
						c = parse_string(&p, &bf);
						if(c < 0)
							i_printf_2((char *)joe_gettext(_("%s %d: Bad string\n")),name,line);
						else {
							int z;
							int first, second;
							unsigned char *t = bf;
							for(z=0;z!=256;++z)
								clist[z] = 0;
							while(!parse_range(&t, &first, &second)) {
								if(first>second)
									second = first;
								while(first<=second)
									clist[first++] = 1;
							}
						}
					}
					/* Create command */
					cmd = mkcmd();
					parse_ws(&p,'#');
					if(!parse_ident(&p,&bf)) {
						int z;
						cmd->new_state = find_state(syntax,bf);
						parse_options(syntax,cmd,f,p,0,name,line);

						/* Install command */
						if (delim)
							state->delim = cmd;
						else for(z=0;z!=256;++z)
							if(clist[z])
								state->cmd[z]=cmd;
					} else
						i_printf_2((char *)joe_gettext(_("%s %d: Missing jump\n")),name,line);
				} else
					i_printf_2((char *)joe_gettext(_("%s %d: No state\n")),name,line);
			} else
				i_printf_2((char *)joe_gettext(_("%s %d: Unknown character\n")),name,line);
		}
	}

	while (stack) {
		struct ifstack *st = stack;
		stack = st->next;
		i_printf_2((char *)joe_gettext(_("%s %d: ifdef with no matching endif\n")),name,st->line);
		joe_free(st);
	}

	fclose(f);

	obj_free(name);
	return first;
}

int syntax_match(struct high_syntax *syntax,unsigned char *name,unsigned char *subr,struct high_param *params)
{
	struct high_param *syntax_params;
	if (zcmp(syntax->name,name))
		return 0;
	if (!syntax->subr ^ !subr)
		return 0;
	if (subr && zcmp(syntax->subr,subr))
		return 0;
	syntax_params = syntax->params;
	while (syntax_params && params) {
		if (zcmp(syntax_params->name,params->name))
			return 0;
		syntax_params = syntax_params->next;
		params = params->next;
	}
	return syntax_params == params;
}

struct high_syntax *load_syntax_subr(unsigned char *name,unsigned char *subr,struct high_param *params)
{
	struct high_syntax *syntax;	/* New syntax table */

	/* Find syntax table */

	/* Already loaded? */
	for(syntax=syntax_list;syntax;syntax=syntax->next)
		if(syntax_match(syntax,name,subr,params))
			return syntax;

	/* Create new one */
	syntax = joe_malloc(sizeof(struct high_syntax));
	syntax->name = zdup(name);
	syntax->subr = subr ? zdup(subr) : 0;
	syntax->params = params;
	syntax->next = syntax_list;
	syntax->nstates = 0;
	syntax->color = 0;
	syntax->states = joe_malloc(sizeof(struct high_state *)*(syntax->szstates = 64));
	syntax->ht_states = htmk(syntax->szstates);
	iz_cmd(&syntax->default_cmd);
	syntax->default_cmd.reset = 1;
	syntax->stack_base = 0;
	syntax_list = syntax;

	if (load_dfa(syntax)) {
		/* dump_syntax(syntax); */
		return syntax;
	} else {
		if(syntax_list == syntax)
			syntax_list = syntax_list->next;
		else {
			struct high_syntax *syn;
			for(syn=syntax_list;syn->next!=syntax;syn=syn->next);
			syn->next = syntax->next;
		}
		htrm(syntax->ht_states);
		joe_free(syntax->name);
		joe_free(syntax->states);
		joe_free(syntax);
		return 0;
	}
}

struct high_syntax *load_syntax(unsigned char *name)
{
	if (!name)
		return 0;

	return load_syntax_subr(name,0,0);
}
@


1.46
log
@Fix more compiler warnings.  Update builtins.c
@
text
@d119 1
d133 1
a133 1
				stack = syntax->stack_base;
@


1.45
log
@Syntax highlighter stack
@
text
@a454 1
	int c;
d503 1
a503 1
				c = parse_ws(&p,'#');
@


1.44
log
@Update configure scripts to use docdir and datadir
@
text
@d21 2
d25 2
a26 1
	struct high_state *h = syntax->states[h_state.state];
d33 1
a34 1
	int *attr = attr_buf;
d40 1
d53 1
a53 1
		/* Expand attribute array if necessary */
d55 9
a63 3
			attr_buf = joe_realloc(attr_buf,sizeof(int)*(attr_size*2));
			attr = attr_buf + attr_size;
			attr_size *= 2;
d74 1
d76 1
a76 1
			if (h->delim && c == h_state.saved_s[0])
d80 1
d90 3
a92 1
			/* Determine new state */
d95 1
a95 4
				h = cmd->new_state;
				/* Recolor string delimiter */
				for(x= -(buf_idx+1);x<-1;++x)
					attr[x-ofst] = h -> color;
d98 35
a132 4
				h = cmd->new_state;
				/* Recolor keyword */
				for(x= -(buf_idx+1);x<-1;++x)
					attr[x-ofst] = h -> color;
d134 1
d137 1
d139 3
d144 1
a144 1
					attr[x] = h -> color;
d149 1
a149 1
					attr[x] = h -> color;
d182 1
a182 1
				
d190 1
a190 1
				
d205 1
a205 1
		
d214 2
a215 1
	/* Return new state number */
d222 1
a222 1
static struct high_state *find_state(struct high_syntax *syntax,unsigned char *prefix,unsigned char *name)
a223 1
	unsigned char *buf = vsmk(128);
a225 3
	buf = vscatz(buf, prefix);
	buf = vscatz(buf, name);

d227 1
a227 1
	state = htfind(syntax->ht_states, buf);
d233 1
a233 1
		state->name=zdup(buf);
d236 1
a236 3
		if(!syntax->nstates)
			/* We're the first state */
			syntax->default_cmd.new_state = state;
a244 1
	obj_free(buf);
d265 2
a267 2
	cmd->call_subr = 0;
	cmd->parms = 0;
d325 2
d339 1
d341 3
d346 9
a354 1
		buf = vsfmt(buf, 0, USTR "Syntax name=%s, nstates=%d\n",syntax->name,syntax->nstates);
d368 1
a368 1
					buf = vsfmt(buf, 0, USTR "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d374 1
a374 1
			buf = vsfmt(buf, 0, USTR "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d381 1
a381 9
struct ifstack {
	struct ifstack *next;
	int ignore;	/* Ignore input lines if set */
	int skip;	/* Set to skip the else part */
	int else_part;	/* Set if we're in the else part */
	int line;
};

struct syparm *parse_parms(unsigned char **ptr,unsigned char *name,int line)
d385 12
a396 1
	struct syparm *sy = 0;
d404 29
a432 5
			else if (!parse_ident(&p,&bf)) {
				struct syparm *n = (struct syparm *)joe_malloc(sizeof(struct syparm));
				n->next = sy;
				sy = n;
				n->name = zdup(bf);
d440 1
d442 1
a442 1
	return sy;
d445 6
a450 2
struct high_state *append_dfa(struct high_syntax *syntax, unsigned char *prefix, unsigned char *name, struct high_state *rtn,
                              int *needs_link,struct syparm *parms,unsigned char *subr)
a451 1
	unsigned char *full_name = vsmk(128);
d455 103
a567 1
	unsigned char *short_name = name;
d572 2
a573 2
		full_name = vsfmt(full_name, 0, USTR "%s/.joe/syntax/%s.jsf",p,name);
		f = fopen((char *)full_name,"r");
d577 2
a578 2
		full_name = vsfmt(full_name, 0, USTR "%ssyntax/%s.jsf",JOEDATA,name);
		f = fopen((char *)full_name,"r");
d580 2
a581 1
	if(!f)
d583 1
a583 4
	name = full_name;

	/* Color are always file local */
	syntax->color = 0;
d593 1
a593 1
					struct ifstack *st = (struct ifstack *)joe_malloc(sizeof(struct ifstack));
d602 4
a605 3
							struct syparm *sy;
							for (sy = parms; sy; sy = sy->next)
								if (!zcmp(sy->name, bf))
d607 1
a607 2
							if (sy)
								st->ignore = 0;
d636 1
a636 1
							if (subr && !zcmp(bf, subr))
d656 1
a656 1
		} else if ((subr && !this_one) || (!subr && inside_subr)) {
d661 1
a661 1
				state = find_state(syntax,prefix,bf);
d667 1
a667 1
				if(!parse_ident(&p,&bf)) {
d682 2
a683 3
		} else if(!parse_char(&p, '-')) { /* No. sync lines */
			if(parse_int(&p, &syntax->sync_lines))
				syntax->sync_lines = -1;
d721 2
a722 102
						cmd->new_state = find_state(syntax,prefix,bf);

						/* Parse options */
						while (parse_ws(&p,'#'), !parse_ident(&p,&bf))
							if(!zcmp(bf,USTR "buffer")) {
								cmd->start_buffering = 1;
							} else if(!zcmp(bf,USTR "hold")) {
								cmd->stop_buffering = 1;
							} else if(!zcmp(bf,USTR "return")) {
								if (rtn)
									cmd->new_state = rtn;
							} else if(!zcmp(bf,USTR "save_c")) {
								cmd->save_c = 1;
							} else if(!zcmp(bf,USTR "save_s")) {
								cmd->save_s = 1;
							} else if(!zcmp(bf,USTR "recolor")) {
								parse_ws(&p,'#');
								if(!parse_char(&p,'=')) {
									parse_ws(&p,'#');
									if(parse_int(&p,&cmd->recolor))
										i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
								} else
									i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
							} else if(!zcmp(bf,USTR "call")) {
								parse_ws(&p,'#');
								if(!parse_char(&p,'=')) {
									parse_ws(&p,'#');
									if (!parse_char(&p,'.')) {
										cmd->call = zdup(short_name);
										goto subr;
									} else if (parse_ident(&p,&bf1))
										i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
									else {
										cmd->call = zdup(bf1);
										if (!parse_char(&p,'.')) {
											subr:
											if (parse_ident(&p,&bf1))
												i_printf_2((char *)joe_gettext(_("%s %d: Missing subroutine name\n")),name,line);
											else
												cmd->call_subr = zdup(bf1);
										}
										*needs_link = 1;
										cmd->parms = parse_parms(&p,name,line);
									}
								} else
									i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
							} else if(!zcmp(bf,USTR "strings") || !zcmp(bf,USTR "istrings")) {
								if (bf[0]=='i')
									cmd->ignore = 1;
								while(vsgets(&buf,f)) {
									++line;
									p = buf;
									c = parse_ws(&p,'#');
									if (*p) {
										if(!parse_field(&p,USTR "done"))
											break;
										if(parse_string(&p,&bf) >= 0) {
											parse_ws(&p,'#');
											if (cmd->ignore)
												lowerize(bf);
											if(!parse_ident(&p,&bf1)) {
												struct high_cmd *kw_cmd=mkcmd();
												kw_cmd->noeat=1;
												kw_cmd->new_state = find_state(syntax,prefix,bf1);
												if (!zcmp(bf, USTR "&")) {
													cmd->delim = kw_cmd;
												} else {
													if(!cmd->keywords)
														cmd->keywords = htmk(64);
														htadd(cmd->keywords,zdup(bf),kw_cmd);
												}
												while (parse_ws(&p,'#'), !parse_ident(&p,&bf))
													if(!zcmp(bf,USTR "buffer")) {
														kw_cmd->start_buffering = 1;
													} else if(!zcmp(bf,USTR "hold")) {
														kw_cmd->stop_buffering = 1;
													} else if(!zcmp(bf,USTR "recolor")) {
														parse_ws(&p,'#');
														if(!parse_char(&p,'=')) {
															parse_ws(&p,'#');
															if(parse_int(&p,&kw_cmd->recolor))
																i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
														} else
															i_printf_2((char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
													} else
														i_printf_2((char *)joe_gettext(_("%s %d: Unknown option\n")),name,line);
											} else
												i_printf_2((char *)joe_gettext(_("%s %d: Missing state name\n")),name,line);
										} else
											i_printf_2((char *)joe_gettext(_("%s %d: Missing string\n")),name,line);
									}
								}
							} else if(!zcmp(bf,USTR "noeat")) {
								cmd->noeat = 1;
							} else if(!zcmp(bf,USTR "mark")) {
								cmd->start_mark = 1;
							} else if(!zcmp(bf,USTR "markend")) {
								cmd->stop_mark = 1;
							} else if(!zcmp(bf,USTR "recolormark")) {
								cmd->recolor_mark = 1;
							} else
								i_printf_2((char *)joe_gettext(_("%s %d: Unknown option\n")),name,line);
d748 1
a748 1
	obj_free(full_name);
d752 18
a769 3
/* Load dfa */

void link_syntax(struct high_syntax *syntax);
d771 1
a771 1
struct high_syntax *load_dfa(unsigned char *name)
a773 9
	int needs_link = 0;

	if (!name)
		return NULL;

	if(!attr_buf) {
		attr_size = 1024;
		attr_buf = joe_malloc(sizeof(int)*attr_size);
	}
d779 1
a779 1
		if(!zcmp(syntax->name,name))
d785 2
a791 2
	syntax->sync_lines = 50;
	syntax->recur = 0;
d793 3
d797 1
a797 3
	if (append_dfa(syntax,USTR "",name,NULL,&needs_link,NULL,NULL)) {
		if (needs_link)
			link_syntax(syntax);
a798 1
		syntax_list = syntax;
d801 7
d816 1
a816 12
/* Link in subroutine calls made to other tables */

/* List of existing subroutines */

struct sub_list {
	struct sub_list *next;
	unsigned char *name;
	struct high_state *rtn;	/* Return address */
	struct high_state *sub;	/* Pointer to subroutine */
};

struct high_state *find_sub(struct sub_list *list,unsigned char *name,struct high_state *rtn)
d818 2
a819 25
	/* printf("Find %s %p\n",name,(void *)rtn); */
	while (list) {
		if (!zcmp(list->name, name) && list->rtn==rtn)
			return list->rtn;
		list = list->next;
	}
	return 0;
}

struct sub_list *add_sub(struct sub_list *list,unsigned char *name,struct high_state *rtn,struct high_state *sub)
{
	struct sub_list *l=(struct sub_list *)malloc(sizeof(struct sub_list));
	l->next = list;
	l->name = zdup(name);
	l->rtn = rtn;
	l->sub = sub;
	/* printf("Add %p %s\n",(void *)rtn,name); */
	return l;
}

void link_syntax(struct high_syntax *syntax)
{
	int depth;
	int start = 0;
	struct sub_list *sub_list = 0;
d821 1
a821 33
	for (depth = 0; depth != 5; ++depth) {
		int inst = 0;
		int x = start;
		int nstates = syntax->nstates;
		start = nstates;
		for (; x != nstates; ++x) {
			struct high_state *state = syntax->states[x];
			int y;
			for(y = 0; y != 256; ++y) {
				struct high_cmd *cmd = state->cmd[y];
				if (cmd->call) {
					unsigned char *buf1 = vsmk(128);
					unsigned char *buf = vsmk(128);
					struct high_state *sub;
					int needs_link = 0;
					buf1 = vsfmt(buf1, 0, USTR "%d.%s.%s",depth,cmd->call,(cmd->call_subr?cmd->call_subr:USTR ""));
					/* printf("%s is looking for %s.%s\n",state->name,cmd->call,(cmd->call_subr?cmd->call_subr:USTR "")); */
					if ( 1 ) { /* !(sub = find_sub(sub_list, buf1, cmd->new_state))) { */
						/* printf("loading...\n"); */
						buf = vsfmt(buf, 0, USTR "%d.%d.",depth,inst++);
						sub = append_dfa(syntax,buf,cmd->call,cmd->new_state,&needs_link,cmd->parms,cmd->call_subr);
						if (sub)
							sub_list = add_sub(sub_list, buf1, cmd->new_state, sub);

					}
					if (sub)
						cmd->new_state = sub;
					cmd->call = 0;
					obj_free(buf1);
				}
			}
		}
	}
@


1.43
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d389 1
a389 1
		full_name = vsfmt(full_name, 0, USTR "%ssyntax/%s.jsf",JOERC,name);
@


1.42
log
@semiautomatic variables
@
text
@d25 3
a27 1
	unsigned char buf[24];	/* Name buffer (trunc after 23 characters) */
d69 9
d79 1
a79 1
			if (cmd->delim && !zcmp(h_state.saved_s,buf)) {
d85 1
a85 1
			} else if (cmd->keywords && (cmd->ignore ? (kw_cmd=htfind(cmd->keywords,lowerize(buf))) : (kw_cmd=htfind(cmd->keywords,buf)))) {
d772 1
a772 1
					buf1 = vsfmt(buf1, 0, USTR "%d.%s.%s",depth,cmd->call,cmd->call_subr);
@


1.41
log
@UC -> USTR
@
text
@d165 1
a165 1
	unsigned char buf[256];
d168 2
a169 1
	joe_snprintf_2(buf, sizeof(buf), "%s%s", prefix, name);
d192 1
a192 1

d231 1
a231 1
	unsigned char bf[256];
d233 1
a233 1
	joe_snprintf_2(bf, sizeof(bf), "%s.%s", syn, name);
d240 1
d246 2
a247 2
	unsigned char bf[256];
	if(!parse_tows(&p, bf)) {
d269 1
a269 1
			while(parse_ws(&p,'#'), !parse_ident(&p,bf,sizeof(bf))) {
d285 1
d288 1
a288 2
		unsigned char buf[1024];
		joe_snprintf_2(buf, sizeof(buf), "Syntax name=%s, nstates=%d\n",syntax->name,syntax->nstates);
d295 1
a295 1
			joe_snprintf_2(buf, sizeof(buf), "   state %s %x\n",s->name,s->color);
d302 1
a302 1
					joe_snprintf_4(buf, sizeof(buf), "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d308 1
a308 1
			joe_snprintf_4(buf, sizeof(buf), "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d326 1
a326 1
	unsigned char bf[256];
d335 1
a335 1
			else if (!parse_ident(&p,bf,sizeof(bf))) {
d354 4
a357 4
	unsigned char full_name[1024];
	unsigned char buf[1024];
	unsigned char bf[256];
	unsigned char bf1[256];
d373 1
a373 1
		joe_snprintf_2(full_name,sizeof(full_name),"%s/.joe/syntax/%s.jsf",p,name);
d378 1
a378 1
		joe_snprintf_2(full_name,sizeof(full_name),"%ssyntax/%s.jsf",JOERC,name);
d389 1
a389 1
	while(fgets((char *)buf,1023,f)) {
d394 1
a394 1
			if (!parse_ident(&p, bf, sizeof(bf))) {
d404 1
a404 1
						if (!parse_ident(&p, bf, sizeof(bf))) {
d433 1
a433 1
					if (parse_ident(&p, bf, sizeof(bf))) {
d462 1
a462 1
			if(!parse_ident(&p, bf, sizeof(bf))) {
d470 1
a470 1
				if(!parse_ident(&p,bf,sizeof(bf))) {
d503 1
a503 1
						c = parse_string(&p, bf, sizeof(bf));
d523 1
a523 1
					if(!parse_ident(&p,bf,sizeof(bf))) {
d528 1
a528 1
						while (parse_ws(&p,'#'), !parse_ident(&p,bf,sizeof(bf)))
d555 1
a555 1
									} else if (parse_ident(&p,bf1,sizeof(bf1)))
d561 1
a561 1
											if (parse_ident(&p,bf1,sizeof(bf1)))
d574 1
a574 1
								while(fgets((char *)buf,1023,f)) {
d581 1
a581 1
										if(parse_string(&p,bf,sizeof(bf)) >= 0) {
d585 1
a585 1
											if(!parse_ident(&p,bf1,sizeof(bf1))) {
d596 1
a596 1
												while (parse_ws(&p,'#'), !parse_ident(&p,bf,sizeof(bf)))
d652 1
d757 2
a758 2
					unsigned char buf1[256];
					unsigned char buf[256];
d761 1
a761 1
					joe_snprintf_3(buf1,sizeof(buf1),"%d.%s.%s",depth,cmd->call,cmd->call_subr);
d765 1
a765 1
						joe_snprintf_2(buf,sizeof(buf),"%d.%d.",depth,inst++);
d774 1
@


1.40
log
@change US to UC
@
text
@d393 1
a393 1
				if (!zcmp(bf, UC "ifdef")) {
d415 1
a415 1
				} else if (!zcmp(bf, UC "else")) {
d422 1
a422 1
				} else if (!zcmp(bf, UC "endif")) {
d429 1
a429 1
				} else if (!zcmp(bf, UC "subr")) {
d441 1
a441 1
				} else if (!zcmp(bf, UC "end")) {
d494 1
a494 1
					if(!parse_field(&p, UC "*")) {
d498 1
a498 1
					} else if(!parse_field(&p, UC "&")) {
d527 1
a527 1
							if(!zcmp(bf,UC "buffer")) {
d529 1
a529 1
							} else if(!zcmp(bf,UC "hold")) {
d531 1
a531 1
							} else if(!zcmp(bf,UC "return")) {
d534 1
a534 1
							} else if(!zcmp(bf,UC "save_c")) {
d536 1
a536 1
							} else if(!zcmp(bf,UC "save_s")) {
d538 1
a538 1
							} else if(!zcmp(bf,UC "recolor")) {
d546 1
a546 1
							} else if(!zcmp(bf,UC "call")) {
d569 1
a569 1
							} else if(!zcmp(bf,UC "strings") || !zcmp(bf,UC "istrings")) {
d577 1
a577 1
										if(!parse_field(&p,UC "done"))
d587 1
a587 1
												if (!zcmp(bf, UC "&")) {
d595 1
a595 1
													if(!zcmp(bf,UC "buffer")) {
d597 1
a597 1
													} else if(!zcmp(bf,UC "hold")) {
d599 1
a599 1
													} else if(!zcmp(bf,UC "recolor")) {
d615 1
a615 1
							} else if(!zcmp(bf,UC "noeat")) {
d617 1
a617 1
							} else if(!zcmp(bf,UC "mark")) {
d619 1
a619 1
							} else if(!zcmp(bf,UC "markend")) {
d621 1
a621 1
							} else if(!zcmp(bf,UC "recolormark")) {
d689 1
a689 1
	if (append_dfa(syntax,UC "",name,NULL,&needs_link,NULL,NULL)) {
d759 1
a759 1
					/* printf("%s is looking for %s.%s\n",state->name,cmd->call,(cmd->call_subr?cmd->call_subr:UC "")); */
@


1.39
log
@hash table fix
@
text
@d393 1
a393 1
				if (!zcmp(bf, US "ifdef")) {
d415 1
a415 1
				} else if (!zcmp(bf, US "else")) {
d422 1
a422 1
				} else if (!zcmp(bf, US "endif")) {
d429 1
a429 1
				} else if (!zcmp(bf, US "subr")) {
d441 1
a441 1
				} else if (!zcmp(bf, US "end")) {
d494 1
a494 1
					if(!parse_field(&p, US "*")) {
d498 1
a498 1
					} else if(!parse_field(&p, US "&")) {
d527 1
a527 1
							if(!zcmp(bf,US "buffer")) {
d529 1
a529 1
							} else if(!zcmp(bf,US "hold")) {
d531 1
a531 1
							} else if(!zcmp(bf,US "return")) {
d534 1
a534 1
							} else if(!zcmp(bf,US "save_c")) {
d536 1
a536 1
							} else if(!zcmp(bf,US "save_s")) {
d538 1
a538 1
							} else if(!zcmp(bf,US "recolor")) {
d546 1
a546 1
							} else if(!zcmp(bf,US "call")) {
d569 1
a569 1
							} else if(!zcmp(bf,US "strings") || !zcmp(bf,US "istrings")) {
d577 1
a577 1
										if(!parse_field(&p,US "done"))
d587 1
a587 1
												if (!zcmp(bf, US "&")) {
d595 1
a595 1
													if(!zcmp(bf,US "buffer")) {
d597 1
a597 1
													} else if(!zcmp(bf,US "hold")) {
d599 1
a599 1
													} else if(!zcmp(bf,US "recolor")) {
d615 1
a615 1
							} else if(!zcmp(bf,US "noeat")) {
d617 1
a617 1
							} else if(!zcmp(bf,US "mark")) {
d619 1
a619 1
							} else if(!zcmp(bf,US "markend")) {
d621 1
a621 1
							} else if(!zcmp(bf,US "recolormark")) {
d689 1
a689 1
	if (append_dfa(syntax,US "",name,NULL,&needs_link,NULL,NULL)) {
d759 1
a759 1
					/* printf("%s is looking for %s.%s\n",state->name,cmd->call,(cmd->call_subr?cmd->call_subr:US "")); */
@


1.38
log
@hash table
@
text
@d696 1
a699 1
		htrm(syntax->ht_states);
@


1.37
log
@short_name fix.  document language and charset
@
text
@a164 1
	int x;
d171 1
a171 3
	for(x=0;x!=syntax->nstates;++x)
		if(!zcmp(syntax->states[x]->name,buf))
			break;
d174 1
a174 1
	if(x==syntax->nstates) {
d189 3
a191 2
	} else
		state = syntax->states[x];
d683 2
a684 1
	syntax->states = joe_malloc(sizeof(struct high_state *)*(syntax->szstates=64));
d699 1
d748 1
a748 1
		for (; x!= nstates; ++x) {
@


1.36
log
@multi-line qw, startup log
@
text
@d368 1
d553 1
a553 1
										cmd->call = zdup(name);
@


1.35
log
@gettext()
@
text
@d261 1
a261 1
			fprintf(stderr,(char *)joe_gettext(_("%s %d: Class already defined\n")),name,line);
d341 1
a341 1
				fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing )\n")),name,line);
d354 1
d372 2
a373 2
		joe_snprintf_2(buf,sizeof(buf),"%s/.joe/syntax/%s.jsf",p,name);
		f = fopen((char *)buf,"r");
d377 2
a378 2
		joe_snprintf_2(buf,sizeof(buf),"%ssyntax/%s.jsf",JOERC,name);
		f = fopen((char *)buf,"r");
d382 1
d412 1
a412 1
							fprintf(stderr,(char *)joe_gettext(_("%s %d: missing parameter for ifdef\n")),name,line);
d422 1
a422 1
						fprintf(stderr,(char *)joe_gettext(_("%s %d: else with no matching if\n")),name,line);
d429 1
a429 1
						fprintf(stderr,(char *)joe_gettext(_("%s %d: endif with no matching if\n")),name,line);
d433 1
a433 1
						fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing subroutine name\n")),name,line);
d448 1
a448 1
					fprintf(stderr,(char *)joe_gettext(_("%s %d: Unknown control statement\n")),name,line);
d451 1
a451 1
				fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing control statement name\n")),name,line);
d478 1
a478 1
						fprintf(stderr,(char *)joe_gettext(_("%s %d: Unknown class\n")),name,line);
d481 1
a481 1
					fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing color for state definition\n")),name,line);
d483 1
a483 1
				fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing state name\n")),name,line);
d504 1
a504 1
							fprintf(stderr,(char *)joe_gettext(_("%s %d: Bad string\n")),name,line);
d544 1
a544 1
										fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d546 1
a546 1
									fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d555 1
a555 1
										fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d561 1
a561 1
												fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing subroutine name\n")),name,line);
d569 1
a569 1
									fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d605 1
a605 1
																fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d607 1
a607 1
															fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing value for option\n")),name,line);
d609 1
a609 1
														fprintf(stderr,(char *)joe_gettext(_("%s %d: Unknown option\n")),name,line);
d611 1
a611 1
												fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing state name\n")),name,line);
d613 1
a613 1
											fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing string\n")),name,line);
d625 1
a625 1
								fprintf(stderr,(char *)joe_gettext(_("%s %d: Unknown option\n")),name,line);
d634 1
a634 1
						fprintf(stderr,(char *)joe_gettext(_("%s %d: Missing jump\n")),name,line);
d636 1
a636 1
					fprintf(stderr,(char *)joe_gettext(_("%s %d: No state\n")),name,line);
d638 1
a638 1
				fprintf(stderr,(char *)joe_gettext(_("%s %d: Unknown character\n")),name,line);
d645 1
a645 1
		fprintf(stderr,(char *)joe_gettext(_("%s %d: ifdef with no matching endif\n")),name,st->line);
@


1.34
log
@Add rexx.  Take advantage of highlighter subroutines.
@
text
@d169 1
a169 1
	joe_snprintf_2((char *)buf, sizeof(buf), "%s%s", prefix, name);
d234 1
a234 1
	joe_snprintf_2((char *)bf, sizeof(bf), "%s.%s", syn, name);
d261 1
a261 1
			fprintf(stderr,"%s %d: Class already defined\n",name,line);
d288 1
a288 1
		joe_snprintf_2((char *)buf, sizeof(buf), "Syntax name=%s, nstates=%d\n",syntax->name,syntax->nstates);
d295 1
a295 1
			joe_snprintf_2((char *)buf, sizeof(buf), "   state %s %x\n",s->name,s->color);
d302 1
a302 1
					joe_snprintf_4((char *)buf, sizeof(buf), "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d308 1
a308 1
			joe_snprintf_4((char *)buf, sizeof(buf), "     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
d341 1
a341 1
				fprintf(stderr,"%s %d: Missing )\n",name,line);
d371 1
a371 1
		joe_snprintf_2((char *)buf,sizeof(buf),"%s/.joe/syntax/%s.jsf",p,name);
d376 1
a376 1
		joe_snprintf_2((char *)buf,sizeof(buf),"%ssyntax/%s.jsf",JOERC,name);
d410 1
a410 1
							fprintf(stderr,"%s %d: missing parameter for ifdef\n",name,line);
d420 1
a420 1
						fprintf(stderr,"%s %d: else with no matching if\n",name,line);
d427 1
a427 1
						fprintf(stderr,"%s %d: endif with no matching if\n",name,line);
d431 1
a431 1
						fprintf(stderr,"%s %d: Missing subroutine name\n",name,line);
d446 1
a446 1
					fprintf(stderr,"%s %d: Unknown control statement\n",name,line);
d449 1
a449 1
				fprintf(stderr,"%s %d: Missing control statement name\n",name,line);
d476 1
a476 1
						fprintf(stderr,"%s %d: Unknown class\n",name,line);
d479 1
a479 1
					fprintf(stderr,"%s %d: Missing color for state definition\n",name,line);
d481 1
a481 1
				fprintf(stderr,"%s %d: Missing state name\n",name,line);
d502 1
a502 1
							fprintf(stderr,"%s %d: Bad string\n",name,line);
d542 1
a542 1
										fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d544 1
a544 1
									fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d553 1
a553 1
										fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d559 1
a559 1
												fprintf(stderr,"%s %d: Missing subroutine name\n",name,line);
d567 1
a567 1
									fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d603 1
a603 1
																fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d605 1
a605 1
															fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d607 1
a607 1
														fprintf(stderr,"%s %d: Unknown option\n",name,line);
d609 1
a609 1
												fprintf(stderr,"%s %d: Missing state name\n",name,line);
d611 1
a611 1
											fprintf(stderr,"%s %d: Missing string\n",name,line);
d623 1
a623 1
								fprintf(stderr,"%s %d: Unknown option\n",name,line);
d632 1
a632 1
						fprintf(stderr,"%s %d: Missing jump\n",name,line);
d634 1
a634 1
					fprintf(stderr,"%s %d: No state\n",name,line);
d636 1
a636 1
				fprintf(stderr,"%s %d: Unknown character\n",name,line);
d643 1
a643 1
		fprintf(stderr,"%s %d: ifdef with no matching endif\n",name,st->line);
d755 1
a755 1
					joe_snprintf_3((char *)buf1,sizeof(buf1),"%d.%s.%s",depth,cmd->call,cmd->call_subr);
d759 1
a759 1
						joe_snprintf_2((char *)buf,sizeof(buf),"%d.%d.",depth,inst++);
@


1.33
log
@Subroutines for syntax highlighter.
@
text
@d276 4
d282 1
a282 1
void dump_syntax(struct high_syntax *syntax)
d284 23
a306 13
	int x;
	printf("Syntax name=%s, nstates=%d\n",syntax->name,syntax->nstates);
	for(x=0;x!=syntax->nstates;++x) {
		int y;
		int f = -1;
		struct high_state *s = syntax->states[x];
		printf("   state %s %x\n",s->name,s->color);
		for (y = 0; y != 256; ++y) {
			if (f == -1)
				f = y;
			else if (s->cmd[f]->new_state != s->cmd[y]->new_state) {
				printf("     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
				f = y;
d308 3
a311 1
		printf("     [%d-%d] -> %s %d\n",f,y-1,s->cmd[f]->new_state->name,s->cmd[f]->recolor);
a314 4
/* Load syntax file */

struct high_syntax *syntax_list;

d382 3
d451 7
a457 2
		} else if ((stack && stack->ignore) || (subr && !this_one) || (!subr && inside_subr)) {
			/* Ignore this line */
a481 2
		} else if(!parse_char(&p, '=')) {
			parse_color_def(&syntax->color,p,name,line);
d755 4
a758 2
					joe_snprintf_2((char *)buf1,sizeof(buf1),"%d.%s",depth,cmd->call);
					if (!(sub = find_sub(sub_list, buf1, cmd->new_state))) {
d763 1
@


1.32
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d163 1
a163 1
static struct high_state *find_state(struct high_syntax *syntax,unsigned char *name)
d166 1
d169 2
d173 1
a173 1
		if(!zcmp(syntax->states[x]->name,name))
d180 1
a180 1
		state->name=zdup(name);
d214 3
d276 23
d303 38
a340 1
struct high_syntax *load_dfa(unsigned char *name)
d349 1
d351 1
a351 1
	struct high_syntax *syntax;	/* New syntax table */
d353 2
a354 15

	if (!name)
		return NULL;

	if(!attr_buf) {
		attr_size = 1024;
		attr_buf = joe_malloc(sizeof(int)*attr_size);
	}

	/* Find syntax table */

	/* Already loaded? */
	for(syntax=syntax_list;syntax;syntax=syntax->next)
		if(!zcmp(syntax->name,name))
			return syntax;
a369 11
	/* Create new one */
	syntax = joe_malloc(sizeof(struct high_syntax));
	syntax->name = zdup(name);
	syntax->next = syntax_list;
	syntax_list = syntax;
	syntax->nstates = 0;
	syntax->color = 0;
	syntax->states = joe_malloc(sizeof(struct high_state *)*(syntax->szstates=64));
	syntax->sync_lines = 50;
	iz_cmd(&syntax->default_cmd);

d375 64
a438 1
		if(!parse_char(&p, ':')) {
d441 4
a444 1
				state = find_state(syntax,bf);
d504 1
a504 1
						cmd->new_state = find_state(syntax,bf);
d512 3
d527 23
d567 1
a567 1
												kw_cmd->new_state = find_state(syntax,bf1);
d622 7
d631 120
a750 1
	return syntax;
@


1.31
log
@new cvs server
@
text
@a8 2
#include "config.h"
#include <stdlib.h>
a9 5
#include "scrn.h"
#include "utils.h"
#include "hash.h"
#include "charmap.h"
#include "syntax.h"
d282 1
a282 1
	FILE *f;
@


1.30
log
@Allow escape sequences in strings.
@
text
@d39 3
d95 5
d131 15
d154 5
d215 3
d470 6
@


1.29
log
@New line attribute cache.
@
text
@d239 1
a239 1
			while(parse_ws(&p,'#'), !parse_ident(&p,bf,255)) {
d309 1
a309 1
			if(!parse_ident(&p, bf, 255)) {
d314 1
a314 1
				if(!parse_ident(&p,bf,255)) {
d349 2
a350 2
						c = parse_string(&p, bf, 255);
						if(c)
d369 1
a369 1
					if(!parse_ident(&p,bf,255)) {
d374 1
a374 1
						while (parse_ws(&p,'#'), !parse_ident(&p,bf,255))
d401 1
a401 1
										if(!parse_string(&p,bf,255)) {
d405 1
a405 1
											if(!parse_ident(&p,bf1,255)) {
d416 1
a416 1
												while (parse_ws(&p,'#'), !parse_ident(&p,bf,255))
@


1.28
log
@Valgrind fixes.
@
text
@d98 1
@


1.27
log
@fix gcc-4.0.0 warnings
@
text
@d89 2
a90 1
				attr[x] = h -> color;
@


1.26
log
@Allow colors to controlled from joerc file
@
text
@a10 1
#include <string.h>
d72 1
a72 1
			if (cmd->delim && !strcmp(h_state.saved_s,buf)) {
d93 1
a93 1
				strcpy((char *)h_state.saved_s,(char *)buf);
d147 1
a147 1
		if(!strcmp(syntax->states[x]->name,name))
d154 1
a154 1
		state->name=joe_strdup(name);
d204 1
a204 1
		if (!strcmp(color->name,bf)) break;
d208 1
a208 1
		if (!strcmp(color->name,name)) break;
d224 1
a224 1
			color->name = joe_strdup(bf);
d273 1
a273 1
		if(!strcmp(syntax->name,name))
d292 1
a292 1
	syntax->name = joe_strdup(name);
d315 1
a315 1
						if(!strcmp(color->name,bf))
d373 1
a373 1
							if(!strcmp(bf,"buffer")) {
d375 1
a375 1
							} else if(!strcmp(bf,"hold")) {
d377 1
a377 1
							} else if(!strcmp(bf,"save_c")) {
d379 1
a379 1
							} else if(!strcmp(bf,"save_s")) {
d381 1
a381 1
							} else if(!strcmp(bf,"recolor")) {
d389 1
a389 1
							} else if(!strcmp(bf,"strings") || !strcmp(bf,"istrings")) {
d407 1
a407 1
												if (!strcmp((char *)bf, "&")) {
d412 1
a412 1
														htadd(cmd->keywords,joe_strdup(bf),kw_cmd);
d415 1
a415 1
													if(!strcmp(bf,"buffer")) {
d417 1
a417 1
													} else if(!strcmp(bf,"hold")) {
d419 1
a419 1
													} else if(!strcmp(bf,"recolor")) {
d435 1
a435 1
							} else if(!strcmp(bf,"noeat")) {
@


1.25
log
@Fix uninitialized array bug.
@
text
@d195 50
d329 1
a329 23
			if(!parse_ident(&p, bf, 255)) {
				struct high_color *color;

				/* Find color */
				for(color=syntax->color;color;color=color->next)
					if(!strcmp(color->name,bf))
						break;
				/* If it doesn't exist, create it */
				if(!color) {
					color = joe_malloc(sizeof(struct high_color));
					color->name = joe_strdup(bf);
					color->color = 0;
					color->next = syntax->color;
					syntax->color = color;
				} else {
					fprintf(stderr,"%s %d: Class already defined\n",name,line);
				}

				/* Parse color definition */
				while(parse_ws(&p,'#'), !parse_ident(&p,bf,255)) {
					color->color |= meta_color(bf);
				}
			}
@


1.24
log
@Fix uninitialized structure bug.
@
text
@d41 2
@


1.23
log
@Fix -pedantic warnings.
@
text
@d172 1
a172 1
static struct high_cmd *mkcmd()
a173 1
	struct high_cmd *cmd = joe_malloc(sizeof(struct high_cmd));
d184 6
d248 1
a248 5
	syntax->default_cmd.noeat = 0;
	syntax->default_cmd.recolor = 0;
	syntax->default_cmd.start_buffering = 0;
	syntax->default_cmd.new_state = 0;
	syntax->default_cmd.keywords = 0;
@


1.22
log
@Highlighter state now includes a saved string.
This improves shell and perl highlighters.
@
text
@d52 1
a52 1
			attr_buf = realloc(attr_buf,sizeof(int)*(attr_size*2));
d92 1
a92 1
				strcpy(h_state.saved_s,buf);
d152 2
a153 2
		state=malloc(sizeof(struct high_state));
		state->name=(unsigned char *)strdup((char *)name);
d160 1
a160 1
			syntax->states=realloc(syntax->states,sizeof(struct high_state *)*(syntax->szstates*=2));
d174 1
a174 1
	struct high_cmd *cmd = malloc(sizeof(struct high_cmd));
d210 1
a210 1
		attr_buf = malloc(sizeof(int)*attr_size);
d235 2
a236 2
	syntax = malloc(sizeof(struct high_syntax));
	syntax->name = (unsigned char *)strdup((char *)name);
d241 1
a241 1
	syntax->states = malloc(sizeof(struct high_state *)*(syntax->szstates=64));
d285 2
a286 2
					color = malloc(sizeof(struct high_color));
					color->name = (unsigned char *)strdup((char *)bf);
d382 1
a382 1
														htadd(cmd->keywords,(unsigned char *)strdup((char *)bf),kw_cmd);
@


1.21
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d29 1
a29 1
int parse(struct high_syntax *syntax,P *line,int state)
d31 1
a31 1
	struct high_state *h = syntax->states[state];
d33 1
a33 1
	unsigned char buf[20];	/* Name buffer (trunc after 19 characters) */
d66 4
a69 1
			cmd = h->cmd[c];
d71 7
a77 1
			if (cmd->keywords && (cmd->ignore ? (kw_cmd=htfind(cmd->keywords,lowerize(buf))) : (kw_cmd=htfind(cmd->keywords,buf)))) {
d90 20
d123 1
a123 1
		if (buf_idx<19 && buf_en)
d133 2
a134 1
	return h->no;
d164 1
d179 2
d183 1
d306 1
a306 1
			} else if (c=='"' || c=='*') {
d309 1
d314 2
d347 4
d377 7
a383 3
												if(!cmd->keywords)
													cmd->keywords = htmk(64);
												htadd(cmd->keywords,(unsigned char *)strdup((char *)bf),kw_cmd);
d411 3
a413 1
						for(z=0;z!=256;++z)
@


1.20
log
@Smart indent and backspace now work even if cursor
is not right at indentation point.  Also autoindent
does not happen if cursor is on a space or tab character.

Jmacs: ^W (cut) now works if mark is after point.  (Added -autoswap
mode).  Also: preserve mark and point positions during block
operations.
@
text
@d189 1
a189 1
		snprintf((char *)buf,sizeof(buf),"%s/.joe/syntax/%s.jsf",p,name);
d194 1
a194 1
		snprintf((char *)buf,sizeof(buf),"%ssyntax/%s.jsf",JOERC,name);
@


1.19
log
@Allow options after strings in syntax files.
@
text
@d20 1
d22 2
a23 1
   Array 'attr' has coloring for each character of line.
d38 1
a38 1
	int buf_en = 0;	/* Set for buffering */
d43 1
a43 2
		struct high_cmd *cmd;
		struct high_cmd *kw_cmd;
d50 1
d58 1
d61 1
d93 1
a93 1
		/* Save in buffer */
@


1.18
log
@Can now parse charmap files.
@
text
@d42 1
a42 2
		struct high_state *kw_new_state;
		struct high_state *old_state;
a55 1
		/* Color with current state */
d59 1
a60 1
			old_state = h;
d64 3
a66 2
			if (cmd->keywords && (cmd->ignore ? (kw_new_state=htfind(cmd->keywords,lowerize(buf))) : (kw_new_state=htfind(cmd->keywords,buf)))) {
				h = kw_new_state;
a71 3
				/* Recolor if necessary */
				for(x=cmd->recolor;x<0;++x)
					attr[x] = h -> color;
d73 4
d135 15
d294 1
a294 9
					cmd = malloc(sizeof(struct high_cmd));
					cmd->noeat = 0;
					cmd->recolor = 0;
					cmd->start_buffering = 0;
					cmd->stop_buffering = 0;
					cmd->new_state = 0;
					cmd->keywords = 0;
					cmd->ignore = 0;

d329 3
d334 16
a349 1
												htadd(cmd->keywords,(unsigned char *)strdup((char *)bf),find_state(syntax,bf1));
@


1.17
log
@Checks ~/.joe/syntax for syntax files.
Applied new Selinux patch.
@
text
@d165 1
a165 3
			break;
	if(syntax)
		return syntax;
@


1.16
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d170 10
a179 2
	sprintf((char *)buf,"%ssyntax/%s.jsf",JOERC,name);
	f=fopen((char *)buf,"r");
@


1.15
log
@Eliminate iconv() dependency.
@
text
@d16 1
@


1.14
log
@Fix mutt mode: need -wordwrap, not -autoindent.

Fix configure.ac and Makefile.am to link -liconv if
necessary.
@
text
@d193 1
a193 1
		c = parse_ws(&p);
d199 1
a199 1
				parse_ws(&p);
d235 1
a235 1
				while(parse_ws(&p), !parse_ident(&p,bf,255)) {
d243 1
a243 1
			c = parse_ws(&p);
d281 1
a281 1
					parse_ws(&p);
d287 1
a287 1
						while (parse_ws(&p), !parse_ident(&p,bf,255))
d293 1
a293 1
								parse_ws(&p);
d295 1
a295 1
									parse_ws(&p);
d306 1
a306 1
									c = parse_ws(&p);
d311 1
a311 1
											parse_ws(&p);
@


1.13
log
@Improved fortran highlighter.
@
text
@d151 3
@


1.12
log
@More syntax files: tcl

Now 'noeat' implies 'recolor=-1', which reduces debug time
for syntax definition files.
@
text
@d35 2
d69 1
a69 1
					attr[x] = h -> color;
d77 1
a77 1
			if (cmd->start_buffering)
d79 7
d89 4
a92 1
		if(buf_idx<19) buf[buf_idx++]=c;
d273 1
d287 2
@


1.11
log
@Added XML.  Improved HTML.
Now allow comment lines in syntax file string lists.
@
text
@d55 1
a55 1
		*attr++ = h->color;
d58 1
d75 1
a75 1
			if(cmd->start_buffering)
@


1.10
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@d288 13
a300 10
									if(!parse_field(&p,US "done"))
										break;
									if(!parse_string(&p,bf,255)) {
										parse_ws(&p);
										if (cmd->ignore)
											lowerize(bf);
										if(!parse_ident(&p,bf1,255)) {
											if(!cmd->keywords)
												cmd->keywords = htmk(64);
											htadd(cmd->keywords,(unsigned char *)strdup((char *)bf),find_state(syntax,bf1));
d302 2
a303 3
											fprintf(stderr,"%s %d: Missing state name\n",name,line);
									} else
										fprintf(stderr,"%s %d: Missing string\n",name,line);
@


1.9
log
@Added ` u to insert unicode characters in hex.

Fixed typeing of unicode (utypebw() optimization bug).

Fixed editor hang when syntax hightlighter hits unicode character.
@
text
@d62 1
a62 1
			if(cmd->keywords && (kw_new_state=htfind(cmd->keywords,buf))) {
d262 1
d281 3
a283 1
							} else if(!strcmp(bf,"strings")) {
d292 2
@


1.8
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d43 4
@


1.7
log
@
Messed around with Makefile.am:
  put *Rc files in joe subdirectory
  put *.jsf file in joe/syntax subdirectory
@
text
@d99 1
d104 3
a106 1
		/* FIXME: init cmd table? */
d110 2
d163 5
@


1.6
log
@Added way to specify no. lines back to start parsing when we don't know
the syntax highlight parsing state.
@
text
@d144 1
a144 1
	sprintf((char *)buf,"%s%s.jsf",JOERC,name);
@


1.5
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d157 1
d209 3
@


1.4
log
@Clean up syntax.c: use subroutine for allocating new states and use
hash table for keywords.
@
text
@d30 1
a30 1
	char buf[20];	/* Name buffer (trunc after 19 characters) */
d87 1
a87 1
static struct high_state *find_state(struct high_syntax *syntax,char *name)
d100 1
a100 1
		state->name=strdup(name);
d116 1
a116 1
struct high_syntax *load_dfa(char *name)
d118 3
a120 3
	char buf[1024];
	char bf[256];
	char bf1[256];
d122 1
a122 1
	char *p;
d144 2
a145 2
	sprintf(buf,"%s%s.jsf",JOERC,name);
	f=fopen(buf,"r");
d151 1
a151 1
	syntax->name = strdup(name);
d159 1
a159 1
	while(fgets(buf,1023,f)) {
d195 1
a195 1
					color->name = strdup(bf);
d215 1
a215 1
					if(!parse_field(&p, "*")) {
d226 1
a226 1
							char *t = bf;
d263 1
a263 1
								while(fgets(buf,1023,f)) {
d267 1
a267 1
									if(!parse_field(&p,"done"))
d274 1
a274 1
											htadd(cmd->keywords,strdup(bf),find_state(syntax,bf1));
@


1.3
log
@Clean up meaning of default color.

Allow syntax to be specified in joerc file: "-syntax perl"

Add class definitions to syntax files.

Add perl and verilog definitions (they need work).

Change joerc to assume files with . in their name do not want word
wrap enabled (except for .txt).
@
text
@d15 1
d39 1
a39 1
		struct high_keyword *word;
d58 2
a59 4
			for(word=cmd->keyword_list;word;word=word->next)
				if(!strcmp(word->name,buf)) break;
			if(word) {
				h = word->new_state;
d85 27
d120 1
a126 1
	int szstates;			/* Malloc size of states table (in syntax) */
d156 1
a156 1
	syntax->states = malloc(sizeof(struct high_state *)*(szstates=64));
d166 1
a166 19
				int x;

				/* Find state */
				for(x=0;x!=syntax->nstates;++x)
					if(!strcmp(syntax->states[x]->name,bf))
						break;

				/* It doesn't exist, so create it */
				if(x==syntax->nstates) {
					state=malloc(sizeof(struct high_state));
					state->name=strdup(bf);
					state->no=syntax->nstates;
					state->color=FG_WHITE;
					/* FIXME: init cmd table? */
					if(syntax->nstates==szstates)
						syntax->states=realloc(syntax->states,sizeof(struct high_state *)*(szstates*=2));
					syntax->states[syntax->nstates++]=state;
				} else
					state = syntax->states[x];
d243 1
a243 1
					cmd->keyword_list = 0;
a246 1
						struct high_state *h;
d248 1
a248 17
						for(z=0;z!=syntax->nstates;++z)
							if(!strcmp(syntax->states[z]->name,bf))
								break;

						if(z==syntax->nstates) {
							h=malloc(sizeof(struct high_state));
							h->name=strdup(bf);
							h->no=syntax->nstates;
							h->color=FG_WHITE;
							/* FIXME: init cmd table? */
							if(syntax->nstates==szstates)
								syntax->states=realloc(syntax->states,sizeof(struct high_state *)*(szstates*=2));
							syntax->states[syntax->nstates++]=h;
						} else
							h = syntax->states[z];

						cmd->new_state = h;
a269 5
										struct high_keyword *k=malloc(sizeof(struct high_keyword));
										k->name=strdup(bf);
										k->next=cmd->keyword_list;
										k->new_state=0;
										cmd->keyword_list=k;
d271 4
a274 21
										if(!parse_ident(&p,bf,255)) {
											struct high_state *h;
											int z;
											for(z=0;z!=syntax->nstates;++z)
												if(!strcmp(syntax->states[z]->name,bf))
													break;

											if(z==syntax->nstates) {
												h=malloc(sizeof(struct high_state));
												h->name=strdup(bf);
												h->no=syntax->nstates;
												h->color=FG_WHITE;
												/* FIXME: init cmd table? */
												if(syntax->nstates==szstates)
													syntax->states=realloc(syntax->states,sizeof(struct high_state *)*(szstates*=2));
												syntax->states[syntax->nstates++]=h;
											} else
												h = syntax->states[z];

											k->new_state = h;
											
@


1.2
log
@More changes for syntax highlighting.
@
text
@d129 1
d162 10
a171 16
					if(!strcmp(bf,"Keyword"))
						state->color=FG_YELLOW;
					else if(!strcmp(bf,"Type"))
						state->color=FG_GREEN;
					else if(!strcmp(bf,"Constant"))
						state->color=FG_MAGENTA;
					else if(!strcmp(bf,"Escape"))
						state->color=FG_RED;
					else if(!strcmp(bf,"Idle"))
						state->color=FG_WHITE;
					else if(!strcmp(bf,"Comment"))
						state->color=FG_CYAN;
					else if(!strcmp(bf,"Preproc"))
						state->color=FG_BLUE;
					else
						state->color=FG_WHITE;
d176 24
@


1.1
log
@Syntax highlighting baby steps.
@
text
@d1 7
a7 1
/* Syntax highlighting functions */
d10 2
a12 1
#include "b.h"
d14 2
d17 4
a20 1
/* Given starting state and a line, return ending state and colors to use for the line */
d22 2
a23 19
#define stIDLE 0		/* Initial state */
#define stCOMMENT 1		/* In a comment */
#define stCOMMENTe 3		/* In a comment plus * (tmp) */
#define stIDLEsl 4		/* IDLE plus / (tmp) */
#define stLCOMMENT 5		/* In a // comment (tmp) */
#define stCCONST 6
#define stSCONST 7
#define stAND 8
#define stOR 9
#define stEQ 10
#define stNOT 11
#define stGT 12
#define stLT 13
#define stMOD 14
#define stXOR 15
#define stMUL 16
#define stSUB 17
#define stADD 18
#define stSHR 19
d25 1
a25 1
int parse_c(int state,int *out,P *p)
d27 284
a310 2
int c;
int x=0;
d312 1
a312 947
for(x=0;x!=1024;++x)
  out[x]=FG_WHITE;
x=0;

for(c=pgetc(p);;c=pgetc(p))
  switch(state)
    {
    case stAND:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '&':
        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stOR:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '|':
        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stEQ:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stNOT:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stGT:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        case '>':
          {
          state = stSHR;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stLT:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        case '<':
          {
          state = stSHR;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stMOD:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stXOR:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stMUL:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stSUB:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stADD:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stSHR:
      {
      switch(c)
        {
        case '\n':
        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '=':
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }

        default:
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          goto ahead;
          }
        }
      break;
      }

    case stIDLE:
      {
      ahead:
      switch(c)
        {
        case '\n':
          return state;

        case NO_MORE_DATA:
          return state;

        case ' ': case '\t': case '\r':
          {
          out[x++]=FG_WHITE;
          break;
          }

        case '/':
          {
          state = stIDLEsl;
          break;
          }

        case '(':
        case ')':
        case '[':
        case ']':
        case '{':
        case '}':
          {
          out[x++]=FG_WHITE;
          break;
          }

        case '~':
          {
          out[x++]=FG_WHITE;
          break;
          }

        case '&': /* could be && or &= */
          {
          state = stAND;
          break;
          }

        case '|': /* could be || or |= */
          {
          state = stOR;
          break;
          }

        case '=': /* could be = or == */
          {
          state = stEQ;
          break;
          }

        case '!': /* could be ! or != */
          {
          state = stNOT;
          break;
          }

        case '>': /* could be >> or >= */
          {
          state = stGT;
          break;
          }

        case '<': /* could be < or <= */
          {
          state = stLT;
          break;
          }

        case '%': /* could be % or %= */
          {
          state = stMOD;
          break;
          }

        case '^': /* could be ^ or ^= */
          {
          state = stXOR;
          break;
          }

        case '*': /* could be * or *= */
          {
          state = stMUL;
          break;
          }

        case '-': /* could be - or -= */
          {
          state = stSUB;
          break;
          }

        case '+': /* could be + or += */
          {
          state = stADD;
          break;
          }

        case '\'': /* character constant */
          {
          out[x++]=FG_MAGENTA;
          state = stCCONST;
          break;
          }

        case '"': /* string constant */
          {
          out[x++]=FG_MAGENTA;
          state = stSCONST;
          break;
          }

        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
          {
          int y;

          nConst:
          y=x;

          lp:
          do
            {
            ++x;
            c=pgetc(p);
            }
            while(c>='0' && c<='9');

          if(c=='x' || c=='X')
            { /* Hex constant */
            goto lp;
            }
          else if(c=='.')
            { /* Second half of floating follows */
            goto lp;
            }
          else if(c=='U')
            { /* U for unsigned */
            ++x;
            c=pgetc(p);
            goto done;
            }
          else if(c=='e' || c=='E')
            { /* Third half of floating follows */
            ++x;
            c=pgetc(p);
            if(c=='+' || c=='-')
              goto lp;
            else if(c>='0' && c<='9')
              goto lp;
            }

          done:
          while(y!=x) out[y++]=FG_MAGENTA;
          goto ahead;
          break;
          }

        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':
        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p':
        case 'q': case 'r': case 's': case 't': case 'u': case 'v': case 'w': case 'x':
        case 'y': case 'z':
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H':
        case 'I': case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P':
        case 'Q': case 'R': case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
        case 'Y': case 'Z':
        case '_':
          {
          int y=x;
          char buf[20];
          int n;
          buf[0]=c;
          ++x;
          /* Reads ahead */
          while((c=pgetc(p)), (c>='a' && c<='z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9'))
            if(x-y<18)
              buf[x++-y]=c;
            else
              x++;
          buf[x-y]=0;
          if(!strcmp(buf,"int") ||
             !strcmp(buf,"float") ||
             !strcmp(buf,"long") ||
             !strcmp(buf,"short") ||
             !strcmp(buf,"char") ||
             !strcmp(buf,"double") ||
             !strcmp(buf,"signed") ||
             !strcmp(buf,"unsigned") ||
             !strcmp(buf,"void") ||
             !strcmp(buf,"static") ||
             !strcmp(buf,"extern") ||
             !strcmp(buf,"register") ||
             !strcmp(buf,"volatile") ||
             !strcmp(buf,"inline") ||
             !strcmp(buf,"automatic"))
            n=FG_GREEN;
          else if(!strcmp(buf,"if") ||
             !strcmp(buf,"else") ||
             !strcmp(buf,"while") ||
             !strcmp(buf,"for") ||
             !strcmp(buf,"break") ||
             !strcmp(buf,"continue") ||
             !strcmp(buf,"do") ||
             !strcmp(buf,"case") ||
             !strcmp(buf,"default") ||
             !strcmp(buf,"switch") ||
             !strcmp(buf,"goto"))
            n=FG_YELLOW;
          else
            n=FG_WHITE;
          while(y!=x) out[y++]=n;
          goto ahead;
          break;
          }

        case '#': /* Could't be preprocessor directive if it's first thing on line */
          { /* Come back to this */
          out[x++]=FG_WHITE;
          break;
          }

        case ';': /* at end of statements */
          {
          out[x++]=FG_WHITE;
          break;
          }

        case ':': /* for labels and case and ? */
          {
          out[x++]=FG_WHITE;
          break;
          }

        case ',':
          {
          out[x++]=FG_WHITE;
          break;
          }

        case '.': /* could be constant or separator */
          {
          c=pgetc(p);
          if(c>='0' && c<='9')
            {
            goto nConst;
            }
          else
            {
            out[x++]=FG_WHITE;
            goto ahead;
            }
          }

        case '?': /* ? operator */
          {
          out[x++]=FG_WHITE;
          break;
          }

        default: /* ` and @@ are unused in C.  \ at end of line... */
          {
          out[x++]=FG_WHITE;
          break;
          }
        }
      break;
      }

    case stCCONST:
      {
      switch(c)
        {
        case NO_MORE_DATA:
          {
          out[x++]=FG_MAGENTA;
          return stIDLE;
          }

        case '\n':
          {
          out[x++]=FG_MAGENTA;
          return stIDLE;
          }

        case '\'':
          {
          out[x++]=FG_MAGENTA;
          state = stIDLE;
          break;
          }

        case '%':
          {
          out[x++]=FG_RED;
          lp1:
          c=pgetc(p);
          switch(c)
            {
            case NO_MORE_DATA:
            case '\n':
              return stIDLE;

            case '\'':
              {
              out[x++]=FG_MAGENTA;
              state = stIDLE;
              break;
              }

            case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
            case 'e': case 'E': case 'f': case 'F': case 'g': case 'G':
            case 'a': case 'A': case 'c': case 's': case 'p': case 'n':
            case '%': case 'S': case 'C':
              {
              out[x++]=FG_RED;
              break;
              }

            default:
              {
              out[x++]=FG_RED;
              goto lp1;
              }
            }
          break;
          }

        case '\\':
          {
          out[x++]=FG_RED;
          c=pgetc(p);
          if(c==NO_MORE_DATA)
            {
            out[x++]=FG_MAGENTA;
            return stIDLE;
            }
          else if(c=='\n')
            {
            out[x++]=FG_MAGENTA;
            return stCCONST;
            }
          else
            {
            out[x++]=FG_RED;
            }
          break;
          }

        default:
          {
          out[x++]=FG_MAGENTA;
          break;
          }
        }
      break;
      }

    case stSCONST:
      {
      switch(c)
        {
        case NO_MORE_DATA:
          {
          out[x++]=FG_MAGENTA;
          return stIDLE;
          }

        case '\n':
          {
          out[x++]=FG_MAGENTA;
          return stIDLE;
          }

        case '\"':
          {
          out[x++]=FG_MAGENTA;
          state = stIDLE;
          break;
          }

        case '%':
          {
          out[x++]=FG_RED;
          lp2:
          c=pgetc(p);
          switch(c)
            {
            case NO_MORE_DATA:
            case '\n':
              return stIDLE;

            case '\'':
              {
              out[x++]=FG_MAGENTA;
              state = stIDLE;
              break;
              }

            case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
            case 'e': case 'E': case 'f': case 'F': case 'g': case 'G':
            case 'a': case 'A': case 'c': case 's': case 'p': case 'n':
            case '%': case 'S': case 'C':
              {
              out[x++]=FG_RED;
              break;
              }

            default:
              {
              out[x++]=FG_RED;
              goto lp2;
              }
            }
          break;
          }

        case '\\':
          {
          out[x++]=FG_MAGENTA;
          c=pgetc(p);
          if(c==NO_MORE_DATA)
            {
            out[x++]=FG_MAGENTA;
            return stIDLE;
            }
          else if(c=='\n')
            {
            out[x++]=FG_MAGENTA;
            return stSCONST;
            }
          else
            {
            out[x++]=FG_MAGENTA;
            }
          break;
          }

        default:
          {
          out[x++]=FG_MAGENTA;
          break;
          }
        }
      break;
      }

    case stIDLEsl:
      {
      switch(c)
        {
        case '*':
          {
          state = stCOMMENT;
          out[x++]=FG_CYAN;
          out[x++]=FG_CYAN;
          break;
          }

        case '/':
          {
          state = stLCOMMENT;
          out[x++]=FG_CYAN;
          out[x++]=FG_CYAN;
          break;
          }

        case NO_MORE_DATA:
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        case '\n':
          {
          out[x++]=FG_WHITE;
          return stIDLE;
          }

        default:
          {
          out[x++]=FG_WHITE;
          out[x++]=FG_WHITE;
          state = stIDLE;
          break;
          }
        }
      break;
      }

    case stLCOMMENT:
      {
      switch(c)
        {
        case '\n':
          return stIDLE;

        case NO_MORE_DATA:
          return stIDLE;

        default:
          {
          out[x++]=FG_CYAN;
          break;
          }
        }
      break;
      }

    case stCOMMENT:
      {
      switch(c)
        {
        case '\n':
          return state;

        case NO_MORE_DATA:
          return state;

        case '*':
          {
          out[x++]=FG_CYAN;
          state = stCOMMENTe;
          break;
          }

        default:
          {
          out[x++]=FG_CYAN;
          break;
          }
        }
      break;
      }

    case stCOMMENTe:
      {
      switch(c)
        {
        case '\n':
          return stCOMMENT;

        case NO_MORE_DATA:
          return stCOMMENT;

        case '/':
          {
          out[x++]=FG_CYAN;
          state = stIDLE;
          break;
          }

        case '*':
          {
          out[x++]=FG_CYAN;
          break;
          }

        default:
          {
          out[x++]=FG_CYAN;
          state = stCOMMENT;
          break;
          }
        }
      break;
      }
    }
@

