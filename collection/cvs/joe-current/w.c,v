head	1.39;
access;
symbols
	joe_3_5:1.36
	joe-3_4:1.35
	help:1.35
	joe_3_1:1.26
	joe_3_0:1.25
	joe_2_9_8:1.18
	joe_2_9_8_pre1:1.15
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.31.02.31.55;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.20.20.56.18;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.18.19.32.08;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.14.17.50.51;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.03.21.01.31;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.28.15.13.17;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.26.05.47.32;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.27.05.29.33;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.07.19.59.55;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.16.35.13;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.18.02.26.36;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.17.13.22.38;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.17.13.13.17;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.15.14.29.08;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.12.13.58.28;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.09.18.48.49;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.39.35;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.27.13.31.30;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.13.57.21;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.29;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.29;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.39
log
@More work on coroutine refactoring.
@
text
@/*
 *	Window system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Count no. of main windows */

int countmain(Screen *t)
{
	int nmain = 1;
	W *m = t->curwin->main;
	W *q;

	for (q = t->curwin->link.next; q != t->curwin; q = q->link.next)
		if (q->main != m) {
			++nmain;
			m = q->main;
		}
	return nmain;
}

/* Redraw a window */

void wredraw(W *w)
{
	msetI(w->t->t->updtab + w->y, 1, w->h);
}

/* Find first window in a group */

W *findtopw(W *w)
{
	W *x;

	for (x = w; x->link.prev->main == w->main && x->link.prev != w; x = x->link.prev) ;
	return x;
}

/* Determine height of a window.  Returns reqh if it is set, otherwise
 * used fixed or hh scaled to the current screen size */

static int geth(W *w)
{
	if (w->reqh)
		return w->reqh;
	else if (w->fixed)
		return w->fixed;
	else
		return (((long) w->t->h - w->t->wind) * w->hh) / 1000;
}

/* Set the height of a window */

static void seth(W *w, int h)
{
	long tmp;

	w->reqh = h;
	tmp = 1000L * h;
	w->hh = tmp / (w->t->h - w->t->wind) + (tmp % (w->t->h - w->t->wind) ? 1 : 0);
}

/* Determine height of a family of windows.  Uses 'reqh' if it's set */

int getgrouph(W *w)
{
	W *x;
	int h;

	/* Find first window in family */
	x = findtopw(w);

	/* Add heights of all windows in family */
	for (w = x, h = geth(w); w->link.next != x && w->link.next->main == x->main; w = w->link.next, h += geth(w)) ;

	return h;
}

/* Determine minimum height of a family */

static int getminh(W *w)
{
	W *x;
	int h;

	x = findtopw(w);
	for (w = x, h = (w->fixed ? w->fixed : 2); w->link.next != x && w->link.next->main == x->main; w = w->link.next, h += (w->fixed ? w->fixed : 2)) ;

	return h;
}

/* Find last window in a group */

W *findbotw(W *w)
{
	W *x;

	for (x = w; x->link.next->main == w->main && x->link.next != w; x = x->link.next) ;
	return x;
}

/* Demote group of window to end of window list.  Returns true if top window
   was demoted */

int demotegroup(W *w)
{
	W *top = findtopw(w);
	W *bot = findbotw(w);
	W *next;
	int flg = 0;

	for (w = top; w != bot; w = next) {
		next = w->link.next;
		if (w == w->t->topwin) {
			flg = 1;
			w->t->topwin = next;
		} else
			demote(W, link, w->t->topwin, w);
		w->y = -1;
	}
	if (w == w->t->topwin)
		flg = 1;
	else
		demote(W, link, w->t->topwin, w);
	w->y = -1;
	return flg;
}

/* Find last window on the screen */

W *lastw(Screen *t)
{
	W *x;

	for (x = t->topwin; x->link.next != t->topwin && x->link.next->y >= 0; x = x->link.next) ;
	return x;
}

/* Create a screen object */

Screen *scr;

Screen *screate(SCRN *scrn)
{
	Screen *t = (Screen *) joe_malloc(sizeof(Screen));

	t->t = scrn;
	t->w = scrn->co;
	t->h = scrn->li;
	t->topwin = NULL;
	t->curwin = NULL;
	t->wind = skiptop;
	scr = t;
	return t;
}

void sresize(Screen *t)
{
	SCRN *scrn = t->t;
	W *w;

	t->w = scrn->co;
	t->h = scrn->li;
	if (t->h - t->wind < FITHEIGHT)
		t->wind = t->h - FITHEIGHT;
	if (t->wind < 0)
		t->wind = 0;
	w = t->topwin;
	do {
		w->y = -1;
		w->w = t->w - 1;
		w = w->link.next;
	} while (w != t->topwin);
	wfit(t);
	updall();
}

void updall(void)
{
	int y;

	for (y = 0; y != scr->h; ++y) {
		scr->t->updtab[y] = 1;
	}
}

void scrins(B *b, long l, long n, int flg)
{
	W *w;

	if ((w = scr->topwin) != NULL) {
		do {
			if (w->y >= 0) {
				if (w->object && w->watom->ins)
					w->watom->ins(w->object, b, l, n, flg);
			}
		w = w->link.next;
		} while (w != scr->topwin);
	}
}

void scrdel(B *b, long l, long n, int flg)
{
	W *w;

	if ((w = scr->topwin) != NULL) {
		do {
			if (w->y >= 0) {
				if (w->object && w->watom->del)
					w->watom->del(w->object, b, l, n, flg);
			}
		w = w->link.next;
		} while (w != scr->topwin);
	}
}

W *watpos(Screen *t,int x,int y)
{
	W *w=t->topwin;
	do
		if(w->y>=0 && w->y<=y && w->y+w->h>y && w->x<=x && w->x+w->w>x)
			return w;
		while(w=w->link.next, w!=t->topwin);
	return 0;
}

/* Fit as many windows on the screen as is possible beginning with the window
 * at topwin.  Give any extra space which couldn't be used to fit in another
 * window to the last text window on the screen.  This function guarentees
 * to fit on the window with the cursor in it (moves topwin to next group
 * of windows until window with cursor fits on screen).
 */

static int doabort(W *w, int *ret);

void wfit(Screen *t)
{
	int y;			/* Where next window goes */
	int left;		/* Lines left on screen */
	W *w;			/* Current window we're fitting */
	W *pw;			/* Main window of previous family */
	int req;		/* Amount this family needs */
	int adj;		/* Amount family needs to be adjusted */
	int flg = 0;		/* Set if cursor window was placed on screen */
	int ret;

	dostaupd = 1;

      tryagain:
	y = t->wind;
	left = t->h - y;
	pw = NULL;

	w = t->topwin;
	do {
		w->ny = -1;
		w->nh = geth(w);
		w = w->link.next;
	} while (w != t->topwin);

	/* Fit a group of windows on the screen */
	w = t->topwin;
	do {
		req = getgrouph(w);
		if (req > left)	/* If group is taller than lines left */
			adj = req - left;	/* then family gets shorter */
		else
			adj = 0;

		/* Fit a family of windows on the screen */
		do {
			w->ny = y;	/* Set window's y position */
			if (!w->win) {
				pw = w;
				w->nh -= adj;	/* Adjust main window of the group */
			}
			if (!w->win && w->nh < 2)
				while (w->nh < 2)
					w->nh += doabort(w->link.next, &ret);
			if (w == t->curwin)
				flg = 1;	/* Set if we got window with cursor */
			y += w->nh;
			left -= w->nh;	/* Increment y value by height of window */
			w = w->link.next;	/* Next window */
		} while (w != t->topwin && w->main == w->link.prev->main);
	} while (w != t->topwin && left >= FITHEIGHT);

	/* We can't use extra space to fit a new family on, so give space to parent of
	 * previous family */
	pw->nh += left;

	/* Adjust that family's children which are below the parent */
	while ((pw = pw->link.next) != w)
		pw->ny += left;

	/* Make sure the cursor window got on the screen */
	if (!flg) {
		t->topwin = findbotw(t->topwin)->link.next;
		goto tryagain;
	}

	/* All of the windows are now on the screen.  Scroll the screen to reflect what
	 * happened
	 */
	w = t->topwin;
	do {
		if (w->y >= 0 && w->ny >= 0)
			if (w->ny > w->y) {
				W *l = pw = w;

				while (pw->link.next != t->topwin && (pw->link.next->y < 0 || pw->link.next->ny < 0 || pw->link.next->ny > pw->link.next->y)) {
					pw = pw->link.next;
					if (pw->ny >= 0 && pw->y >= 0)
						l = pw;
				}
				/* Scroll windows between l and w */
			      loop1:
				if (l->ny >= 0 && l->y >= 0)
					nscrldn(t->t, l->y, l->ny + uns_min(l->h, l->nh), l->ny - l->y);
				if (w != l) {
					l = l->link.prev;
					goto loop1;
				}
				w = pw->link.next;
			} else if (w->ny < w->y) {
				W *l = pw = w;

				while (pw->link.next != t->topwin && (pw->link.next->y < 0 || pw->link.next->ny < 0 || pw->link.next->ny < pw->link.next->y)) {
					pw = pw->link.next;
					if (pw->ny >= 0 && pw->y >= 0)
						l = pw;
				}
				/* Scroll windows between l and w */
			      loop0:
				if (w->ny >= 0 && w->y >= 0)
					nscrlup(t->t, w->ny, w->y + uns_min(w->h, w->nh), w->y - w->ny);
				if (w != l) {
					w = w->link.next;
					goto loop0;
				}
				w = pw->link.next;
			} else
				w = w->link.next;
		else
			w = w->link.next;
	} while (w != t->topwin);

	/* Update current height and position values */
	w = t->topwin;
	do {
		if (w->ny >= 0) {
			if (w->object) {
				if (w->watom->move)
					w->watom->move(w->object, w->x, w->ny);
				if (w->watom->resize)
					w->watom->resize(w->object, w->w, w->nh);
			}
			if (w->y == -1) {
				msetI(t->t->updtab + w->ny, 1, w->nh);
			}
			w->y = w->ny;
		} else
			w->y = -1;
		w->h = w->nh;
		w->reqh = 0;
		w = w->link.next;
	} while (w != t->topwin);
}

/* Goto next window */

int wnext(Screen *t)
{
	if (t->curwin->link.next != t->curwin) {
		t->curwin = t->curwin->link.next;
		if (t->curwin->y == -1)
			wfit(t);
		return 0;
	} else
		return -1;
}

/* Goto previous window */

int wprev(Screen *t)
{
	if (t->curwin->link.prev != t->curwin) {
		t->curwin = t->curwin->link.prev;
		if (t->curwin->y == -1) {
			t->topwin = findtopw(t->curwin);
			wfit(t);
		}
		return 0;
	} else
		return -1;
}

/* Grow window */

int wgrow(W *w)
{
	W *nextw;

	/* If we're the last window on the screen, shrink the previous window */
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) && w != w->t->topwin)
		return wshrink(w->link.prev->main);

	/* Get to next variable size window */
	for (nextw = w->link.next; nextw->fixed && nextw != w->t->topwin; nextw = nextw->link.next) ;

	/* Is it below us, on screen and big enough to take space from? */
	if (nextw == w->t->topwin || nextw->y == -1 || nextw->h <= FITHEIGHT)
		return -1;

	/* Increase this window's height */
	seth(w, w->h + 1);

	/* Decrease next window's height */
	seth(nextw, nextw->h - 1);

	/* Do it */
	wfit(w->t);

	return 0;
}

/* Shrink window */

int wshrink(W *w)
{
	W *nextw;

	/* If we're the last window on the screen, grow the previous window */
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) && w != w->t->topwin)
		return wgrow(w->link.prev->main);

	/* Is this window too small already? */
	if (w->h <= FITHEIGHT)
		return -1;

	/* Get to window below us */
	for (nextw = w->link.next; nextw != w->t->topwin && nextw->fixed; nextw = nextw->link.next) ;
	if (nextw == w->t->topwin)
		return -1;

	/* Decrease the size of this window */
	seth(w, w->h - 1);

	/* Increase the size of next window */
	seth(nextw, nextw->h + 1);

	/* Do it */
	wfit(w->t);

	return 0;
}

/* Grow window up */

int wgrowup(W *w)
{
	return wshrink(w->link.prev->main);
}

/* Grow window down */

int wgrowdown(W *w)
{
	return wgrow(w->link.prev->main);
}

/* Show all windows */

void wshowall(Screen *t)
{
	int n = 0;
	int set;
	W *w;

	/* Count no. of main windows */
	w = t->topwin;
	do {
		if (!w->win)
			++n;
		w = w->link.next;
	} while (w != t->topwin);

	/* Compute size to set each window */
	if ((set = (t->h - t->wind) / n) < FITHEIGHT)
		set = FITHEIGHT;

	/* Set size of each variable size window */
	w = t->topwin;
	do {
		if (!w->win) {
			int h = getminh(w);

			if (h >= set)
				seth(w, 2);
			else
				seth(w, set - (h - 2));
			w->orgwin = NULL;
		}
		w = w->link.next;
	} while (w != t->topwin);

	/* Do it */
	wfit(t);
}

static void wspread(Screen *t)
{
	int n = 0;
	W *w = t->topwin;

	do {
		if (w->y >= 0 && !w->win)
			++n;
		w = w->link.next;
	} while (w != t->topwin);
	if (!n) {
		wfit(t);
		return;
	}
	if ((t->h - t->wind) / n >= FITHEIGHT)
		n = (t->h - t->wind) / n;
	else
		n = FITHEIGHT;
	w = t->topwin;
	do {
		if (!w->win) {
			int h = getminh(w);

			if (h >= n)
				seth(w, 2);
			else
				seth(w, n - (h - 2));
			w->orgwin = NULL;
		}
		w = w->link.next;
	} while (w != t->topwin);
	wfit(t);
}

/* Show just one family of windows */

void wshowone(W *w)
{
	W *q = w->t->topwin;

	do {
		if (!q->win) {
			seth(q, w->t->h - w->t->wind - (getminh(q) - 2));
			q->orgwin = NULL;
		}
		q = q->link.next;
	} while (q != w->t->topwin);
	wfit(w->t);
}

/* Create a window */

W *wcreate(Screen *t, WATOM *watom, W *where, W *target, W *original, int height, unsigned char *huh)
{
	W *new;

	if (height < 1)
		return NULL;

	/* Create the window */
	new = (W *) joe_malloc(sizeof(W));
	new->coro = 0;
	new->t = t;
	new->w = t->w - 1;
	seth(new, height);
	new->h = new->reqh;
	new->y = -1;
	new->ny = 0;
	new->nh = 0;
	new->x = 0;
	new->huh = huh;
	new->orgwin = original;
	new->watom = watom;
	new->object = NULL;
	new->msgb = NULL;
	new->msgt = NULL;
	/* Set window's target and family */
/* was:	if (new->win = target) {	which may be mistyped == */
	if ((new->win = target) != NULL) {	/* A subwindow */
		new->main = target->main;
		new->fixed = height;
	} else {		/* A parent window */
		new->main = new;
		new->fixed = 0;
	}

	/* Get space for window */
	if (original) {
		if (original->h - height <= 2) {
			/* Not enough space for window */
			joe_free(new);
			return NULL;
		} else
			seth(original, original->h - height);
	}

	/* Create new keyboard handler for window */
	if (watom->context)
		new->kbd = mkkbd(kmap_getcontext(watom->context));
	else
		new->kbd = NULL;

	/* Put window on the screen */
	if (where)
		enquef(W, link, where, new);
	else {
		if (t->topwin)
			enqueb(W, link, t->topwin, new);
		else {
			izque(W, link, new);
			t->curwin = t->topwin = new;
		}
	}

	return new;
}

/* Abort group of windows */

static int doabort(W *w, int *ret)
{
	int amnt = geth(w);
	W *z;

	w->y = -2;
	if (w->t->topwin == w)
		w->t->topwin = w->link.next;
      loop:
	z = w->t->topwin;
	do {
		if (z->orgwin == w)
			z->orgwin = NULL;
		if ((z->win == w || z->main == w) && z->y != -2) {
			amnt += doabort(z, ret);
			goto loop;
		}
	} while (z = z->link.next, z != w->t->topwin);
	if (w->orgwin)
		seth(w->orgwin, geth(w->orgwin) + geth(w));
	if (w->t->curwin == w) {
		if (w->t->curwin->win)
			w->t->curwin = w->t->curwin->win;
		else if (w->orgwin)
			w->t->curwin = w->orgwin;
		else
			w->t->curwin = w->link.next;
	}
	if (qempty(W, link, w)) {
		leave = 1;
		amnt = 0;
	}
	deque(W, link, w);
	if (w->watom->abort && w->object) {
		*ret = w->watom->abort(w->object);
	} else {
		*ret = -1;
	}
	rmkbd(w->kbd);
	joe_free(w);
	windie(w);
	return amnt;
}

/* Abort a window and its children */

int wabort(W *w)
{
	Screen *t = w->t;
	int ret;

	if (w != w->main) {
		doabort(w, &ret);
		if (!leave)
			wfit(t);
	} else {
		doabort(w, &ret);
		if (!leave) {
			if (lastw(t)->link.next != t->topwin)
				wfit(t);
			else
				wspread(t);
		}
	}
	return ret;
}

/* Display a message and skip the next key */

int bg_msg;

static void mdisp(SCRN *t, int y, unsigned char *s)
{
	int ofst;
	int len;

	len = fmtlen(s);
	if (len <= (t->co - 1))
		ofst = 0;
	else
		ofst = len - (t->co - 1);
	genfmt(t, 0, y, ofst, s, BG_COLOR(bg_msg), 1);
	t->updtab[y] = 1;
}

void msgout(W *w)
{
	SCRN *t = w->t->t;

	if (w->msgb) {
		mdisp(t, w->y + w->h - 1, w->msgb);
		obj_free(w->msgb);
		w->msgb = 0;
	}
	if (w->msgt) {
		mdisp(t, w->y + ((w->h > 1 && (w->y || !staen)) ? 1 : 0), w->msgt);
		obj_free(w->msgt);
		w->msgt = 0;
	}
}

/* Set temporary message */

/* display message on bottom line of window */
void msgnw(W *w, unsigned char *s)
{
	if (w->msgb)
		obj_free(w->msgb);
	w->msgb = vsdupz(s);
	obj_perm(w->msgb);
}

void msgnwt(W *w, unsigned char *s)
{
	if (w->msgt)
		obj_free(w->msgt);
	w->msgt = vsdupz(s);
	obj_perm(w->msgt);
}

int urtn(BASE *b, int k)
{
	if (b->parent->watom->rtn)
		return b->parent->watom->rtn(b, k);
	else
		return -1;
}

int utype(BASE *b, int k)
{
	if (b->parent->watom->type)
		return b->parent->watom->type(b, k);
	else
		return -1;
}

/* Window user commands */

int uprevw(BASE *bw)
{
	return wprev(bw->parent->t);
}

int unextw(BASE *bw)
{
	return wnext(bw->parent->t);
}

int ugroww(BASE *bw)
{
	return wgrow(bw->parent);
}

int ushrnk(BASE *bw)
{
	return wshrink(bw->parent);
}

int uexpld(BASE *bw)
{
	if (bw->parent->t->h - bw->parent->t->wind == getgrouph(bw->parent))
		wshowall(bw->parent->t);
	else
		wshowone(bw->parent);
	return 0;
}

int uretyp(BASE *bw)
{
	nredraw(bw->parent->t->t);
	return 0;
}

/* Get message window on screen */

W *find_window(Screen *t, B *b)
{
	W *w = t->topwin;
	do {
		if (w->watom == &watomtw && ((BW *)w->object)->b == b)
			return w;
		w = w->link.next;
	} while(w != t->topwin);
	return 0;
}

int umwind(BW *bw)
{
	W *msgw;
	if (!errbuf) {
		msgnw(bw->parent, joe_gettext(_("There is no message buffer")));
		return -1;
	}

	/* Find message window */
	msgw = find_window(bw->parent->t, errbuf);

	if (msgw) {
		/* The window exists */
		bw->parent->t->curwin = msgw;
		wshowone(msgw);
		return 0;
	} else {
		/* Make it the current window */
		msgw = bw->parent;
		get_buffer_in_window(bw, errbuf);
		wshowone(msgw);
		return 0;
	}
}

/* Fit previous window and current window on screen.  If there is no previous window,
 * split the current window to create one. */

int umfit(BW *bw)
{
	W *p;
	W *w = bw->parent->main;
	Screen *t = w->t;
	wshowone(w);
	p = findtopw(w)->link.prev->main;
	if (p == w) {
		/* We have to split */
		usplitw(bw);
	}
	w = t->curwin;
	p = findtopw(w)->link.prev->main;
	if (p == w) {
		return -1;
	}
	/* Request size */
	if (p->t->h - 6 < 3)
		return -1;
	seth(p, p->t->h - 6);
	t->topwin = p;
	t->curwin = p;
	/* Fit them on the screen */
	wfit(t);
	t->curwin = w;
	wfit(t);
	return 0;
}
@


1.38
log
@get uquery to use coroutines: eliminates recursive edloop calls.
@
text
@d567 1
a567 1
W *wcreate(Screen *t, WATOM *watom, W *where, W *target, W *original, int height, unsigned char *huh, int *notify)
a576 1
	new->notify = notify;
a668 2
		if (w->notify)
			*w->notify = -1;
a670 2
		if (w->notify)
			*w->notify = 1;
@


1.37
log
@semiautomatic variables
@
text
@d576 1
@


1.36
log
@fix compiler warnings
@
text
@d729 1
d734 1
a740 2
unsigned char msgbuf[JOE_MSGBUFSIZE];

d744 4
a747 1
	w->msgb = s;
d752 4
a755 1
	w->msgt = s;
@


1.35
log
@gettext()
@
text
@a840 1
	return -1;
@


1.34
log
@A option for search
Restore cursor to old position
@
text
@d822 1
a822 1
		msgnw(bw->parent, US "There is no message buffer");
@


1.33
log
@Change SCREEN to Screen
@
text
@d804 71
@


1.32
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d12 1
a12 1
int countmain(SCREEN *t)
d135 1
a135 1
W *lastw(SCREEN *t)
d145 1
a145 1
SCREEN *scr;
d147 1
a147 1
SCREEN *screate(SCRN *scrn)
d149 1
a149 1
	SCREEN *t = (SCREEN *) joe_malloc(sizeof(SCREEN));
d161 1
a161 1
void sresize(SCREEN *t)
d221 1
a221 1
W *watpos(SCREEN *t,int x,int y)
d240 1
a240 1
void wfit(SCREEN *t)
d376 1
a376 1
int wnext(SCREEN *t)
d389 1
a389 1
int wprev(SCREEN *t)
d478 1
a478 1
void wshowall(SCREEN *t)
d515 1
a515 1
static void wspread(SCREEN *t)
d567 1
a567 1
W *wcreate(SCREEN *t, WATOM *watom, W *where, W *target, W *original, int height, unsigned char *huh, int *notify)
d686 1
a686 1
	SCREEN *t = w->t;
@


1.31
log
@New line attribute cache.
@
text
@a7 1
#include "config.h"
a9 18
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "blocks.h"
#include "kbd.h"
#include "poshist.h"
#include "queue.h"
#include "rc.h"
#include "scrn.h"
#include "utils.h"
#include "utf8.h"
#include "syntax.h"
#include "w.h"

extern int dspasis;		/* Set to display chars above 127 as-is */
extern int staen;		/* 0 if top-most status line not displayed */

a29 1
	int x;
a238 1
extern volatile int dostaupd;
@


1.30
log
@Background color for screen item
@
text
@a50 2
	for(x=0; x!=w->h; ++x)
		invalidate_state(w->t->t->syntab + w->y + x);
d208 1
a208 2
		invalidate_state(scr->t->syntab + y);
		}
a383 1
				int q;
d385 1
a385 3
				for(q=0; q!=w->nh; ++q)
					invalidate_state(t->t->syntab + w->ny + q);
				}
@


1.29
log
@        Reformat mouse.c

        Apply diff patch

        Apply vpath patch

        Apply electrum's mouse patch (send mouse off code during
        shell escape)

        Mouse can now resize windows

        Mouse can position cursor in menus.  Double-click selects
        an item.  Need to add scroll.

@
text
@d734 2
d746 1
a746 1
	genfmt(t, 0, y, ofst, s, 1);
@


1.28
log
@Jesse McGrew's xterm mouse support.
@
text
@d489 14
@


1.27
log
@Highlighter state now includes a saved string.
This improves shell and perl highlighters.
@
text
@d244 10
@


1.26
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d23 1
d49 1
d51 2
a52 1
	msetI(w->t->t->syntab + w->y, -1, w->h);
d210 1
a210 1
		scr->t->syntab[y] = -1;
d377 1
d379 2
a380 1
				msetI(t->t->syntab + w->ny, -1, w->nh);
@


1.25
log
@Allow UTF-8 in menu entries.

Clear up genfield() and genfmt() stuff.  Now control characters in
file names are properly displayed.

When UTF-8 character decodes to 127 - 159, 0 - 31, display it
as a control character.
@
text
@a26 1
extern int utf8;
@


1.24
log
@Oops: fixed status line (forgot fmtpos()).
@
text
@a703 275
/* Generate text with formatting escape sequences */

extern int mk_wcwidth(int c);

void genfmt(SCRN *t, int x, int y, int ofst, unsigned char *s, int flg)
{
	int *scrn = t->scrn + y * t->co + x;
	int *attr = t->attr + y * t->co + x;
	int atr = 0;
	int col = 0;
	int c;
	struct utf8_sm sm;

	utf8_init(&sm);

	while ((c = *s++) != '\0')
		if (c == '\\') {
			switch (c = *s++) {
			case 'u':
			case 'U':
				atr ^= UNDERLINE;
				break;
			case 'i':
			case 'I':
				atr ^= INVERSE;
				break;
			case 'b':
			case 'B':
				atr ^= BOLD;
				break;
			case 'd':
			case 'D':
				atr ^= DIM;
				break;
			case 'f':
			case 'F':
				atr ^= BLINK;
				break;
			case 0:
				--s;
				break;
			default:
				/* Allow only ASCII here */
				if (col++ >= ofst) {
					outatr(utf8, t, scrn, attr, x, y, (c&0x7F), atr);
					++scrn;
					++attr;
					++x;
				}
				break;
			}
		} else {
			int wid = 0;
			int d;
			if(utf8) {
				d = utf8_decode(&sm,c);
				if (d>=0)
					wid = mk_wcwidth(d);
			} else {
				d = c;
				wid = 1;
			}
			if (d=='\t')
				d = ' ';

			if (col >= ofst) {
				outatr(utf8, t, scrn, attr, x, y, d, atr);
				scrn += wid;
				attr += wid;
				x += wid;
				col += wid;
			} else if (col+wid>ofst) {
				while (col<ofst) {
					++col;
					--wid;
				}
				while (wid) {
					outatr(utf8, t, scrn, attr, x, y, '<', atr);
					++scrn;
					++attr;
					++x;
					++col;
					--wid;
				}
			} else
				col += wid;
		}
	if (flg)
		eraeol(t, x, y);
}

/* Generate text: no formatting */

void gentxt(SCRN *t, int x, int y, int ofst, unsigned char *s, int len, int flg)
{
	int *scrn = t->scrn + y * t->co + x;
	int *attr = t->attr + y * t->co + x;
	int col;
	unsigned char c;
	int a;

	if (utf8) {
		struct utf8_sm sm;
		utf8_init(&sm);
		col = 0;
		while(*s) {
			int d = utf8_decode(&sm, *s);
			int wid = 0;
			if (d>=0)
				wid = mk_wcwidth(d);

			if (d=='\t')
				d = ' ';

			if (col>=ofst) {
				outatr(utf8, t, scrn, attr, x, y, d, a);
				scrn+=wid;
				attr+=wid;
				x+=wid;
				col+=wid;
			} else if (col+wid>ofst) {
				while (col<ofst) {
					++col;
					--wid;
				}
				while (wid) {
					outatr(utf8, t, scrn, attr, x, y, '<', a);
					++scrn;
					++attr;
					++x;
					++col;
					--wid;
				}
			} else
				col += wid;

			++s;
		}
	} else {
		for (col = 0; col != len; ++col)
			if (col >= ofst) {
				c = s[col];
				if (c == '\t')
					c = ' ';
				xlat(&a, &c);
				outatr(utf8, t, scrn, attr, x, y, c, a);
				++scrn;
				++attr;
				++x;
			}
	}
	if (flg)
		eraeol(t, x, y);
}

/* Width function for above */

int gentxtwidth(unsigned char *s)
{
	if (utf8) {
		int col=0;
		struct utf8_sm sm;
		utf8_init(&sm);

		while(*s) {
			int d = utf8_decode(&sm,*s);
			if (d>=0)
				col += mk_wcwidth(d);
		++s;
		}

		return col;
	} else
		return strlen((char *)s);
}

/* Determine column width of string with format codes */

int fmtlen(unsigned char *s)
{
	int col = 0;
	struct utf8_sm sm;

	utf8_init(&sm);

	while (*s) {
		if (*s == '\\') {
			switch (*++s) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				++s;
				continue;
			case 0:
				return col;
			default:
				++s;
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(utf8) {
				int d = utf8_decode(&sm,*s);
				if (d>=0)
					wid = mk_wcwidth(d);
			} else {
				wid = 1;
			}
			col += wid;
			++s;
		}
	}
	return col;
}

/* Return offset within format string which corresponds to a particular
   column */

/* FIXME: this is not valid if we land in the middle of a double-wide character */

int fmtpos(unsigned char *s, int goal)
{
	unsigned char *org = s;
	int col = 0;
	struct utf8_sm sm;

	utf8_init(&sm);

	while (*s && col<goal) {
		if (*s == '\\') {
			switch (*++s) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				++s;
				continue;
			case 0:
				return col;
			default:
				++s;
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(utf8) {
				int d = utf8_decode(&sm,*s);
				if (d>=0)
					wid = mk_wcwidth(d);
			} else {
				wid = 1;
			}
			col += wid;
			++s;
		}
	}

	return s - org + goal - col;
}

@


1.23
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d930 2
d936 3
d940 2
a941 2
	while (*s && col != goal) {
		if (*s == '\\')
d956 14
a969 1
				--s;
d971 3
a973 2
		++col;
		++s;
d975 1
@


1.22
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d22 1
d706 2
d715 3
d746 1
d748 1
a748 1
					outatr(utf8, t, scrn, attr, x, y, c, atr);
d755 35
a789 7
		} else if (col++ >= ofst) {
			if (c == '\t')
				c = ' ';
			outatr(utf8, t, scrn, attr, x, y, c, atr);
			++scrn;
			++attr;
			++x;
d805 36
a840 10
	for (col = 0; col != len; ++col)
		if (col >= ofst) {
			c = s[col];
			if (c == '\t')
				c = ' ';
			xlat(&a, &c);
			outatr(utf8, t, scrn, attr, x, y, c, a);
			++scrn;
			++attr;
			++x;
d842 13
d859 21
d885 3
d905 14
a918 1
				--s;
d920 2
a922 2
		++col;
		++s;
@


1.21
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d26 1
d741 1
a741 1
					outatr(t, scrn, attr, x, y, c, atr);
d751 1
a751 1
			outatr(t, scrn, attr, x, y, c, atr);
d776 1
a776 1
			outatr(t, scrn, attr, x, y, c, a);
@


1.20
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d564 1
a564 1
W *wcreate(SCREEN *t, WATOM *watom, W *where, W *target, W *original, int height, char *huh, int *notify)
d665 1
a665 1
		*ret = w->watom->abort(w->object, MAXINT);
d704 1
a704 1
void genfmt(SCRN *t, int x, int y, int ofst, char *s, int flg)
d761 1
a761 1
void gentxt(SCRN *t, int x, int y, int ofst, char *s, int len, int flg)
d786 1
a786 1
int fmtlen(char *s)
d818 1
a818 1
int fmtpos(char *s, int goal)
d820 1
a820 1
	char *org = s;
d849 1
a849 1
static void mdisp(SCRN *t, int y, char *s)
d879 1
a879 1
char msgbuf[JOE_MSGBUFSIZE];
d882 1
a882 1
void msgnw(W *w, char *s)
d887 1
a887 1
void msgnwt(W *w, char *s)
@


1.19
log
@Syntax highlighting baby steps.
@
text
@d707 1
d740 1
a740 1
					outatr(t, scrn, x, y, c, atr);
d742 1
d750 1
a750 1
			outatr(t, scrn, x, y, c, atr);
d752 1
d764 1
d775 1
a775 1
			outatr(t, scrn, x, y, c, a);
d777 1
@


1.18
log
@change 0 to NULL where we're talking about pointers
@
text
@d48 1
d204 1
a204 1
	for (y = 0; y != scr->h; ++y)
d206 2
d372 1
a372 1
			if (w->y == -1)
d374 2
@


1.17
log
@rename getcontext() to kmap_getcontext() to prevent conflict with glibc
@
text
@d171 2
a172 2
	t->topwin = 0;
	t->curwin = 0;
d263 1
a263 1
	pw = 0;
d498 1
a498 1
			w->orgwin = 0;
d534 1
a534 1
			w->orgwin = 0;
d550 1
a550 1
			q->orgwin = 0;
d564 1
a564 1
		return 0;
d580 3
a582 3
	new->object = 0;
	new->msgb = 0;
	new->msgt = 0;
d598 1
a598 1
			return 0;
d607 1
a607 1
		new->kbd = 0;
d638 1
a638 1
			z->orgwin = 0;
@


1.16
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d605 1
a605 1
		new->kbd = mkkbd(getcontext(watom->context));
@


1.15
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d135 4
a138 3
		if (w == w->t->topwin)
			flg = 1, w->t->topwin = next;
		else
d191 4
a194 2
		w->y = -1, w->w = t->w - 1;
	} while (w = w->link.next, w != t->topwin);
d217 2
a218 1
		} while (w = w->link.next, w != scr->topwin);
d232 2
a233 1
		} while (w = w->link.next, w != scr->topwin);
d269 2
a270 1
	} while ((w = w->link.next) != t->topwin);
d284 4
a287 2
			if (!w->win)
				pw = w, w->nh -= adj;	/* Adjust main window of the group */
d376 2
a377 1
	} while (w = w->link.next, w != t->topwin);
d481 2
a482 1
	} while (w = w->link.next, w != t->topwin);
d500 2
a501 1
	} while (w = w->link.next, w != t->topwin);
d515 2
a516 1
	} while (w = w->link.next, w != t->topwin);
d536 2
a537 1
	} while (w = w->link.next, w != t->topwin);
d552 2
a553 1
	} while (q = q->link.next, q != w->t->topwin);
d615 4
a618 2
		else
			izque(W, link, new), t->curwin = t->topwin = new;
@


1.14
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d165 1
a165 1
	SCREEN *t = (SCREEN *) malloc(sizeof(SCREEN));
d553 1
a553 1
	new = (W *) malloc(sizeof(W));
d583 1
a583 1
			free(new);
d653 1
a653 1
	free(w);
@


1.13
log
@change xlat macro into xlat(int *, char *) function
@
text
@d29 1
a29 1
int countmain(SCREEN * t)
d45 1
a45 1
void wredraw(W * w)
d52 1
a52 1
W *findtopw(W * w)
d63 1
a63 1
static int geth(W * w)
d75 1
a75 1
static void seth(W * w, int h)
d86 1
a86 1
int getgrouph(W * w)
d102 1
a102 1
static int getminh(W * w)
d115 1
a115 1
W *findbotw(W * w)
d126 1
a126 1
int demotegroup(W * w)
d151 1
a151 1
W *lastw(SCREEN * t)
d163 1
a163 1
SCREEN *screate(SCRN * scrn)
d177 1
a177 1
void sresize(SCREEN * t)
d204 1
a204 1
void scrins(B * b, long l, long n, int flg)
d218 1
a218 1
void scrdel(B * b, long l, long n, int flg)
d242 1
a242 1
void wfit(SCREEN * t)
d373 1
a373 1
int wnext(SCREEN * t)
d386 1
a386 1
int wprev(SCREEN * t)
d401 1
a401 1
int wgrow(W * w)
d430 1
a430 1
int wshrink(W * w)
d461 1
a461 1
void wshowall(SCREEN * t)
d496 1
a496 1
static void wspread(SCREEN * t)
d530 1
a530 1
void wshowone(W * w)
d545 1
a545 1
W *wcreate(SCREEN * t, WATOM * watom, W * where, W * target, W * original, int height, char *huh, int *notify)
d610 1
a610 1
static int doabort(W * w, int *ret)
d660 1
a660 1
int wabort(W * w)
d683 1
a683 1
void genfmt(SCRN * t, int x, int y, int ofst, char *s, int flg)
d737 1
a737 1
void gentxt(SCRN * t, int x, int y, int ofst, char *s, int len, int flg)
d823 1
a823 1
static void mdisp(SCRN * t, int y, char *s)
d837 1
a837 1
void msgout(W * w)
d866 1
a866 1
int urtn(BASE * b, int k)
d874 1
a874 1
int utype(BASE * b, int k)
d884 1
a884 1
int uprevw(BASE * bw)
d889 1
a889 1
int unextw(BASE * bw)
d894 1
a894 1
int ugroww(BASE * bw)
d899 1
a899 1
int ushrnk(BASE * bw)
d904 1
a904 1
int uexpld(BASE * bw)
d913 1
a913 1
int uretyp(BASE * bw)
@


1.12
log
@change indentation of cases in the switch() statement
@
text
@d741 1
a741 1
	int c;
d746 1
a746 1
			c = (unsigned) s[col];
d749 1
a749 1
			xlat(a, c);
@


1.11
log
@change indentation of do {} while() cycles
@
text
@d691 1
a691 1
		if (c == '\\')
d693 2
a694 2
				case 'u':
				case 'U':
d697 2
a698 3

				case 'i':
				case 'I':
d701 2
a702 3

				case 'b':
				case 'B':
d705 2
a706 3

				case 'd':
				case 'D':
d709 2
a710 3

				case 'f':
				case 'F':
d713 1
a713 2

				case 0:
d716 1
a716 2

				default:
d723 1
d765 1
a765 1
		if (*s == '\\')
d767 10
a776 10
				case 'u':
				case 'i':
				case 'd':
				case 'f':
				case 'b':
				case 'U':
				case 'I':
				case 'D':
				case 'F':
				case 'B':
d778 2
a779 3
				goto cont;

				case 0:
d782 1
a784 1
	      cont:;
d800 10
a809 10
				case 'u':
				case 'i':
				case 'd':
				case 'f':
				case 'b':
				case 'U':
				case 'I':
				case 'D':
				case 'F':
				case 'B':
d811 2
a812 3
				goto cont;

				case 0:
a816 1
	      cont:;
@


1.10
log
@include only headers which are needed
@
text
@d189 1
a189 1
	do
d191 1
a191 1
	while (w = w->link.next, w != t->topwin);
d264 1
a264 2
	}
	while ((w = w->link.next) != t->topwin);
d288 2
a289 4
		}
		while (w != t->topwin && w->main == w->link.prev->main);
	}
	while (w != t->topwin && left >= FITHEIGHT);
d309 1
a309 1
	do
d349 1
a349 1
	while (w != t->topwin);
d368 1
a368 2
	}
	while (w = w->link.next, w != t->topwin);
d469 1
a469 1
	do
d472 1
a472 1
	while (w = w->link.next, w != t->topwin) ;
d480 1
a480 1
	do
d490 1
a490 1
	while (w = w->link.next, w != t->topwin) ;
d501 1
a501 1
	do
d504 1
a504 1
	while (w = w->link.next, w != t->topwin) ;
d514 1
a514 1
	do
d524 1
a524 1
	while (w = w->link.next, w != t->topwin) ;
d534 1
a534 1
	do
d539 1
a539 1
	while (q = q->link.next, q != w->t->topwin) ;
d627 1
a627 2
	}
	while (z = z->link.next, z != w->t->topwin);
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@d14 6
a19 1
#include "b.h"
a20 4
#include "queue.h"
#include "main.h"
#include "poshist.h"
#include "blocks.h"
@


1.8
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d2 8
a9 5
	Window system
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.7
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d863 1
a863 1
char msgbuf[MSGBUFSIZE];
@


1.6
log
@version 2.9.7-pre3
@
text
@d866 1
a866 1
void msgnw(BASE *w, char *s)
d868 1
a868 1
	w->parent->msgb = s;
d871 1
a871 1
void msgnwt(BASE *w, char *s)
d873 1
a873 1
	w->parent->msgt = s;
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d60 1
a60 1
int geth(W * w)
d72 1
a72 1
void seth(W * w, int h)
d99 1
a99 1
int getminh(W * w)
d236 1
a236 1
static int doabort();
d497 1
a497 1
void wspread(SCREEN * t)
d865 2
a866 1
void msgnw(BASE * w, char *s)
d871 1
a871 1
void msgnwt(BASE * w, char *s)
@


1.4
log
@changed as of joe-2.9.6
@
text
@d9 3
d26 2
a27 1
int countmain (SCREEN * t) {
d31 1
d33 4
a36 5
		if (q->main != m)
		  {
			  ++nmain;
			  m = q->main;
		  }
d42 3
a44 2
void wredraw (W *w) {
	msetI (w->t->t->updtab + w->y, 1, w->h);
d49 2
a50 1
W *findtopw (W *w) {
d52 2
a53 2
	for (x = w; x->link.prev->main == w->main && x->link.prev != w;
	     x = x->link.prev);
d60 2
a61 1
int geth (W *w) {
d72 2
a73 1
void seth (W *w, int h) {
d75 1
d78 1
a78 3
	w->hh =
		tmp / (w->t->h - w->t->wind) +
		(tmp % (w->t->h - w->t->wind) ? 1 : 0);
d83 2
a84 1
int getgrouph (W *w) {
d89 1
a89 1
	x = findtopw (w);
d92 1
a92 3
	for (w = x, h = geth (w);
	     w->link.next != x && w->link.next->main == x->main;
	     w = w->link.next, h += geth (w));
d99 2
a100 1
int getminh (W *w) {
d103 3
a105 4
	x = findtopw (w);
	for (w = x, h = (w->fixed ? w->fixed : 2);
	     w->link.next != x && w->link.next->main == x->main;
	     w = w->link.next, h += (w->fixed ? w->fixed : 2));
d112 2
a113 1
W *findbotw (W *w) {
d115 2
a116 2
	for (x = w; x->link.next->main == w->main && x->link.next != w;
	     x = x->link.next);
d123 4
a126 3
int demotegroup (W *w) {
	W *top = findtopw (w);
	W *bot = findbotw (w);
d129 9
a137 9
	for (w = top; w != bot; w = next)
	  {
		  next = w->link.next;
		  if (w == w->t->topwin)
			  flg = 1, w->t->topwin = next;
		  else
			  demote (W, link, w->t->topwin, w);
		  w->y = -1;
	  }
d141 1
a141 1
		demote (W, link, w->t->topwin, w);
d148 2
a149 1
W *lastw (SCREEN *t) {
d151 2
a152 2
	for (x = t->topwin; x->link.next != t->topwin && x->link.next->y >= 0;
	     x = x->link.next);
d160 4
a163 2
SCREEN *screate (SCRN *scrn) {
	SCREEN *t = (SCREEN *) malloc (sizeof (SCREEN));
d174 2
a175 1
void sresize (SCREEN *t) {
d178 1
d189 2
a190 2
	wfit (t);
	updall ();
d193 2
a194 1
void updall (void) {
d196 1
d201 2
a202 1
void scrins (B *b, long l, long n, int flg) {
d204 9
a212 9
	if (w = scr->topwin)
		do
			if (w->y >= 0)
			  {
				  if (w->object && w->watom->ins)
					  w->watom->ins (w->object, b, l, n,
							 flg);
			  }
		while (w = w->link.next, w != scr->topwin);
d215 2
a216 1
void scrdel (B *b, long l, long n, int flg) {
d218 9
a226 9
	if (w = scr->topwin)
		do
			if (w->y >= 0)
			  {
				  if (w->object && w->watom->del)
					  w->watom->del (w->object, b, l, n,
							 flg);
			  }
		while (w = w->link.next, w != scr->topwin);
d236 1
a236 1
static int doabort ();
d239 2
a240 1
void wfit (SCREEN *t) {
d249 1
d258 4
a261 5
	do
	  {
		  w->ny = -1;
		  w->nh = geth (w);
	  }
d266 23
a288 27
	do
	  {
		  req = getgrouph (w);
		  if (req > left)	/* If group is taller than lines left */
			  adj = req - left;	/* then family gets shorter */
		  else
			  adj = 0;

		  /* Fit a family of windows on the screen */
		  do
		    {
			    w->ny = y;	/* Set window's y position */
			    if (!w->win)
				    pw = w, w->nh -= adj;	/* Adjust main window of the group */
			    if (!w->win && w->nh < 2)
				    while (w->nh < 2)
					    w->nh +=
						    doabort (w->link.next,
							     &ret);
			    if (w == t->curwin)
				    flg = 1;	/* Set if we got window with cursor */
			    y += w->nh;
			    left -= w->nh;	/* Increment y value by height of window */
			    w = w->link.next;	/* Next window */
		    }
		  while (w != t->topwin && w->main == w->link.prev->main);
	  }
d300 4
a303 5
	if (!flg)
	  {
		  t->topwin = findbotw (t->topwin)->link.next;
		  goto tryagain;
	  }
d311 35
a345 55
			if (w->ny > w->y)
			  {
				  W *l = pw = w;
				  while (pw->link.next != t->topwin &&
					 (pw->link.next->y < 0
					  || pw->link.next->ny < 0
					  || pw->link.next->ny >
					  pw->link.next->y))
				    {
					    pw = pw->link.next;
					    if (pw->ny >= 0 && pw->y >= 0)
						    l = pw;
				    }
				  /* Scroll windows between l and w */
				loop1:
				  if (l->ny >= 0 && l->y >= 0)
					  nscrldn (t->t, l->y,
						   l->ny + uns_min (l->h,
								    l->nh),
						   l->ny - l->y);
				  if (w != l)
				    {
					    l = l->link.prev;
					    goto loop1;
				    }
				  w = pw->link.next;
			  }
			else if (w->ny < w->y)
			  {
				  W *l = pw = w;
				  while (pw->link.next != t->topwin &&
					 (pw->link.next->y < 0 ||
					  pw->link.next->ny < 0 ||
					  pw->link.next->ny <
					  pw->link.next->y))
				    {
					    pw = pw->link.next;
					    if (pw->ny >= 0 && pw->y >= 0)
						    l = pw;
				    }
				  /* Scroll windows between l and w */
				loop0:
				  if (w->ny >= 0 && w->y >= 0)
					  nscrlup (t->t, w->ny,
						   w->y + uns_min (w->h,
								   w->nh),
						   w->y - w->ny);
				  if (w != l)
				    {
					    w = w->link.next;
					    goto loop0;
				    }
				  w = pw->link.next;
			  }
			else
d353 16
a368 22
	do
	  {
		  if (w->ny >= 0)
		    {
			    if (w->object)
			      {
				      if (w->watom->move)
					      w->watom->move (w->object, w->x,
							      w->ny);
				      if (w->watom->resize)
					      w->watom->resize (w->object,
								w->w, w->nh);
			      }
			    if (w->y == -1)
				    msetI (t->t->updtab + w->ny, 1, w->nh);
			    w->y = w->ny;
		    }
		  else
			  w->y = -1;
		  w->h = w->nh;
		  w->reqh = 0;
	  }
d374 8
a381 9
int wnext (SCREEN *t) {
	if (t->curwin->link.next != t->curwin)
	  {
		  t->curwin = t->curwin->link.next;
		  if (t->curwin->y == -1)
			  wfit (t);
		  return 0;
	  }
	else
d387 10
a396 12
int wprev (SCREEN *t) {
	if (t->curwin->link.prev != t->curwin)
	  {
		  t->curwin = t->curwin->link.prev;
		  if (t->curwin->y == -1)
		    {
			    t->topwin = findtopw (t->curwin);
			    wfit (t);
		    }
		  return 0;
	  }
	else
d402 2
a403 1
int wgrow (W *w) {
d407 2
a408 3
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) &&
	    w != w->t->topwin)
		return wshrink (w->link.prev->main);
d411 1
a411 2
	for (nextw = w->link.next; nextw->fixed && nextw != w->t->topwin;
	     nextw = nextw->link.next);
d418 1
a418 1
	seth (w, w->h + 1);
d421 1
a421 1
	seth (nextw, nextw->h - 1);
d424 1
a424 1
	wfit (w->t);
d431 2
a432 1
int wshrink (W *w) {
d436 2
a437 3
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) &&
	    w != w->t->topwin)
		return wgrow (w->link.prev->main);
d444 1
a444 2
	for (nextw = w->link.next;
	     nextw != w->t->topwin && nextw->fixed; nextw = nextw->link.next);
d449 1
a449 1
	seth (w, w->h - 1);
d452 1
a452 1
	seth (nextw, nextw->h + 1);
d455 1
a455 1
	wfit (w->t);
d462 2
a463 1
void wshowall (SCREEN *t) {
d473 1
a473 1
	while (w = w->link.next, w != t->topwin);
d482 10
a491 10
		if (!w->win)
		  {
			  int h = getminh (w);
			  if (h >= set)
				  seth (w, 2);
			  else
				  seth (w, set - (h - 2));
			  w->orgwin = 0;
		  }
	while (w = w->link.next, w != t->topwin);
d494 1
a494 1
	wfit (t);
d497 2
a498 1
void wspread (SCREEN *t) {
d501 1
d505 5
a509 6
	while (w = w->link.next, w != t->topwin);
	if (!n)
	  {
		  wfit (t);
		  return;
	  }
d516 11
a526 11
		if (!w->win)
		  {
			  int h = getminh (w);
			  if (h >= n)
				  seth (w, 2);
			  else
				  seth (w, n - (h - 2));
			  w->orgwin = 0;
		  }
	while (w = w->link.next, w != t->topwin);
	wfit (t);
d531 2
a532 1
void wshowone (W *w) {
d534 1
d536 6
a541 7
		if (!q->win)
		  {
			  seth (q, w->t->h - w->t->wind - (getminh (q) - 2));
			  q->orgwin = 0;
		  }
	while (q = q->link.next, q != w->t->topwin);
	wfit (w->t);
d546 2
a547 1
W *wcreate (SCREEN *t, WATOM *watom, W *where, W *target, W *original, int height, char *huh, int *notify) {
d554 1
a554 1
	new = (W *) malloc (sizeof (W));
d558 1
a558 1
	seth (new, height);
d571 8
a578 10
	if (new->win = target)
	  {			/* A subwindow */
		  new->main = target->main;
		  new->fixed = height;
	  }
	else
	  {			/* A parent window */
		  new->main = new;
		  new->fixed = 0;
	  }
d581 8
a588 9
	if (original)
		if (original->h - height <= 2)
		  {
			  /* Not enough space for window */
			  free (new);
			  return 0;
		  }
		else
			seth (original, original->h - height);
d592 1
a592 1
		new->kbd = mkkbd (getcontext (watom->context));
d598 7
a604 8
		enquef (W, link, where, new);
	else
	  {
		  if (t->topwin)
			  enqueb (W, link, t->topwin, new);
		  else
			  izque (W, link, new), t->curwin = t->topwin = new;
	  }
d611 3
a613 2
static int doabort (W *w, int *ret) {
	int amnt = geth (w);
d615 1
d621 8
a628 10
	do
	  {
		  if (z->orgwin == w)
			  z->orgwin = 0;
		  if ((z->win == w || z->main == w) && z->y != -2)
		    {
			    amnt += doabort (z, ret);
			    goto loop;
		    }
	  }
d631 2
a632 2
		seth (w->orgwin, geth (w->orgwin) + geth (w));
	if (w->t->curwin == w)
d639 18
a656 21
	if (qempty (W, link, w))
	  {
		  leave = 1;
		  amnt = 0;
	  }
	deque (W, link, w);
	if (w->watom->abort && w->object)
	  {
		  *ret = w->watom->abort (w->object, MAXINT);
		  if (w->notify)
			  *w->notify = -1;
	  }
	else
	  {
		  *ret = -1;
		  if (w->notify)
			  *w->notify = 1;
	  }
	rmkbd (w->kbd);
	free (w);
	windie (w);
d662 2
a663 1
int wabort (W *w) {
d666 14
a679 17
	if (w != w->main)
	  {
		  doabort (w, &ret);
		  if (!leave)
			  wfit (t);
	  }
	else
	  {
		  doabort (w, &ret);
		  if (!leave)
		    {
			    if (lastw (t)->link.next != t->topwin)
				    wfit (t);
			    else
				    wspread (t);
		    }
	  }
d685 2
a686 1
void genfmt (SCRN *t, int x, int y, int ofst, char *s, int flg) {
d691 2
a692 1
	while (c = *s++)
d694 44
a737 48
			switch (c = *s++)
			  {
			  case 'u':
			  case 'U':
				  atr ^= UNDERLINE;
				  break;

			  case 'i':
			  case 'I':
				  atr ^= INVERSE;
				  break;

			  case 'b':
			  case 'B':
				  atr ^= BOLD;
				  break;

			  case 'd':
			  case 'D':
				  atr ^= DIM;
				  break;

			  case 'f':
			  case 'F':
				  atr ^= BLINK;
				  break;

			  case 0:
				  --s;
				  break;

			  default:
				  if (col++ >= ofst)
				    {
					    outatr (t, scrn, x, y, c, atr);
					    ++scrn;
					    ++x;
				    }
				  break;
			  }
		else if (col++ >= ofst)
		  {
			  if (c == '\t')
				  c = ' ';
			  outatr (t, scrn, x, y, c, atr);
			  ++scrn;
			  ++x;
		  }
d739 1
a739 1
		eraeol (t, x, y);
d744 2
a745 1
void gentxt (SCRN * t, int x, int y, int ofst, char *s, int len, int flg) {
d750 1
d752 9
a760 10
		if (col >= ofst)
		  {
			  c = (unsigned) s[col];
			  if (c == '\t')
				  c = ' ';
			  xlat (a, c);
			  outatr (t, scrn, x, y, c, a);
			  ++scrn;
			  ++x;
		  }
d762 1
a762 1
		eraeol (t, x, y);
d767 2
a768 1
int fmtlen (char *s) {
d770 24
a793 25
	while (*s)
	  {
		  if (*s == '\\')
			  switch (*++s)
			    {
			    case 'u':
			    case 'i':
			    case 'd':
			    case 'f':
			    case 'b':
			    case 'U':
			    case 'I':
			    case 'D':
			    case 'F':
			    case 'B':
				    ++s;
				    goto cont;

			    case 0:
				    --s;
			    }
		  ++col;
		  ++s;
		cont:;
	  }
d800 2
a801 1
int fmtpos (char *s, int goal) {
d804 24
a827 25
	while (*s && col != goal)
	  {
		  if (*s == '\\')
			  switch (*++s)
			    {
			    case 'u':
			    case 'i':
			    case 'd':
			    case 'f':
			    case 'b':
			    case 'U':
			    case 'I':
			    case 'D':
			    case 'F':
			    case 'B':
				    ++s;
				    goto cont;

			    case 0:
				    --s;
			    }
		  ++col;
		  ++s;
		cont:;
	  }
d833 2
a834 1
static void mdisp (SCRN *t, int y, char *s) {
d837 2
a838 1
	len = fmtlen (s);
d843 1
a843 1
	genfmt (t, 0, y, ofst, s, 1);
d847 2
a848 1
void msgout (W *w) {
d850 9
a858 11
	if (w->msgb)
	  {
		  mdisp (t, w->y + w->h - 1, w->msgb);
		  w->msgb = 0;
	  }
	if (w->msgt)
	  {
		  mdisp (t, w->y + ((w->h > 1 && (w->y || !staen)) ? 1 : 0),
			 w->msgt);
		  w->msgt = 0;
	  }
d865 2
a866 1
void msgnw (BASE *w, char *s) {
d870 2
a871 1
void msgnwt (BASE *w, char *s) {
d875 2
a876 1
int urtn (BASE *b, int k) {
d878 1
a878 1
		return b->parent->watom->rtn (b, k);
d883 2
a884 1
int utype (BASE *b, int k) {
d886 1
a886 1
		return b->parent->watom->type (b, k);
d893 3
a895 2
int uprevw (BASE *bw) {
	return wprev (bw->parent->t);
d898 3
a900 2
int unextw (BASE *bw) {
	return wnext (bw->parent->t);
d903 3
a905 2
int ugroww (BASE *bw) {
	return wgrow (bw->parent);
d908 3
a910 2
int ushrnk (BASE *bw) {
	return wshrink (bw->parent);
d913 4
a916 3
int uexpld (BASE *bw) {
	if (bw->parent->t->h - bw->parent->t->wind == getgrouph (bw->parent))
		wshowall (bw->parent->t);
d918 1
a918 1
		wshowone (bw->parent);
d922 3
a924 2
int uretyp (BASE *bw) {
	nredraw (bw->parent->t->t);
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Window system
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d18 2
a19 2
extern int dspasis;	/* Set to display chars above 127 as-is */
extern int staen;	/* 0 if top-most status line not displayed */
d23 12
a34 14
int countmain(t)
SCREEN *t;
 {
 int nmain=1;
 W *m=t->curwin->main;
 W *q;
 for(q=t->curwin->link.next;q!=t->curwin;q=q->link.next)
  if(q->main!=m)
   {
   ++nmain;
   m=q->main;
   }
 return nmain;
 }
d38 3
a40 5
void wredraw(w)
W *w;
 {
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
d44 6
a49 7
W *findtopw(w)
W *w;
 {
 W *x;
 for(x=w;x->link.prev->main==w->main && x->link.prev!=w;x=x->link.prev);
 return x;
 }
d54 8
a61 8
int geth(w)
W *w;
 {
 if(w->reqh) return w->reqh;
 else
  if(w->fixed) return w->fixed;
  else return (((long)w->t->h-w->t->wind)*w->hh)/1000;
 }
d65 8
a72 8
void seth(w,h)
W *w;
 {
 long tmp;
 w->reqh=h;
 tmp=1000L*h;
 w->hh=tmp/(w->t->h-w->t->wind)+(tmp%(w->t->h-w->t->wind)?1:0);
 }
d76 11
a86 13
int getgrouph(w)
W *w;
 {
 W *x;
 int h;

 /* Find first window in family */
 x=findtopw(w);

 /* Add heights of all windows in family */
 for(w=x, h=geth(w);
     w->link.next!=x && w->link.next->main==x->main;
     w=w->link.next, h+=geth(w));
d88 2
a89 2
 return h;
 }
d93 7
a99 9
int getminh(w)
W *w;
 {
 W *x;
 int h;
 x=findtopw(w);
 for(w=x, h=(w->fixed?w->fixed:2);
     w->link.next!=x && w->link.next->main==x->main;
     w=w->link.next, h+=(w->fixed?w->fixed:2));
d101 2
a102 2
 return h;
 }
d106 6
a111 7
W *findbotw(w)
W *w;
 {
 W *x;
 for(x=w;x->link.next->main==w->main && x->link.next!=w;x=x->link.next);
 return x;
 }
d116 21
a136 19
int demotegroup(w)
W *w;
 {
 W *top=findtopw(w);
 W *bot=findbotw(w);
 W *next;
 int flg=0;
 for(w=top;w!=bot;w=next)
  {
  next=w->link.next;
  if(w==w->t->topwin) flg=1, w->t->topwin=next;
  else demote(W,link,w->t->topwin,w);
  w->y= -1;
  }
 if(w==w->t->topwin) flg=1;
 else demote(W,link,w->t->topwin,w);
 w->y= -1;
 return flg;
 }
d140 6
a145 7
W *lastw(t)
SCREEN *t;
 {
 W *x;
 for(x=t->topwin;x->link.next!=t->topwin && x->link.next->y>=0;x=x->link.next);
 return x;
 }
d151 60
a210 63
SCREEN *screate(scrn)
SCRN *scrn;
 {
 SCREEN *t=(SCREEN *)malloc(sizeof(SCREEN));
 t->t=scrn;
 t->w=scrn->co;
 t->h=scrn->li;
 t->topwin=0;
 t->curwin=0;
 t->wind=skiptop;
 scr=t;
 return t;
 }

void sresize(t)
SCREEN *t;
 {
 SCRN *scrn=t->t;
 W *w;
 t->w=scrn->co;
 t->h=scrn->li;
 if(t->h-t->wind<FITHEIGHT) t->wind=t->h-FITHEIGHT;
 if(t->wind<0) t->wind=0;
 w=t->topwin; do
  w->y= -1, w->w=t->w-1;
  while(w=w->link.next, w!=t->topwin);
 wfit(t);
 updall();
 }

void updall()
 {
 int y;
 for(y=0;y!=scr->h;++y) scr->t->updtab[y]=1;
 }

void scrins(b,l,n,flg)
B *b;
long l,n;
int flg;
 {
 W *w;
 if(w=scr->topwin) do
  if(w->y>=0)
   {
   if(w->object && w->watom->ins) w->watom->ins(w->object,b,l,n,flg);
   }
  while(w=w->link.next, w!=scr->topwin);
 }

void scrdel(b,l,n,flg)
B *b;
long l,n;
int flg;
 {
 W *w;
 if(w=scr->topwin) do
  if(w->y>=0)
   {
   if(w->object && w->watom->del) w->watom->del(w->object,b,l,n,flg);
   }
  while(w=w->link.next, w!=scr->topwin);
 }
d219 2
a220 2
static int doabort();
extern int dostaupd;
d222 162
a383 128
void wfit(t)
SCREEN *t;
 {
 int y;		/* Where next window goes */
 int left;	/* Lines left on screen */
 W *w;		/* Current window we're fitting */
 W *pw;		/* Main window of previous family */
 int req;	/* Amount this family needs */
 int adj;	/* Amount family needs to be adjusted */
 int flg=0;	/* Set if cursor window was placed on screen */
 int ret;
 dostaupd=1;

 tryagain:
 y=t->wind; left=t->h-y; pw=0;

 w=t->topwin; do
  {
  w->ny= -1;
  w->nh=geth(w);
  }
  while((w=w->link.next)!=t->topwin);

 /* Fit a group of windows on the screen */
 w=t->topwin; do
  {
  req=getgrouph(w);
  if(req>left)		/* If group is taller than lines left */
   adj=req-left;		/* then family gets shorter */
  else adj=0;
  
  /* Fit a family of windows on the screen */
  do
   {
   w->ny=y;			/* Set window's y position */
   if(!w->win) pw=w, w->nh-=adj;	/* Adjust main window of the group */
   if(!w->win && w->nh<2) while(w->nh<2) w->nh+=doabort(w->link.next,&ret);
   if(w==t->curwin) flg=1;	/* Set if we got window with cursor */
   y+=w->nh; left-=w->nh;	/* Increment y value by height of window */
   w=w->link.next;		/* Next window */
   } while(w!=t->topwin && w->main==w->link.prev->main);
  } while(w!=t->topwin && left>=FITHEIGHT);

 /* We can't use extra space to fit a new family on, so give space to parent of
  * previous family */
 pw->nh+=left;

 /* Adjust that family's children which are below the parent */
 while((pw=pw->link.next)!=w) pw->ny+=left;

 /* Make sure the cursor window got on the screen */
 if(!flg)
  {
  t->topwin=findbotw(t->topwin)->link.next;
  goto tryagain;
  }

 /* All of the windows are now on the screen.  Scroll the screen to reflect what
  * happened
  */
 w=t->topwin; do
  if(w->y>=0 && w->ny>=0)
   if(w->ny>w->y)
    {
    W *l=pw=w;
    while(pw->link.next!=t->topwin &&
          (pw->link.next->y<0 || pw->link.next->ny<0 ||
          pw->link.next->ny>pw->link.next->y))
     {
     pw=pw->link.next;
     if(pw->ny>=0 && pw->y>=0) l=pw;
     }
    /* Scroll windows between l and w */
    loop1:
    if(l->ny>=0 && l->y>=0)
     nscrldn(t->t,l->y,l->ny+uns_min(l->h,l->nh),l->ny-l->y);
    if(w!=l)
     {
     l=l->link.prev;
     goto loop1;
     }
    w=pw->link.next;
    }
   else if(w->ny<w->y)
    {
    W *l=pw=w;
    while(pw->link.next!=t->topwin &&
          (pw->link.next->y<0 || 
          pw->link.next->ny<0 || 
          pw->link.next->ny<pw->link.next->y))
     {
     pw=pw->link.next;
     if(pw->ny>=0 && pw->y>=0) l=pw;
     }
    /* Scroll windows between l and w */
    loop0:
    if(w->ny>=0 && w->y>=0)
     nscrlup(t->t,w->ny,w->y+uns_min(w->h,w->nh),w->y-w->ny);
    if(w!=l)
     {
     w=w->link.next;
     goto loop0;
     }
    w=pw->link.next;
    }
   else w=w->link.next;
  else w=w->link.next;
  while(w!=t->topwin);

 /* Update current height and position values */
 w=t->topwin; do
  {
  if(w->ny>=0)
   {
   if(w->object)
    {
    if(w->watom->move) w->watom->move(w->object,w->x,w->ny);
    if(w->watom->resize) w->watom->resize(w->object,w->w,w->nh);
    }
   if(w->y== -1) msetI(t->t->updtab+w->ny,1,w->nh);
   w->y=w->ny;
   }
  else w->y= -1;
  w->h=w->nh;
  w->reqh=0;
  }
  while(w=w->link.next, w!=t->topwin);
 }
d387 11
a397 11
int wnext(t)
SCREEN *t;
 {
 if(t->curwin->link.next!=t->curwin)
  {
  t->curwin=t->curwin->link.next;
  if(t->curwin->y== -1) wfit(t);
  return 0;
  }
 else return -1;
 }
d401 14
a414 15
int wprev(t)
SCREEN *t;
 {
 if(t->curwin->link.prev!=t->curwin)
  {
  t->curwin=t->curwin->link.prev;
  if(t->curwin->y== -1)
   {
   t->topwin=findtopw(t->curwin);
   wfit(t);
   }
  return 0;
  }
 else return -1;
 }
d418 15
a432 20
int wgrow(w)
W *w;
 {
 W *nextw;

 /* If we're the last window on the screen, shrink the previous window */
 if((w->link.next==w->t->topwin || w->link.next->y== -1) &&
    w!=w->t->topwin)
  return wshrink(w->link.prev->main);

 /* Get to next variable size window */
 for(nextw=w->link.next;nextw->fixed && nextw!=w->t->topwin;nextw=nextw->link.next);

 /* Is it below us, on screen and big enough to take space from? */
 if(nextw==w->t->topwin ||
    nextw->y== -1 ||
    nextw->h<=FITHEIGHT) return -1;

 /* Increase this window's height */
 seth(w,w->h+1);
d434 2
a435 2
 /* Decrease next window's height */
 seth(nextw,nextw->h-1);
d437 2
a438 2
 /* Do it */
 wfit(w->t);
d440 5
a444 2
 return 0;
 }
d448 20
a467 21
int wshrink(w)
W *w;
 {
 W *nextw;

 /* If we're the last window on the screen, grow the previous window */
 if((w->link.next==w->t->topwin || w->link.next->y== -1) &&
    w!=w->t->topwin)
  return wgrow(w->link.prev->main);

 /* Is this window too small already? */
 if(w->h<=FITHEIGHT) return -1;

 /* Get to window below us */
 for(nextw=w->link.next;
     nextw!=w->t->topwin && nextw->fixed;
     nextw=nextw->link.next);
 if(nextw==w->t->topwin) return -1;

 /* Decrease the size of this window */
 seth(w,w->h-1);
d469 2
a470 2
 /* Increase the size of next window */
 seth(nextw,nextw->h+1);
d472 2
a473 2
 /* Do it */
 wfit(w->t);
d475 2
a476 2
 return 0;
 }
d480 64
a543 55
void wshowall(t)
SCREEN *t;
 {
 int n=0;
 int set;
 W *w;

 /* Count no. of main windows */
 w=t->topwin; do
  if(!w->win) ++n;
  while(w=w->link.next, w!=t->topwin);

 /* Compute size to set each window */
 if((set=(t->h-t->wind)/n)<FITHEIGHT) set=FITHEIGHT;

 /* Set size of each variable size window */
 w=t->topwin; do
  if(!w->win)
   {
   int h=getminh(w);
   if(h>=set) seth(w,2);
   else seth(w,set-(h-2));
   w->orgwin=0;
   }
  while(w=w->link.next, w!=t->topwin);

 /* Do it */
 wfit(t);
 }

void wspread(t)
SCREEN *t;
 {
 int n=0;
 W *w=t->topwin; do
  if(w->y>=0 && !w->win) ++n;
  while(w=w->link.next, w!=t->topwin);
 if(!n)
  {
  wfit(t);
  return;
  }
 if((t->h-t->wind)/n>=FITHEIGHT) n=(t->h-t->wind)/n;
 else n=FITHEIGHT;
 w=t->topwin; do
  if(!w->win)
   {
   int h=getminh(w);
   if(h>=n) seth(w,2);
   else seth(w,n-(h-2));
   w->orgwin=0;
   }
  while(w=w->link.next, w!=t->topwin);
 wfit(t);
 }
d547 11
a557 12
void wshowone(w)
W *w;
 {
 W *q=w->t->topwin; do
  if(!q->win)
   {
   seth(q,w->t->h-w->t->wind-(getminh(q)-2));
   q->orgwin=0;
   }
  while(q=q->link.next, q!=w->t->topwin);
 wfit(w->t);
 }
d561 62
a622 61
W *wcreate(t,watom,where,target,original,height,huh,notify)
SCREEN *t;
WATOM *watom;
W *where, *target, *original;
int height;
char *huh;
int *notify;
 {
 W *new;

 if(height<1) return 0;

 /* Create the window */
 new=(W *)malloc(sizeof(W));
 new->notify=notify;
 new->t=t;
 new->w=t->w-1;
 seth(new,height);
 new->h=new->reqh;
 new->y= -1;
 new->ny=0; new->nh=0;
 new->x=0;
 new->huh=huh;
 new->orgwin=original;
 new->watom=watom;
 new->object=0;
 new->msgb=0;
 new->msgt=0;
 /* Set window's target and family */
 if(new->win=target)
  { /* A subwindow */
  new->main=target->main;
  new->fixed=height;
  }
 else
  { /* A parent window */
  new->main=new;
  new->fixed=0;
  }

 /* Get space for window */
 if(original)
  if(original->h-height<=2)
   {
   /* Not enough space for window */
   free(new);
   return 0;
   }
  else seth(original,original->h-height);

 /* Create new keyboard handler for window */
 if(watom->context) new->kbd=mkkbd(getcontext(watom->context));
 else new->kbd=0;

 /* Put window on the screen */
 if(where) enquef(W,link,where,new);
 else
  {
  if(t->topwin) enqueb(W,link,t->topwin,new);
  else izque(W,link,new), t->curwin=t->topwin=new;
  }
d624 2
a625 2
 return new;
 }
d629 51
a679 46
static int doabort(w,ret)
W *w;
int *ret;
 {
 int amnt=geth(w);
 W *z;
 w->y= -2;
 if(w->t->topwin==w) w->t->topwin=w->link.next;
 loop:
 z=w->t->topwin; do
  {
  if(z->orgwin==w) z->orgwin=0;
  if((z->win==w || z->main==w) && z->y!= -2)
   {
   amnt+=doabort(z,ret);
   goto loop;
   }
  }
  while(z=z->link.next, z!=w->t->topwin);
 if(w->orgwin) seth(w->orgwin,geth(w->orgwin)+geth(w));
 if(w->t->curwin==w)
  if(w->t->curwin->win) w->t->curwin=w->t->curwin->win;
  else
   if(w->orgwin) w->t->curwin=w->orgwin;
   else w->t->curwin=w->link.next;
 if(qempty(W,link,w))
  {
  leave=1;
  amnt=0;
  }
 deque(W,link,w);
 if(w->watom->abort && w->object)
  {
  *ret=w->watom->abort(w->object,MAXINT);
  if(w->notify) *w->notify= -1;
  }
 else
  {
  *ret= -1;
  if(w->notify) *w->notify= 1;
  }
 rmkbd(w->kbd);
 free(w);
 windie(w);
 return amnt;
 }
d683 22
a704 21
int wabort(w)
W *w;
 {
 SCREEN *t=w->t;
 int ret;
 if(w!=w->main)
  {
  doabort(w,&ret);
  if(!leave) wfit(t);
  }
 else
  {
  doabort(w,&ret);
  if(!leave)
   {
   if(lastw(t)->link.next!=t->topwin) wfit(t);
   else wspread(t);
   }
  }
 return ret;
 }
d708 58
a765 53
void genfmt(t,x,y,ofst,s,flg)
SCRN *t;
char *s;
 {
 int *scrn=t->scrn+y*t->co+x;
 int atr=0;
 int col=0;
 int c;
 while(c= *s++)
  if(c=='\\')
   switch(c= *s++)
    {
    case 'u': case 'U':
    atr^=UNDERLINE;
    break;
    
    case 'i': case 'I':
    atr^=INVERSE;
    break;
    
    case 'b': case 'B':
    atr^=BOLD;
    break;
    
    case 'd': case 'D':
    atr^=DIM;
    break;
    
    case 'f': case 'F':
    atr^=BLINK;
    break;
    
    case 0: --s;
    break;

    default:
    if(col++>=ofst)
     {
     outatr(t,scrn,x,y,c,atr);
     ++scrn;
     ++x;
     }
    break;
    }
  else if(col++>=ofst)
   {
   if(c=='\t') c=' ';
   outatr(t,scrn,x,y,c,atr);
   ++scrn;
   ++x;
   }
 if(flg) eraeol(t,x,y);
 }
d769 19
a787 19
void gentxt(t,x,y,ofst,s,len,flg)
SCRN *t;
char *s;
 {
 int *scrn=t->scrn+y*t->co+x;
 int col;
 int c;
 int a;
 for(col=0;col!=len;++col)
  if(col>=ofst)
   {
   c= (unsigned)s[col];
   if(c=='\t') c=' ';
   xlat(a,c);
   outatr(t,scrn,x,y,c,a);
   ++scrn; ++x;
   }
 if(flg) eraeol(t,x,y);
 }
d791 29
a819 21
int fmtlen(s)
char *s;
 {
 int col=0;
 while(*s)
  {
  if(*s=='\\')
   switch(*++s)
    {
    case 'u': case 'i': case 'd': case 'f': case 'b':
    case 'U': case 'I': case 'D': case 'F': case 'B':
    ++s; goto cont;

    case 0:
    --s;
    }
  ++col; ++s;
  cont:;
  }
 return col;
 }
d824 30
a853 22
int fmtpos(s,goal)
char *s;
 {
 char *org=s;
 int col=0;
 while(*s && col!=goal)
  {
  if(*s=='\\')
   switch(*++s)
    {
    case 'u': case 'i': case 'd': case 'f': case 'b':
    case 'U': case 'I': case 'D': case 'F': case 'B':
    ++s; goto cont;

    case 0:
    --s;
    }
  ++col; ++s;
  cont:;
  }
 return s-org+goal-col;
 }
d857 26
a882 28
static void mdisp(t,y,s)
SCRN *t;
char *s;
 {
 int ofst;
 int len;
 len=fmtlen(s);
 if(len<=(t->co-1)) ofst=0;
 else ofst=len-(t->co-1);
 genfmt(t,0,y,ofst,s,1);
 t->updtab[y]=1;
 }

void msgout(w)
W *w;
 {
 SCRN *t=w->t->t;
 if(w->msgb)
  {
  mdisp(t,w->y+w->h-1,w->msgb);
  w->msgb=0;
  }
 if(w->msgt)
  {
  mdisp(t,w->y+( (w->h>1 && (w->y || !staen)) ? 1 : 0 ),w->msgt);
  w->msgt=0;
  }
 }
d886 1
a886 1
char msgbuf[80];
d888 21
a908 27
void msgnw(w,s)
BASE *w;
char *s;
 {
 w->parent->msgb=s;
 }

void msgnwt(w,s)
BASE *w;
char *s;
 {
 w->parent->msgt=s;
 }

int urtn(b,k)
BASE *b;
 {
 if(b->parent->watom->rtn) return b->parent->watom->rtn(b,k);
 else return -1;
 }

int utype(b,k)
BASE *b;
 {
 if(b->parent->watom->type) return b->parent->watom->type(b,k);
 else return -1;
 }
d912 28
a939 39
int uprevw(bw)
BASE *bw;
 {
 return wprev(bw->parent->t);
 }

int unextw(bw)
BASE *bw;
 {
 return wnext(bw->parent->t);
 }

int ugroww(bw)
BASE *bw;
 {
 return wgrow(bw->parent);
 }

int ushrnk(bw)
BASE *bw;
 {
 return wshrink(bw->parent);
 }

int uexpld(bw)
BASE *bw;
 {
 if(bw->parent->t->h-bw->parent->t->wind==getgrouph(bw->parent))
  wshowall(bw->parent->t);
 else wshowone(bw->parent);
 return 0;
 }

int uretyp(bw)
BASE *bw;
 {
 nredraw(bw->parent->t->t);
 return 0;
 }
@


1.2
log
@changed as of joe-2.9.4
@
text
@d26 1
a26 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d320 1
a320 1
     nscrldn(t->t,l->y,l->ny+Umin(l->h,l->nh),l->ny-l->y);
d342 1
a342 1
     nscrlup(t->t,w->ny,w->y+Umin(w->h,w->nh),w->y-w->ny);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
