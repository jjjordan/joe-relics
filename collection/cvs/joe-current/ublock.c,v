head	1.61;
access;
symbols
	joe_3_5:1.55
	joe-3_4:1.53
	help:1.53
	joe_3_1:1.36
	joe_3_0:1.23
	joe_2_9_8:1.18
	joe_2_9_8_pre1:1.12
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.23.21.53.49;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.22.04.47.42;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.21.04.47.00;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.18.03.29.32;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.17.23.54.47;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.16.21.37.36;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.14.16.35.54;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.12.05.34.35;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.05.05.06.18;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.04.16.29.41;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.04.16.24.40;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.04.05.33.09;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.26.05.14.41;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.08.19.09.53;	author sonic_amiga;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.24.20.57.26;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.15.02.01.14;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.12.02.06.37;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.11.18.05.39;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.11.14.14.04;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.11.13.56.10;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.06.19.20.32;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.06.18.32.49;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.06.16.23.12;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.03.12.28.48;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.26.20.14.52;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.22.03.40.21;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.22.01.56.50;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.09.49.59;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.39.21;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.27.13.30.48;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.21.07.56.47;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.13.54.23;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/*
 * 	Highlighted block functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

int nowmarking;

/* Global options */

int square = 0;			/* Set for rectangle mode */
int lightoff = 0;		/* Set if highlighting should turn off

				   after block operations */
/* Global variables */

P *markb = NULL;		/* Beginning and end of block */
P *markk = NULL;

/* Push markb & markk */

typedef struct marksav MARKSAV;
struct marksav {
	LINK(MARKSAV) link;
	P *markb, *markk;
} markstack = { { &markstack, &markstack} };
MARKSAV markfree = { {&markfree, &markfree} };
int nstack = 0;

int upsh(BW *bw)
{
	MARKSAV *m = alitem(&markfree, sizeof(MARKSAV));

	m->markb = 0;
	m->markk = 0;
	if (markk)
		pdupown(markk, &m->markk, USTR "upsh");
	if (markb)
		pdupown(markb, &m->markb, USTR "upsh");
	enqueb(MARKSAV, link, &markstack, m);
	++nstack;
	return 0;
}

int upop(BW *bw)
{
	MARKSAV *m = markstack.link.prev;

	if (m != &markstack) {
		--nstack;
		prm(markk);
		prm(markb);
		markk = m->markk;
		if (markk)
			markk->owner = &markk;
		markb = m->markb;
		if (markb)
			markb->owner = &markb;
		demote(MARKSAV, link, &markfree, m);
		if (lightoff)
			unmark(bw);
		updall();
		return 0;
	} else
		return -1;
}

/* Return true if markb/markk are valid */
/* If r is set, swap markb with markk if necessary */

int autoswap;

int markv(int r)
{
	if (markb && markk && markb->b == markk->b && (r == 2 ? markk->byte >= markb->byte : markk->byte > markb->byte) &&
	    (!square || (r == 2 ? markk->xcol >= markb->xcol : markk->xcol > markb->xcol))) {
		return 1;
	} else if(autoswap && r && markb && markk && markb->b == markk->b && markb->byte > markk->byte && (!square || markk->xcol < markb->xcol)) {
		P *p = pdup(markb, USTR "markv");
		prm(markb); markb=0; pdupown(markk, &markb, USTR "markv");
		prm(markk); markk=0; pdupown(p, &markk, USTR "markv");
		prm(p);
		return 1;
	} else
		return 0;
}

/* Rectangle-mode subroutines */

/* B *pextrect(P *org,long height,long left,long right);
 * Copy a rectangle into a new buffer
 *
 * org points to top-left corner of rectangle.
 * height is number of lines in rectangle.
 * right is rightmost column of rectangle + 1
 */

B *pextrect(P *org, long int height, long int right)
{
	P *p = pdup(org, USTR "pextrect");	/* Left part of text to extract */
	P *q = pdup(p, USTR "pextrect");		/* After right part of text to extract */
	B *tmp = bmk(NULL);	/* Buffer to extract to */
	P *z = pdup(tmp->eof, USTR "pextrect");	/* Buffer pointer */

	while (height--) {
		pcol(p, org->xcol);
		pset(q, p);
		pcolwse(q, right);
		p_goto_eof(z);
		binsb(z, bcpy(p, q));
		p_goto_eof(z);
		binsc(z, '\n');
		pnextl(p);
	}
	prm(p);
	prm(q);
	prm(z);
	return tmp;
}

/* void pdelrect(P *org,long height,long right);
 * Delete a rectangle.
 */

void pdelrect(P *org, long int height, long int right)
{
	P *p = pdup(org, USTR "pdelrect");
	P *q = pdup(p, USTR "pdelrect");

	while (height--) {
		pcol(p, org->xcol);
		pset(q, p);
		pcol(q, right);
		bdel(p, q);
		pnextl(p);
	}
	prm(p);
	prm(q);
}

/* void pclrrect(P *org,long height,long right,int usetabs);
 * Blank-out a rectangle.
 */

void pclrrect(P *org, long int height, long int right, int usetabs)
{
	P *p = pdup(org, USTR "pclrrect");
	P *q = pdup(p, USTR "pclrrect");

	while (height--) {
		long pos;

		pcol(p, org->xcol);
		pset(q, p);
		pcoli(q, right);
		pos = q->col;
		bdel(p, q);
		pfill(p, pos, usetabs);
		pnextl(p);
	}
	prm(p);
	prm(q);
}

/* int ptabrect(P *org,long height,long right)
 * Check if there are any TABs in a rectangle
 */

int ptabrect(P *org, long int height, long int right)
{
	P *p = pdup(org, USTR "ptabrect");

	while (height--) {
		int c;

		pcol(p, org->xcol);
		while ((c = pgetc(p)) != NO_MORE_DATA && c != '\n') {
			if (c == '\t') {
				prm(p);
				return '\t';
			} else if (piscol(p) > right)
				break;
		}
		if (c != '\n')
			pnextl(p);
	}
	prm(p);
	return ' ';
}

/* Insert rectangle */

void pinsrect(P *cur, B *tmp, long int width, int usetabs)
{
	P *p = pdup(cur, USTR "pinsrect");	/* We insert at & move this pointer */
	P *q = pdup(tmp->bof, USTR "pinsrect");	/* These are for scanning through 'tmp' */
	P *r = pdup(q, USTR "pinsrect");

/*	if (width) */
		while (pset(r, q), p_goto_eol(q), (q->line != tmp->eof->line || piscol(q))) {
			pcol(p, cur->xcol);
			if (piscol(p) < cur->xcol)
				pfill(p, cur->xcol, usetabs);
			binsb(p, bcpy(r, q));
			pfwrd(p, q->byte - r->byte);
			if (piscol(p) < cur->xcol + width)
				pfill(p, cur->xcol + width, usetabs);
			if (piseol(p))
				pbackws(p);
			if (!pnextl(p)) {
				binsc(p, '\n');
				pgetc(p);
			}
			if (pgetc(q) == NO_MORE_DATA)
				break;
		}
	prm(p);
	prm(q);
	prm(r);
}

/* Block functions */

/* Set beginning */

int umarkb(BW *bw)
{
	pdupown(bw->cursor, &markb, USTR "umarkb");
	markb->xcol = bw->cursor->xcol;
	updall();
	return 0;
}

int udrop(BW *bw)
{
	prm(markk);
	if (marking && markb)
		prm(markb);
	else
		umarkb(bw);
	return 0;
}

int ubegin_marking(BW *bw)
{
	if (nowmarking) {
		/* We're marking now... don't stop */
		return 0;
	} else if (markv(0) && bw->cursor->b==markb->b) {
		/* Try to extend current block */
		if (bw->cursor->byte==markb->byte) {
			pset(markb,markk);
			prm(markk); markk=0;
			nowmarking = 1;
			return 0;
		} else if(bw->cursor->byte==markk->byte) {
			prm(markk); markk=0;
			nowmarking = 1;
			return 0;
		}
	}
	/* Start marking - no message */
	prm(markb); markb=0;
	prm(markk); markk=0;
	updall();
	nowmarking = 1;
	return umarkb(bw);
}

int utoggle_marking(BW *bw)
{
	if (markv(0) && bw->cursor->b==markb->b && bw->cursor->byte>=markb->byte && bw->cursor->byte<=markk->byte) {
		/* Just clear selection */
		prm(markb); markb=0;
		prm(markk); markk=0;
		updall();
		nowmarking = 0;
		msgnw(bw->parent, joe_gettext(_("Selection cleared.")));
		return 0;
	} else if (markk) {
		/* Clear selection and start new one */
		prm(markb); markb=0;
		prm(markk); markk=0;
		updall();
		nowmarking = 1;
		msgnw(bw->parent, joe_gettext(_("Selection started.")));
		return umarkb(bw);
	} else if (markb && markb->b==bw->cursor->b) {
		nowmarking = 0;
		if (bw->cursor->byte<markb->byte) {
			pdupown(markb, &markk, USTR "utoggle_marking");
			prm(markb); markb=0;
			pdupown(bw->cursor, &markb, USTR "utoggle_marking");
			markb->xcol = bw->cursor->xcol;
		} else {
			pdupown(bw->cursor, &markk, USTR "utoggle_marking");
			markk->xcol = bw->cursor->xcol;
		}
		updall(); /* Because other windows could be changed */
		return 0;
	} else {
		nowmarking = 1;
		msgnw(bw->parent, joe_gettext(_("Selection started.")));
		return umarkb(bw);
	}
}

int uselect(BW *bw)
{
	if (!markb)
		umarkb(bw);
	return 0;
}

/* Set end */

int umarkk(BW *bw)
{
	pdupown(bw->cursor, &markk, USTR "umarkk");
	markk->xcol = bw->cursor->xcol;
	updall();
	return 0;
}

/* Unset marks */

int unmark(BW *bw)
{
	prm(markb);
	prm(markk);
	nowmarking = 0;
	updall();
	return 0;
}

/* Mark line */

int umarkl(BW *bw)
{
	p_goto_bol(bw->cursor);
	umarkb(bw);
	pnextl(bw->cursor);
	umarkk(bw);
	utomarkb(bw);
	pcol(bw->cursor, bw->cursor->xcol);
	return 0;
}

int utomarkb(BW *bw)
{
	if (markb && markb->b == bw->b) {
		pset(bw->cursor, markb);
		return 0;
	} else
		return -1;
}

int utomarkk(BW *bw)
{
	if (markk && markk->b == bw->b) {
		pset(bw->cursor, markk);
		return 0;
	} else
		return -1;
}

int uswap(BW *bw)
{
	if (markb && markb->b == bw->b) {
		P *q = pdup(markb, USTR "uswap");

		umarkb(bw);
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else
		return -1;
}

int utomarkbk(BW *bw)
{
	if (markb && markb->b == bw->b && bw->cursor->byte != markb->byte) {
		pset(bw->cursor, markb);
		return 0;
	} else if (markk && markk->b == bw->b && bw->cursor->byte != markk->byte) {
		pset(bw->cursor, markk);
		return 0;
	} else
		return -1;
}

/* Delete block */

int ublkdel(BW *bw)
{
	if (markv(1)) {
		if (square)
			if (bw->o.overtype) {
				long ocol = markk->xcol;

				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, ptabrect(markb, markk->line - markb->line + 1, markk->xcol));
				pcol(markk, ocol);
				markk->xcol = ocol;
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
		else
			bdel(markb, markk);
		if (lightoff)
			unmark(bw);
	} else {
		msgnw(bw->parent, joe_gettext(_("No block")));
		return -1;
	}
	return 0;
}

/* Special delete block function for PICO */

int upicokill(BW *bw)
{
	upsh(bw);
	umarkk(bw);
	if (markv(1)) {
		if (square)
			if (bw->o.overtype) {
				long ocol = markk->xcol;

				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, ptabrect(markb, markk->line - markb->line + 1, markk->xcol));
				pcol(markk, ocol);
				markk->xcol = ocol;
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
		else
			bdel(markb, markk);
		if (lightoff)
			unmark(bw);
	} else
		udelln(bw);
	return 0;
}

/* Move highlighted block */

int ublkmove(BW *bw)
{
	if (markv(1)) {
		if (markb->b!=bw->b && !modify_logic(bw,markb->b))
			return -1;
		if (square) {
			long height = markk->line - markb->line + 1;
			long width = markk->xcol - markb->xcol;
			int usetabs = ptabrect(markb, height, markk->xcol);
			long ocol = piscol(bw->cursor);
			B *tmp = pextrect(markb, height, markk->xcol);
			int update_xcol = (bw->cursor->xcol >= markk->xcol && bw->cursor->line >= markb->line && bw->cursor->line <= markk->line);

			ublkdel(bw);
			/* now we can't use markb and markk until we set them again */
			/* ublkdel() frees them */
			if (bw->o.overtype) {
				/* If cursor was in block, blkdel moves it to left edge of block, so fix it
				 * back to its original place here */
				pcol(bw->cursor, ocol);
				pfill(bw->cursor, ocol, ' ');
				pdelrect(bw->cursor, height, piscol(bw->cursor) + width);
			} else if (update_xcol)
				/* If cursor was to right of block, xcol was not properly updated */
				bw->cursor->xcol -= width;
			pinsrect(bw->cursor, tmp, width, usetabs);
			brm(tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			return 0;
		} else if (bw->cursor->b != markk->b || bw->cursor->byte > markk->byte || bw->cursor->byte < markb->byte) {
			long size = markk->byte - markb->byte;

			binsb(bw->cursor, bcpy(markb, markk));
			bdel(markb, markk);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pfwrd(markk, size);
			}
			updall();
			return 0;
		}
	}
	msgnw(bw->parent, joe_gettext(_("No block")));
	return -1;
}

/* Duplicate highlighted block */

int ublkcpy(BW *bw)
{
	if (markv(1)) {
		if (square) {
			long height = markk->line - markb->line + 1;
			long width = markk->xcol - markb->xcol;
			int usetabs = ptabrect(markb, height, markk->xcol);
			B *tmp = pextrect(markb, height, markk->xcol);

			if (bw->o.overtype)
				pdelrect(bw->cursor, height, piscol(bw->cursor) + width);
			pinsrect(bw->cursor, tmp, width, usetabs);
			brm(tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			return 0;
		} else {
			long size = markk->byte - markb->byte;
			B *tmp = bcpy(markb, markk);

			/* Simple overtype for hex mode */
			if (bw->o.hex && bw->o.overtype) {
				P *q = pdup(bw->cursor, USTR "ublkcpy");
				if (q->byte + size >= q->b->eof->byte)
					pset(q, q->b->eof);
				else
					pfwrd(q, size);
				bdel(bw->cursor, q);
				prm(q);
			}

			binsb(bw->cursor, tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pfwrd(markk, size);
			}
			updall();
			return 0;
		}
	} else {
		msgnw(bw->parent, joe_gettext(_("No block")));
		return -1;
	}
}

/* Write highlighted block to a file */
/* This is called by ublksave in ufile.c */

/*int dowrite(BW *bw, unsigned char *s, void *object)
{
	if (markv(1)) {
		if (square) {
			int fl;
			int ret = 0;
			B *tmp = pextrect(markb,
					  markk->line - markb->line + 1,
					  markk->xcol);

			if ((fl = bsave(tmp->bof, s, tmp->eof->byte, 0)) != 0) {
				msgnw(bw->parent, joe_gettext(msgs[-fl]));
				ret = -1;
			}
			brm(tmp);
			if (lightoff)
				unmark(bw);
			vsrm(s);
			return ret;
		} else {
			int fl;
			int ret = 0;

			if ((fl = bsave(markb, s, markk->byte - markb->byte, 0)) != 0) {
				msgnw(bw->parent, joe_gettext(msgs[-fl]));
				ret = -1;
			}
			if (lightoff)
				unmark(bw);
			vsrm(s);
			return ret;
		}
	} else {
		vsrm(s);
		msgnw(bw->parent, USTR _(_("No block")));
		return -1;
	}
}*/

/* Set highlighted block on a program block */

void setindent(BW *bw)
{
	P *p, *q;
	long indent;

	if (pisblank(bw->cursor))
		return;

	p = pdup(bw->cursor, USTR "setindent");
	q = pdup(p, USTR "setindent");
	indent = pisindent(p);

	do {
		if (!pprevl(p))
			goto done;
		else
			p_goto_bol(p);
	} while (pisindent(p) >= indent || pisblank(p));
	pnextl(p);
	/* Maybe skip blank lines at beginning */
      done:
	p_goto_bol(p);
	p->xcol = piscol(p);
	if (markb)
		prm(markb);
	markb = p;
	p->owner = &markb;

	do {
		if (!pnextl(q))
			break;
	} while (pisindent(q) >= indent || pisblank(q));
	/* Maybe skip blank lines at end */
	if (markk)
		prm(markk);
	q->xcol = piscol(q);
	markk = q;
	q->owner = &markk;

	updall();
}

/* Purity check */
/* Verifies that at least n indentation characters (for non-blank lines) match c */
/* If n is 0 (for urindent), this fails if c is space but indentation begins with tab */

int purity_check(int c, int n)
{
	P *p = pdup(markb, USTR "purity_check");
	while (p->byte < markk->byte) {
		int x;
		p_goto_bol(p);
		if (!n && c==' ' && brc(p)=='\t') {
			prm(p);
			return 0;
		} else if (!piseol(p))
			for (x=0; x!=n; ++x)
				if (pgetc(p)!=c) {
					prm(p);
					return 0;
				}
		pnextl(p);
	}
	prm(p);
	return 1;
}

/* Left indent check */
/* Verify that there is enough whitespace to do the left indent */

int lindent_check(int c, int n)
{
	P *p = pdup(markb, USTR "lindent_check");
	int indwid;
	if (c=='\t')
		indwid = n * p->b->o.tab;
	else
		indwid = n;
	while (p->byte < markk->byte) {
		p_goto_bol(p);
		if (!piseol(p) && pisindent(p)<indwid) {
			prm(p);
			return 0;
		}
		pnextl(p);
	}
	prm(p);
	return 1;
}

/* Indent more */

int urindent(BW *bw)
{
	if (square) {
		if (markb && markk && markb->b == markk->b && markb->byte <= markk->byte && markb->xcol <= markk->xcol) {
			P *p = pdup(markb, USTR "urindent");

			do {
				pcol(p, markb->xcol);
				pfill(p, markb->xcol + bw->o.istep, bw->o.indentc);
			} while (pnextl(p) && p->line <= markk->line);
			prm(p);
		}
	} else {
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte) {
			setindent(bw);
		} else if ( 1 /* bw->o.purify */) {
			P *p = pdup(markb, USTR "urindent");
			P *q = pdup(markb, USTR "urindent");
			int indwid;

			if (bw->o.indentc=='\t')
				indwid = bw->o.tab * bw->o.istep;
			else
				indwid = bw->o.istep;

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p)) {
					int col;
					pset(q, p);
					p_goto_indent(q, bw->o.indentc);
					col = piscol(q);
					bdel(p,q);
					pfill(p,col+indwid,bw->o.indentc);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else if (purity_check(bw->o.indentc,0)) {
			P *p = pdup(markb, USTR "urindent");

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p))
					while (piscol(p) < bw->o.istep) {
						binsc(p, bw->o.indentc);
						pgetc(p);
					}
				pnextl(p);
			}
			prm(p);
		} else {
			/* Purity failure */
			msgnw(bw->parent,joe_gettext(_("Selected lines not properly indented")));
			return 1;
		}
	}
	return 0;
}

/* Indent less */

int ulindent(BW *bw)
{
	if (square) {
		if (markb && markk && markb->b == markk->b && markb->byte <= markk->byte && markb->xcol <= markk->xcol) {
			P *p = pdup(markb, USTR "ulindent");
			P *q = pdup(p, USTR "ulindent");

			do {
				pcol(p, markb->xcol);
				while (piscol(p) < markb->xcol + bw->o.istep) {
					int c = pgetc(p);

					if (c != ' ' && c != '\t' && c != bw->o.indentc) {
						prm(p);
						prm(q);
						return -1;
					}
				}
			} while (pnextl(p) && p->line <= markk->line);
			pset(p, markb);
			do {
				pcol(p, markb->xcol);
				pset(q, p);
				pcol(q, markb->xcol + bw->o.istep);
				bdel(p, q);
			} while (pnextl(p) && p->line <= markk->line);
			prm(p);
			prm(q);
		}
	} else {
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte) {
			setindent(bw);
		} else if (1 /* bw->o.purify */ && lindent_check(bw->o.indentc,bw->o.istep)) {
			P *p = pdup(markb, USTR "ulindent");
			P *q = pdup(markb, USTR "ulindent");
			int indwid;

			if (bw->o.indentc=='\t')
				indwid = bw->o.tab * bw->o.istep;
			else
				indwid = bw->o.istep;

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p)) {
					int col;
					pset(q, p);
					p_goto_indent(q, bw->o.indentc);
					col = piscol(q);
					bdel(p,q);
					pfill(p,col-indwid,bw->o.indentc);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else if (purity_check(bw->o.indentc,bw->o.istep)) {
			P *p = pdup(markb, USTR "ulindent");
			P *q = pdup(p, USTR "ulindent");

			p_goto_bol(p);
			while (p->byte < markk->byte) {
				if (!piseol(p)) {
					pset(q, p);
					while (piscol(q) < bw->o.istep)
						pgetc(q);
					bdel(p, q);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else {
			/* Purity failure */
			msgnw(bw->parent,joe_gettext(_("Selected lines not properly indented")));
			return 1;
		}
	}
	return 0;
}

/* Insert a file */

int uinsf(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("Name of file to insert (^C to abort): ")), &filehist,
	                       USTR "Names", cmplt, locale_map, 3, 0, NULL);
	if (s) {
		if (square)
			if (markv(1)) {
				B *tmp;
				long width = markk->xcol - markb->xcol;
				long height;
				int usetabs = ptabrect(markb,
						       markk->line - markb->line + 1,
						       markk->xcol);

				tmp = bload(s);
				if (berror) {
					msgnw(bw->parent, joe_gettext(msgs[-berror]));
					brm(tmp);
					return -1;
				}
				if (piscol(tmp->eof))
					height = tmp->eof->line + 1;
				else
					height = tmp->eof->line;
				if (bw->o.overtype) {
					pclrrect(markb, long_max(markk->line - markb->line + 1, height), markk->xcol, usetabs);
					pdelrect(markb, height, width + markb->xcol);
				}
				pinsrect(markb, tmp, width, usetabs);
				pdupown(markb, &markk, USTR "doinsf");
				markk->xcol = markb->xcol;
				if (height) {
					pline(markk, markk->line + height - 1);
					pcol(markk, markb->xcol + width);
					markk->xcol = markb->xcol + width;
				}
				brm(tmp);
				updall();
				return 0;
			} else {
				msgnw(bw->parent, joe_gettext(_("No block")));
				return -1;
		} else {
			int ret = 0;
			B *tmp = bload(s);

			if (berror) {
				msgnw(bw->parent, joe_gettext(msgs[-berror])), brm(tmp);
				ret = -1;
			} else
				binsb(bw->cursor, tmp);
			bw->cursor->xcol = piscol(bw->cursor);
			return ret;
		}
		return 0;
	} else {
		return -1;
	}
}

/* Filter highlighted block through a UNIX command */

static int filtflg = 0;

static B *filthist = NULL;

static void markall(BW *bw)
{
	pdupown(bw->cursor->b->bof, &markb, USTR "markall");
	markb->xcol = 0;
	pdupown(bw->cursor->b->eof, &markk, USTR "markall");
	markk->xcol = piscol(markk);
	updall();
}

static int checkmark(BW *bw)
{
	if (!markv(1))
		if (square)
			return 2;
		else {
			markall(bw);
			filtflg = 1;
			return 1;
	} else {
		filtflg = 0;
		return 0;
	}
}

int ufilt(BW *bw)
{
#ifdef __MSDOS__
	msgnw(bw->parent, joe_gettext(_("Sorry, no sub-processes in DOS (yet)")));
	return -1;
#else
	int fr[2];
	int fw[2];
	int flg = 0;
	unsigned char *s;
	switch (checkmark(bw)) {
		case 0:
			s = joe_gettext(_("Command to filter block through (^C to abort): "));
			break;
		case 1:
			s = joe_gettext(_("Command to filter file through (^C to abort): "));
			break;
		default:
			msgnw(bw->parent, joe_gettext(_("No block")));
			return -1;
	}
	s = ask(bw->parent, s, &filthist, NULL, utypebw, locale_map, 0, 0, NULL);

	if (markb && markk && !square && markb->b == bw->b && markk->b == bw->b && markb->byte == markk->byte) {
		flg = 1; /* Empty block */
		goto ok;
	}
	if (!markv(1)) {
		msgnw(bw->parent, joe_gettext(_("No block")));
		return -1;
	}
	ok:

	pipe(fr);
	pipe(fw);
	npartial(bw->parent->t->t);
	ttclsn();
#ifdef HAVE_FORK
	if (!fork()) {
#else
	if (!vfork()) { /* For AMIGA only */
#endif
#ifdef HAVE_PUTENV
		unsigned char *fname, *name;
		unsigned len;
#endif
		signrm();
		close(0);
		close(1);
		close(2);
		dup(fw[0]);
		dup(fr[1]);
		dup(fr[1]);
		close(fw[0]);
		close(fr[1]);
		close(fw[1]);
		close(fr[0]);
#ifdef HAVE_PUTENV
		fname = vsncpy(NULL, 0, sc("JOE_FILENAME="));
		name = bw->b->name ? bw->b->name : (unsigned char *)"Unnamed";
		if((len = zlen(name)) >= 512)	/* limit filename length */
			len = 512;
		fname = vsncpy(sv(fname), name, len);
		putenv((char *)fname);
#endif
		execl("/bin/sh", "/bin/sh", "-c", s, NULL);
		_exit(0);
	}
	close(fr[1]);
	close(fw[0]);
#ifdef HAVE_FORK
	if (fork()) {
#else
	if (vfork()) { /* For AMIGA only */
#endif
		close(fw[1]);
		if (square) {
			B *tmp;
			long width = markk->xcol - markb->xcol;
			long height;
			int usetabs = ptabrect(markb,
					       markk->line - markb->line + 1,
					       markk->xcol);

			tmp = bread(fr[0], MAXLONG);
			if (piscol(tmp->eof))
				height = tmp->eof->line + 1;
			else
				height = tmp->eof->line;
			if (bw->o.overtype) {
				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, usetabs);
				pdelrect(markb, long_max(height, markk->line - markb->line + 1), width + markb->xcol);
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
			pinsrect(markb, tmp, width, usetabs);
			pdupown(markb, &markk, USTR "dofilt");
			markk->xcol = markb->xcol;
			if (height) {
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			if (lightoff)
				unmark(bw);
			brm(tmp);
			updall();
		} else {
			P *p = pdup(markk, USTR "dofilt");
			if (!flg)
				prgetc(p);
			bdel(markb, p);
			binsb(p, bread(fr[0], MAXLONG));
			if (!flg) {
				pset(p,markk);
				prgetc(p);
				bdel(p,markk);
			}
			prm(p);
			if (lightoff)
				unmark(bw);
		}
		close(fr[0]);
		wait(NULL);
		wait(NULL);
	} else {
		if (square) {
			B *tmp = pextrect(markb,
					  markk->line - markb->line + 1,
					  markk->xcol);

			bsavefd(tmp->bof, fw[1], tmp->eof->byte);
		} else
			bsavefd(markb, fw[1], markk->byte - markb->byte);
		close(fw[1]);
		_exit(0);
	}
	ttopnn();
	if (filtflg)
		unmark(bw);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
#endif
}

/* Force region to lower case */

int ulower(BW *bw)
{
	if (markv(1)) {
		P *q;
	        P *p;
	        int c;
		B *b = bcpy(markb,markk);
		/* Leave one character in buffer to keep pointers set properly... */
		q = pdup(markk, USTR "ulower");
		prgetc(q);
		bdel(markb,q);
		b->o.charmap = markb->b->o.charmap;
		p=pdup(b->bof, USTR "ulower");
		while ((c=pgetc(p))!=NO_MORE_DATA) {
			c = joe_tolower(b->o.charmap,c);
			binsc(q,c);
			pgetc(q);
		}
		prm(p);
		bdel(q,markk);
		prm(q);
		brm(b);
		bw->cursor->xcol = piscol(bw->cursor);
		return 0;
	} else
		return -1;
}

/* Force region to upper case */

int uupper(BW *bw)
{
	if (markv(1)) {
		P *q;
	        P *p;
	        int c;
		B *b = bcpy(markb,markk);
		q = pdup(markk, USTR "uupper");
		prgetc(q);
		bdel(markb,q);
		b->o.charmap = markb->b->o.charmap;
		p=pdup(b->bof, USTR "uupper");
		while ((c=pgetc(p))!=NO_MORE_DATA) {
			c = joe_toupper(b->o.charmap,c);
			binsc(q,c);
			pgetc(q);
		}
		prm(p);
		bdel(q,markk);
		prm(q);
		brm(b);
		bw->cursor->xcol = piscol(bw->cursor);
		return 0;
	} else
		return -1;
}

/* Get sum, sum of squares, and return count of
 * a block of numbers.
 *
 * avg = sum/count
 *
 * stddev = sqrt(  (a-avg)^2 + (b-avg)^2 + (c-avg)^2 )
 *        = sqrt(  a^2-2*a*avg+avg^2  + b^2-2*b*avg+avg^2 + c^2-2*c*avg+avg^2 )
 *        = sqrt(  a^2+b^2+c^2 + 3*avg^2 - 2*avg*(a+b+c) )
 *        = sqrt(  sumsq + count*avg^2 - 2*avg*sum  )
 *
 */

int blksum(double *sum, double *sumsq)
{
	unsigned char buf[80];
	if (markv(1)) {
		P *q = pdup(markb, USTR "blksum");
		int x;
		int c;
		double accu = 0.0;
		double accusq = 0.0;
		double v;
		int count = 0;
		long left = markb->xcol;
		long right = markk->xcol;
		while (q->byte < markk->byte) {
			/* Skip until we're within columns */
			while (q->byte < markk->byte && square && (piscol(q) < left || piscol(q) >= right))
				pgetc(q);

			/* Skip to first number */
			while (q->byte < markk->byte && (!square || (piscol(q) >= left && piscol(q) < right))) {
				c=pgetc(q);
				if ((c >= '0' && c <= '9') || c == '.' || c == '-') {
					/* Copy number into buffer */
					buf[0]=c; x=1;
					while (q->byte < markk->byte && (!square || (piscol(q) >= left && piscol(q) < right))) {
						c=pgetc(q);
						if ((c >= '0' && c <= '9') || c == 'e' || c == 'E' ||
						    c == 'p' || c == 'P' || c == 'x' || c == 'X' ||
						    c == '.' || c == '-' || c == '+' ||
						    (c >= 'a' && c <= 'f') || (c >= 'A' && c<='F')) {
							if(x != 79)
								buf[x++]=c;
						} else
							break;
					}
					/* Convert number to floating point, add it to total */
					buf[x] = 0;
					v = strtod((char *)buf,NULL);
					++count;
					accu += v;
					accusq += v*v;
					break;
				}
			}
		}
		prm(q);
		*sum = accu;
		*sumsq = accusq;
		return count;
	} else
		return -1;
}

/* Get a (possibly square) block into a buffer */

unsigned char *blkget()
{
	if (markv(1)) {
		P *q;
		unsigned char *buf=joe_malloc(markk->byte-markb->byte+1);
		unsigned char *s=buf;
		long left = markb->xcol;
		long right = markk->xcol;
		q = pdup(markb, USTR "blkget");
		while (q->byte < markk->byte) {
			/* Skip until we're within columns */
			while (q->byte < markk->byte && square && (piscol(q) < left || piscol(q) >= right))
				pgetc(q);

			/* Copy text into buffer */
			while (q->byte < markk->byte && (!square || (piscol(q) >= left && piscol(q) < right))) {
				*s++ = pgetc(q);
			}
			/* Add a new line if we went past right edge of column */
			if (square && q->byte<markk->byte && piscol(q) >= right)
				*s++ = '\n';
		}
		prm(q);
		*s = 0;
		return buf;
	} else
		return 0;
}
@


1.60
log
@More fixes:
	guessindent don't write to istep if spaces,
	lmargin limit is 1 not 2,
	add .js file type,
	allow file insert on zero width rectangle blocks,
@
text
@d206 1
a206 1
//	if (width)
@


1.59
log
@More work on coroutine refactoring.
@
text
@d82 2
a83 1
	if (markb && markk && markb->b == markk->b && markk->byte > markb->byte && (!square || markk->xcol > markb->xcol)) {
d206 1
a206 1
	if (width)
@


1.58
log
@more refactoring
@
text
@d567 1
a567 1
/*int dowrite(BW *bw, unsigned char *s, void *object, int *notify)
a568 2
	if (notify)
		*notify = 1;
a850 2
		/* if (notify)
			*notify = 1; */
a958 2
	/* if (notify)
		*notify = 1; */
@


1.57
log
@fix tags.
switch more wmkpw to ask
@
text
@d848 1
a848 1
int doinsf(BW *bw, unsigned char *s, void *object, int *notify)
d850 36
a885 14
	if (notify)
		*notify = 1;
	if (square)
		if (markv(1)) {
			B *tmp;
			long width = markk->xcol - markb->xcol;
			long height;
			int usetabs = ptabrect(markb,
					       markk->line - markb->line + 1,
					       markk->xcol);

			tmp = bload(s);
			if (berror) {
				msgnw(bw->parent, joe_gettext(msgs[-berror]));
d887 4
a891 20
			}
			if (piscol(tmp->eof))
				height = tmp->eof->line + 1;
			else
				height = tmp->eof->line;
			if (bw->o.overtype) {
				pclrrect(markb, long_max(markk->line - markb->line + 1, height), markk->xcol, usetabs);
				pdelrect(markb, height, width + markb->xcol);
			}
			pinsrect(markb, tmp, width, usetabs);
			pdupown(markb, &markk, USTR "doinsf");
			markk->xcol = markb->xcol;
			if (height) {
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			brm(tmp);
			updall();
			return 0;
d893 12
a904 2
			msgnw(bw->parent, joe_gettext(_("No block")));
			return -1;
d906 1
a906 10
		int ret = 0;
		B *tmp = bload(s);

		if (berror) {
			msgnw(bw->parent, joe_gettext(msgs[-berror])), brm(tmp);
			ret = -1;
		} else
			binsb(bw->cursor, tmp);
		bw->cursor->xcol = piscol(bw->cursor);
		return ret;
a909 1

d961 1
a961 1
	s = ask(bw->parent, s, &filthist, NULL, utypebw, NULL, locale_map, 0, 0, NULL);
@


1.56
log
@semiautomatic variables
@
text
@d908 27
a934 1
static int dofilt(BW *bw, unsigned char *s, void *object, int *notify)
d936 4
d943 13
d957 2
a958 2
	if (notify)
		*notify = 1;
d960 1
a960 1
		flg = 1;
d962 2
a963 1
	} if (!markv(1)) {
d967 1
a967 1
      ok:
d979 2
a980 2
		unsigned char		*fname, *name;
		unsigned	len;
a1076 50
}

static B *filthist = NULL;

static void markall(BW *bw)
{
	pdupown(bw->cursor->b->bof, &markb, USTR "markall");
	markb->xcol = 0;
	pdupown(bw->cursor->b->eof, &markk, USTR "markall");
	markk->xcol = piscol(markk);
	updall();
}

static int checkmark(BW *bw)
{
	if (!markv(1))
		if (square)
			return 2;
		else {
			markall(bw);
			filtflg = 1;
			return 1;
	} else {
		filtflg = 0;
		return 0;
	}
}

int ufilt(BW *bw)
{
#ifdef __MSDOS__
	msgnw(bw->parent, joe_gettext(_("Sorry, no sub-processes in DOS (yet)")));
	return -1;
#else
	switch (checkmark(bw)) {
	case 0:
		if (wmkpw(bw->parent, joe_gettext(_("Command to filter block through (^C to abort): ")), &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map, 1))
			return 0;
		else
			return -1;
	case 1:
		if (wmkpw(bw->parent, joe_gettext(_("Command to filter file through (^C to abort): ")), &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map, 1))
			return 0;
		else
			return -1;
	case 2:
	default:
		msgnw(bw->parent, joe_gettext(_("No block")));
		return -1;
	}
@


1.55
log
@UC -> USTR
@
text
@a897 1
		vsrm(s);
d952 1
a952 1
		if((len = slen(name)) >= 512)	/* limit filename length */
a955 1
		vsrm(fname);
a1027 1
	vsrm(s);
@


1.54
log
@change US to UC
@
text
@d44 1
a44 1
		pdupown(markk, &m->markk, UC "upsh");
d46 1
a46 1
		pdupown(markb, &m->markb, UC "upsh");
d85 3
a87 3
		P *p = pdup(markb, UC "markv");
		prm(markb); markb=0; pdupown(markk, &markb, UC "markv");
		prm(markk); markk=0; pdupown(p, &markk, UC "markv");
d106 2
a107 2
	P *p = pdup(org, UC "pextrect");	/* Left part of text to extract */
	P *q = pdup(p, UC "pextrect");		/* After right part of text to extract */
d109 1
a109 1
	P *z = pdup(tmp->eof, UC "pextrect");	/* Buffer pointer */
d133 2
a134 2
	P *p = pdup(org, UC "pdelrect");
	P *q = pdup(p, UC "pdelrect");
d153 2
a154 2
	P *p = pdup(org, UC "pclrrect");
	P *q = pdup(p, UC "pclrrect");
d177 1
a177 1
	P *p = pdup(org, UC "ptabrect");
d201 3
a203 3
	P *p = pdup(cur, UC "pinsrect");	/* We insert at & move this pointer */
	P *q = pdup(tmp->bof, UC "pinsrect");	/* These are for scanning through 'tmp' */
	P *r = pdup(q, UC "pinsrect");
d234 1
a234 1
	pdupown(bw->cursor, &markb, UC "umarkb");
d297 1
a297 1
			pdupown(markb, &markk, UC "utoggle_marking");
d299 1
a299 1
			pdupown(bw->cursor, &markb, UC "utoggle_marking");
d302 1
a302 1
			pdupown(bw->cursor, &markk, UC "utoggle_marking");
d325 1
a325 1
	pdupown(bw->cursor, &markk, UC "umarkk");
d376 1
a376 1
		P *q = pdup(markb, UC "uswap");
d538 1
a538 1
				P *q = pdup(bw->cursor, UC "ublkcpy");
d603 1
a603 1
		msgnw(bw->parent, UC _(_("No block")));
d618 2
a619 2
	p = pdup(bw->cursor, UC "setindent");
	q = pdup(p, UC "setindent");
d658 1
a658 1
	P *p = pdup(markb, UC "purity_check");
d682 1
a682 1
	P *p = pdup(markb, UC "lindent_check");
d706 1
a706 1
			P *p = pdup(markb, UC "urindent");
d718 2
a719 2
			P *p = pdup(markb, UC "urindent");
			P *q = pdup(markb, UC "urindent");
d742 1
a742 1
			P *p = pdup(markb, UC "urindent");
d769 2
a770 2
			P *p = pdup(markb, UC "ulindent");
			P *q = pdup(p, UC "ulindent");
d798 2
a799 2
			P *p = pdup(markb, UC "ulindent");
			P *q = pdup(markb, UC "ulindent");
d822 2
a823 2
			P *p = pdup(markb, UC "ulindent");
			P *q = pdup(p, UC "ulindent");
d876 1
a876 1
			pdupown(markb, &markk, UC "doinsf");
d989 1
a989 1
			pdupown(markb, &markk, UC "dofilt");
d1001 1
a1001 1
			P *p = pdup(markk, UC "dofilt");
d1042 1
a1042 1
	pdupown(bw->cursor->b->bof, &markb, UC "markall");
d1044 1
a1044 1
	pdupown(bw->cursor->b->eof, &markk, UC "markall");
d1099 1
a1099 1
		q = pdup(markk, UC "ulower");
d1103 1
a1103 1
		p=pdup(b->bof, UC "ulower");
d1128 1
a1128 1
		q = pdup(markk, UC "uupper");
d1132 1
a1132 1
		p=pdup(b->bof, UC "uupper");
d1164 1
a1164 1
		P *q = pdup(markb, UC "blksum");
d1223 1
a1223 1
		q = pdup(markb, UC "blkget");
@


1.53
log
@gettext()
@
text
@d44 1
a44 1
		pdupown(markk, &m->markk, US "upsh");
d46 1
a46 1
		pdupown(markb, &m->markb, US "upsh");
d85 3
a87 3
		P *p = pdup(markb, US "markv");
		prm(markb); markb=0; pdupown(markk, &markb, US "markv");
		prm(markk); markk=0; pdupown(p, &markk, US "markv");
d106 2
a107 2
	P *p = pdup(org, US "pextrect");	/* Left part of text to extract */
	P *q = pdup(p, US "pextrect");		/* After right part of text to extract */
d109 1
a109 1
	P *z = pdup(tmp->eof, US "pextrect");	/* Buffer pointer */
d133 2
a134 2
	P *p = pdup(org, US "pdelrect");
	P *q = pdup(p, US "pdelrect");
d153 2
a154 2
	P *p = pdup(org, US "pclrrect");
	P *q = pdup(p, US "pclrrect");
d177 1
a177 1
	P *p = pdup(org, US "ptabrect");
d201 3
a203 3
	P *p = pdup(cur, US "pinsrect");	/* We insert at & move this pointer */
	P *q = pdup(tmp->bof, US "pinsrect");	/* These are for scanning through 'tmp' */
	P *r = pdup(q, US "pinsrect");
d234 1
a234 1
	pdupown(bw->cursor, &markb, US "umarkb");
d297 1
a297 1
			pdupown(markb, &markk, US "utoggle_marking");
d299 1
a299 1
			pdupown(bw->cursor, &markb, US "utoggle_marking");
d302 1
a302 1
			pdupown(bw->cursor, &markk, US "utoggle_marking");
d325 1
a325 1
	pdupown(bw->cursor, &markk, US "umarkk");
d376 1
a376 1
		P *q = pdup(markb, US "uswap");
d538 1
a538 1
				P *q = pdup(bw->cursor, US "ublkcpy");
d603 1
a603 1
		msgnw(bw->parent, US _(_("No block")));
d618 2
a619 2
	p = pdup(bw->cursor, US "setindent");
	q = pdup(p, US "setindent");
d658 1
a658 1
	P *p = pdup(markb, US "purity_check");
d682 1
a682 1
	P *p = pdup(markb, US "lindent_check");
d706 1
a706 1
			P *p = pdup(markb, US "urindent");
d718 2
a719 2
			P *p = pdup(markb, US "urindent");
			P *q = pdup(markb, US "urindent");
d742 1
a742 1
			P *p = pdup(markb, US "urindent");
d769 2
a770 2
			P *p = pdup(markb, US "ulindent");
			P *q = pdup(p, US "ulindent");
d798 2
a799 2
			P *p = pdup(markb, US "ulindent");
			P *q = pdup(markb, US "ulindent");
d822 2
a823 2
			P *p = pdup(markb, US "ulindent");
			P *q = pdup(p, US "ulindent");
d876 1
a876 1
			pdupown(markb, &markk, US "doinsf");
d989 1
a989 1
			pdupown(markb, &markk, US "dofilt");
d1001 1
a1001 1
			P *p = pdup(markk, US "dofilt");
d1042 1
a1042 1
	pdupown(bw->cursor->b->bof, &markb, US "markall");
d1044 1
a1044 1
	pdupown(bw->cursor->b->eof, &markk, US "markall");
d1099 1
a1099 1
		q = pdup(markk, US "ulower");
d1103 1
a1103 1
		p=pdup(b->bof, US "ulower");
d1128 1
a1128 1
		q = pdup(markk, US "uupper");
d1132 1
a1132 1
		p=pdup(b->bof, US "uupper");
d1164 1
a1164 1
		P *q = pdup(markb, US "blksum");
d1223 1
a1223 1
		q = pdup(markb, US "blkget");
@


1.52
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d284 1
a284 1
		msgnw(bw->parent, US "Selection cleared.");
d292 1
a292 1
		msgnw(bw->parent, US "Selection started.");
d309 1
a309 1
		msgnw(bw->parent, US "Selection started.");
d417 1
a417 1
		msgnw(bw->parent, US "No block");
d503 1
a503 1
	msgnw(bw->parent, US "No block");
d559 1
a559 1
		msgnw(bw->parent, US "No block");
d580 1
a580 1
				msgnw(bw->parent, msgs[-fl]);
d593 1
a593 1
				msgnw(bw->parent, msgs[-fl]);
d603 1
a603 1
		msgnw(bw->parent, US "No block");
d756 1
a756 1
			msgnw(bw->parent,US "Selected lines not properly indented");
d839 1
a839 1
			msgnw(bw->parent,US "Selected lines not properly indented");
d863 1
a863 1
				msgnw(bw->parent, msgs[-berror]);
d887 1
a887 1
			msgnw(bw->parent, US "No block");
d894 1
a894 1
			msgnw(bw->parent, msgs[-berror]), brm(tmp);
d921 1
a921 1
		msgnw(bw->parent, US "No block");
d1067 1
a1067 1
	msgnw(bw->parent, "Sorry, no sub-processes in DOS (yet)");
d1072 1
a1072 1
		if (wmkpw(bw->parent, US "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map, 1))
d1077 1
a1077 1
		if (wmkpw(bw->parent, US "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map, 1))
d1083 1
a1083 1
		msgnw(bw->parent, US "No block");
@


1.51
log
@add joe_debug
@
text
@a7 1
#include "config.h"
a9 7
#include <unistd.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
d14 1
a14 12
#include "b.h"
#include "pw.h"
#include "queue.h"
#include "scrn.h"
#include "tty.h"
#include "ublock.h"
#include "uedit.h"
#include "utils.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"
a21 2
extern int marking, nowmarking;

d255 1
a255 1
	} else if (markv(0) && bw->cursor->b==markb->b)
d267 1
a399 2
extern int udelln(BW *bw);

a688 1
		int x;
d862 2
a863 2
			if (error) {
				msgnw(bw->parent, msgs[-error]);
d893 2
a894 2
		if (error) {
			msgnw(bw->parent, msgs[-error]), brm(tmp);
d1181 1
a1181 1
				if (c >= '0' && c <= '9' || c == '.' || c == '-') {
d1186 1
a1186 1
						if (c >= '0' && c <= '9' || c == 'e' || c == 'E' ||
d1189 1
a1189 1
						    c >= 'a' && c <= 'f' || c >= 'A' && c<='F') {
a1220 2
		int x;
		int c;
@


1.50
log
@Fix ctrl-selection bug
@
text
@d65 1
a65 1
		pdupown(markk, &m->markk);
d67 1
a67 1
		pdupown(markb, &m->markb);
d106 3
a108 3
		P *p = pdup(markb);
		prm(markb); markb=0; pdupown(markk, &markb);
		prm(markk); markk=0; pdupown(p, &markk);
d127 2
a128 2
	P *p = pdup(org);	/* Left part of text to extract */
	P *q = pdup(p);		/* After right part of text to extract */
d130 1
a130 1
	P *z = pdup(tmp->eof);	/* Buffer pointer */
d154 2
a155 2
	P *p = pdup(org);
	P *q = pdup(p);
d174 2
a175 2
	P *p = pdup(org);
	P *q = pdup(p);
d198 1
a198 1
	P *p = pdup(org);
d222 3
a224 3
	P *p = pdup(cur);	/* We insert at & move this pointer */
	P *q = pdup(tmp->bof);	/* These are for scanning through 'tmp' */
	P *r = pdup(q);
d255 1
a255 1
	pdupown(bw->cursor, &markb);
d317 1
a317 1
			pdupown(markb, &markk);
d319 1
a319 1
			pdupown(bw->cursor, &markb);
d322 1
a322 1
			pdupown(bw->cursor, &markk);
d345 1
a345 1
	pdupown(bw->cursor, &markk);
d396 1
a396 1
		P *q = pdup(markb);
d560 1
a560 1
				P *q = pdup(bw->cursor);
d640 2
a641 2
	p = pdup(bw->cursor);
	q = pdup(p);
d680 1
a680 1
	P *p = pdup(markb);
d704 1
a704 1
	P *p = pdup(markb);
d729 1
a729 1
			P *p = pdup(markb);
d741 2
a742 2
			P *p = pdup(markb);
			P *q = pdup(markb);
d765 1
a765 1
			P *p = pdup(markb);
d792 2
a793 2
			P *p = pdup(markb);
			P *q = pdup(p);
d821 2
a822 2
			P *p = pdup(markb);
			P *q = pdup(markb);
d845 2
a846 2
			P *p = pdup(markb);
			P *q = pdup(p);
d899 1
a899 1
			pdupown(markb, &markk);
d1012 1
a1012 1
			pdupown(markb, &markk);
d1024 1
a1024 1
			P *p = pdup(markk);
d1065 1
a1065 1
	pdupown(bw->cursor->b->bof, &markb);
d1067 1
a1067 1
	pdupown(bw->cursor->b->eof, &markk);
d1122 1
a1122 1
		q = pdup(markk);
d1126 1
a1126 1
		p=pdup(b->bof);
d1151 1
a1151 1
		q = pdup(markk);
d1155 1
a1155 1
		p=pdup(b->bof);
d1187 1
a1187 1
		P *q = pdup(markb);
d1248 1
a1248 1
		q = pdup(markb);
@


1.49
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d273 1
a273 1
	if (nowmarking)
d276 1
a276 1
	else if (markv(0) && bw->cursor->b==markb->b)
@


1.48
log
@Blocks to work in hex mode.
Overtype mode for hex.
@
text
@d1220 1
a1220 1
					v = strtod(buf,NULL);
@


1.47
log
@Save file names from command line in state file
@
text
@d556 1
d558 12
a569 1
			binsb(bw->cursor, bcpy(markb, markk));
@


1.46
log
@Get joe to compile on irix
@
text
@d942 1
a942 1
	if (fork()) {
@


1.45
log
@Fix ~ expansion insanity
@
text
@d941 5
a945 1
	if (!vfork()) {
d975 5
a979 1
	if (vfork()) {
@


1.44
log
@FIx some math and first change bugs.
@
text
@d1075 1
a1075 1
		if (wmkpw(bw->parent, US "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
d1080 1
a1080 1
		if (wmkpw(bw->parent, US "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
@


1.43
log
@update other rc files.  fix marking problems with jpico.
@
text
@d475 1
a475 2
		if (markb->b->rdonly) {
			msgnw(bw->parent, US "Read only");
a476 1
		}
@


1.42
log
@Fix -marking
@
text
@d357 1
@


1.41
log
@fix blocks of hex
@
text
@d41 1
a41 1
extern int marking;
d273 1
a273 1
	if (marking)
d281 1
a281 1
			marking = 1;
d285 1
a285 1
			marking = 1;
d292 1
a292 1
	marking = 1;
d303 1
a303 1
		marking = 0;
d311 1
a311 1
		marking = 1;
d315 1
a315 1
		marking = 0;
d328 1
a328 1
		marking = 1;
@


1.40
log
@Add eval to math.
@
text
@d1192 2
a1193 1
						    c == '.' || c == '-' || c == '+') {
@


1.39
log
@Statistics functions
@
text
@d1215 33
@


1.38
log
@Apply patches, improve verilog syntax.
@
text
@d1151 64
@


1.37
log
@
AmigaOS is now supported. See "README.AMIGA" file for details
@
text
@d578 1
a578 1
int dowrite(BW *bw, unsigned char *s, void *object, int *notify)
d617 1
a617 1
}
@


1.36
log
@Smart indent and backspace now work even if cursor
is not right at indentation point.  Also autoindent
does not happen if cursor is on a space or tab character.

Jmacs: ^W (cut) now works if mark is after point.  (Added -autoswap
mode).  Also: preserve mark and point positions during block
operations.
@
text
@d942 1
a942 1
	if (!fork()) {
d972 1
a972 1
	if (fork()) {
@


1.35
log
@Renamed dropon to toggle_marking and added
begin_marking.
@
text
@d97 3
d103 7
a109 1
	if (markb && markk && markb->b == markk->b && markk->byte > markb->byte && (!square || markk->xcol > markb->xcol))
d111 1
a111 1
	else
d925 1
d929 2
a930 1
	if (markb && markk && !square && markb->b == bw->b && markk->b == bw->b && markb->byte == markk->byte)
d932 1
a932 1
	if (!markv(1)) {
a972 2
		long szz;

d1005 11
a1015 4
			bdel(markb, markk);
			szz = markk->b->eof->byte;
			binsb(markk, bread(fr[0], MAXLONG));
			pfwrd(markk, markk->b->eof->byte - szz);
d1097 2
a1098 1
	if (markv(0)) {
a1100 1
	        int flg;
d1102 4
a1105 5
		if (bw->cursor->b==markk->b && bw->cursor->byte==markk->byte)
			flg = 1;
		else
			flg = 0;
		bdel(markb,markk);
d1110 2
a1111 4
			binsc(markk,c);
			pgetc(markk);
			if (flg)
				pgetc(bw->cursor);
d1114 2
d1127 2
a1128 1
	if (markv(0)) {
a1130 1
	        int flg;
d1132 3
a1134 5
		if (bw->cursor->b==markk->b && bw->cursor->byte==markk->byte)
			flg = 1;
		else
			flg = 0;
		bdel(markb,markk);
d1139 2
a1140 4
			binsc(markk,c);
			pgetc(markk);
			if (flg)
				pgetc(bw->cursor);
d1143 2
@


1.34
log
@Added "upper" and "lower" functions (no longer depend on "tr" command).
Fix jmacs transpose word command.
@
text
@d262 26
a287 1
int udropon(BW *bw)
@


1.33
log
@Fix marking mode so only window with cursor is
effected.

Ctrl-space clears selection when cursor is in
selection, otherwise it starts a new one.
@
text
@d32 1
d1051 62
@


1.32
log
@Improved Ctrl-space marking.
@
text
@d263 2
a264 1
	if (markk) {
d271 8
d290 1
@


1.31
log
@Update file date on save.
@
text
@d268 1
d284 1
@


1.30
log
@Warn if file changed on save.
@
text
@d263 22
a284 7
	prm(markk);
	marking = 1;
	if (marking && markb)
		prm(markb);
	else
		umarkb(bw);
	return 0;
@


1.29
log
@Ctrl-<space> drops anchor and turns on marking mode.
@
text
@d528 2
a529 2
			if ((fl = bsave(tmp->bof, s, tmp->eof->byte)) != 0) {
				msgnw(bw->parent, msgs[5 + fl]);
d541 2
a542 2
			if ((fl = bsave(markb, s, markk->byte - markb->byte)) != 0) {
				msgnw(bw->parent, msgs[5 + fl]);
d813 1
a813 1
				msgnw(bw->parent, msgs[error + 5]);
d844 1
a844 1
			msgnw(bw->parent, msgs[error + 5]), brm(tmp);
@


1.28
log
@Added "select" for Ctrl-arrow key selecting.
@
text
@d261 11
@


1.27
log
@Added drop_no_redrop function.
@
text
@d261 1
a261 1
int udrop_no_redrop(BW *bw)
d263 1
a263 4
	prm(markk);
	if (marking && markb)
		return 0;
	else
@


1.26
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d261 10
@


1.25
log
@Elimiante --pedantic warnings.
@
text
@d31 1
d989 1
a989 1
		if (wmkpw(bw->parent, US "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, -1))
d994 1
a994 1
		if (wmkpw(bw->parent, US "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, -1))
@


1.24
log
@Smart backspace now always fixes the indentation.

Indent left and right always fixes indentation.
@
text
@d687 1
a687 1
			msgnw(bw->parent,"Selected lines not properly indented");
d770 1
a770 1
			msgnw(bw->parent,"Selected lines not properly indented");
@


1.23
log
@Added -purify option.
@
text
@d648 1
a648 1
		} else if (bw->o.purify) {
d728 1
a728 1
		} else if (bw->o.purify && lindent_check(bw->o.indentc,bw->o.istep)) {
@


1.22
log
@^K , and ^K . have improved purity checking and more useful automatic block
selection.
@
text
@d196 1
a196 1
				return 1;
d204 1
a204 1
	return 0;
d412 1
a412 1
				pfill(bw->cursor, ocol, 0);
d607 24
d641 1
a641 1
				pfill(p, markb->xcol + bw->o.istep, bw->o.indentc == '\t' ? 1 : 0);
d646 1
a646 1
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte)
d648 25
a672 1
		else if (purity_check(bw->o.indentc,0)) {
d726 1
a726 1
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte)
d728 25
a752 1
		else if (purity_check(bw->o.indentc,bw->o.istep)) {
@


1.21
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d557 1
a557 1
	} while (pisindent(p) >= indent && !pisblank(p));
d559 1
d571 2
a572 2
	} while (pisindent(q) >= indent && !pisblank(q));

d582 25
d624 1
a624 1
		else {
d637 4
d680 1
a680 1
		else {
a685 15
				if (!piseol(p))
					while (piscol(p) < bw->o.istep) {
						int c = pgetc(p);

						if (c != ' ' && c != '\t' && c != bw->o.indentc) {
							prm(p);
							prm(q);
							return -1;
						}
					}
				pnextl(p);
			}
			pset(p, markb);
			p_goto_bol(p);
			while (p->byte < markk->byte) {
d696 4
@


1.20
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d897 1
a897 1
		if (wmkpw(bw->parent, US "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL))
d902 1
a902 1
		if (wmkpw(bw->parent, US "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL))
@


1.19
log
@FEATURE: set enviroment variable JOE_FILENAME= when filtering block
@
text
@d357 1
a357 1
		msgnw(bw->parent, "No block");
d394 1
a394 1
			msgnw(bw->parent, "Read only");
d445 1
a445 1
	msgnw(bw->parent, "No block");
d489 1
a489 1
		msgnw(bw->parent, "No block");
d497 1
a497 1
int dowrite(BW *bw, char *s, void *object, int *notify)
d533 1
a533 1
		msgnw(bw->parent, "No block");
d688 1
a688 1
int doinsf(BW *bw, char *s, void *object, int *notify)
d727 1
a727 1
			msgnw(bw->parent, "No block");
d749 1
a749 1
static int dofilt(BW *bw, char *s, void *object, int *notify)
d759 1
a759 1
		msgnw(bw->parent, "No block");
d770 1
a770 1
		char		*fname, *name;
d786 1
a786 1
		name = bw->b->name ? bw->b->name : "Unnamed";
d790 1
a790 1
		putenv(fname);
d897 1
a897 1
		if (wmkpw(bw->parent, "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL))
d902 1
a902 1
		if (wmkpw(bw->parent, "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL))
d908 1
a908 1
		msgnw(bw->parent, "No block");
@


1.18
log
@change 0 to NULL where we're talking about pointers
@
text
@d12 3
d769 4
d784 9
@


1.17
log
@fix segafults in isalpha()-like functions
@
text
@d40 2
a41 2
P *markb = 0;			/* Beginning and end of block */
P *markk = 0;
d847 1
a847 1
static B *filthist = 0;
@


1.16
log
@insert braces to make if() block evident
@
text
@d179 1
a179 1
 * Check if there are any TABs in a rectange
d190 1
a190 1
		while (c = pgetc(p), c != MAXINT && c != '\n')
d196 1
d227 1
a227 1
			if (pgetc(q) == MAXINT)
@


1.15
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d449 1
a449 1
	if (markv(1))
d483 1
d497 1
a497 1
	if (markv(1))
d526 1
@


1.14
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d517 4
a520 2
			if ((fl = bsave(markb, s, markk->byte - markb->byte)) != 0)
				msgnw(bw->parent, msgs[5 + fl]), ret = -1;
d727 4
a730 3
		if (error)
			msgnw(bw->parent, msgs[error + 5]), brm(tmp), ret = -1;
		else
d861 2
a862 1
			markall(bw), filtflg = 1;
@


1.13
log
@don't use markb and markk after they are freed (fixes segfault)
@
text
@d49 1
a49 5
} markstack = {

	{
	&markstack, &markstack}
};
d222 4
a225 2
			if (!pnextl(p))
				binsc(p, '\n'), pgetc(p);
d504 4
a507 2
			if ((fl = bsave(tmp->bof, s, tmp->eof->byte)) != 0)
				msgnw(bw->parent, msgs[5 + fl]), ret = -1;
d596 4
a599 2
					while (piscol(p) < bw->o.istep)
						binsc(p, bw->o.indentc), pgetc(p);
@


1.12
log
@don't exchange points of start and end of the block when checking validity
of block pointers
@
text
@d401 1
d404 2
d412 1
a412 1
			} else if (bw->cursor->xcol >= markk->xcol && bw->cursor->line >= markb->line && bw->cursor->line <= markk->line)
@


1.11
log
@change indentation of cases in the switch() statement
@
text
@d101 1
a101 9
	else if (r && markb && markk && markb->b == markk->b && markk->byte < markb->byte && (!square || markk->xcol < markb->xcol)) {
		P *t = markb;

		markb = markk;
		markk = t;
		markb->owner = &markb;
		markk->owner = &markk;
		return 1;
	} else
@


1.10
log
@change indentation of do {} while() cycles
@
text
@d876 1
a876 1
		case 0:
d881 1
a881 2

		case 1:
d886 2
a887 3

		case 2:
		default:
@


1.9
log
@include only headers which are needed
@
text
@d549 1
a549 1
	do
d554 1
a554 1
	while (pisindent(p) >= indent && !pisblank(p));
d564 1
a564 1
	do
d567 1
a567 1
	while (pisindent(q) >= indent && !pisblank(q)) ;
d589 1
a589 2
			}
			while (pnextl(p) && p->line <= markk->line);
d631 1
a631 2
			}
			while (pnextl(p) && p->line <= markk->line);
d638 1
a638 2
			}
			while (pnextl(p) && p->line <= markk->line);
@


1.8
log
@put struct definitions and other goodies into types.h
@
text
@d12 1
d14 1
d18 1
d20 2
a21 1
#include "bw.h"
d23 2
a24 3
#include "w.h"
#include "pw.h"
#include "qw.h"
d28 1
a28 1
#include "ublock.h"
@


1.7
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d2 6
a7 6
	Highlighted block functions
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/

d9 1
@


1.6
log
@version 2.9.7-pre3
@
text
@d359 1
a359 1
		msgnw(bw, "No block");
d396 1
a396 1
			msgnw(bw, "Read only");
d444 1
a444 1
	msgnw(bw, "No block");
d487 1
a487 1
		msgnw(bw, "No block");
d508 1
a508 1
				msgnw(bw, msgs[5 + fl]), ret = -1;
d519 1
a519 1
				msgnw(bw, msgs[5 + fl]), ret = -1;
d526 1
a526 1
		msgnw(bw, "No block");
d697 1
a697 1
				msgnw(bw, msgs[error + 5]);
d721 1
a721 1
			msgnw(bw, "No block");
d728 1
a728 1
			msgnw(bw, msgs[error + 5]), brm(tmp), ret = -1;
d752 1
a752 1
		msgnw(bw, "No block");
d871 1
a871 1
	msgnw(bw, "Sorry, no sub-processes in DOS (yet)");
d889 1
a889 1
		msgnw(bw, "No block");
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d53 1
a53 2
int upsh(bw)
BW *bw;
d68 1
a68 2
int upop(bw)
BW *bw;
d93 1
a93 1
int markv(r)
d119 1
a119 3
B *pextrect(org, height, right)
P *org;
long height, right;
d146 1
a146 3
void pdelrect(org, height, right)
P *org;
long height, right;
d166 1
a166 3
void pclrrect(org, height, right, usetabs)
P *org;
long height, right;
d190 1
a190 3
int ptabrect(org, height, right)
P *org;
long height, right;
d213 1
a213 4
void pinsrect(cur, tmp, width, usetabs)
P *cur;
B *tmp;
long width;
d244 1
a244 2
int umarkb(bw)
BW *bw;
d252 1
a252 2
int udrop(bw)
BW *bw;
d264 1
a264 2
int umarkk(bw)
BW *bw;
d274 1
a274 2
int unmark(bw)
BW *bw;
d284 1
a284 2
int umarkl(bw)
BW *bw;
d295 1
a295 2
int utomarkb(bw)
BW *bw;
d304 1
a304 2
int utomarkk(bw)
BW *bw;
d313 1
a313 2
int uswap(bw)
BW *bw;
d326 1
a326 2
int utomarkbk(bw)
BW *bw;
d340 1
a340 1
extern int udelln();
d342 1
a342 2
int ublkdel(bw)
BW *bw;
d367 1
a367 2
int upicokill(bw)
BW *bw;
d392 1
a392 2
int ublkmove(bw)
BW *bw;
d450 1
a450 2
int ublkcpy(bw)
BW *bw;
d495 1
a495 5
int dowrite(bw, s, object, notify)
BW *bw;
char *s;
void *object;
int *notify;
d533 1
a533 2
void setindent(bw)
BW *bw;
d576 1
a576 2
int urindent(bw)
BW *bw;
d610 1
a610 2
int ulindent(bw)
BW *bw;
d682 1
a682 5
int doinsf(bw, s, object, notify)
BW *bw;
char *s;
void *object;
int *notify;
d742 1
a742 5
static int dofilt(bw, s, object, notify)
BW *bw;
char *s;
void *object;
int *notify;
d845 1
a845 2
void markall(bw)
BW *bw;
d854 1
a854 2
int checkmark(bw)
BW *bw;
d868 1
a868 2
int ufilt(bw)
BW *bw;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d8 2
d11 4
a14 1
#include "config.h"
d30 1
d42 2
a43 3
struct marksav
{
	LINK (MARKSAV) link;
d45 2
a46 3
}
markstack =
{
d53 2
a54 3
int
upsh (bw)
     BW *bw;
d56 2
a57 1
	MARKSAV *m = alitem (&markfree, sizeof (MARKSAV));
d61 1
a61 1
		pdupown (markk, &m->markk);
d63 2
a64 2
		pdupown (markb, &m->markb);
	enqueb (MARKSAV, link, &markstack, m);
d69 2
a70 3
int
upop (bw)
     BW *bw;
d73 17
a89 18
	if (m != &markstack)
	  {
		  --nstack;
		  prm (markk);
		  prm (markb);
		  markk = m->markk;
		  if (markk)
			  markk->owner = &markk;
		  markb = m->markb;
		  if (markb)
			  markb->owner = &markb;
		  demote (MARKSAV, link, &markfree, m);
		  if (lightoff)
			  unmark (bw);
		  updall ();
		  return 0;
	  }
	else
d95 1
a95 2
int
markv (r)
d97 11
a107 17
	if (markb && markk && markb->b == markk->b
	    && markk->byte > markb->byte && (!square
					     || markk->xcol >
					     markb->xcol)) return 1;
	else if (r && markb && markk && markb->b == markk->b
		 && markk->byte < markb->byte && (!square
						  || markk->xcol <
						  markb->xcol))
	  {
		  P *t = markb;
		  markb = markk;
		  markk = t;
		  markb->owner = &markb;
		  markk->owner = &markk;
		  return 1;
	  }
	else
d121 22
a142 23
B *
pextrect (org, height, right)
     P *org;
     long height, right;
{
	P *p = pdup (org);	/* Left part of text to extract */
	P *q = pdup (p);	/* After right part of text to extract */
	B *tmp = bmk (NULL);	/* Buffer to extract to */
	P *z = pdup (tmp->eof);	/* Buffer pointer */
	while (height--)
	  {
		  pcol (p, org->xcol);
		  pset (q, p);
		  pcolwse (q, right);
		  p_goto_eof (z);
		  binsb (z, bcpy (p, q));
		  p_goto_eof (z);
		  binsc (z, '\n');
		  pnextl (p);
	  }
	prm (p);
	prm (q);
	prm (z);
d150 16
a165 17
void
pdelrect (org, height, right)
     P *org;
     long height, right;
{
	P *p = pdup (org);
	P *q = pdup (p);
	while (height--)
	  {
		  pcol (p, org->xcol);
		  pset (q, p);
		  pcol (q, right);
		  bdel (p, q);
		  pnextl (p);
	  }
	prm (p);
	prm (q);
d172 20
a191 20
void
pclrrect (org, height, right, usetabs)
     P *org;
     long height, right;
{
	P *p = pdup (org);
	P *q = pdup (p);
	while (height--)
	  {
		  long pos;
		  pcol (p, org->xcol);
		  pset (q, p);
		  pcoli (q, right);
		  pos = q->col;
		  bdel (p, q);
		  pfill (p, pos, usetabs);
		  pnextl (p);
	  }
	prm (p);
	prm (q);
d198 20
a217 22
int
ptabrect (org, height, right)
     P *org;
     long height, right;
{
	P *p = pdup (org);
	while (height--)
	  {
		  int c;
		  pcol (p, org->xcol);
		  while (c = pgetc (p), c != MAXINT && c != '\n')
			  if (c == '\t')
			    {
				    prm (p);
				    return 1;
			    }
			  else if (piscol (p) > right)
				  break;
		  if (c != '\n')
			  pnextl (p);
	  }
	prm (p);
d223 9
a231 9
void
pinsrect (cur, tmp, width, usetabs)
     P *cur;
     B *tmp;
     long width;
{
	P *p = pdup (cur);	/* We insert at & move this pointer */
	P *q = pdup (tmp->bof);	/* These are for scanning through 'tmp' */
	P *r = pdup (q);
d233 18
a250 20
		while (pset (r, q), p_goto_eol (q),
		       (q->line != tmp->eof->line || piscol (q)))
		  {
			  pcol (p, cur->xcol);
			  if (piscol (p) < cur->xcol)
				  pfill (p, cur->xcol, usetabs);
			  binsb (p, bcpy (r, q));
			  pfwrd (p, q->byte - r->byte);
			  if (piscol (p) < cur->xcol + width)
				  pfill (p, cur->xcol + width, usetabs);
			  if (piseol (p))
				  pbackws (p);
			  if (!pnextl (p))
				  binsc (p, '\n'), pgetc (p);
			  if (pgetc (q) == MAXINT)
				  break;
		  }
	prm (p);
	prm (q);
	prm (r);
d257 2
a258 3
int
umarkb (bw)
     BW *bw;
d260 1
a260 1
	pdupown (bw->cursor, &markb);
d262 1
a262 1
	updall ();
d266 2
a267 3
int
udrop (bw)
     BW *bw;
d269 1
a269 1
	prm (markk);
d271 1
a271 1
		prm (markb);
d273 1
a273 1
		umarkb (bw);
d279 2
a280 3
int
umarkk (bw)
     BW *bw;
d282 1
a282 1
	pdupown (bw->cursor, &markk);
d284 1
a284 1
	updall ();
d290 6
a295 7
int
unmark (bw)
     BW *bw;
{
	prm (markb);
	prm (markk);
	updall ();
d301 9
a309 10
int
umarkl (bw)
     BW *bw;
{
	p_goto_bol (bw->cursor);
	umarkb (bw);
	pnextl (bw->cursor);
	umarkk (bw);
	utomarkb (bw);
	pcol (bw->cursor, bw->cursor->xcol);
d313 7
a319 10
int
utomarkb (bw)
     BW *bw;
{
	if (markb && markb->b == bw->b)
	  {
		  pset (bw->cursor, markb);
		  return 0;
	  }
	else
d323 7
a329 10
int
utomarkk (bw)
     BW *bw;
{
	if (markk && markk->b == bw->b)
	  {
		  pset (bw->cursor, markk);
		  return 0;
	  }
	else
d333 11
a343 13
int
uswap (bw)
     BW *bw;
{
	if (markb && markb->b == bw->b)
	  {
		  P *q = pdup (markb);
		  umarkb (bw);
		  pset (bw->cursor, q);
		  prm (q);
		  return 0;
	  }
	else
d347 10
a356 16
int
utomarkbk (bw)
     BW *bw;
{
	if (markb && markb->b == bw->b && bw->cursor->byte != markb->byte)
	  {
		  pset (bw->cursor, markb);
		  return 0;
	  }
	else if (markk && markk->b == bw->b
		 && bw->cursor->byte != markk->byte)
	  {
		  pset (bw->cursor, markk);
		  return 0;
	  }
	else
d362 1
a362 1
extern int udelln ();
d364 21
a384 36
int
ublkdel (bw)
     BW *bw;
{
	if (markv (1))
	  {
		  if (square)
			  if (bw->o.overtype)
			    {
				    long ocol = markk->xcol;
				    pclrrect (markb,
					      markk->line - markb->line + 1,
					      markk->xcol, ptabrect (markb,
								     markk->
								     line -
								     markb->
								     line + 1,
								     markk->
								     xcol));
				    pcol (markk, ocol);
				    markk->xcol = ocol;
			    }
			  else
				  pdelrect (markb,
					    markk->line - markb->line + 1,
					    markk->xcol);
		  else
			  bdel (markb, markk);
		  if (lightoff)
			  unmark (bw);
	  }
	else
	  {
		  msgnw (bw, "No block");
		  return -1;
	  }
d390 21
a410 35
int
upicokill (bw)
     BW *bw;
{
	upsh (bw);
	umarkk (bw);
	if (markv (1))
	  {
		  if (square)
			  if (bw->o.overtype)
			    {
				    long ocol = markk->xcol;
				    pclrrect (markb,
					      markk->line - markb->line + 1,
					      markk->xcol, ptabrect (markb,
								     markk->
								     line -
								     markb->
								     line + 1,
								     markk->
								     xcol));
				    pcol (markk, ocol);
				    markk->xcol = ocol;
			    }
			  else
				  pdelrect (markb,
					    markk->line - markb->line + 1,
					    markk->xcol);
		  else
			  bdel (markb, markk);
		  if (lightoff)
			  unmark (bw);
	  }
	else
		udelln (bw);
d416 54
a469 68
int
ublkmove (bw)
     BW *bw;
{
	if (markv (1))
	  {
		  if (markb->b->rdonly)
		    {
			    msgnw (bw, "Read only");
			    return -1;
		    }
		  if (square)
		    {
			    long height = markk->line - markb->line + 1;
			    long width = markk->xcol - markb->xcol;
			    int usetabs =
				    ptabrect (markb, height, markk->xcol);
			    long ocol = piscol (bw->cursor);
			    B *tmp = pextrect (markb, height, markk->xcol);
			    ublkdel (bw);
			    if (bw->o.overtype)
			      {
				      /* If cursor was in block, blkdel moves it to left edge of block, so fix it
				       * back to its original place here */
				      pcol (bw->cursor, ocol);
				      pfill (bw->cursor, ocol, 0);
				      pdelrect (bw->cursor, height,
						piscol (bw->cursor) + width);
			      }
			    else if (bw->cursor->xcol >= markk->xcol &&
				     bw->cursor->line >= markb->line &&
				     bw->cursor->line <= markk->line)
				    /* If cursor was to right of block, xcol was not properly updated */
				    bw->cursor->xcol -= width;
			    pinsrect (bw->cursor, tmp, width, usetabs);
			    brm (tmp);
			    if (lightoff)
				    unmark (bw);
			    else
			      {
				      umarkb (bw);
				      umarkk (bw);
				      pline (markk, markk->line + height - 1);
				      pcol (markk, markb->xcol + width);
				      markk->xcol = markb->xcol + width;
			      }
			    return 0;
		    }
		  else if (bw->cursor->b != markk->b ||
			   bw->cursor->byte > markk->byte ||
			   bw->cursor->byte < markb->byte)
		    {
			    long size = markk->byte - markb->byte;
			    binsb (bw->cursor, bcpy (markb, markk));
			    bdel (markb, markk);
			    if (lightoff)
				    unmark (bw);
			    else
			      {
				      umarkb (bw);
				      umarkk (bw);
				      pfwrd (markk, size);
			      }
			    updall ();
			    return 0;
		    }
	  }
	msgnw (bw, "No block");
d475 2
a476 3
int
ublkcpy (bw)
     BW *bw;
d478 38
a515 44
	if (markv (1))
		if (square)
		  {
			  long height = markk->line - markb->line + 1;
			  long width = markk->xcol - markb->xcol;
			  int usetabs = ptabrect (markb, height, markk->xcol);
			  B *tmp = pextrect (markb, height, markk->xcol);
			  if (bw->o.overtype)
				  pdelrect (bw->cursor, height,
					    piscol (bw->cursor) + width);
			  pinsrect (bw->cursor, tmp, width, usetabs);
			  brm (tmp);
			  if (lightoff)
				  unmark (bw);
			  else
			    {
				    umarkb (bw);
				    umarkk (bw);
				    pline (markk, markk->line + height - 1);
				    pcol (markk, markb->xcol + width);
				    markk->xcol = markb->xcol + width;
			    }
			  return 0;
		  }
		else
		  {
			  long size = markk->byte - markb->byte;
			  binsb (bw->cursor, bcpy (markb, markk));
			  if (lightoff)
				  unmark (bw);
			  else
			    {
				    umarkb (bw);
				    umarkk (bw);
				    pfwrd (markk, size);
			    }
			  updall ();
			  return 0;
		  }
	else
	  {
		  msgnw (bw, "No block");
		  return -1;
	  }
d521 5
a525 6
int
dowrite (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d529 30
a558 39
	if (markv (1))
		if (square)
		  {
			  int fl;
			  int ret = 0;
			  B *tmp =
				  pextrect (markb,
					    markk->line - markb->line + 1,
					    markk->xcol);
			  if (fl = bsave (tmp->bof, s, tmp->eof->byte))
				  msgnw (bw, msgs[5 + fl]), ret = -1;
			  brm (tmp);
			  if (lightoff)
				  unmark (bw);
			  vsrm (s);
			  return ret;
		  }
		else
		  {
			  int fl;
			  int ret = 0;
			  if (fl =
			      bsave (markb, s,
				     markk->byte - markb->byte)) msgnw (bw,
									msgs[5
									     +
									     fl]),
					  ret = -1;
			  if (lightoff)
				  unmark (bw);
			  vsrm (s);
			  return ret;
		  }
	else
	  {
		  vsrm (s);
		  msgnw (bw, "No block");
		  return -1;
	  }
d563 2
a564 3
void
setindent (bw)
     BW *bw;
d568 2
a569 1
	if (pisblank (bw->cursor))
d572 3
a574 3
	p = pdup (bw->cursor);
	q = pdup (p);
	indent = pisindent (p);
d577 1
a577 1
		if (!pprevl (p))
d580 3
a582 3
			p_goto_bol (p);
	while (pisindent (p) >= indent && !pisblank (p));
	pnextl (p);
d584 2
a585 2
	p_goto_bol (p);
	p->xcol = piscol (p);
d587 1
a587 1
		prm (markb);
d592 1
a592 1
		if (!pnextl (q))
d594 1
a594 1
	while (pisindent (q) >= indent && !pisblank (q));
d597 2
a598 2
		prm (markk);
	q->xcol = piscol (q);
d602 1
a602 1
	updall ();
d607 2
a608 3
int
urindent (bw)
     BW *bw;
d610 27
a636 40
	if (square)
	  {
		  if (markb && markk && markb->b == markk->b &&
		      markb->byte <= markk->byte
		      && markb->xcol <= markk->xcol)
		    {
			    P *p = pdup (markb);
			    do
			      {
				      pcol (p, markb->xcol);
				      pfill (p, markb->xcol + bw->o.istep,
					     bw->o.indentc == '\t' ? 1 : 0);
			      }
			    while (pnextl (p) && p->line <= markk->line);
			    prm (p);
		    }
	  }
	else
	  {
		  if (!markb || !markk || markb->b != markk->b ||
		      bw->cursor->byte < markb->byte
		      || bw->cursor->byte > markk->byte
		      || markb->byte == markk->byte)
			  setindent (bw);
		  else
		    {
			    P *p = pdup (markb);
			    while (p->byte < markk->byte)
			      {
				      p_goto_bol (p);
				      if (!piseol (p))
					      while (piscol (p) < bw->o.istep)
						      binsc (p,
							     bw->o.indentc),
							      pgetc (p);
				      pnextl (p);
			      }
			    prm (p);
		    }
	  }
d642 2
a643 3
int
ulindent (bw)
     BW *bw;
d645 14
a658 22
	if (square)
	  {
		  if (markb && markk && markb->b == markk->b &&
		      markb->byte <= markk->byte
		      && markb->xcol <= markk->xcol)
		    {
			    P *p = pdup (markb);
			    P *q = pdup (p);
			    do
			      {
				      pcol (p, markb->xcol);
				      while (piscol (p) <
					     markb->xcol + bw->o.istep)
					{
						int c = pgetc (p);
						if (c != ' ' && c != '\t'
						    && c != bw->o.indentc)
						  {
							  prm (p);
							  prm (q);
							  return -1;
						  }
d660 31
a690 42
			      }
			    while (pnextl (p) && p->line <= markk->line);
			    pset (p, markb);
			    do
			      {
				      pcol (p, markb->xcol);
				      pset (q, p);
				      pcol (q, markb->xcol + bw->o.istep);
				      bdel (p, q);
			      }
			    while (pnextl (p) && p->line <= markk->line);
			    prm (p);
			    prm (q);
		    }
	  }
	else
	  {
		  if (!markb || !markk || markb->b != markk->b ||
		      bw->cursor->byte < markb->byte
		      || bw->cursor->byte > markk->byte
		      || markb->byte == markk->byte)
			  setindent (bw);
		  else
		    {
			    P *p = pdup (markb);
			    P *q = pdup (p);
			    p_goto_bol (p);
			    while (p->byte < markk->byte)
			      {
				      if (!piseol (p))
					      while (piscol (p) < bw->o.istep)
						{
							int c = pgetc (p);
							if (c != ' '
							    && c != '\t'
							    && c !=
							    bw->o.indentc)
							  {
								  prm (p);
								  prm (q);
								  return -1;
							  }
a691 12
				      pnextl (p);
			      }
			    pset (p, markb);
			    p_goto_bol (p);
			    while (p->byte < markk->byte)
			      {
				      if (!piseol (p))
					{
						pset (q, p);
						while (piscol (q) <
						       bw->o.istep) pgetc (q);
						bdel (p, q);
d693 17
a709 6
				      pnextl (p);
			      }
			    prm (p);
			    prm (q);
		    }
	  }
d715 5
a719 6
int
doinsf (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d724 42
a765 43
		if (markv (1))
		  {
			  B *tmp;
			  long width = markk->xcol - markb->xcol;
			  long height;
			  int usetabs =
				  ptabrect (markb,
					    markk->line - markb->line + 1,
					    markk->xcol);
			  tmp = bload (s);
			  if (error)
			    {
				    msgnw (bw, msgs[error + 5]);
				    brm (tmp);
				    return -1;
			    }
			  if (piscol (tmp->eof))
				  height = tmp->eof->line + 1;
			  else
				  height = tmp->eof->line;
			  if (bw->o.overtype)
			    {
				    pclrrect (markb,
					      long_max (markk->line -
							markb->line + 1,
							height), markk->xcol,
					      usetabs);
				    pdelrect (markb, height,
					      width + markb->xcol);
			    }
			  pinsrect (markb, tmp, width, usetabs);
			  pdupown (markb, &markk);
			  markk->xcol = markb->xcol;
			  if (height)
			    {
				    pline (markk, markk->line + height - 1);
				    pcol (markk, markb->xcol + width);
				    markk->xcol = markb->xcol + width;
			    }
			  brm (tmp);
			  updall ();
			  return 0;
		  }
d767 5
a771 16
		  {
			  msgnw (bw, "No block");
			  return -1;
		  }
	else
	  {
		  int ret = 0;
		  B *tmp = bload (s);
		  if (error)
			  msgnw (bw, msgs[error + 5]), brm (tmp), ret = -1;
		  else
			  binsb (bw->cursor, tmp);
		  vsrm (s);
		  bw->cursor->xcol = piscol (bw->cursor);
		  return ret;
	  }
d779 5
a783 6
static int
dofilt (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d787 1
d790 6
a795 8
	if (markb && markk && !square &&
	    markb->b == bw->b && markk->b == bw->b
	    && markb->byte == markk->byte) goto ok;
	if (!markv (1))
	  {
		  msgnw (bw, "No block");
		  return -1;
	  }
d798 80
a877 99
	pipe (fr);
	pipe (fw);
	npartial (bw->parent->t->t);
	ttclsn ();
	if (!fork ())
	  {
		  signrm ();
		  close (0);
		  close (1);
		  close (2);
		  dup (fw[0]);
		  dup (fr[1]);
		  dup (fr[1]);
		  close (fw[0]);
		  close (fr[1]);
		  close (fw[1]);
		  close (fr[0]);
		  execl ("/bin/sh", "/bin/sh", "-c", s, NULL);
		  _exit (0);
	  }
	close (fr[1]);
	close (fw[0]);
	if (fork ())
	  {
		  long szz;
		  close (fw[1]);
		  if (square)
		    {
			    B *tmp;
			    long width = markk->xcol - markb->xcol;
			    long height;
			    int usetabs =
				    ptabrect (markb,
					      markk->line - markb->line + 1,
					      markk->xcol);
			    tmp = bread (fr[0], MAXLONG);
			    if (piscol (tmp->eof))
				    height = tmp->eof->line + 1;
			    else
				    height = tmp->eof->line;
			    if (bw->o.overtype)
			      {
				      pclrrect (markb,
						markk->line - markb->line + 1,
						markk->xcol, usetabs);
				      pdelrect (markb,
						long_max (height,
							  markk->line -
							  markb->line + 1),
						width + markb->xcol);
			      }
			    else
				    pdelrect (markb,
					      markk->line - markb->line + 1,
					      markk->xcol);
			    pinsrect (markb, tmp, width, usetabs);
			    pdupown (markb, &markk);
			    markk->xcol = markb->xcol;
			    if (height)
			      {
				      pline (markk, markk->line + height - 1);
				      pcol (markk, markb->xcol + width);
				      markk->xcol = markb->xcol + width;
			      }
			    if (lightoff)
				    unmark (bw);
			    brm (tmp);
			    updall ();
		    }
		  else
		    {
			    bdel (markb, markk);
			    szz = markk->b->eof->byte;
			    binsb (markk, bread (fr[0], MAXLONG));
			    pfwrd (markk, markk->b->eof->byte - szz);
			    if (lightoff)
				    unmark (bw);
		    }
		  close (fr[0]);
		  wait (0);
		  wait (0);
	  }
	else
	  {
		  if (square)
		    {
			    B *tmp =
				    pextrect (markb,
					      markk->line - markb->line + 1,
					      markk->xcol);
			    bsavefd (tmp->bof, fw[1], tmp->eof->byte);
		    }
		  else
			  bsavefd (markb, fw[1], markk->byte - markb->byte);
		  close (fw[1]);
		  _exit (0);
	  }
	vsrm (s);
	ttopnn ();
d879 2
a880 2
		unmark (bw);
	bw->cursor->xcol = piscol (bw->cursor);
d886 2
a887 3
void
markall (bw)
     BW *bw;
d889 1
a889 1
	pdupown (bw->cursor->b->bof, &markb);
d891 3
a893 3
	pdupown (bw->cursor->b->eof, &markk);
	markk->xcol = piscol (markk);
	updall ();
d896 2
a897 3
int
checkmark (bw)
     BW *bw;
d899 1
a899 1
	if (!markv (1))
d902 7
a908 10
		else
		  {
			  markall (bw), filtflg = 1;
			  return 1;
		  }
	else
	  {
		  filtflg = 0;
		  return 0;
	  }
d911 2
a912 3
int
ufilt (bw)
     BW *bw;
d915 1
a915 1
	msgnw (bw, "Sorry, no sub-processes in DOS (yet)");
d918 18
a935 22
	switch (checkmark (bw))
	  {
	  case 0:
		  if (wmkpw (bw->parent,
			     "Command to filter block through (^C to abort): ",
			     &filthist, dofilt, NULL, NULL, utypebw, NULL,
			     NULL)) return 0;
		  else
			  return -1;

	  case 1:
		  if (wmkpw (bw->parent,
			     "Command to filter file through (^C to abort): ",
			     &filthist, dofilt, NULL, NULL, utypebw, NULL,
			     NULL)) return 0;
		  else
			  return -1;

	  case 2:
		  msgnw (bw, "No block");
		  return -1;
	  }
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Highlighted block functions
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d8 1
d23 3
a25 3
int square=0;				/* Set for rectangle mode */
int lightoff=0;				/* Set if highlighting should turn off
					   after block operations */
d30 2
a31 2
P *markb=0;				/* Beginning and end of block */
P *markk=0;
d37 53
a89 37
 {
 LINK(MARKSAV) link;
 P *markb, *markk;
 } markstack={{&markstack,&markstack}};
MARKSAV markfree={{&markfree,&markfree}};
int nstack=0;

int upsh(bw) 
BW *bw;
 {
 MARKSAV *m=alitem(&markfree,sizeof(MARKSAV));
 m->markb=0; m->markk=0;
 if(markk) pdupown(markk,&m->markk);
 if(markb) pdupown(markb,&m->markb);
 enqueb(MARKSAV,link,&markstack,m);
 ++nstack;
 return 0;
 }

int upop(bw)
BW *bw;
 {
 MARKSAV *m=markstack.link.prev;
 if(m!=&markstack)
  {
  --nstack;
  prm(markk);
  prm(markb);
  markk=m->markk; if(markk) markk->owner= &markk;
  markb=m->markb; if(markb) markb->owner= &markb;
  demote(MARKSAV,link,&markfree,m);
  if(lightoff) unmark(bw);
  updall();
  return 0;
  }
 else return -1;
 }
d93 22
a114 16
int markv(r)
 {
 if(markb && markk && markb->b==markk->b && markk->byte>markb->byte &&
    (!square || markk->xcol>markb->xcol)) return 1;
 else if(r && markb && markk && markb->b==markk->b &&
         markk->byte<markb->byte && (!square || markk->xcol<markb->xcol))
  {
  P *t=markb;
  markb=markk;
  markk=t;
  markb->owner= &markb;
  markk->owner= &markk;
  return 1;
  }
 else return 0;
 }
d126 25
a150 20
B *pextrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);	/* Left part of text to extract */
 P *q=pdup(p);		/* After right part of text to extract */
 B *tmp=bmk(NULL);	/* Buffer to extract to */
 P *z=pdup(tmp->eof);	/* Buffer pointer */
 while(height--)
  {
  pcol(p,org->xcol);
  pset(q,p);
  pcolwse(q,right); 
  peof(z); binsb(z,bcpy(p,q));
  peof(z); binsc(z,'\n');
  pnextl(p);
  }
 prm(p); prm(q); prm(z);
 return tmp;
 }
d156 18
a173 16
void pdelrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);
 P *q=pdup(p);
 while(height--)
  {
  pcol(p,org->xcol);
  pset(q,p);
  pcol(q,right);
  bdel(p,q);
  pnextl(p);
  }
 prm(p); prm(q);
 }
d179 21
a199 19
void pclrrect(org,height,right,usetabs)
P *org;
long height,right;
 {
 P *p=pdup(org);
 P *q=pdup(p);
 while(height--)
  {
  long pos;
  pcol(p,org->xcol);
  pset(q,p);
  pcoli(q,right);
  pos=q->col;
  bdel(p,q);
  pfill(p,pos,usetabs);
  pnextl(p);
  }
 prm(p); prm(q);
 }
d205 24
a228 19
int ptabrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);
 while(height--)
  {
  int c;
  pcol(p,org->xcol);
  while(c=pgetc(p), c!=MAXINT && c!='\n')
   if(c=='\t')
    {
    prm(p); return 1;
    }
   else if(piscol(p)>right) break;
  if(c!='\n') pnextl(p);
  }
 prm(p); return 0;
 }
d232 31
a262 21
void pinsrect(cur,tmp,width,usetabs)
P *cur;
B *tmp;
long width;
 {
 P *p=pdup(cur);		/* We insert at & move this pointer */
 P *q=pdup(tmp->bof);		/* These are for scanning through 'tmp' */
 P *r=pdup(q);
 if(width)
  while(pset(r,q), peol(q), (q->line!=tmp->eof->line || piscol(q)))
   {
   pcol(p,cur->xcol);
   if(piscol(p)<cur->xcol) pfill(p,cur->xcol,usetabs);
   binsb(p,bcpy(r,q)); pfwrd(p,q->byte-r->byte);
   if(piscol(p)<cur->xcol+width) pfill(p,cur->xcol+width,usetabs);
   if(piseol(p)) pbackws(p);
   if(!pnextl(p)) binsc(p,'\n'), pgetc(p);
   if(pgetc(q)==MAXINT) break;
   }
 prm(p); prm(q); prm(r);
 }
d268 21
a288 19
int umarkb(bw)
BW *bw;
 {
 pdupown(bw->cursor,&markb);
 markb->xcol=bw->cursor->xcol;
 updall();
 return 0;
 }

int udrop(bw)
BW *bw;
 {
 prm(markk);
 if(marking && markb)
  prm(markb);
 else
  umarkb(bw);
 return 0;
 }
d292 9
a300 8
int umarkk(bw)
BW *bw;
 {
 pdupown(bw->cursor,&markk);
 markk->xcol=bw->cursor->xcol;
 updall();
 return 0;
 }
d304 9
a312 8
int unmark(bw)
BW *bw;
 {
 prm(markb);
 prm(markk);
 updall();
 return 0;
 }
d316 73
a388 48
int umarkl(bw)
BW *bw;
 {
 pbol(bw->cursor);
 umarkb(bw);
 pnextl(bw->cursor);
 umarkk(bw);
 utomarkb(bw);
 pcol(bw->cursor,bw->cursor->xcol);
 return 0;
 }

int utomarkb(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b) { pset(bw->cursor,markb); return 0; }
 else return -1;
 }

int utomarkk(bw)
BW *bw;
 {
 if(markk && markk->b==bw->b) { pset(bw->cursor,markk); return 0; }
 else return -1;
 }

int uswap(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b)
  {
  P *q=pdup(markb);
  umarkb(bw);
  pset(bw->cursor,q); prm(q);
  return 0;
  }
 else return -1;
 }

int utomarkbk(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b && bw->cursor->byte!=markb->byte)
  { pset(bw->cursor,markb); return 0; }
 else if(markk && markk->b==bw->b && bw->cursor->byte!=markk->byte)
  { pset(bw->cursor,markk); return 0; }
 else return -1;
 }
d392 1
a392 1
extern int udelln();
d394 38
a431 22
int ublkdel(bw)
BW *bw;
 {
 if(markv(1))
  {
  if(square)
   if(bw->o.overtype)
    {
    long ocol=markk->xcol;
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,
             ptabrect(markb,markk->line-markb->line+1,markk->xcol));
    pcol(markk,ocol); markk->xcol=ocol;
    }
   else
    pdelrect(markb,markk->line-markb->line+1,markk->xcol);
  else
   bdel(markb,markk);
  if(lightoff) unmark(bw);
  }
 else { msgnw(bw,"No block"); return -1; }
 return 0;
 }
d435 37
a471 24
int upicokill(bw)
BW *bw;
 {
 upsh(bw);
 umarkk(bw);
 if(markv(1))
  {
  if(square)
   if(bw->o.overtype)
    {
    long ocol=markk->xcol;
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,
             ptabrect(markb,markk->line-markb->line+1,markk->xcol));
    pcol(markk,ocol); markk->xcol=ocol;
    }
   else
    pdelrect(markb,markk->line-markb->line+1,markk->xcol);
  else
   bdel(markb,markk);
  if(lightoff) unmark(bw);
  }
 else udelln(bw);
 return 0;
 }
d475 70
a544 60
int ublkmove(bw)
BW *bw;
 {
 if(markv(1))
  {
  if(markb->b->rdonly) { msgnw(bw,"Read only"); return -1; }
  if(square)
   {
   long height=markk->line-markb->line+1;
   long width=markk->xcol-markb->xcol;
   int usetabs=ptabrect(markb,height,markk->xcol);
   long ocol=piscol(bw->cursor);
   B *tmp=pextrect(markb,height,markk->xcol);
   ublkdel(bw);
   if(bw->o.overtype)
    {
    /* If cursor was in block, blkdel moves it to left edge of block, so fix it
     * back to its original place here */
    pcol(bw->cursor,ocol);
    pfill(bw->cursor,ocol,0);
    pdelrect(bw->cursor,height,piscol(bw->cursor)+width);
    }
   else if(bw->cursor->xcol>=markk->xcol &&
           bw->cursor->line>=markb->line &&
           bw->cursor->line<=markk->line)
    /* If cursor was to right of block, xcol was not properly updated */
    bw->cursor->xcol-=width;
   pinsrect(bw->cursor,tmp,width,usetabs);
   brm(tmp);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   return 0;
   }
  else if(bw->cursor->b!=markk->b ||
          bw->cursor->byte>markk->byte ||
          bw->cursor->byte<markb->byte)
   {
   long size=markk->byte-markb->byte;
   binsb(bw->cursor,bcpy(markb,markk));
   bdel(markb,markk);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pfwrd(markk,size);
    }
   updall();
   return 0;
   }
  }
 msgnw(bw,"No block");
 return -1;
 }
d548 49
a596 39
int ublkcpy(bw)
BW *bw;
 {
 if(markv(1))
  if(square)
   {
   long height=markk->line-markb->line+1;
   long width=markk->xcol-markb->xcol;
   int usetabs=ptabrect(markb,height,markk->xcol);
   B *tmp=pextrect(markb,height,markk->xcol);
   if(bw->o.overtype) pdelrect(bw->cursor,height,piscol(bw->cursor)+width);
   pinsrect(bw->cursor,tmp,width,usetabs);
   brm(tmp);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   return 0;
   }
  else
   {
   long size=markk->byte-markb->byte;
   binsb(bw->cursor,bcpy(markb,markk));
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pfwrd(markk,size);
    }
   updall();
   return 0;
   }
 else { msgnw(bw,"No block"); return -1; }
 }
d601 49
a649 35
int dowrite(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(markv(1))
  if(square)
   {
   int fl;
   int ret=0;
   B *tmp=pextrect(markb,markk->line-markb->line+1,markk->xcol);
   if(fl=bsave(tmp->bof,s,tmp->eof->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
   brm(tmp);
   if(lightoff) unmark(bw);
   vsrm(s);
   return ret;
   }
  else
   {
   int fl;
   int ret=0;
   if(fl=bsave(markb,s,markk->byte-markb->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
   if(lightoff) unmark(bw);
   vsrm(s);
   return ret;
   }
 else
  {
  vsrm(s);
  msgnw(bw,"No block");
  return -1;
  }
 }
d653 41
a693 32
void setindent(bw)
BW *bw;
 {
 P *p, *q;
 long indent;
 if(pisblank(bw->cursor)) return;
 
 p=pdup(bw->cursor);
 q=pdup(p);
 indent=pisindent(p);
 
 do
  if(!pprevl(p)) goto done;
  else pbol(p);
  while(pisindent(p)>=indent && !pisblank(p));
 pnextl(p);
 done:
 pbol(p);
 p->xcol=piscol(p);
 if(markb) prm(markb);
 markb=p; p->owner= &markb;
 
 do
  if(!pnextl(q)) break;
  while(pisindent(q)>=indent && !pisblank(q));
 
 if(markk) prm(markk);
 q->xcol=piscol(q);
 markk=q; q->owner= &markk;
 
 updall();
 }
d697 46
a742 37
int urindent(bw)
BW *bw;
 {
 if(square)
  {
  if(markb && markk && markb->b==markk->b &&
     markb->byte<=markk->byte && markb->xcol<=markk->xcol)
   {
   P *p=pdup(markb);
   do
    {
    pcol(p,markb->xcol);
    pfill(p,markb->xcol+bw->o.istep,bw->o.indentc=='\t'?1:0);
    } while(pnextl(p) && p->line<=markk->line);
   prm(p);
   }
  }
 else
  {
  if(!markb || !markk || markb->b!=markk->b ||
     bw->cursor->byte<markb->byte || bw->cursor->byte>markk->byte ||
     markb->byte==markk->byte)
   setindent(bw);
  else
   {
   P *p=pdup(markb);
   while(p->byte<markk->byte)
    {
    pbol(p);
    if(!piseol(p)) while(piscol(p)<bw->o.istep) binsc(p,bw->o.indentc), pgetc(p);
    pnextl(p);
    }
   prm(p);
   }
  }
 return 0;
 }
d746 91
a836 77
int ulindent(bw)
BW *bw;
 {
 if(square)
  {
  if(markb && markk && markb->b==markk->b &&
     markb->byte<=markk->byte && markb->xcol<=markk->xcol)
   {
   P *p=pdup(markb);
   P *q=pdup(p);
   do
    {
    pcol(p,markb->xcol);
    while(piscol(p)<markb->xcol+bw->o.istep)
     {
     int c=pgetc(p);
     if(c!=' ' && c!='\t' && c!=bw->o.indentc)
      {
      prm(p);
      prm(q);
      return -1;
      }
     }
    } while(pnextl(p) && p->line<=markk->line);
   pset(p,markb);
   do
    {
    pcol(p,markb->xcol);
    pset(q,p);
    pcol(q,markb->xcol+bw->o.istep);
    bdel(p,q);
    } while(pnextl(p) && p->line<=markk->line);
   prm(p); prm(q);
   }
  }
 else
  {
  if(!markb || !markk || markb->b!=markk->b ||
     bw->cursor->byte<markb->byte || bw->cursor->byte>markk->byte ||
     markb->byte==markk->byte)
   setindent(bw);
  else
   {
   P *p=pdup(markb);
   P *q=pdup(p);
   pbol(p);
   while(p->byte<markk->byte)
    {
    if(!piseol(p)) while(piscol(p)<bw->o.istep)
     {
     int c=pgetc(p);
     if(c!=' ' && c!='\t' && c!=bw->o.indentc)
      {
      prm(p);
      prm(q);
      return -1;
      }
     }
    pnextl(p);
    }
   pset(p,markb);
   pbol(p);
   while(p->byte<markk->byte)
    {
    if(!piseol(p))
     {
     pset(q,p);
     while(piscol(q)<bw->o.istep) pgetc(q);
     bdel(p,q);
     }
    pnextl(p);
    }
   prm(p); prm(q);
   }
  }
 return 0;
 }
d840 71
a910 52
int doinsf(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(square)
  if(markv(1))
   {
   B *tmp;
   long width=markk->xcol-markb->xcol;
   long height;
   int usetabs=ptabrect(markb,markk->line-markb->line+1,markk->xcol);
   tmp=bload(s); 
   if(error)
    {
    msgnw(bw,msgs[error+5]);
    brm(tmp);
    return -1;
    }
   if(piscol(tmp->eof)) height=tmp->eof->line+1;
   else height=tmp->eof->line;
   if(bw->o.overtype)
    {
    pclrrect(markb,long_max(markk->line-markb->line+1,height),markk->xcol,usetabs);
    pdelrect(markb,height,width+markb->xcol);
    }
   pinsrect(markb,tmp,width,usetabs);
   pdupown(markb,&markk);
   markk->xcol=markb->xcol;
   if(height)
    {
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   brm(tmp);
   updall();
   return 0;
   }
  else { msgnw(bw,"No block"); return -1; }
 else
  {
  int ret=0;
  B *tmp=bload(s);
  if(error) msgnw(bw,msgs[error+5]), brm(tmp), ret= -1;
  else binsb(bw->cursor,tmp);
  vsrm(s);
  bw->cursor->xcol=piscol(bw->cursor);
  return ret;
  }
 }
d915 1
a915 1
static int filtflg=0;
d917 162
a1078 131
static int dofilt(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int fr[2];
 int fw[2];
 if(notify) *notify=1; 
 if(markb && markk && !square &&
    markb->b==bw->b && markk->b==bw->b && markb->byte==markk->byte) goto ok;
 if(!markv(1))
  {
  msgnw(bw,"No block");
  return -1;
  }
 ok:
 
 pipe(fr);
 pipe(fw);
 npartial(bw->parent->t->t);
 ttclsn();
 if(!fork())
  {
  signrm();
  close(0);
  close(1);
  close(2);
  dup(fw[0]);
  dup(fr[1]);
  dup(fr[1]);
  close(fw[0]);
  close(fr[1]);
  close(fw[1]);
  close(fr[0]);
  execl("/bin/sh","/bin/sh","-c",s,NULL);
  _exit(0);
  }
 close(fr[1]);
 close(fw[0]);
 if(fork())
  {
  long szz;
  close(fw[1]);
  if(square)
   {
   B *tmp;
   long width=markk->xcol-markb->xcol;
   long height;
   int usetabs=ptabrect(markb,markk->line-markb->line+1,markk->xcol);
   tmp=bread(fr[0],MAXLONG);
   if(piscol(tmp->eof)) height=tmp->eof->line+1;
   else height=tmp->eof->line;
   if(bw->o.overtype)
    {
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,usetabs);
    pdelrect(markb,long_max(height,markk->line-markb->line+1),width+markb->xcol);
    }
   else pdelrect(markb,markk->line-markb->line+1,markk->xcol);
   pinsrect(markb,tmp,width,usetabs);
   pdupown(markb,&markk);
   markk->xcol=markb->xcol;
   if(height)
    {
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   if(lightoff) unmark(bw);
   brm(tmp);
   updall();
   }
  else
   {
   bdel(markb,markk);
   szz=markk->b->eof->byte;
   binsb(markk,bread(fr[0],MAXLONG));
   pfwrd(markk,markk->b->eof->byte-szz);
   if(lightoff) unmark(bw);
   }
  close(fr[0]);
  wait(0);
  wait(0);
  }
 else
  {
  if(square)
   {
   B *tmp=pextrect(markb,markk->line-markb->line+1,markk->xcol);
   bsavefd(tmp->bof,fw[1],tmp->eof->byte);
   }
  else bsavefd(markb,fw[1],markk->byte-markb->byte);
  close(fw[1]);
  _exit(0);
  }
 vsrm(s);
 ttopnn();
 if(filtflg) unmark(bw);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

static B *filthist=0;

void markall(bw)
BW *bw;
 {
 pdupown(bw->cursor->b->bof,&markb); markb->xcol=0;
 pdupown(bw->cursor->b->eof,&markk); markk->xcol=piscol(markk);
 updall();
 }

int checkmark(bw)
BW *bw;
 {
 if(!markv(1))
  if(square) return 2;
  else
   {
   markall(bw), filtflg=1;
   return 1;
   }
 else
  {
  filtflg=0;
  return 0;
  }
 }

int ufilt(bw)
BW *bw;
 {
d1080 2
a1081 2
 msgnw(bw,"Sorry, no sub-processes in DOS (yet)");
 return -1;
d1083 22
a1104 18
 switch(checkmark(bw))
  {
  case 0:
  if(wmkpw(bw,
           "Command to filter block through (^C to abort): ",
           &filthist,dofilt,NULL,NULL,utypebw,NULL,NULL)) return 0;
  else return -1;

  case 1:
  if(wmkpw(bw,
           "Command to filter file through (^C to abort): ",
           &filthist,dofilt,NULL,NULL,utypebw,NULL,NULL)) return 0;
  else return -1;

  case 2:
  msgnw(bw,"No block");
  return -1;
  }
d1106 1
a1106 1
 }
@


1.2
log
@changed as of joe-2.9.4
@
text
@d27 1
a27 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d705 1
a705 1
    pclrrect(markb,Lmax(markk->line-markb->line+1,height),markk->xcol,usetabs);
d794 1
a794 1
    pdelrect(markb,Lmax(height,markk->line-markb->line+1),width+markb->xcol);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
