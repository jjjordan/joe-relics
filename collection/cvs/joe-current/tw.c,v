head	1.57;
access;
symbols
	joe_3_5:1.49
	joe-3_4:1.44
	help:1.44
	joe_3_1:1.26
	joe_3_0:1.21
	joe_2_9_8:1.17
	joe_2_9_8_pre1:1.14
	joe_2_9_7:1.5
	joe_2_9_7_pre3:1.5
	joe_2_9_7_pre2:1.4
	joe_2_9_6:1.3
	joe_2_9_5:1.2
	joe_2_9_4:1.1.1.1
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.02.04.05.09;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.31.23.45.11;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.31.22.59.19;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.02.15.01.26;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.14.17.50.51;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.12.02.07.05;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.06.04.28.58;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.06.04.27.31;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.06.03.01.44;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.30.04.40.48;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.28.15.13.16;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.21.02.15.56;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.20.03.50.59;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.21.15.48.54;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.21.14.47.42;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.14.07.30.39;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.14.04.23.05;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.10.16.06.35;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.16.21.10.15;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.08.15.20.39;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.18.04.05.09;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.04.17.39.20;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.07.16.06;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.04.13.20.52;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.54.16;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.53.40;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.11;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.11;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/* 
 *	Text editing windows
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int staen = 0;
int staupd = 0;
int keepup = 0;
int bg_stalin;

/* Move text window */

static void movetw(BW *bw, int x, int y)
{
	TW *tw = (TW *) bw->object;

	if (y || !staen) {
		if (!tw->staon) {	/* Scroll down and shrink */
			nscrldn(bw->parent->t->t, y, bw->parent->nh + y, 1);
		}
		bwmove(bw, x + (bw->o.linums ? LINCOLS : 0), y + 1);
		tw->staon = 1;
	} else {
		if (tw->staon) {	/* Scroll up and grow */
			nscrlup(bw->parent->t->t, y, bw->parent->nh + y, 1);
		}
		bwmove(bw, x + (bw->o.linums ? LINCOLS : 0), y);
		tw->staon = 0;
	}
}

/* Resize text window */

static void resizetw(BW *bw, int wi, int he)
{
	if (bw->parent->ny || !staen)
		bwresz(bw, wi - (bw->o.linums ? LINCOLS : 0), he - 1);
	else
		bwresz(bw, wi - (bw->o.linums ? LINCOLS : 0), he);
}

/* Get current context */

/* Find first line (going backwards) which has 0 indentation level
 * and is not a comment, blank, or block structuring line.  This is
 * likely to be the line with the function name.
 *
 * There are actually two possibilities:
 *
 * We want the first line- 
 *
 * int
 * foo(int x,int y) {
 *
 *   }
 *
 * We want the last line-
 *
 * program foo(input,output);
 * var a, b, c : real;
 * begin
 *
 */

unsigned char *get_context(BW *bw)
{
	P *p = pdup(bw->cursor, USTR "get_context");
	unsigned char *buf = 0;
	unsigned char *buf1;
	int i, spc;


	buf1 = vsmk(128);
	/* Find first line with 0 indentation which is not a comment line */
	do {
		p_goto_bol(p);
		if (!pisindent(p) && !pisblank(p)) {
			/* next: */
			buf = brlinevs(buf, p);
			/* Ignore comment and block structuring lines */
			if (!(buf[0]=='{' ||
			    (buf[0]=='/' && buf[1]=='*') ||
			    buf[0]=='\f' ||
			    (buf[0]=='/' && buf[1]=='/') ||
			    buf[0]=='#' ||
			    (buf[0]=='b' && buf[1]=='e' && buf[2]=='g' && buf[3]=='i' && buf[4]=='n') ||
			    (buf[0]=='B' && buf[1]=='E' && buf[2]=='G' && buf[3]=='I' && buf[4]=='N') ||
			    (buf[0]=='-' && buf[1]=='-') ||
			    buf[0]==';')) {
 				/* replace tabs to spaces and remove adjoining spaces */
 				buf1 = vstrunc(buf1, 0);
 				for (i=0,spc=0; buf[i]; i++) {
 					if (buf[i]=='\t' || buf[i]==' ') {
 						if (spc) continue;
 						spc = 1;
 					}
 					else spc = 0;
 					if (buf[i]=='\t')
 						buf1 = vsadd(buf1, ' ');
					else if (buf[i]=='\\') {
						buf1 = vsadd(buf1, '\\');
						buf1 = vsadd(buf1, '\\');
					} else
						buf1 = vsadd(buf1, buf[i]);
 				}
				/* Uncomment to get the last line instead of the first line (see above)
			    	if (pprevl(p)) {
			    		p_goto_bol(p);
			    		if (!pisindent(p) && !pisblank(p))
			    			goto next;
			    	}
			    	*/
			    	break;
			}
			
		}
	} while (!buf1[0] && pprevl(p));

	prm(p);

	return buf1;
}

unsigned char *duplicate_backslashes(unsigned char *s, int len)
{
	unsigned char *m;
	int x, count;
	for (x = count = 0; x != len; ++x)
		if (s[x] == '\\')
			++count;
	m = vsmk(len + count);
	for (x = 0; x != len; ++x) {
		m = vsadd(m, s[x]);
		if (s[x] == '\\')
			m = vsadd(m, '\\');
	}
	return m;
}

/* static */unsigned char *stagen(unsigned char *stalin, BW *bw, unsigned char *s, int fill)
{
	unsigned char buf[80];
	int x;
	W *w = bw->parent;
	time_t n=time(NULL);
	struct tm *cas;
	cas=localtime(&n);

	stalin = vstrunc(stalin, 0);
	obj_perm(stalin);
	while (*s) {
		if (*s == '%' && s[1]) {
			switch (*++s) {
			case 'x': /* Context (but only if autoindent is enabled) */
				{
					if ( bw->o.autoindent) {
						unsigned char *s = get_context(bw);
						unsigned char *t = my_iconv(NULL,locale_map,s,bw->o.charmap);
						stalin = vscat(stalin, sv(t));
					}
				}
				break;

			case 'y':
				{
					if (bw->o.syntax) {
						joe_snprintf_1(buf, sizeof(buf), "(%s)", bw->o.syntax->name);
						stalin = vsncpy(sv(stalin), sz(buf));
					}
				}
				break;
			case 't':
				{
					time_t n = time(NULL);
					int l;
					unsigned char *d = (unsigned char *)ctime(&n);

					l = (d[11] - '0') * 10 + d[12] - '0';
					if (l > 12)
						l -= 12;
					joe_snprintf_1(buf, sizeof(buf), "%2.2d", l);
					if (buf[0] == '0')
						buf[0] = fill;
					stalin = vsncpy(sv(stalin), buf, 2);
					stalin = vsncpy(sv(stalin), d + 13, 3);
				}
				break;
			    case 'd':
				{
				if (s[1]) switch (*++s) {
					case 'd' : joe_snprintf_1(buf,sizeof(buf),"%02d",cas->tm_mday); break;
					case 'm' : joe_snprintf_1(buf,sizeof(buf),"%02d",cas->tm_mon + 1); break;
					case 'y' : joe_snprintf_1(buf,sizeof(buf),"%02d",cas->tm_year % 100); break;
					case 'Y' : joe_snprintf_1(buf,sizeof(buf),"%04d",cas->tm_year + 1900); break;
					case 'w' : joe_snprintf_1(buf,sizeof(buf),"%d",cas->tm_wday); break;
					case 'D' : joe_snprintf_1(buf,sizeof(buf),"%03d",cas->tm_yday); break;
					default : buf[0]='d'; buf[1]=*s; buf[2]=0;
					}
				else { buf[0]='d'; buf[1]=0;}
				stalin=vsncpy(sv(stalin),sz(buf));
				}
				break;

				case 'E':
				{
				int l;
				unsigned char *ch;
				buf[0]=0;
				for(l=0;s[l+1] && s[l+1] != '%'; l++) buf[l]=s[l+1];
				if (s[l+1]=='%' && buf[0]) {
					buf[l]=0;
					s+=l+1;
					ch=(unsigned char *)getenv((char *)buf);
					if (ch) stalin=vsncpy(sv(stalin),sz(ch));
					} 
				}
				break;

			case 'Z':
				{
					int l;
					unsigned char *ch;
					buf[0]=0;
					for(l=0;s[l+1] && s[l+1] != '%'; l++) buf[l]=s[l+1];
					if (s[l+1]=='%' && buf[0]) {
						buf[l]=0;
						s+=l+1;
						ch=get_status(bw, buf);
						if (ch) stalin=vsncpy(sv(stalin),sz(ch));
					} 
				}
				break;

			case 'u':
				{
					time_t n = time(NULL);
					unsigned char *d = (unsigned char *)ctime(&n);

					stalin = vsncpy(sv(stalin), d + 11, 5);
				}
				break;
			case 'T':
				if (bw->o.overtype)
					stalin = vsadd(stalin, 'O');
				else
					stalin = vsadd(stalin, 'I');
				break;
			case 'W':
				if (bw->o.wordwrap)
					stalin = vsadd(stalin, 'W');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'I':
				if (bw->o.autoindent)
					stalin = vsadd(stalin, 'A');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'X':
				if (square)
					stalin = vsadd(stalin, 'X');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'n':
				{
				if (bw->b->name) {
					unsigned char *tmp = simplify_prefix(bw->b->name);
					unsigned char *tmp1 = duplicate_backslashes(sv(tmp));
					stalin = vsncpy(sv(stalin), sv(tmp1));
				} else {
					stalin = vsncpy(sv(stalin), sz(joe_gettext(_("Unnamed"))));
				}
				}
				break;
			case 'm':
				if (bw->b->changed)
					stalin = vsncpy(sv(stalin), sz(joe_gettext(_("(Modified)"))));
				break;
			case 'R':
				if (bw->b->rdonly)
					stalin = vsncpy(sv(stalin), sz(joe_gettext(_("(Read only)"))));
				break;
			case '*':
				if (bw->b->changed)
					stalin = vsadd(stalin, '*');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'r':
				joe_snprintf_1(buf, sizeof(buf), "%-4ld", bw->cursor->line + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'o':
				joe_snprintf_1(buf, sizeof(buf), "%-4lld", bw->cursor->byte);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'O':
				joe_snprintf_1(buf, sizeof(buf), "%-4llX", bw->cursor->byte);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'a':
				if (!piseof(bw->cursor))
					joe_snprintf_1(buf, sizeof(buf), "%3d", brch(bw->cursor));
				else
					joe_snprintf_0(buf, sizeof(buf), "   ");
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'A':
				if (!piseof(bw->cursor))
					joe_snprintf_1(buf, sizeof(buf), "%2.2X", brch(bw->cursor));
				else
					joe_snprintf_0(buf, sizeof(buf), "  ");
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'c':
				joe_snprintf_1(buf, sizeof(buf), "%-3ld", piscol(bw->cursor) + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'p':
				if (bw->b->eof->byte >= 1024*1024)
					joe_snprintf_1(buf, sizeof(buf), "%3lld", (bw->cursor->byte >> 10) * 100 / (bw->b->eof->byte >> 10));
				else if (bw->b->eof->byte)
					joe_snprintf_1(buf, sizeof(buf), "%3lld", bw->cursor->byte * 100 / bw->b->eof->byte);
				else
					joe_snprintf_0(buf, sizeof(buf), "100");
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'l':
				joe_snprintf_1(buf, sizeof(buf), "%-4ld", bw->b->eof->line + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'k':
				{
					int i;
					unsigned char *cpos = buf;

					buf[0] = 0;
					if (w->kbd->x && w->kbd->seq[0])
						for (i = 0; i != w->kbd->x; ++i) {
							int c = w->kbd->seq[i] & 127;

							if (c < 32) {
								cpos[0] = '^';
								cpos[1] = c + '@@';
								cpos += 2;
							} else if (c == 127) {
								cpos[0] = '^';
								cpos[1] = '?';
								cpos += 2;
							} else {
								cpos[0] = c;
								cpos += 1;
							}
						}
					*cpos++ = fill;
					while (cpos - buf < 4)
						*cpos++ = fill;
					stalin = vsncpy(sv(stalin), buf, cpos - buf);
				}
				break;
			case 'S':
				if (bw->b->pid)
					stalin = vsncpy(sv(stalin), sz(joe_gettext(_("*SHELL*"))));
				break;
			case 'M':
				if (recmac) {
					joe_snprintf_1(buf, sizeof(buf), joe_gettext(_("(Macro %d recording...)")), recmac->n);
					stalin = vsncpy(sv(stalin), sz(buf));
				}
				break;
			default:
				stalin = vsadd(stalin, *s);
			}
		} else
			stalin = vsadd(stalin, *s);
		++s;
	}
	return stalin;
}

static void disptw(BW *bw, int flg)
{
	W *w = bw->parent;
	TW *tw = (TW *) bw->object;

	if (bw->o.linums != bw->linums) {
		bw->linums = bw->o.linums;
		resizetw(bw, w->w, w->h);
		movetw(bw, w->x, w->y);
		bwfllw(bw);
	}

	if (bw->o.hex) {
		w->cury = (bw->cursor->byte-bw->top->byte)/16 + bw->y - w->y;
		w->curx = (bw->cursor->byte-bw->top->byte)%16 + 60 - bw->offset;
	} else {
		w->cury = bw->cursor->line - bw->top->line + bw->y - w->y;
		w->curx = bw->cursor->xcol - bw->offset + (bw->o.linums ? LINCOLS : 0);
	}

	if ((staupd || keepup || bw->cursor->line != tw->prevline || bw->b->changed != tw->changed || bw->b != tw->prev_b) && (w->y || !staen)) {
		int fill;

		tw->prevline = bw->cursor->line;
		tw->changed = bw->b->changed;
		tw->prev_b = bw->b;
		if (bw->o.rmsg[0])
			fill = bw->o.rmsg[0];
		else
			fill = ' ';
		tw->stalin = stagen(tw->stalin, bw, bw->o.lmsg, fill);
		tw->staright = stagen(tw->staright, bw, bw->o.rmsg, fill);
		if (fmtlen(tw->staright) < w->w) {
			int x = fmtpos(tw->stalin, w->w - fmtlen(tw->staright));

			if (x > vslen(tw->stalin))
				tw->stalin = vsfill(sv(tw->stalin), fill, x - vslen(tw->stalin));
			tw->stalin = vsncpy(tw->stalin, fmtpos(tw->stalin, w->w - fmtlen(tw->staright)), sv(tw->staright));
		}
		tw->stalin = vstrunc(tw->stalin, fmtpos(tw->stalin, w->w));
		genfmt(w->t->t, w->x, w->y, 0, tw->stalin, bg_stalin, 0);
		w->t->t->updtab[w->y] = 0;
	}

	if (flg) {
		if (bw->o.hex)
			bwgenh(bw);
		else
			bwgen(bw, bw->o.linums);
	}
}

/* Split current window */

static void iztw(TW *tw, int y)
{
	tw->stalin = NULL;
	tw->staright = NULL;
	tw->changed = -1;
	tw->prevline = -1;
	tw->staon = (!staen || y);
	tw->prev_b = 0;
}

int usplitw(BW *bw)
{
	W *w = bw->parent;
	int newh = getgrouph(w);
	W *new;
	TW *newtw;
	BW *newbw;

	dostaupd = 1;
	if (newh / 2 < FITHEIGHT)
		return -1;
	new = wcreate(w->t, w->watom, findbotw(w), NULL, w, newh / 2 + (newh & 1), NULL);
	if (!new)
		return -1;
	wfit(new->t);
	new->object = (void *) (newbw = bwmk(new, bw->b, 0, NULL));
	++bw->b->count;
	newbw->offset = bw->offset;
	newbw->object = (void *) (newtw = (TW *) joe_malloc(sizeof(TW)));
	iztw(newtw, new->y);
	pset(newbw->top, bw->top);
	pset(newbw->cursor, bw->cursor);
	newbw->cursor->xcol = bw->cursor->xcol;
	new->t->curwin = new;
	return 0;
}

int uduptw(BW *bw)
{
	W *w = bw->parent;
	int newh = getgrouph(w);
	W *new;
	TW *newtw;
	BW *newbw;

	dostaupd = 1;
	new = wcreate(w->t, w->watom, findbotw(w), NULL, NULL, newh, NULL);
	if (!new)
		return -1;
	if (demotegroup(w))
		new->t->topwin = new;
	new->object = (void *) (newbw = bwmk(new, bw->b, 0, NULL));
	++bw->b->count;
	newbw->offset = bw->offset;
	newbw->object = (void *) (newtw = (TW *) joe_malloc(sizeof(TW)));
	iztw(newtw, new->y);
	pset(newbw->top, bw->top);
	pset(newbw->cursor, bw->cursor);
	newbw->cursor->xcol = bw->cursor->xcol;
	new->t->curwin = new;
	wfit(w->t);
	return 0;
}

static void instw(BW *bw, B *b, long int l, long int n, int flg)
{
	if (b == bw->b)
		bwins(bw, l, n, flg);
}

static void deltw(BW *bw, B *b, long int l, long int n, int flg)
{
	if (b == bw->b)
		bwdel(bw, l, n, flg);
}

WATOM watomtw = {
	USTR "main",
	disptw,
	bwfllw,
	NULL,
	rtntw,
	utypebw,
	resizetw,
	movetw,
	instw,
	deltw,
	TYPETW
};

int abortit(BW *bw)
{
	W *w;
	TW *tw;
	B *b;
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	w = bw->parent;
	tw = (TW *) bw->object;
	/* If only one main window on the screen... */
	if (countmain(w->t) == 1)
		/* Replace it with an orphaned buffer if there are any */
		if ((b = borphan()) != NULL) {
			void *object = bw->object;
			/* FIXME: Shouldn't we wabort() and wcreate here to kill
			   any prompt windows? */

			bwrm(bw);
			w->object = (void *) (bw = bwmk(w, b, 0, NULL));
			wredraw(bw->parent);
			bw->object = object;
			return 0;
		}
	bwrm(bw);
	obj_free(tw->stalin);
	joe_free(tw);
	w->object = NULL;
	wabort(w);	/* Eliminate this window and it's children */
	return 0;
}

/* k is last character types which lead to uabort.  If k is -1, it means uabort
   was called internally, and not by the user: which means uabort will not send
   Ctrl-C to process */
int uabort(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch) {
		int c = query(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), 0);
		if (!yncheck(yes_key, c))
			return -1;
	}
	genexmsg(bw, 0, NULL);
	return abortit(bw);
}

int ucancel(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw) {
		wabort(bw->parent);
		return 0;
	} else
		return uabort(bw,k);
}

/* Same as above, but only calls genexmsg if nobody else has */

int uabort1(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch) {
		int c = query(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), 0);
		if (!yncheck(yes_key, c))
			return -1;
	}
	if (!exmsg) genexmsg(bw, 0, NULL);
	return abortit(bw);
}

/* Abort buffer without prompting: just fail if this is last window on buffer */

int uabortbuf(BW *bw)
{
	W *w = bw->parent;
	B *b;

	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);

	if (okrepl(bw))
		return -1;

	if ((b = borphan()) != NULL) {
		void *object = bw->object;

		bwrm(bw);
		w->object = (void *) (bw = bwmk(w, b, 0, NULL));
		wredraw(bw->parent);
		bw->object = object;
		return 0;
	}

	genexmsg(bw, 0, NULL);
	return abortit(bw);
}

/* Kill current window (orphans buffer) */

int utw0(BASE *b)
{
	BW *bw = b->parent->main->object;

	if (countmain(b->parent->t) == 1)
		return -1;
	if (bw->b->count == 1)
		orphit(bw);
	return uabort(bw, -1);
}

/* Kill all other windows (orphans buffers) */

int utw1(BASE *b)
{
	W *starting = b->parent;
	W *mainw = starting->main;
	Screen *t = mainw->t;
	int yn;

	do {
		yn = 0;
	      loop:
		do {
			wnext(t);
		} while (t->curwin->main == mainw && t->curwin != starting);
		if (t->curwin->main != mainw) {
			BW *bw = t->curwin->main->object;
			utw0((BASE *)bw);
			yn = 1;
			goto loop;
		}
	} while (yn);
	return 0;
}

void setline(B *b, long int line)
{
	W *w = maint->curwin;

	do {
		if (w->watom->what == TYPETW) {
			BW *bw = w->object;

			if (bw->b == b) {
				long oline = bw->top->line;

				/* pline(bw->top, line); */
				pline(bw->cursor, line);
				if (w->y >= 0 && bw->top->line > oline && bw->top->line - oline < bw->h)
					nscrlup(w->t->t, bw->y, bw->y + bw->h, (int) (bw->top->line - oline));
				else if (w->y >= 0 && bw->top->line < oline && oline - bw->top->line < bw->h)
					nscrldn(w->t->t, bw->y, bw->y + bw->h, (int) (oline - bw->top->line));
				msetI(bw->t->t->updtab + bw->y, 1, bw->h);
			}
		}
	} while ((w = w->link.next) != maint->curwin);
	/* In case error buffer was orphaned */
	if (errbuf == b && b->oldcur) {
		pline(b->oldcur, line);
	}
}

/* Create a text window.  It becomes the last window on the screen */

BW *wmktw(Screen *t, B *b)
{
	W *w;
	BW *bw;
	TW *tw;

	w = wcreate(t, &watomtw, NULL, NULL, NULL, t->h, NULL);
	wfit(w->t);
	w->object = (void *) (bw = bwmk(w, b, 0, NULL));
	bw->object = (void *) (tw = (TW *) joe_malloc(sizeof(TW)));
	iztw(tw, w->y);
	return bw;
}
@


1.56
log
@Coroutine version of menus with macros
@
text
@a193 1
				int l;
d195 6
a200 6
					case 'd' : sprintf(buf,"%02d",cas->tm_mday); break;
					case 'm' : sprintf(buf,"%02d",cas->tm_mon + 1); break;
					case 'y' : sprintf(buf,"%02d",cas->tm_year % 100); break;
					case 'Y' : sprintf(buf,"%04d",cas->tm_year + 1900); break;
					case 'w' : sprintf(buf,"%d",cas->tm_wday); break;
					case 'D' : sprintf(buf,"%03d",cas->tm_yday); break;
d211 1
a211 1
				char *ch;
d217 1
a217 1
					ch=getenv(buf);
d226 1
a226 1
					char *ch;
@


1.55
log
@Allow backslashes in filenames
@
text
@d224 15
@


1.54
log
@Fix %A
Add ^@@ to rjoe
@
text
@d128 16
d260 2
a261 1
					stalin = vsncpy(sv(stalin), sv(tmp));
@


1.53
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d287 1
a287 1
					joe_snprintf_1(buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
d297 1
a297 1
					joe_snprintf_1(buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
@


1.52
log
@More work on coroutine refactoring.
@
text
@d128 1
a128 1
static unsigned char *stagen(unsigned char *stalin, BW *bw, unsigned char *s, int fill)
d133 3
d176 32
@


1.51
log
@more work on coroutine refactor
prompt window experiment
@
text
@d420 1
a420 1
	new = wcreate(w->t, w->watom, findbotw(w), NULL, w, newh / 2 + (newh & 1), NULL, NULL);
d445 1
a445 1
	new = wcreate(w->t, w->watom, findbotw(w), NULL, NULL, newh, NULL, NULL);
d666 1
a666 1
	w = wcreate(t, &watomtw, NULL, NULL, NULL, t->h, NULL, NULL);
@


1.50
log
@semiautomatic variables
@
text
@d424 1
a424 1
	new->object = (void *) (newbw = bwmk(new, bw->b, 0));
d450 1
a450 1
	new->object = (void *) (newbw = bwmk(new, bw->b, 0));
d509 1
a509 1
			w->object = (void *) (bw = bwmk(w, b, 0));
a521 24
/* User routine for aborting a text window */

static int naborttw(BW *bw, int k, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (k != YES_CODE && !yncheck(yes_key, k))
		return -1;

	genexmsg(bw, 0, NULL);
	return abortit(bw);
}

static int naborttw1(BW *bw, int k, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (k != YES_CODE && !yncheck(yes_key, k))
		return -1;

	if (!exmsg) genexmsg(bw, 0, NULL);
	return abortit(bw);
}

d531 3
a533 4
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch)
		if (mkqw(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), naborttw, NULL, NULL, NULL))
			return 0;
		else
d535 3
a537 2
	else
		return naborttw(bw, YES_CODE, NULL, NULL);
d557 3
a559 4
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch)
		if (mkqw(bw->parent, sz(joe_gettext(_("Lose changes to this file (y,n,^C)? "))), naborttw1, NULL, NULL, NULL))
			return 0;
		else
d561 3
a563 2
	else
		return naborttw1(bw, YES_CODE, NULL, NULL);
d583 1
a583 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d589 2
a590 1
	return naborttw(bw, YES_CODE, NULL, NULL);
d668 1
a668 1
	w->object = (void *) (bw = bwmk(w, b, 0));
@


1.49
log
@UC -> USTR
@
text
@d72 3
a74 2
	static unsigned char buf1[stdsiz];
	int i, j, spc;
d77 1
a77 1
	buf1[0] = 0;
d83 1
a83 1
			brzs(p,stdbuf,stdsiz/8); /* To avoid buffer overruns with my_iconv */
d85 9
a93 10
			if (!(stdbuf[0]=='{' ||
			    (stdbuf[0]=='/' && stdbuf[1]=='*') ||
			    stdbuf[0]=='\f' ||
			    (stdbuf[0]=='/' && stdbuf[1]=='/') ||
			    stdbuf[0]=='#' ||
			    (stdbuf[0]=='b' && stdbuf[1]=='e' && stdbuf[2]=='g' && stdbuf[3]=='i' && stdbuf[4]=='n') ||
			    (stdbuf[0]=='B' && stdbuf[1]=='E' && stdbuf[2]=='G' && stdbuf[3]=='I' && stdbuf[4]=='N') ||
			    (stdbuf[0]=='-' && stdbuf[1]=='-') ||
			    stdbuf[0]==';')) {
			    	/* zcpy(buf1,stdbuf); */
d95 3
a97 2
 				for (i=0,j=0,spc=0; stdbuf[i]; i++) {
 					if (stdbuf[i]=='\t' || stdbuf[i]==' ') {
d102 5
a106 5
 					if (stdbuf[i]=='\t')
 						buf1[j++] = ' ';
					else if (stdbuf[i]=='\\') {
						buf1[j++] = '\\';
						buf1[j++] = '\\';
d108 1
a108 1
						buf1[j++] = stdbuf[i];
a109 1
 				buf1[j]= '\0';
d135 1
d143 2
a144 4
						/* We need to translate between file's character set to
						   locale */
						my_iconv(stdbuf,locale_map,s,bw->o.charmap);
						stalin = vsncpy(sv(stalin), sz(stdbuf));
a209 1
					vsrm(tmp);
d380 2
a381 2
			if (x > sLEN(tw->stalin))
				tw->stalin = vsfill(sv(tw->stalin), fill, x - sLEN(tw->stalin));
d515 1
a515 1
	vsrm(tw->stalin);
@


1.48
log
@change US to UC
@
text
@d71 1
a71 1
	P *p = pdup(bw->cursor, UC "get_context");
d478 1
a478 1
	UC "main",
@


1.47
log
@large file patch, makefile fix, tty.c fix.
@
text
@d71 1
a71 1
	P *p = pdup(bw->cursor, US "get_context");
d478 1
a478 1
	US "main",
@


1.46
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d239 1
a239 1
				joe_snprintf_1(buf, sizeof(buf), "%-4ld", bw->cursor->byte);
d246 1
a246 1
				joe_snprintf_1(buf, sizeof(buf), "%-4lX", bw->cursor->byte);
d281 1
a281 1
					joe_snprintf_1(buf, sizeof(buf), "%3ld", ((unsigned long)bw->cursor->byte >> 10) * 100 / ((unsigned long)bw->b->eof->byte >> 10));
d283 1
a283 1
					joe_snprintf_1(buf, sizeof(buf), "%3ld", bw->cursor->byte * 100 / bw->b->eof->byte);
@


1.45
log
@i18n yes/no
@
text
@d530 1
a530 1
	if (k != YES_CODE && !yncheck(yes_string, k))
d541 1
a541 1
	if (k != YES_CODE && !yncheck(yes_string, k))
@


1.44
log
@gettext()
@
text
@d530 1
a530 1
	if (k != 'y' && k != 'Y')
d541 1
a541 1
	if (k != 'y' && k != 'Y')
d563 1
a563 1
		return naborttw(bw, 'y', NULL, NULL);
d589 1
a589 1
		return naborttw1(bw, 'y', NULL, NULL);
d615 1
a615 1
	return naborttw(bw, 'y', NULL, NULL);
@


1.43
log
@A option for search
Restore cursor to old position
@
text
@d153 1
a153 1
						joe_snprintf_1((char *)buf, sizeof(buf), "(%s)", bw->o.syntax->name);
d167 1
a167 1
					joe_snprintf_1((char *)buf, sizeof(buf), "%2.2d", l);
d213 1
a213 1
					stalin = vsncpy(sv(stalin), sc("Unnamed"));
d219 1
a219 1
					stalin = vsncpy(sv(stalin), sc("(Modified)"));
d223 1
a223 1
					stalin = vsncpy(sv(stalin), sc("(Read only)"));
d232 1
a232 1
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->cursor->line + 1);
d239 1
a239 1
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->cursor->byte);
d246 1
a246 1
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4lX", bw->cursor->byte);
d254 1
a254 1
					joe_snprintf_1((char *)buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
d256 1
a256 1
					joe_snprintf_0((char *)buf, sizeof(buf), "   ");
d264 1
a264 1
					joe_snprintf_1((char *)buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
d266 1
a266 1
					joe_snprintf_0((char *)buf, sizeof(buf), "  ");
d273 1
a273 1
				joe_snprintf_1((char *)buf, sizeof(buf), "%-3ld", piscol(bw->cursor) + 1);
d281 1
a281 1
					joe_snprintf_1((char *)buf, sizeof(buf), "%3ld", ((unsigned long)bw->cursor->byte >> 10) * 100 / ((unsigned long)bw->b->eof->byte >> 10));
d283 1
a283 1
					joe_snprintf_1((char *)buf, sizeof(buf), "%3ld", bw->cursor->byte * 100 / bw->b->eof->byte);
d285 1
a285 1
					joe_snprintf_0((char *)buf, sizeof(buf), "100");
d292 1
a292 1
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->b->eof->line + 1);
d329 1
a329 1
					stalin = vsncpy(sv(stalin), sc("*SHELL*"));
d333 1
a333 1
					joe_snprintf_1((char *)buf, sizeof(buf), "(Macro %d recording...)", recmac->n);
d558 1
a558 1
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), naborttw, NULL, NULL, NULL))
d584 1
a584 1
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), naborttw1, NULL, NULL, NULL))
@


1.42
log
@Change SCREEN to Screen
@
text
@d477 1
a477 1
static WATOM watomtw = {
d673 1
d677 4
@


1.41
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d637 1
a637 1
	SCREEN *t = mainw->t;
d680 1
a680 1
BW *wmktw(SCREEN *t, B *b)
@


1.40
log
@new cvs server
@
text
@a7 1
#include "config.h"
a9 24
#include <stdio.h>
#ifdef HAVE_TIME_H
#include <time.h>
#endif

#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "qw.h"
#include "scrn.h"
#include "uedit.h"
#include "ufile.h"
#include "ushell.h"
#include "utils.h"
#include "vs.h"
#include "syntax.h"
#include "path.h"
#include "w.h"
#include "utf8.h"

extern int bg_text;
extern unsigned char *exmsg;
extern int square;
d81 1
a81 1
			next:
d85 1
a85 1
			    stdbuf[0]=='/' && stdbuf[1]=='*' ||
d87 1
a87 1
			    stdbuf[0]=='/' && stdbuf[1]=='/' ||
d89 3
a91 3
			    stdbuf[0]=='b' && stdbuf[1]=='e' && stdbuf[2]=='g' && stdbuf[3]=='i' && stdbuf[4]=='n' ||
			    stdbuf[0]=='B' && stdbuf[1]=='E' && stdbuf[2]=='G' && stdbuf[3]=='I' && stdbuf[4]=='N' ||
			    stdbuf[0]=='-' && stdbuf[1]=='-' ||
a346 2
extern int hex;

d391 1
a391 1
	if (flg)
d396 1
a410 2
extern int dostaupd;

@


1.39
log
@add joe_debug
@
text
@d30 1
d107 1
a107 1
			brzs(p,stdbuf,stdsiz-1);
d167 4
a170 1
						stalin = vsncpy(sv(stalin), sz(s));
d695 1
a695 1
				pline(bw->top, line);
@


1.38
log
@%p asgain
@
text
@d95 1
a95 1
	P *p = pdup(bw->cursor);
@


1.37
log
@Allow setting foreground and background colors.  Added new status line color.
@
text
@d301 2
a302 2
				if (bw->b->eof->byte >= 65536)
					joe_snprintf_1((char *)buf, sizeof(buf), "%3ld", ((unsigned long)bw->cursor->byte >> 16) * 100 / ((unsigned long)bw->b->eof->byte >> 16));
@


1.36
log
@fix %p range problem.  remove debug messages.
@
text
@d37 1
d410 1
a410 1
		genfmt(w->t->t, w->x, w->y, 0, tw->stalin, BG_COLOR(bg_text), 0);
@


1.35
log
@fix gcc-4.0.0 warnings
@
text
@d300 3
a302 1
				if (bw->b->eof->byte)
@


1.34
log
@fix mouse & hex bugs
@
text
@d116 1
a116 1
			    	/* strcpy((char *)buf1,(char *)stdbuf); */
@


1.33
log
@Background color for screen item
@
text
@d412 4
a415 1
		bwgen(bw, bw->o.linums);
@


1.32
log
@Add wheel mouse support
@
text
@d31 1
d407 1
a407 1
		genfmt(w->t->t, w->x, w->y, 0, tw->stalin, 0);
@


1.31
log
@hex edit mode
@
text
@d380 1
a380 1
		w->curx = (bw->cursor->byte-bw->top->byte)%16 + 59;
@


1.30
log
@Get current directory from files on command line
@
text
@d364 2
d378 7
a384 2
	w->cury = bw->cursor->line - bw->top->line + bw->y - w->y;
	w->curx = bw->cursor->xcol - bw->offset + (bw->o.linums ? LINCOLS : 0);
@


1.29
log
@fix locks bug, jmacs improvements
@
text
@d28 1
d226 9
a234 1
				stalin = vsncpy(sv(stalin), sz(bw->b->name ? bw->b->name : (unsigned char *)"Unnamed"));
@


1.28
log
@Added tex and css highlighters.
Display tabs as a single space on status line.
Update perl, php and c highlighters (php has too many colors, perl needs '-'
for POD to work).
@
text
@d122 7
a128 1
 					buf1[j++] = (stdbuf[i]=='\t')? ' ' : stdbuf[i];
@


1.27
log
@Fix -pedantic warnings.
@
text
@d94 1
d114 11
a124 1
			    	strcpy((char *)buf1,(char *)stdbuf);
@


1.26
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d113 1
a113 1
			    	strcpy(buf1,stdbuf);
@


1.25
log
@Many jpicorc.in improvements.
@
text
@d154 1
a154 1
						snprintf((char *)buf, sizeof(buf), "(%s)", bw->o.syntax->name);
d168 1
a168 1
					snprintf((char *)buf, sizeof(buf), "%2.2d", l);
d225 1
a225 1
				snprintf((char *)buf, sizeof(buf), "%-4ld", bw->cursor->line + 1);
d232 1
a232 1
				snprintf((char *)buf, sizeof(buf), "%-4ld", bw->cursor->byte);
d239 1
a239 1
				snprintf((char *)buf, sizeof(buf), "%-4lX", bw->cursor->byte);
d247 1
a247 1
					snprintf((char *)buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
d249 1
a249 1
					snprintf((char *)buf, sizeof(buf), "   ");
d257 1
a257 1
					snprintf((char *)buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
d259 1
a259 1
					snprintf((char *)buf, sizeof(buf), "  ");
d266 1
a266 1
				snprintf((char *)buf, sizeof(buf), "%-3ld", piscol(bw->cursor) + 1);
d274 1
a274 1
					snprintf((char *)buf, sizeof(buf), "%3ld", bw->cursor->byte * 100 / bw->b->eof->byte);
d276 1
a276 1
					snprintf((char *)buf, sizeof(buf), "100");
d283 1
a283 1
				snprintf((char *)buf, sizeof(buf), "%-4ld", bw->b->eof->line + 1);
d324 1
a324 1
					snprintf((char *)buf, sizeof(buf), "(Macro %d recording...)", recmac->n);
@


1.24
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d550 9
@


1.23
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d319 1
a319 1
				if (bw->pid)
d353 1
a353 1
	if ((staupd || keepup || bw->cursor->line != tw->prevline || bw->b->changed != tw->changed) && (w->y || !staen)) {
d358 1
d390 1
d449 5
a453 1
/* User routine for aborting a text window */
d455 1
a455 1
static int naborttw(BW *bw, int k, void *object, int *notify)
d457 3
a459 3
	W *w = bw->parent;
	B *b;
	TW *tw = (TW *) bw->object;
d461 13
a473 6
	if (notify)
		*notify = 1;
	if (k != 'y' && k != 'Y')
		return -1;

	genexmsg(bw, 0, NULL);
d475 12
d488 1
d491 2
d504 1
a504 1
	wabort(w);		/* Eliminate this window and it's children */
d508 3
a510 1
static void instw(BW *bw, B *b, long int l, long int n, int flg)
d512 7
a518 2
	if (b == bw->b)
		bwins(bw, l, n, flg);
d521 1
a521 1
static void deltw(BW *bw, B *b, long int l, long int n, int flg)
d523 7
a529 2
	if (b == bw->b)
		bwdel(bw, l, n, flg);
a531 14
static WATOM watomtw = {
	US "main",
	disptw,
	bwfllw,
	NULL,
	rtntw,
	utypebw,
	resizetw,
	movetw,
	instw,
	deltw,
	TYPETW
};

d539 1
a539 6
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte && k != -1) {
		unsigned char c = 3;
		joe_write(bw->out, &c, 1); /* Send Ctrl-C to process */
		return 0;
	}
	if (bw->pid)
d550 18
a567 1
/* Abort buffer */
d574 1
a574 1
	if (bw->pid)
a600 3
	if (bw->pid) {
		return ukillpid(bw);
	}
a622 4
			if (bw->pid) {
				msgnw(bw->parent, US "Process running in this window");
				return -1;
			}
@


1.22
log
@New status line escape sequence: %x shows current context (function
cursor is in).

More globs in *rc.in files.

csh.jsf lisp.jsf
@
text
@d520 1
a520 1
	if (bw->b->changed && bw->b->count == 1)
@


1.21
log
@Fixed bug where '-syntax' on command line had
no effect.

Now if terminal is UTF-8, the default file type
is assumed to be UTF-8.
@
text
@d67 65
d142 9
@


1.20
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d27 1
d80 1
a80 1
						snprintf((char *)buf, sizeof(buf), "(%s)", bw->o.syntax);
@


1.19
log
@Fix screen update bug introduced with Apr 7th change.

Option settings now can be based on file contents as well as
file name.

Added syntax indicator for status line.
@
text
@d29 1
a29 1
extern char *exmsg;
d66 1
a66 1
static char *stagen(char *stalin, BW *bw, char *s, int fill)
d68 1
a68 1
	char buf[80];
d79 1
a79 1
						snprintf(buf, sizeof(buf), "(%s)", bw->o.syntax);
d88 1
a88 1
					char *d = ctime(&n);
d93 1
a93 1
					snprintf(buf, sizeof(buf), "%2.2d", l);
d103 1
a103 1
					char *d = ctime(&n);
d133 1
a133 1
				stalin = vsncpy(sv(stalin), sz(bw->b->name ? bw->b->name : "Unnamed"));
d150 1
a150 1
				snprintf(buf, sizeof(buf), "%-4ld", bw->cursor->line + 1);
d157 1
a157 1
				snprintf(buf, sizeof(buf), "%-4ld", bw->cursor->byte);
d164 1
a164 1
				snprintf(buf, sizeof(buf), "%-4lX", bw->cursor->byte);
d172 1
a172 1
					snprintf(buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
d174 1
a174 1
					snprintf(buf, sizeof(buf), "   ");
d182 1
a182 1
					snprintf(buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
d184 1
a184 1
					snprintf(buf, sizeof(buf), "  ");
d191 1
a191 1
				snprintf(buf, sizeof(buf), "%-3ld", piscol(bw->cursor) + 1);
d199 1
a199 1
					snprintf(buf, sizeof(buf), "%3ld", bw->cursor->byte * 100 / bw->b->eof->byte);
d201 1
a201 1
					snprintf(buf, sizeof(buf), "100");
d208 1
a208 1
				snprintf(buf, sizeof(buf), "%-4ld", bw->b->eof->line + 1);
d217 1
a217 1
					char *cpos = buf;
d249 1
a249 1
					snprintf(buf, sizeof(buf), "(Macro %d recording...)", recmac->n);
d418 1
a418 1
	"main",
d431 3
d438 2
a439 2
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte && k != MAXINT) {
		char c = 3;
d493 1
a493 1
	return uabort(bw, MAXINT);
d514 1
a514 1
				msgnw(bw->parent, "Process running in this window");
@


1.18
log
@Fixed ^C and ^D in shell windows.
This will require more work: basically if setsid() doesn't
exist, setpgrp(0,0) should be used instead.  I think the latter
is only for BSD.
@
text
@d76 8
@


1.17
log
@change 0 to NULL where we're talking about pointers
@
text
@d428 2
a429 3
		char c = k;

		joe_write(bw->out, &c, 1);
@


1.16
log
@change type of variables holding time values to time_t
@
text
@d301 2
a302 2
	tw->stalin = 0;
	tw->staright = 0;
d392 1
a392 1
	w->object = 0;
d413 1
a413 1
	0,
@


1.15
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@a28 1
char *ctime(const time_t *);
d78 1
a78 1
					long n = time(NULL);
d94 1
a94 1
					long n = time(NULL);
@


1.14
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d217 12
a228 8
							if (c < 32)
								cpos[0] = '^', cpos[1]
								    = c + '@@', cpos += 2;
							else if (c == 127)
								cpos[0] = '^', cpos[1]
								    = '?', cpos += 2;
							else
								cpos[0] = c, cpos += 1;
d283 1
a283 2
			int x = fmtpos(tw->stalin,
				       w->w - fmtlen(tw->staright));
d508 2
a509 1
			utw0((BASE *)bw), yn = 1;
@


1.13
log
@move jread() / jwrite() into utils.c
@
text
@a14 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d326 1
a326 1
	newbw->object = (void *) (newtw = (TW *) malloc(sizeof(TW)));
d352 1
a352 1
	newbw->object = (void *) (newtw = (TW *) malloc(sizeof(TW)));
d389 1
a389 1
	free(tw);
d545 1
a545 1
	bw->object = (void *) (tw = (TW *) malloc(sizeof(TW)));
@


1.12
log
@change indentation of cases in the switch() statement
@
text
@d28 1
d431 1
a431 1
		jwrite(bw->out, &c, 1);
@


1.11
log
@change indentation of do {} while() cycles
@
text
@d77 1
a77 1
		if (*s == '%' && s[1])
d79 1
a79 1
				case 't':
d95 1
a95 2

				case 'u':
d103 1
a103 2

				case 'T':
d109 1
a109 2

				case 'W':
d115 1
a115 2

				case 'I':
d121 1
a121 2

				case 'X':
d127 1
a127 2

				case 'n':
d130 1
a130 2

				case 'm':
d134 1
a134 2

				case 'R':
d138 1
a138 2

				case '*':
d144 1
a144 2

				case 'r':
d151 1
a151 2

				case 'o':
d158 1
a158 2

				case 'O':
d165 1
a165 2

				case 'a':
d175 1
a175 2

				case 'A':
d185 1
a185 2

				case 'c':
d192 1
a192 2

				case 'p':
d202 1
a202 2

				case 'l':
d209 1
a209 2

				case 'k':
d234 1
a234 2

				case 'S':
d238 1
a238 2

				case 'M':
d244 1
a244 2

				default:
d246 1
@


1.10
log
@include only headers which are needed
@
text
@d518 1
a518 1
		do
d520 1
a520 1
		while (t->curwin->main == mainw && t->curwin != starting);
d530 1
a530 2
	}
	while (yn);
d538 1
a538 1
	do
d553 1
a553 1
	while ((w = w->link.next) != maint->curwin) ;
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@a18 3
#include "w.h"
#include "termcap.h"
#include "vfile.h"
a19 2
#include "tty.h"
#include "scrn.h"
d21 1
a21 3
#include "vs.h"
#include "help.h"
#include "undo.h"
d23 2
a24 1
#include "macro.h"
d28 2
a29 2
#include "qw.h"
#include "tw.h"
@


1.8
log
@non-code clean up
@
text
@d2 8
a9 5
	Text editing windows
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.7
log
@use mkqw(W *, ...) instead of mkqw(BASE *, ...) (ditto. mkqwna() and mkqwnsr())
@
text
@a432 2
int uabort(BW *bw, int k);

@


1.6
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d462 1
a462 1
		if (mkqw(bw, sc("Lose changes to this file (y,n,^C)? "), naborttw, NULL, NULL, NULL))
@


1.5
log
@version 2.9.7-pre3
@
text
@d496 1
a496 1
/* Kill this window */
d512 1
a512 1
/* Only one window */
d528 3
a530 2
			if (((BW *) t->curwin->main->object)->pid) {
				msgnw(t->curwin->main->object, "Process running in this window");
d533 1
a533 1
			utw0(t->curwin->main->object), yn = 1;
@


1.4
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d35 1
a35 1
char *ctime();
d44 1
a44 3
static void movetw(bw, x, y)
BW *bw;
int x, y;
d65 1
a65 3
static void resizetw(bw, wi, he)
BW *bw;
int wi, he;
d73 1
a73 4
char *stagen(stalin, bw, s, fill)
char *stalin;
BW *bw;
char *s;
d278 1
a278 2
static void disptw(bw, flg)
BW *bw;
d323 1
a323 2
void iztw(tw, y)
TW *tw;
d334 1
a334 2
int usplitw(bw)
BW *bw;
d361 1
a361 2
int uduptw(bw)
BW *bw;
d390 1
a390 4
int naborttw(bw, k, object, notify)
BW *bw;
void *object;
int *notify;
d421 1
a421 5
static void instw(bw, b, l, n, flg)
BW *bw;
B *b;
long l, n;
int flg;
d427 1
a427 5
static void deltw(bw, b, l, n, flg)
BW *bw;
B *b;
long l, n;
int flg;
d433 1
a433 1
int uabort();
d449 1
a449 2
int uabort(bw, k)
BW *bw;
d472 1
a472 2
int uabortbuf(bw)
BW *bw;
d498 1
a498 2
int utw0(b)
BASE *b;
d514 1
a514 2
int utw1(b)
BASE *b;
d540 1
a540 3
void setline(b, line)
B *b;
long line;
d564 1
a564 3
BW *wmktw(t, b)
SCREEN *t;
B *b;
@


1.3
log
@changed as of joe-2.9.6
@
text
@d8 1
d10 6
a16 1
#include "config.h"
d35 1
a35 1
char *ctime ();
d44 3
a46 4
static void
movetw (bw, x, y)
     BW *bw;
     int x, y;
d49 14
a62 20
	if (y || !staen)
	  {
		  if (!tw->staon)
		    {		/* Scroll down and shrink */
			    nscrldn (bw->parent->t->t, y, bw->parent->nh + y,
				     1);
		    }
		  bwmove (bw, x + (bw->o.linums ? LINCOLS : 0), y + 1);
		  tw->staon = 1;
	  }
	else
	  {
		  if (tw->staon)
		    {		/* Scroll up and grow */
			    nscrlup (bw->parent->t->t, y, bw->parent->nh + y,
				     1);
		    }
		  bwmove (bw, x + (bw->o.linums ? LINCOLS : 0), y);
		  tw->staon = 0;
	  }
d67 3
a69 4
static void
resizetw (bw, wi, he)
     BW *bw;
     int wi, he;
d72 1
a72 1
		bwresz (bw, wi - (bw->o.linums ? LINCOLS : 0), he - 1);
d74 1
a74 1
		bwresz (bw, wi - (bw->o.linums ? LINCOLS : 0), he);
d77 4
a80 5
char *
stagen (stalin, bw, s, fill)
     char *stalin;
     BW *bw;
     char *s;
d85 197
a281 257
	stalin = vstrunc (stalin, 0);
	while (*s)
	  {
		  if (*s == '%' && s[1])
			  switch (*++s)
			    {
			    case 't':
				    {
					    long n = time (NULL);
					    int l;
					    char *d = ctime (&n);
					    l =
						    (d[11] - '0') * 10 +
						    d[12] - '0';
					    if (l > 12)
						    l -= 12;
					    snprintf (buf, sizeof(buf), "%2.2d", l);
					    if (buf[0] == '0')
						    buf[0] = fill;
					    stalin =
						    vsncpy (sv (stalin), buf,
							    2);
					    stalin =
						    vsncpy (sv (stalin),
							    d + 13, 3);
				    }
				    break;

			    case 'u':
				    {
					    long n = time (NULL);
					    char *d = ctime (&n);
					    stalin =
						    vsncpy (sv (stalin),
							    d + 11, 5);
				    }
				    break;

			    case 'T':
				    if (bw->o.overtype)
					    stalin = vsadd (stalin, 'O');
				    else
					    stalin = vsadd (stalin, 'I');
				    break;

			    case 'W':
				    if (bw->o.wordwrap)
					    stalin = vsadd (stalin, 'W');
				    else
					    stalin = vsadd (stalin, fill);
				    break;

			    case 'I':
				    if (bw->o.autoindent)
					    stalin = vsadd (stalin, 'A');
				    else
					    stalin = vsadd (stalin, fill);
				    break;

			    case 'X':
				    if (square)
					    stalin = vsadd (stalin, 'X');
				    else
					    stalin = vsadd (stalin, fill);
				    break;

			    case 'n':
				    stalin =
					    vsncpy (sv (stalin),
						    sz (bw->b->name ? bw->b->
							name : "Unnamed"));
				    break;

			    case 'm':
				    if (bw->b->changed)
					    stalin =
						    vsncpy (sv (stalin),
							    sc
							    ("(Modified)"));
				    break;

			    case 'R':
				    if (bw->b->rdonly)
					    stalin =
						    vsncpy (sv (stalin),
							    sc
							    ("(Read only)"));
				    break;

			    case '*':
				    if (bw->b->changed)
					    stalin = vsadd (stalin, '*');
				    else
					    stalin = vsadd (stalin, fill);
				    break;

			    case 'r':
				    snprintf (buf, sizeof(buf), "%-4ld",
					     bw->cursor->line + 1);
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'o':
				    snprintf (buf, sizeof(buf), "%-4ld", bw->cursor->byte);
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'O':
				    snprintf (buf, sizeof(buf), "%-4lX", bw->cursor->byte);
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'a':
				    if (!piseof (bw->cursor))
					    snprintf (buf, sizeof(buf),"%3d",
						     255 & brc (bw->cursor));
				    else
					    snprintf (buf,sizeof(buf), "   ");
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'A':
				    if (!piseof (bw->cursor))
					    snprintf (buf,sizeof(buf), "%2.2X",
						     255 & brc (bw->cursor));
				    else
					    snprintf (buf,sizeof(buf), "  ");
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'c':
				    snprintf (buf, sizeof(buf),"%-3ld",
					     piscol (bw->cursor) + 1);
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'p':
				    if (bw->b->eof->byte)
					    snprintf (buf,sizeof(buf), "%3ld",
						     bw->cursor->byte * 100 /
						     bw->b->eof->byte);
				    else
					    snprintf (buf,sizeof(buf), "100");
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'l':
				    snprintf (buf,sizeof(buf), "%-4ld",
					     bw->b->eof->line + 1);
				    for (x = 0; buf[x]; ++x)
					    if (buf[x] == ' ')
						    buf[x] = fill;
				    stalin = vsncpy (sv (stalin), sz (buf));
				    break;

			    case 'k':
				    {
					    int i;
					    char *cpos = buf;
					    buf[0] = 0;
					    if (w->kbd->x && w->kbd->seq[0])
						    for (i = 0;
							 i != w->kbd->x; ++i)
						      {
							      int c =
								      w->kbd->
								      seq[i] & 127;
							      if (c < 32)
								      cpos[0]
									      =
									      '^',
									      cpos
									      [1]
									      =
									      c
									      +
									      '@@',
									      cpos
									      +=
									      2;
							      else if (c ==
								       127)
									      cpos
									      [0]
									      =
									      '^',
									      cpos
									      [1]
									      =
									      '?',
									      cpos
									      +=
									      2;
							      else
								      cpos[0]
									      =
									      c,
									      cpos
									      +=
									      1;
						      }
					    *cpos++ = fill;
					    while (cpos - buf < 4)
						    *cpos++ = fill;
					    stalin =
						    vsncpy (sv (stalin), buf,
							    cpos - buf);
				    }
				    break;

			    case 'S':
				    if (bw->pid)
					    stalin =
						    vsncpy (sv (stalin),
							    sc ("*SHELL*"));
				    break;

			    case 'M':
				    if (recmac)
				      {
					      snprintf (buf,sizeof(buf),
						       "(Macro %d recording...)",
						       recmac->n);
					      stalin =
						      vsncpy (sv (stalin),
							      sz (buf));
				      }
				    break;

			    default:
				    stalin = vsadd (stalin, *s);
			    }
		  else
			  stalin = vsadd (stalin, *s);
		  ++s;
	  }
d285 2
a286 3
static void
disptw (bw, flg)
     BW *bw;
d291 6
a296 7
	if (bw->o.linums != bw->linums)
	  {
		  bw->linums = bw->o.linums;
		  resizetw (bw, w->w, w->h);
		  movetw (bw, w->x, w->y);
		  bwfllw (bw);
	  }
d299 1
a299 2
	w->curx =
		bw->cursor->xcol - bw->offset + (bw->o.linums ? LINCOLS : 0);
d301 23
a323 33
	if ((staupd || keepup || bw->cursor->line != tw->prevline ||
	     bw->b->changed != tw->changed) && (w->y || !staen))
	  {
		  int fill;
		  tw->prevline = bw->cursor->line;
		  tw->changed = bw->b->changed;
		  if (bw->o.rmsg[0])
			  fill = bw->o.rmsg[0];
		  else
			  fill = ' ';
		  tw->stalin = stagen (tw->stalin, bw, bw->o.lmsg, fill);
		  tw->staright = stagen (tw->staright, bw, bw->o.rmsg, fill);
		  if (fmtlen (tw->staright) < w->w)
		    {
			    int x =
				    fmtpos (tw->stalin,
					    w->w - fmtlen (tw->staright));
			    if (x > sLEN (tw->stalin))
				    tw->stalin =
					    vsfill (sv (tw->stalin), fill,
						    x - sLEN (tw->stalin));
			    tw->stalin =
				    vsncpy (tw->stalin,
					    fmtpos (tw->stalin,
						    w->w -
						    fmtlen (tw->staright)),
					    sv (tw->staright));
		    }
		  tw->stalin =
			  vstrunc (tw->stalin, fmtpos (tw->stalin, w->w));
		  genfmt (w->t->t, w->x, w->y, 0, tw->stalin, 0);
		  w->t->t->updtab[w->y] = 0;
	  }
d326 1
a326 1
		bwgen (bw, bw->o.linums);
d331 2
a332 3
void
iztw (tw, y)
     TW *tw;
d343 2
a344 3
int
usplitw (bw)
     BW *bw;
d347 1
a347 1
	int newh = getgrouph (w);
d351 1
d355 1
a355 3
	new =
		wcreate (w->t, w->watom, findbotw (w), NULL, w,
			 newh / 2 + (newh & 1), NULL, NULL);
d358 2
a359 2
	wfit (new->t);
	new->object = (void *) (newbw = bwmk (new, bw->b, 0));
d362 4
a365 4
	newbw->object = (void *) (newtw = (TW *) malloc (sizeof (TW)));
	iztw (newtw, new->y);
	pset (newbw->top, bw->top);
	pset (newbw->cursor, bw->cursor);
d371 2
a372 3
int
uduptw (bw)
     BW *bw;
d375 1
a375 1
	int newh = getgrouph (w);
d379 1
d381 1
a381 3
	new =
		wcreate (w->t, w->watom, findbotw (w), NULL, NULL, newh, NULL,
			 NULL);
d384 1
a384 1
	if (demotegroup (w))
d386 1
a386 1
	new->object = (void *) (newbw = bwmk (new, bw->b, 0));
d389 4
a392 4
	newbw->object = (void *) (newtw = (TW *) malloc (sizeof (TW)));
	iztw (newtw, new->y);
	pset (newbw->top, bw->top);
	pset (newbw->cursor, bw->cursor);
d395 1
a395 1
	wfit (w->t);
d401 4
a404 5
int
naborttw (bw, k, object, notify)
     BW *bw;
     void *object;
     int *notify;
d409 1
d415 1
a415 1
	genexmsg (bw, 0, NULL);
d417 13
a429 13
	if (countmain (w->t) == 1)
		if (b = borphan ())
		  {
			  void *object = bw->object;
			  bwrm (bw);
			  w->object = (void *) (bw = bwmk (w, b, 0));
			  wredraw (bw->parent);
			  bw->object = object;
			  return 0;
		  }
	bwrm (bw);
	vsrm (tw->stalin);
	free (tw);
d431 1
a431 1
	wabort (w);		/* Eliminate this window and it's children */
d435 5
a439 6
static void
instw (bw, b, l, n, flg)
     BW *bw;
     B *b;
     long l, n;
     int flg;
d442 1
a442 1
		bwins (bw, l, n, flg);
d445 5
a449 6
static void
deltw (bw, b, l, n, flg)
     BW *bw;
     B *b;
     long l, n;
     int flg;
d452 1
a452 1
		bwdel (bw, l, n, flg);
d455 1
a455 1
int uabort ();
d471 2
a472 3
int
uabort (bw, k)
     BW *bw;
d475 7
a481 7
		return wabort (bw->parent);
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte && k != MAXINT)
	  {
		  char c = k;
		  write (bw->out, &c, 1);
		  return 0;
	  }
d483 1
a483 1
		return ukillpid (bw);
d485 1
a485 3
		if (mkqw
		    (bw->parent, sc ("Lose changes to this file (y,n,^C)? "),
		     naborttw, NULL, NULL, NULL))
d490 1
a490 1
		return naborttw (bw, 'y', NULL, NULL);
d495 2
a496 3
int
uabortbuf (bw)
     BW *bw;
d500 1
d502 1
a502 1
		return ukillpid (bw);
d504 1
a504 1
	if (okrepl (bw))
d507 9
a515 9
	if (b = borphan ())
	  {
		  void *object = bw->object;
		  bwrm (bw);
		  w->object = (void *) (bw = bwmk (w, b, 0));
		  wredraw (bw->parent);
		  bw->object = object;
		  return 0;
	  }
d517 1
a517 1
	return naborttw (bw, 'y', NULL, NULL);
d522 2
a523 3
int
utw0 (b)
     BASE *b;
d526 2
a527 1
	if (countmain (b->parent->t) == 1)
d529 3
a531 4
	if (bw->pid)
	  {
		  return ukillpid (bw);
	  }
d533 2
a534 2
		orphit (bw);
	return uabort (bw, MAXINT);
d539 2
a540 3
int
utw1 (b)
     BASE *b;
d543 2
a544 2
	W *main = starting->main;
	SCREEN *t = main->t;
d547 15
a561 19
	do
	  {
		  yn = 0;
		loop:
		  do
			  wnext (t);
		  while (t->curwin->main == main && t->curwin != starting);
		  if (t->curwin->main != main)
		    {
			    if (((BW *) t->curwin->main->object)->pid)
			      {
				      msgnw (t->curwin->main->object,
					     "Process running in this window");
				      return -1;
			      }
			    utw0 (t->curwin->main->object), yn = 1;
			    goto loop;
		    }
	  }
d566 3
a568 4
void
setline (b, line)
     B *b;
     long line;
d571 1
d573 15
a587 24
		if (w->watom->what == TYPETW)
		  {
			  BW *bw = w->object;
			  if (bw->b == b)
			    {
				    long oline = bw->top->line;
				    pline (bw->top, line);
				    pline (bw->cursor, line);
				    if (w->y >= 0 && bw->top->line > oline
					&& bw->top->line - oline < bw->h)
					    nscrlup (w->t->t, bw->y,
						     bw->y + bw->h,
						     (int) (bw->top->line -
							    oline));
				    else if (w->y >= 0
					     && bw->top->line < oline
					     && oline - bw->top->line < bw->h)
					    nscrldn (w->t->t, bw->y,
						     bw->y + bw->h,
						     (int) (oline -
							    bw->top->line));
			    }
		  }
	while ((w = w->link.next) != maint->curwin);
d592 3
a594 4
BW *
wmktw (t, b)
     SCREEN *t;
     B *b;
d599 6
a604 5
	w = wcreate (t, &watomtw, NULL, NULL, NULL, t->h, NULL, NULL);
	wfit (w->t);
	w->object = (void *) (bw = bwmk (w, b, 0));
	bw->object = (void *) (tw = (TW *) malloc (sizeof (TW)));
	iztw (tw, w->y);
@


1.2
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
 /* Text editing windows
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 1
This file is part of JOE (Joe's Own Editor)
d8 1
a8 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d29 1
a29 1
char *ctime();
d32 3
a34 3
int staen=0;
int staupd=0;
int keepup=0;
d38 27
a64 24
static void movetw(bw,x,y)
BW *bw;
int x,y;
 {
 TW *tw=(TW *)bw->object;
 if(y || !staen)
  {
  if(!tw->staon)
   { /* Scroll down and shrink */
   nscrldn(bw->parent->t->t,y,bw->parent->nh+y,1);
   }
  bwmove(bw,x+(bw->o.linums?LINCOLS:0),y+1);
  tw->staon=1;
  }
 else
  {
  if(tw->staon)
   { /* Scroll up and grow */
   nscrlup(bw->parent->t->t,y,bw->parent->nh+y,1);
   }
  bwmove(bw,x+(bw->o.linums?LINCOLS:0),y);
  tw->staon=0;
  }
 }
d68 332
a399 216
static void resizetw(bw,wi,he)
BW *bw;
int wi,he;
 {
 if(bw->parent->ny || !staen)
  bwresz(bw,wi-(bw->o.linums?LINCOLS:0),he-1);
 else
  bwresz(bw,wi-(bw->o.linums?LINCOLS:0),he);
 }

char *stagen(stalin,bw,s,fill)
char *stalin;
BW *bw;
char *s;
 {
 char buf[80];
 int x;
 W *w=bw->parent;
 stalin=vstrunc(stalin,0);
 while(*s)
  {
  if(*s=='%' && s[1])
   switch(*++s)
    {
    case 't':
     {
     long n=time(NULL);
     int l;
     char *d=ctime(&n);
     l=(d[11]-'0')*10+d[12]-'0';
     if(l>12) l-=12;
     sprintf(buf,"%2.2d",l);
     if(buf[0]=='0') buf[0]=fill;
     stalin=vsncpy(sv(stalin),buf,2);
     stalin=vsncpy(sv(stalin),d+13,3);
     }
    break;

    case 'u':
     {
     long n=time(NULL);
     char *d=ctime(&n);
     stalin=vsncpy(sv(stalin),d+11,5);
     }
    break;

    case 'T':
    if(bw->o.overtype) stalin=vsadd(stalin,'O');
    else stalin=vsadd(stalin,'I');
    break;
    
    case 'W':
    if(bw->o.wordwrap) stalin=vsadd(stalin,'W');
    else stalin=vsadd(stalin,fill);
    break;

    case 'I':
    if(bw->o.autoindent) stalin=vsadd(stalin,'A');
    else stalin=vsadd(stalin,fill);
    break;

    case 'X':
    if(square) stalin=vsadd(stalin,'X');
    else stalin=vsadd(stalin,fill);
    break;

    case 'n':
    stalin=vsncpy(sv(stalin),sz(bw->b->name?bw->b->name:"Unnamed"));
    break;

    case 'm':
    if(bw->b->changed)
     stalin=vsncpy(sv(stalin),sc("(Modified)"));
    break;

    case 'R':
    if(bw->b->rdonly)
     stalin=vsncpy(sv(stalin),sc("(Read only)"));
    break;

    case '*':
    if(bw->b->changed)
     stalin=vsadd(stalin,'*');
    else
     stalin=vsadd(stalin,fill);
    break;

    case 'r':
    sprintf(buf,"%-4ld",bw->cursor->line+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'o':
    sprintf(buf,"%-4ld",bw->cursor->byte);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'O':
    sprintf(buf,"%-4lX",bw->cursor->byte);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'a':
    if(!piseof(bw->cursor)) sprintf(buf,"%3d",255&brc(bw->cursor));
    else sprintf(buf,"   ");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'A':
    if(!piseof(bw->cursor)) sprintf(buf,"%2.2X",255&brc(bw->cursor));
    else sprintf(buf,"  ");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'c':
    sprintf(buf,"%-3ld",piscol(bw->cursor)+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'p':
    if(bw->b->eof->byte)
     sprintf(buf,"%3ld",bw->cursor->byte*100/bw->b->eof->byte);
    else
     sprintf(buf,"100");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'l':
    sprintf(buf,"%-4ld",bw->b->eof->line+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'k':
     {
     int i;
     char *cpos=buf;
     buf[0]=0;
     if(w->kbd->x && w->kbd->seq[0])
      for(i=0;i!=w->kbd->x;++i)
       {
       int c=w->kbd->seq[i]&127;
       if(c<32) cpos[0]='^', cpos[1]=c+'@@', cpos+=2;
       else if(c==127) cpos[0]='^', cpos[1]='?', cpos+=2;
       else cpos[0]=c, cpos+=1;
       }
     *cpos++=fill;
     while(cpos-buf<4) *cpos++=fill;
     stalin=vsncpy(sv(stalin),buf,cpos-buf);
     }
    break;

    case 'S':
    if(bw->pid) stalin=vsncpy(sv(stalin),sc("*SHELL*"));
    break;

    case 'M':
    if(recmac)
     {
     sprintf(buf,"(Macro %d recording...)",recmac->n);
     stalin=vsncpy(sv(stalin),sz(buf));
     }
    break;

    default: stalin=vsadd(stalin,*s);
    }
  else stalin=vsadd(stalin,*s);
  ++s;
  }
 return stalin;
 }

static void disptw(bw,flg)
BW *bw;
 {
 W *w=bw->parent;
 TW *tw=(TW *)bw->object;

 if(bw->o.linums!=bw->linums)
  {
  bw->linums=bw->o.linums;
  resizetw(bw,w->w,w->h);
  movetw(bw,w->x,w->y);
  bwfllw(bw);
  }

 w->cury=bw->cursor->line-bw->top->line+bw->y-w->y;
 w->curx=bw->cursor->xcol-bw->offset+(bw->o.linums?LINCOLS:0);

 if((staupd || keepup || bw->cursor->line!=tw->prevline ||
     bw->b->changed!=tw->changed) && (w->y || !staen))
  {
  int fill;
  tw->prevline=bw->cursor->line;
  tw->changed=bw->b->changed;
  if(bw->o.rmsg[0]) fill=bw->o.rmsg[0];
  else fill=' ';
  tw->stalin=stagen(tw->stalin,bw,bw->o.lmsg,fill);
  tw->staright=stagen(tw->staright,bw,bw->o.rmsg,fill);
  if(fmtlen(tw->staright)<w->w)
   {
   int x=fmtpos(tw->stalin,w->w-fmtlen(tw->staright));
   if(x>sLEN(tw->stalin)) tw->stalin=vsfill(sv(tw->stalin),fill,x-sLEN(tw->stalin));
   tw->stalin=vsncpy(tw->stalin,fmtpos(tw->stalin,w->w-fmtlen(tw->staright)),sv(tw->staright));
   }
  tw->stalin=vstrunc(tw->stalin,fmtpos(tw->stalin,w->w));
  genfmt(w->t->t,w->x,w->y,0,tw->stalin,0);
  w->t->t->updtab[w->y]=0;
  }
d401 3
a403 2
 if(flg) bwgen(bw,bw->o.linums);
 }
d407 10
a416 9
void iztw(tw,y)
TW *tw;
 {
 tw->stalin=0;
 tw->staright=0;
 tw->changed= -1;
 tw->prevline= -1;
 tw->staon=(!staen || y);
 }
d420 59
a478 49
int usplitw(bw)
BW *bw;
 {
 W *w=bw->parent;
 int newh=getgrouph(w);
 W *new;
 TW *newtw;
 BW *newbw;
 dostaupd=1;
 if(newh/2<FITHEIGHT) return -1;
 new=wcreate(w->t,w->watom,findbotw(w),NULL,w,newh/2+(newh&1),NULL,NULL);
 if(!new) return -1;
 wfit(new->t);
 new->object=(void *)(newbw=bwmk(new,bw->b,0));
 ++bw->b->count;
 newbw->offset=bw->offset;
 newbw->object=(void *)(newtw=(TW *)malloc(sizeof(TW)));
 iztw(newtw,new->y);
 pset(newbw->top,bw->top);
 pset(newbw->cursor,bw->cursor);
 newbw->cursor->xcol=bw->cursor->xcol;
 new->t->curwin=new;
 return 0;
 }

int uduptw(bw)
BW *bw;
 {
 W *w=bw->parent;
 int newh=getgrouph(w);
 W *new;
 TW *newtw;
 BW *newbw;
 dostaupd=1;
 new=wcreate(w->t,w->watom,findbotw(w),NULL,NULL,newh,NULL,NULL);
 if(!new) return -1;
 if(demotegroup(w)) new->t->topwin=new;
 new->object=(void *)(newbw=bwmk(new,bw->b,0));
 ++bw->b->count;
 newbw->offset=bw->offset;
 newbw->object=(void *)(newtw=(TW *)malloc(sizeof(TW)));
 iztw(newtw,new->y);
 pset(newbw->top,bw->top);
 pset(newbw->cursor,bw->cursor);
 newbw->cursor->xcol=bw->cursor->xcol;
 new->t->curwin=new;
 wfit(w->t);
 return 0;
 }
d482 70
a551 64
int naborttw(bw,k,object,notify)
BW *bw;
void *object;
int *notify;
{
W *w=bw->parent;
B *b;
TW *tw=(TW *)bw->object;
if(notify) *notify=1;
if(k!='y' && k!='Y') return -1;

genexmsg(bw,0,NULL);

if(countmain(w->t)==1)
 if(b=borphan())
  {
  void *object=bw->object;
  bwrm(bw);
  w->object=(void *)(bw=bwmk(w,b,0));
  wredraw(bw->parent);
  bw->object=object;
  return 0;
  }
bwrm(bw);
vsrm(tw->stalin);
free(tw);
w->object=0;
wabort(w);		/* Eliminate this window and it's children */
return 0;
}

static void instw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwins(bw,l,n,flg);
 }

static void deltw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwdel(bw,l,n,flg);
 }

int uabort();

static WATOM watomtw=
{
"main",
disptw,
bwfllw,
0,
rtntw,
utypebw,
resizetw,
movetw,
instw,
deltw,
TYPETW
d554 3
a556 2
int uabort(bw,k)
BW *bw;
d558 19
a576 13
if(bw->parent->watom!=&watomtw)
 return wabort(bw->parent);
if(bw->pid && bw->cursor->byte==bw->b->eof->byte && k!= MAXINT)
 {
 char c=k;
 write(bw->out,&c,1);
 return 0;
 }
if(bw->pid) return ukillpid(bw);
if(bw->b->changed && bw->b->count==1)
 if(mkqw(bw,sc("Lose changes to this file (y,n,^C)? "),naborttw,NULL,NULL,NULL)) return 0;
 else return -1;
else return naborttw(bw,'y',NULL,NULL);
d581 21
a601 18
int uabortbuf(bw)
BW *bw;
 {
 W *w=bw->parent;
 B *b;
 if(bw->pid) return ukillpid(bw);

 if(okrepl(bw)) return -1;

 if(b=borphan())
  {
  void *object=bw->object;
  bwrm(bw);
  w->object=(void *)(bw=bwmk(w,b,0));
  wredraw(bw->parent);
  bw->object=object;
  return 0;
  }
d603 2
a604 2
 return naborttw(bw,'y',NULL,NULL);
 }
d608 15
a622 9
int utw0(b)
BASE *b;
 {
 BW *bw=b->parent->main->object;
 if(countmain(b->parent->t)==1) return -1;
 if(bw->pid) { return ukillpid(bw); }
 if(bw->b->count==1) orphit(bw);
 return uabort(bw,MAXINT);
 }
d626 64
a689 49
int utw1(b)
BASE *b;
 {
 W *starting=b->parent;
 W *main=starting->main;
 SCREEN *t=main->t;
 int yn;

 do
  {
  yn=0;
  loop:
  do wnext(t); while(t->curwin->main==main && t->curwin!=starting);
  if(t->curwin->main!=main)
   {
   if(((BW *)t->curwin->main->object)->pid)
    {
    msgnw(t->curwin->main->object,"Process running in this window");
    return -1;
    }
   utw0(t->curwin->main->object), yn=1;
   goto loop;
   }
  } while(yn);
 return 0;
 }

void setline(b,line)
B *b;
long line;
 {
 W *w=maint->curwin;
 do
  if(w->watom->what==TYPETW)
   {
   BW *bw=w->object;
   if(bw->b==b)
    {
    long oline=bw->top->line;
    pline(bw->top,line);
    pline(bw->cursor,line);
    if(w->y>=0 && bw->top->line>oline && bw->top->line-oline<bw->h)
     nscrlup(w->t->t,bw->y,bw->y+bw->h,(int)(bw->top->line-oline));
    else if(w->y>=0 && bw->top->line<oline && oline-bw->top->line<bw->h)
     nscrldn(w->t->t,bw->y,bw->y+bw->h,(int)(oline-bw->top->line));
    }
   }
  while((w=w->link.next)!=maint->curwin);
 }
d693 15
a707 14
BW *wmktw(t,b)
SCREEN *t;
B *b;
 {
 W *w;
 BW *bw;
 TW *tw;
 w=wcreate(t,&watomtw,NULL,NULL,NULL,t->h,NULL,NULL);
 wfit(w->t);
 w->object=(void *)(bw=bwmk(w,b,0));
 bw->object=(void *)(tw=(TW *)malloc(sizeof(TW)));
 iztw(tw,w->y);
 return bw;
 }
@


1.1
log
@Initial revision
@
text
@a26 1
#include "zstr.h"
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
