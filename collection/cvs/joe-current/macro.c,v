head	1.50;
access;
symbols
	joe_3_5:1.41
	joe-3_4:1.39
	help:1.39
	joe_3_1:1.23
	joe_3_0:1.21
	joe_2_9_8:1.18
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.10.22.39.27;	author shallot;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.04.01.13.32;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.31.02.31.55;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.24.04.37.14;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.05.18.18.45;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.22.03.22.37;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.19.21.10.11;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.19.03.02.50;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.14.03.21.36;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.14.00.07.49;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.28.00.46.43;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.27.05.29.32;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.09.18.13.48;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.38.59;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.20.07.18.19;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.09.38;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.53.40;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.54;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.54;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@/*
 *	Keyboard macros
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

MACRO *freemacros = NULL;

/* Create a macro */

MACRO *mkmacro(int k, int flg, int n, CMD *cmd)
{
	MACRO *macro;

	if (!freemacros) {
		int x;

		macro = (MACRO *) joe_malloc(sizeof(MACRO) * 64);
		for (x = 0; x != 64; ++x) {
			macro[x].steps = (MACRO **) freemacros;
			freemacros = macro + x;
		}
	}
	macro = freemacros;
	freemacros = (MACRO *) macro->steps;
	macro->steps = NULL;
	macro->size = 0;
	macro->flg = flg;
	macro->n = n;
	macro->cmd = cmd;
	macro->k = k;
	return macro;
}

/* Eliminate a macro */

void rmmacro(MACRO *macro)
{
	if (macro) {
		if (macro->steps) {
			int x;

			for (x = 0; x != macro->n; ++x)
				rmmacro(macro->steps[x]);
			joe_free(macro->steps);
		}
		macro->steps = (MACRO **) freemacros;
		freemacros = macro;
	}
}

/* Add a step to block macro */

void addmacro(MACRO *macro, MACRO *m)
{
	if (macro->n == macro->size) {
		if (macro->steps)
			macro->steps = (MACRO **) joe_realloc(macro->steps, (macro->size += 8) * sizeof(MACRO *));
		else
			macro->steps = (MACRO **) joe_malloc((macro->size = 8) * sizeof(MACRO *));
	}
	macro->steps[macro->n++] = m;
}

/* Duplicate a macro */

MACRO *dupmacro(MACRO *mac)
{
	MACRO *m = mkmacro(mac->k, mac->flg, mac->n, mac->cmd);

	if (mac->steps) {
		int x;

		m->steps = (MACRO **) joe_malloc((m->size = mac->n) * sizeof(MACRO *));
		for (x = 0; x != m->n; ++x)
			m->steps[x] = dupmacro(mac->steps[x]);
	}
	return m;
}

/* Set key part of macro */

MACRO *macstk(MACRO *m, int k)
{
	m->k = k;
	return m;
}

/* Set flg part of macro */

MACRO *macsta(MACRO *m, int a)
{
	m->flg = a;
	return m;
}

/* Parse text into a macro
 * sta is set to:  ending position in buffer for no error.
 *                 -1 for syntax error
 *                 -2 for need more input
 */

MACRO *mparse(MACRO *m, unsigned char *buf, int *sta)
{
	int y, c, x = 0;

      macroloop:

	/* Skip whitespace */
	while (joe_isblank(locale_map,buf[x]))
		++x;

	/* If the buffer is only whitespace then treat as unknown command */
	if (!buf[x]) {
		*sta = -1;
		return NULL;
	}

	/* Do we have a string? */
	if (buf[x] == '\"') {
		++x;
		while (buf[x] && buf[x] != '\"') {
			if (buf[x] == '\\' && buf[x + 1]) {
				++x;
				switch (buf[x]) {
				case 'n':
					buf[x] = 10;
					break;
				case 'r':
					buf[x] = 13;
					break;
				case 'b':
					buf[x] = 8;
					break;
				case 'f':
					buf[x] = 12;
					break;
				case 'a':
					buf[x] = 7;
					break;
				case 't':
					buf[x] = 9;
					break;
				case 'x':
					c = 0;
					if (buf[x + 1] >= '0' && buf[x + 1] <= '9')
						c = c * 16 + buf[++x] - '0';
					else if ((buf[x + 1] >= 'a' && buf[x + 1] <= 'f') || (buf[x + 1] >= 'A' && buf[x + 1] <= 'F'))
						c = c * 16 + (buf[++x] & 0xF) + 9;
					if (buf[x + 1] >= '0' && buf[x + 1] <= '9')
						c = c * 16 + buf[++x] - '0';
					else if ((buf[x + 1] >= 'a' && buf[x + 1] <= 'f') || (buf[x + 1] >= 'A' && buf[x + 1] <= 'F'))
						c = c * 16 + (buf[++x] & 0xF) + 9;
					buf[x] = c;
					break;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					c = buf[x] - '0';
					if (buf[x + 1] >= '0' && buf[x + 1] <= '7')
						c = c * 8 + buf[++x] - '0';
					if (buf[x + 1] >= '0' && buf[x + 1] <= '7')
						c = c * 8 + buf[++x] - '0';
					buf[x] = c;
					break;
				}
			}
			if (m) {
				if (!m->steps) {
					MACRO *macro = m;

					m = mkmacro(-1, 0, 0, NULL);
					addmacro(m, macro);
				}
			} else
				m = mkmacro(-1, 0, 0, NULL);
			addmacro(m, mkmacro(buf[x], 0, 0, findcmd(USTR "type")));
			++x;
		}
		if (buf[x] == '\"')
			++x;
	}

	/* Do we have a command? */
	else {
		for (y = x; buf[y] && buf[y]!='#' && buf[y] != '!' &&
		            buf[y] != '~' && buf[y] !='-' && buf[y] != ',' &&
		            buf[y] != ' ' && buf[y] != '\t' &&
		            buf[y] != '\n' && buf[x] != '\r'; ++y) ;
		if (y != x) {
			CMD *cmd;
			int flg = 0;

			c = buf[y];
			buf[y] = 0;
			cmd = findcmd(buf + x);
			buf[x = y] = c;

			/* Parse flags */
			while (buf[x]=='-' || buf[x]=='!' || buf[x]=='#' || buf[x]=='~') {
				if (buf[x]=='-') flg |= 1;
				if (buf[x]=='!') flg |= 2;
				if (buf[x]=='#') flg |= 4;
				if (buf[x]=='~') flg |= 8;
				++x;
			}

			if (!cmd) {
				*sta = -1;
				return NULL;
			} else if (m) {
				if (!m->steps) {
					MACRO *macro = m;

					m = mkmacro(-1, 0, 0, NULL);
					addmacro(m, macro);
				}
				addmacro(m, mkmacro(-1, flg, 0, cmd));
			} else
				m = mkmacro(-1, flg, 0, cmd);
		} else { /* not a valid command */
			*sta = -1;
			return NULL;
		}
	}

	/* Skip whitespace */
	while (joe_isblank(locale_map,buf[x]))
		++x;

	/* Do we have a comma? */
	if (buf[x] == ',') {
		++x;
		while (joe_isblank(locale_map,buf[x]))
			++x;
		if (buf[x] && buf[x] != '\r' && buf[x] != '\n')
			goto macroloop;
		*sta = -2;
		return m;
	}

	/* Done */
	*sta = x;
	return m;
}

/* Convert macro to text */

static int first;
static int instr;

unsigned char *unescape(unsigned char *ptr, int c)
{
	if (c == '"') {
		ptr = vsadd(ptr, '\\');
		ptr = vsadd(ptr, '"');
	} else if (c == '\\') {
		ptr = vsadd(ptr, '\\');
		ptr = vsadd(ptr, '\\');
	} else if (c == '\'') {
		ptr = vsadd(ptr, '\\');
		ptr = vsadd(ptr, '\'');
	} else if (c < 32 || c > 126) {
		/* FIXME: what if c > 256 or c < 0 ? */
		ptr = vsadd(ptr, '\\');
		ptr = vsadd(ptr, 'x');
		ptr = vsadd(ptr, "0123456789ABCDEF"[c >> 4]);
		ptr = vsadd(ptr, "0123456789ABCDEF"[c & 15]);
	} else
		ptr = vsadd(ptr, c);
	return ptr;
}

static unsigned char *domtext(unsigned char *ptr, MACRO *m)
{
	int x;

	if (!m)
		return ptr;
	if (m->steps)
		for (x = 0; x != m->n; ++x)
			ptr = domtext(ptr, m->steps[x]);
	else {
		if (instr && zcmp(m->cmd->name, USTR "type")) {
			ptr = vsadd(ptr, '"');
			instr = 0;
		}
		if (first)
			first = 0;
		else if (!instr)
			ptr = vsadd(ptr, ',');
		if (!zcmp(m->cmd->name, USTR "type")) {
			if (!instr) {
				ptr = vsadd(ptr, '"');
				instr = 1;
			}
			ptr = unescape(ptr, m->k);
		} else {
			ptr = vscatz(ptr, m->cmd->name);
			if (!zcmp(m->cmd->name, USTR "play") || !zcmp(m->cmd->name, USTR "gomark") || !zcmp(m->cmd->name, USTR "setmark") || !zcmp(m->cmd->name, USTR "record") || !zcmp(m->cmd->name, USTR "uarg")) {
				ptr = vsadd(ptr, ',');
				ptr = vsadd(ptr, '"');
				ptr = unescape(ptr, m->k);
				ptr = vsadd(ptr, '"');
			}
		}
	}
	return ptr;
}

unsigned char *mtext(unsigned char *s, MACRO *m)
{
	s = vstrunc(s, 0);
	first = 1;
	instr = 0;
	s = domtext(s, m);
	if (instr)
		s = vsadd(s, '"');
	return s;
}

/* Keyboard macro recorder */

static MACRO *kbdmacro[10];
static int playmode[10];

struct recmac *recmac = NULL;

static void unmac(void)
{
	if (recmac)
		rmmacro(recmac->m->steps[--recmac->m->n]);
}

void chmac(void)
{
	if (recmac && recmac->m->n)
		recmac->m->steps[recmac->m->n - 1]->k = 3;
}

static void record(MACRO *m)
{
	if (recmac)
		addmacro(recmac->m, dupmacro(m));
}

static int ifdepth=0;		/* JM: Nesting level of if cmds */
static int ifflag=1;		/* JM: Truth flag for if */
static int iffail=0;		/* JM: Depth where ifflag became 0 */

/* Suspend macro record/play to allow for user input.
 */

int uquery(BW *bw)
{
	int ret = 0;
	/* Suspend current macro until current prompt is complete. */
	if (bw->parent->coro) {
		/* Save macro execution state */
		int oid = ifdepth;
		int oifl = ifflag;
		int oifa = iffail;
		struct recmac *tmp = recmac;
		recmac = 0;
		/* Suspend macro: co_suspend suspends the macro player which called us and chains it
		   to bw->parent->coro so that it continues when bw->parent->coro is done */
		ret = co_query_suspend(bw->parent->coro, 0);
		/* Continue macro */
		recmac = tmp;
		ifdepth = oid;
		ifflag = oifl;
		iffail = oifa;
	}
	return ret;
}

/* Macro execution */

MACRO *curmacro = NULL;		/* Set if we're in a macro */
static int macroptr;
static int arg = 0;		/* Repeat argument */
static int argset = 0;		/* Set if 'arg' is set */

int exsimple(MACRO *m, int arg, int u)
{
	CMD *cmd = m->cmd;
	int flg = 0; /* set if we should not try to merge minor changes into single undo record */
	int ret = 0;

	/* Find command to execute if repeat argument is negative */
	if (arg < 0) {
		arg = -arg;
		if (cmd->negarg)
			cmd = findcmd(cmd->negarg);
		else
			arg = 0; /* Do not execute */
	}

	/* Check if command doesn't like an arg... */
	if (arg != 1 && !cmd->arg)
		arg = 0; /* Do not execute */

	if (arg != 1 || !(cmd->flag & EMINOR)
	    || maint->curwin->watom->what == TYPEQW)	/* Undo work right for s & r */
		flg = 1;

	if (ifflag || (cmd->flag&EMETA)) {
		if (flg && u)
			umclear();
		/* Repeat... */
		while (arg-- && !leave && !ret)
			ret = execmd(cmd, m->k);
		if (leave)
			return ret;
		if (flg && u)
			umclear();
		if (u)
			undomark();
	}

	return ret;
}

int current_arg = 1;
int current_arg_set = 0;

int exmacro(MACRO *m, int u)
{
	int larg;
	int negarg = 0;
	int oid=0, oifl=0, oifa=0;
	int ret = 0;
	int main_ret = 0;
	int o_arg_set = argset;
	int o_arg = arg;

	/* Take argument */

	if (argset) {
		larg = arg;
		arg = 0;
		argset = 0;
	} else {
		larg = 1;
	}

	/* Just a simple command? */

	if (!m->steps) {
		return exsimple(m, larg, u);
	}

	/* Must be a real macro then... */

	if (larg < 0) {
		larg = -larg;
		negarg = 1;
	}

	if (ifflag) {
		if (u)
			umclear();
		/* Repeat... */
		while (larg && !leave && !ret) {
			MACRO *tmpmac = curmacro;
			int tmpptr = macroptr;
			int x = 0;
			int stk = nstack;

			/* Steps of macro... */
			while (m && x != m->n && !leave && !ret) {
				MACRO *d;
				int tmp_arg;
				int tmp_set;

				d = m->steps[x++];
				curmacro = m;
				macroptr = x;
				tmp_arg = current_arg;
				tmp_set = current_arg_set;
				current_arg = o_arg;
				current_arg_set = o_arg_set;

				if(d->steps) oid=ifdepth, oifl=ifflag, oifa=iffail, ifdepth=iffail=0;

				/* If this step wants to know about negative args... */
				if ((d->flg&4)) {
					argset = o_arg_set;
					arg = o_arg;
					larg = 1;
				} else if ((d->flg&1) && negarg) {
					if (argset) {
						arg = -arg;
					} else {
						argset = 1;
						arg = -1;
					}
				}

				if (d->flg&8) {
					larg = 1;
				}

				/* This is the key step of the macro... */
				if (d->flg&2)
					main_ret = exmacro(d, 0);
				else
					ret = exmacro(d, 0);

				if(d->steps) ifdepth=oid, ifflag=oifl, iffail=oifa;
				current_arg = tmp_arg;
				current_arg_set = tmp_set;
				m = curmacro;
				x = macroptr;
			}
			curmacro = tmpmac;
			macroptr = tmpptr;

			/* Pop ^KB ^KK stack */
			while (nstack > stk)
				upop(NULL);
		--larg;
		}
		ret |= main_ret;

		if (leave)
			return ret;
		if (u)
			umclear();
		if (u)
			undomark();
	}

	return ret;
}

/* Execute a macro - for user typing */
/* Records macro in macro recorder, resets if */

int exemac(va_list args)
{
	MACRO *m = va_arg(args, MACRO *);
	record(m);
	ifflag=1; ifdepth=iffail=0;
	return exmacro(m, 1);
}

/* Keyboard macro user routines */

int urecord(BW *bw, int c)
{
	int n;
	struct recmac *r;
	if (c < '0' || c > '9')
		c = query(bw->parent, sz(joe_gettext(_("Macro to record (0-9 or ^C to abort): "))), 0);
	if (c > '9' || c < '0') {
		nungetc(c);
		return -1;
	}
	for (n = 0; n != 10; ++n)
		if (playmode[n])
			return -1;
	r = (struct recmac *) joe_malloc(sizeof(struct recmac));
	r->m = mkmacro(0, 0, 0, NULL);
	r->next = recmac;
	r->n = c - '0';
	recmac = r;
	return 0;
}

int ustop(void)
{
	unmac();
	if (recmac) {
		struct recmac *r = recmac;
		MACRO *m;

		dostaupd = 1;
		recmac = r->next;
		if (kbdmacro[r->n])
			rmmacro(kbdmacro[r->n]);
		kbdmacro[r->n] = r->m;
		if (recmac)
			record(m = mkmacro(r->n + '0', 0, 0, findcmd(USTR "play"))), rmmacro(m);
		joe_free(r);
	}
	return 0;
}


int umacros(BW *bw)
{
	int x;
	unsigned char *buf = vsmk(128);

	p_goto_eol(bw->cursor);
	for (x = 0; x != 10; ++x)
		if (kbdmacro[x]) {
			buf = mtext(buf, kbdmacro[x]);
			binss(bw->cursor, buf);
			p_goto_eol(bw->cursor);
			binss(bw->cursor, vsfmt(buf, 0, USTR "\t^K %c\tMacro %d", x + '0', x));
			p_goto_eol(bw->cursor);
			binsc(bw->cursor, '\n');
			pgetc(bw->cursor);
		}
	return 0;
}

void save_macros(FILE *f)
{
	int x;
	unsigned char *buf = 0;
	for(x = 0; x!= 10; ++x)
		if(kbdmacro[x]) {
			buf = mtext(buf, kbdmacro[x]);
			fprintf(f,"	%d ",x);
			emit_string(f,buf,zlen(buf));
			fprintf(f,"\n");
		}
	fprintf(f,"done\n");
}

void load_macros(FILE *f)
{
	unsigned char *buf = 0;
	unsigned char *bf = 0;
	while(vsgets(&buf,f) && zcmp(buf,USTR "done")) {
		unsigned char *p = buf;
		int n;
		int len;
		int sta;
		parse_ws(&p, '#');
		if(!parse_int(&p,&n)) {
			parse_ws(&p, '#');
			len = parse_string(&p,&bf);
			if (len>0)
				kbdmacro[n] = mparse(NULL,bf,&sta);
		}
	}
}

int uplay(BW *bw, int c)
{
	if (c < '0' || c > '9')
		c = query(bw->parent, sz(joe_gettext(_("Play-"))), QW_STAY);
	if (c >= '0' && c <= '9') {
		int ret;
		c -= '0';
		if (playmode[c] || !kbdmacro[c])
			return -1;
		playmode[c] = 1;
		ret = exmacro(kbdmacro[c], 0);
		playmode[c] = 0;
		return ret;
	} else {
		nungetc(c);
		return -1;
	}
}

/* Repeat-count setting */

int uarg(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(_("No. times to repeat next command (^C to abort): ")),
	NULL, NULL, utypebw, locale_map, 0, 0, NULL);
	if (s) {
		long num;
		num = calc(bw, s);
		if (merr) {
			msgnw(bw->parent, merr);
			return -1;
		}
		arg = num;
		argset = 1;
		return 0;
	} else {
		return -1;
	}
}

int iftest(BW *bw, unsigned char *prompt)
{
	unsigned char *s = ask(bw->parent,prompt,NULL,NULL,utypebw,locale_map,0,0,NULL);
	if (s) {
		long num;
		num=calc(bw,s);
		if(merr) {
			msgnw(bw->parent,merr);
			return -1;
		}
		ifflag = (num ? 1 : 0);
		iffail = ifdepth;
		return 0;
	} else {
		ifdepth--;
		return 0; /* return -1 for prompt creation error? */
	}
}

int uif(BW *bw)
{
	ifdepth++;
	if (!ifflag) return 0;
	return iftest(bw, joe_gettext(_("If (^C to abort): ")));
}

int uelsif(BW *bw)
{
	if (!ifdepth) {
		msgnw(bw->parent,joe_gettext(_("Elsif without if")));
		return -1;
	} else if(ifflag) {
		ifflag=iffail=0; /* don't let the next else/elsif get run */
	} else if(ifdepth == iffail) {
		ifflag=1;	/* so the script can type the condition :) */
		return iftest(bw,joe_gettext(_("Else if: ")));
	}
	return 0;
}

int uelse(BW *bw)
{
	if (!ifdepth) {
		msgnw(bw->parent,joe_gettext(_("Else without if")));
		return -1;
	} else if(ifdepth == iffail) {
		ifflag = !ifflag;
	}
	return 0;
}

int uendif(BW *bw)
{
	if(!ifdepth) {
		msgnw(bw->parent,joe_gettext(_("Endif without if")));
		return -1;
	}
	if(iffail==ifdepth) iffail--, ifflag=1;
	ifdepth--;
	if(ifdepth==0) ifflag=1;
	return 0;
}


int unaarg;
int negarg;

int uuarg(BW *bw, int c)
{
	unsigned char *m;
	unaarg = 0;
	negarg = 0;

	if (c != '-' && (c < '0' || c > '9'))
		c = query(bw->parent, sz(joe_gettext(_("Repeat"))), QW_STAY);

	for (;;) {
		if (c == '-')
			negarg = !negarg;
		else if (c >= '0' && c <= '9')
			unaarg = unaarg * 10 + c - '0';
		else if (c == 'U' - '@@')
			if (unaarg)
				unaarg *= 4;
			else
				unaarg = 16;
		else if (c == 7 || c == 3 || c == 32 || c == -1) {
			return -1;
		} else {
			nungetc(c);
			if (unaarg)
				arg = unaarg;
			else if (negarg)
				arg = 1;
			else
				arg = 4;
			if (negarg)
				arg = -arg;
			argset = 1;
			return 0;
		}
		m = vsfmt(NULL, 0, joe_gettext(_("Repeat %s%d")), negarg ? "-" : "", unaarg);
		c = query(bw->parent, sv(m), QW_STAY);
	}
}
@


1.49
log
@Fixed crash when execmd (Alt+X) is given an empty command, patch by Kevin Glynn (Debian bug #392077)
@
text
@d231 3
@


1.48
log
@More work on coroutine refactoring.
@
text
@d116 6
@


1.47
log
@get uquery to use coroutines: eliminates recursive edloop calls.
@
text
@a352 9
 *
 * Stop recording current macro, make recursive call to edit loop, which
 * runs until dialog is complete, then continue with macro recording.
 *
 * When the macro is played, edit loop is run as a subroutine until dialog
 * is complete, then uquery returns, which continues macro execution.
 *
 * Completion of a dialog is indicated with 'notify' flag (look at interactive
 * dialogs in ufile.c).
d368 1
a368 1
		ret = co_suspend(bw->parent->coro, 0);
a374 11

#if 0
	int ret;
	int oid=ifdepth, oifl=ifflag, oifa=iffail;
	struct recmac *tmp = recmac;

	recmac = NULL;
	ret = edloop(1);
	recmac = tmp;
	ifdepth = oid; ifflag = oifl; iffail = oifa;
#endif
d647 1
a647 1
		c = query(bw->parent, sz(joe_gettext(_("Play-"))), 1);
d758 1
a758 1
		c = query(bw->parent, sz(joe_gettext(_("Repeat"))), 1);
d786 1
a786 1
		c = query(bw->parent, sv(m), 1);
@


1.46
log
@more refactoring
@
text
@d366 20
d394 1
d561 1
a561 1
int exemac(MACRO *m)
d563 1
@


1.45
log
@fix tags.
switch more wmkpw to ask
@
text
@a536 82
#if 0
int exmacro(MACRO *m, int u)
{
	int larg;
	int negarg = 0;
	int flg = 0;
	int oid, oifl, oifa;
	CMD *cmd;
	int ret = 0;

	if (argset) {
		larg = arg;
		arg = 0;
		argset = 0;
		if (larg < 0) {
			negarg = 1;
			larg = -larg;
		}
		if (m->steps)
			negarg = 0;
		else {
			cmd = m->cmd;
			if (!cmd->arg)
				larg = 0;
			else if (negarg) {
				if (cmd->negarg)
					cmd = findcmd(cmd->negarg);
				else
					larg = 0;
			}
		}
	} else {
		cmd = m->cmd;
		larg = 1;
	}

	if (m->steps || larg != 1 || !(cmd->flag & EMINOR)
	    || maint->curwin->watom->what == TYPEQW	/* Undo work right for s & r */
	    )
		flg = 1;

	if (ifflag || (!m->steps && (cmd->flag&EMETA))) {
		if (flg && u)
			umclear();
		while (larg-- && !leave && !ret)
			if (m->steps) {
				MACRO *tmpmac = curmacro;
				int tmpptr = macroptr;
				int x = 0;
				int stk = nstack;

				while (m && x != m->n && !leave && !ret) {
					MACRO *d;

					d = m->steps[x++];
					curmacro = m;
					macroptr = x;
					if(d->steps) oid=ifdepth, oifl=ifflag, oifa=iffail, ifdepth=iffail=0;
					ret = exmacro(d, 0);
					if(d->steps) ifdepth=oid, ifflag=oifl, iffail=oifa;
					m = curmacro;
					x = macroptr;
				}
				curmacro = tmpmac;
				macroptr = tmpptr;
				while (nstack > stk)
					upop(NULL);
			} else
				ret = execmd(cmd, m->k);
		if (leave)
			return ret;
		if (flg && u)
			umclear();

		if (u)
			undomark();
	}

	return ret;
}
#endif

d549 1
a549 1
static int dorecord(BW *bw, int c, void *object, int *notify)
d553 2
a554 3

	if (notify)
		*notify = 1;
a562 1

a569 10
int urecord(BW *bw, int c)
{
	if (c >= '0' && c <= '9')
		return dorecord(bw, c, NULL, NULL);
	else if (mkqw(bw->parent, sz(joe_gettext(_("Macro to record (0-9 or ^C to abort): "))), dorecord, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

a588 19
static int doplay(BW *bw, int c, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (c >= '0' && c <= '9') {
		int ret;

		c -= '0';
		if (playmode[c] || !kbdmacro[c])
			return -1;
		playmode[c] = 1;
		ret = exmacro(kbdmacro[c], 0);
		playmode[c] = 0;
		return ret;
	} else {
		nungetc(c);
		return -1;
	}
}
d644 13
a656 5
	if (c >= '0' && c <= '9')
		return doplay(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sz(joe_gettext(_("Play-"))), doplay, NULL, NULL, NULL))
		return 0;
	else
d658 1
d666 1
a666 1
	NULL, NULL, utypebw, NULL, locale_map, 0, 0, NULL);
d684 1
a684 1
	unsigned char *s = ask(bw->parent,prompt,NULL,NULL,utypebw,NULL,locale_map,0,0,NULL);
d749 1
a749 1
static int douarg(BW *bw, int c, void *object, int *notify)
a751 37
	if (c == '-')
		negarg = !negarg;
	else if (c >= '0' && c <= '9')
		unaarg = unaarg * 10 + c - '0';
	else if (c == 'U' - '@@')
		if (unaarg)
			unaarg *= 4;
		else
			unaarg = 16;
	else if (c == 7 || c == 3 || c == 32) {
		if (notify)
			*notify = 1;
		return -1;
	} else {
		nungetc(c);
		if (unaarg)
			arg = unaarg;
		else if (negarg)
			arg = 1;
		else
			arg = 4;
		if (negarg)
			arg = -arg;
		argset = 1;
		if (notify)
			*notify = 1;
		return 0;
	}
	m = vsfmt(NULL, 0, joe_gettext(_("Repeat %s%d")), negarg ? "-" : "", unaarg);
	if (mkqwna(bw->parent, sv(m), douarg, NULL, NULL, notify))
		return 0;
	else
		return -1;
}

int uuarg(BW *bw, int c)
{
d754 32
a785 6
	if ((c >= '0' && c <= '9') || c == '-')
		return douarg(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sz(joe_gettext(_("Repeat"))), douarg, NULL, NULL, NULL))
		return 0;
	else
		return -1;
@


1.44
log
@coroutines
@
text
@d767 1
a767 1
static int doarg(BW *bw, unsigned char *s, void *object, int *notify)
d769 13
a781 7
	long num;

	if (notify)
		*notify = 1;
	num = calc(bw, s);
	if (merr) {
		msgnw(bw->parent, merr);
a783 3
	arg = num;
	argset = 1;
	return 0;
d786 1
a786 1
int uarg(BW *bw)
d788 10
a797 1
	if (wmkpw(bw->parent, joe_gettext(_("No. times to repeat next command (^C to abort): ")), NULL, doarg, NULL, NULL, utypebw, NULL, NULL, locale_map,0))
d799 4
a802 19
	else
		return -1;
}

static int doif(BW *bw,unsigned char *s,void *object,int *notify)
{
	long num;
	if(notify) *notify=1;
	num=calc(bw,s);
	if(merr) { msgnw(bw->parent,merr); return -1; }
	ifflag=(num?1:0);
	iffail=ifdepth;
	return 0;
}

static int ifabrt()
{
	ifdepth--;
	return 0;
d809 1
a809 2
	if (wmkpw(bw->parent,joe_gettext(_("If (^C to abort): ")),NULL,doif,NULL,ifabrt,utypebw,NULL,NULL,locale_map,0)) return 0;
	else return -1;
d821 1
a821 2
		if(wmkpw(bw->parent,joe_gettext(_("Else if: ")),NULL,doif,NULL,NULL,utypebw,NULL,NULL,locale_map,0)) return 0;
		else return -1;
@


1.43
log
@get rid of debug message
@
text
@a383 2
/* Execute a macro which is just a simple command */

@


1.42
log
@semiautomatic variables
@
text
@a200 2
			if (!cmd)
				printf("Unknown command |%s|\n",buf + x);
@


1.41
log
@UC -> USTR
@
text
@d201 2
a251 1
static unsigned char *ptr;
d258 2
a259 2
		*ptr++ = '\\';
		*ptr++ = '"';
d261 2
a262 2
		*ptr++ = '\\';
		*ptr++ = '\\';
d264 2
a265 2
		*ptr++ = '\\';
		*ptr++ = '\'';
d268 4
a271 4
		*ptr++ = '\\';
		*ptr++ = 'x';
		*ptr++ = "0123456789ABCDEF"[c >> 4];
		*ptr++ = "0123456789ABCDEF"[c & 15];
d273 1
a273 1
		*ptr++ = c;
d277 1
a277 1
static void domtext(MACRO *m)
d282 1
a282 1
		return;
d285 1
a285 1
			domtext(m->steps[x]);
d288 1
a288 1
			*ptr++ = '\"';
d294 1
a294 1
			*ptr++ = ',';
d297 1
a297 1
				*ptr++ = '\"';
d302 1
a302 2
			for (x = 0; m->cmd->name[x]; ++x)
				*ptr++ = m->cmd->name[x];
d304 2
a305 2
				*ptr++ = ',';
				*ptr++ = '"';
d307 1
a307 1
				*ptr++ = '"';
d311 1
d316 1
a316 1
	ptr = s;
d319 1
a319 1
	domtext(m);
d321 1
a321 2
		*ptr++ = '\"';
	*ptr = 0;
d710 1
a710 1
	unsigned char buf[1024];
d715 1
a715 1
			mtext(buf, kbdmacro[x]);
d718 1
a718 2
			joe_snprintf_2(buf, JOE_MSGBUFSIZE, "\t^K %c\tMacro %d", x + '0', x);
			binss(bw->cursor, buf);
d729 1
a729 1
	unsigned char buf[1024];
d732 1
a732 1
			mtext(buf, kbdmacro[x]);
d742 3
a744 3
	unsigned char buf[1024];
	unsigned char bf[1024];
	while(fgets((char *)buf,1023,f) && zcmp(buf,USTR "done\n")) {
d752 1
a752 1
			len = parse_string(&p,bf,sizeof(bf));
a783 1
	vsrm(s);
a802 1
	vsrm(s);
d864 1
d893 2
a894 2
	joe_snprintf_2(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Repeat %s%d")), negarg ? "-" : "", unaarg);
	if (mkqwna(bw->parent, sz(msgbuf), douarg, NULL, NULL, notify))
@


1.40
log
@change US to UC
@
text
@d181 1
a181 1
			addmacro(m, mkmacro(buf[x], 0, 0, findcmd(UC "type")));
d286 1
a286 1
		if (instr && zcmp(m->cmd->name, UC "type")) {
d294 1
a294 1
		if (!zcmp(m->cmd->name, UC "type")) {
d303 1
a303 1
			if (!zcmp(m->cmd->name, UC "play") || !zcmp(m->cmd->name, UC "gomark") || !zcmp(m->cmd->name, UC "setmark") || !zcmp(m->cmd->name, UC "record") || !zcmp(m->cmd->name, UC "uarg")) {
d681 1
a681 1
			record(m = mkmacro(r->n + '0', 0, 0, findcmd(UC "play"))), rmmacro(m);
d745 1
a745 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,UC "done\n")) {
@


1.39
log
@gettext()
@
text
@d181 1
a181 1
			addmacro(m, mkmacro(buf[x], 0, 0, findcmd(US "type")));
d286 1
a286 1
		if (instr && zcmp(m->cmd->name, US "type")) {
d294 1
a294 1
		if (!zcmp(m->cmd->name, US "type")) {
d303 1
a303 1
			if (!zcmp(m->cmd->name, US "play") || !zcmp(m->cmd->name, US "gomark") || !zcmp(m->cmd->name, US "setmark") || !zcmp(m->cmd->name, US "record") || !zcmp(m->cmd->name, US "uarg")) {
d681 1
a681 1
			record(m = mkmacro(r->n + '0', 0, 0, findcmd(US "play"))), rmmacro(m);
d745 1
a745 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,US "done\n")) {
@


1.38
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d662 1
a662 1
	else if (mkqw(bw->parent, sc("Macro to record (0-9 or ^C to abort): "), dorecord, NULL, NULL, NULL))
d718 1
a718 1
			joe_snprintf_2((char *)buf, JOE_MSGBUFSIZE, "\t^K %c\tMacro %d", x + '0', x);
d764 1
a764 1
	else if (mkqwna(bw->parent, sc("Play-"), doplay, NULL, NULL, NULL))
d791 1
a791 1
	if (wmkpw(bw->parent, US "No. times to repeat next command (^C to abort): ", NULL, doarg, NULL, NULL, utypebw, NULL, NULL, locale_map,0))
d819 1
a819 1
	if (wmkpw(bw->parent,US "If (^C to abort): ",NULL,doif,NULL,ifabrt,utypebw,NULL,NULL,locale_map,0)) return 0;
d826 1
a826 1
		msgnw(bw->parent,US "Elsif without if");
d832 1
a832 1
		if(wmkpw(bw->parent,US "Else if: ",NULL,doif,NULL,NULL,utypebw,NULL,NULL,locale_map,0)) return 0;
d841 1
a841 1
		msgnw(bw->parent,US "Else without if");
d852 1
a852 1
		msgnw(bw->parent,US "Endif without if");
d895 1
a895 1
	joe_snprintf_2((char *)msgbuf, JOE_MSGBUFSIZE, "Repeat %s%d", negarg ? "-" : "", unaarg);
d908 1
a908 1
	else if (mkqwna(bw->parent, sc("Repeat"), douarg, NULL, NULL, NULL))
@


1.37
log
@Allow escape sequences in strings.
@
text
@a7 1
#include "config.h"
a9 21
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "b.h"
#include "cmd.h"
#include "main.h"
#include "pw.h"
#include "qw.h"
#include "tty.h"
#include "ublock.h"
#include "uedit.h"
#include "umath.h"
#include "undo.h"
#include "utils.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"

d435 1
a435 1
	int oid, oifl, oifa;
a667 2
extern volatile int dostaupd;

d812 1
d835 1
@


1.36
log
@fix gcc-4.0.0 warnings
@
text
@d759 1
a759 1
			emit_hdlc(f,buf,zlen(buf));
d777 1
a777 1
			len = parse_hdlc(&p,bf,1023);
@


1.35
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@a11 1
#include <string.h>
d308 1
a308 1
		if (instr && strcmp(m->cmd->name, "type")) {
d316 1
a316 1
		if (!strcmp(m->cmd->name, "type")) {
d325 1
a325 1
			if (!strcmp(m->cmd->name, "play") || !strcmp(m->cmd->name, "gomark") || !strcmp(m->cmd->name, "setmark") || !strcmp(m->cmd->name, "record") || !strcmp(m->cmd->name, "uarg")) {
d759 1
a759 1
			emit_hdlc(f,buf,strlen((char *)buf));
d769 1
a769 1
	while(fgets((char *)buf,1023,f) && strcmp((char *)buf,"done\n")) {
@


1.34
log
@hex edit mode
@
text
@d760 1
a760 1
			emit_hdlc(f,buf,strlen(buf));
d770 1
a770 1
	while(fgets(buf,1023,f) && strcmp(buf,"done\n")) {
d850 1
a850 1
		msgnw(bw->parent,"Elsif without if");
d856 1
a856 1
		if(wmkpw(bw->parent,"Else if: ",NULL,doif,NULL,NULL,utypebw,NULL,NULL,locale_map,0)) return 0;
d864 1
a864 1
		msgnw(bw->parent,"Else without if");
d875 1
a875 1
		msgnw(bw->parent,"Endif without if");
@


1.33
log
@fix locks bug, jmacs improvements
@
text
@d500 2
d506 2
a507 2
				int tmp_arg = current_arg;
				int tmp_set = current_arg_set;
@


1.32
log
@Enhance macros again.  Improve jmacs.  Fix != in math.
@
text
@d461 2
a462 3

	int tmp_arg = current_arg;
	int tmp_set = current_arg_set;
a467 2
		current_arg = arg;
		current_arg_set = 1;
a471 2
		current_arg_set = 0;
		current_arg = 1;
d477 1
a477 2
		ret = exsimple(m, larg, u);
		goto done;
d504 5
d513 2
a514 2
					argset = current_arg_set;
					arg = current_arg;
d536 2
a558 5
	done:

	current_arg = tmp_arg;
	current_arg_set = tmp_set;

@


1.31
log
@improve macro language...
@
text
@d213 4
a216 1
		for (y = x; buf[y] && buf[y] != '!' && buf[y] !='-' && buf[y] != ',' && buf[y] != ' ' && buf[y] != '\t' && buf[y] != '\n' && buf[x] != '\r'; ++y) ;
d227 1
a227 1
			while (buf[x]=='-' || buf[x]=='!') {
d230 2
d451 3
d462 3
d469 2
d475 2
d481 4
a484 2
	if (!m->steps)
		return exsimple(m, larg, u);
d497 1
a497 1
		while (larg-- && !leave && !ret) {
d513 5
a517 1
				if ((d->flg&1) && negarg) {
d526 4
d546 1
d557 6
@


1.30
log
@Fix ~ expansion insanity
@
text
@d37 1
a37 1
MACRO *mkmacro(int k, int arg, int n, CMD *cmd)
d45 1
a45 1
		for (x = 0; x != 64; ++x) {	/* FIXME: why limit to 64? */
d54 1
a54 1
	macro->arg = arg;
d95 1
a95 1
	MACRO *m = mkmacro(mac->k, mac->arg, mac->n, mac->cmd);
d115 1
a115 1
/* Set arg part of macro */
d119 1
a119 1
	m->arg = a;
d199 1
a199 1
					m = mkmacro(-1, 1, 0, NULL);
d203 2
a204 2
				m = mkmacro(-1, 1, 0, NULL);
			addmacro(m, mkmacro(buf[x], 1, 0, findcmd(US "type")));
d213 1
a213 1
		for (y = x; buf[y] && buf[y] != ',' && buf[y] != ' ' && buf[y] != '\t' && buf[y] != '\n' && buf[x] != '\r'; ++y) ;
d216 1
d221 9
d237 1
a237 1
					m = mkmacro(-1, 1, 0, NULL);
d240 1
a240 1
				addmacro(m, mkmacro(-1, 1, 0, cmd));
d242 1
a242 2
				m = mkmacro(-1, 1, 0, cmd);
			buf[x = y] = c;
d404 131
d614 1
d644 1
a644 1
	r->m = mkmacro(0, 1, 0, NULL);
d676 1
a676 1
			record(m = mkmacro(r->n + '0', 1, 0, findcmd(US "play"))), rmmacro(m);
@


1.29
log
@Perforce macro and support for it.
@
text
@d645 1
a645 1
	if (wmkpw(bw->parent, US "No. times to repeat next command (^C to abort): ", NULL, doarg, NULL, NULL, utypebw, NULL, NULL, locale_map))
d672 1
a672 1
	if (wmkpw(bw->parent,US "If (^C to abort): ",NULL,doif,NULL,ifabrt,utypebw,NULL,NULL,locale_map)) return 0;
d685 1
a685 1
		if(wmkpw(bw->parent,"Else if: ",NULL,doif,NULL,NULL,utypebw,NULL,NULL,locale_map)) return 0;
@


1.28
log
@file locking.
@
text
@d475 2
a476 1
/* Execute a macro */
@


1.27
log
@Fix bugs with "if"
@
text
@d363 11
a373 1
/* Query for user input */
@


1.26
log
@Jesse McGrew's xterm mouse support.
@
text
@d661 1
a661 1
	if (wmkpw(bw->parent,"If (^C to abort): ",NULL,doif,NULL,ifabrt,utypebw,NULL,NULL,NULL)) return 0;
d674 1
a674 1
		if(wmkpw(bw->parent,"Else if: ",NULL,doif,NULL,NULL,utypebw,NULL,NULL,NULL)) return 0;
@


1.25
log
@Clean up .joe_state file stuff some more.
@
text
@d359 4
d368 1
d374 1
d390 1
d425 32
a456 29
	if (flg && u)
		umclear();
	while (larg-- && !leave && !ret)
		if (m->steps) {
			MACRO *tmpmac = curmacro;
			int tmpptr = macroptr;
			int x = 0;
			int stk = nstack;

			while (m && x != m->n && !leave && !ret) {
				MACRO *d;

				d = m->steps[x++];
				curmacro = m;
				macroptr = x;
				ret = exmacro(d, 0);
				m = curmacro;
				x = macroptr;
			}
			curmacro = tmpmac;
			macroptr = tmpptr;
			while (nstack > stk)
				upop(NULL);
		} else
			ret = execmd(cmd, m->k);
	if (leave)
		return ret;
	if (flg && u)
		umclear();
d458 3
a460 2
	if (u)
		undomark();
d470 1
d640 63
@


1.24
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@d585 2
a586 1
			kbdmacro[n] = mparse(NULL,bf,&sta);
@


1.23
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d263 1
a263 1
static unsigned char *unescape(unsigned char *ptr, int c)
d268 3
d558 32
@


1.22
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d546 1
a546 1
			snprintf((char *)buf, JOE_MSGBUFSIZE, "\t^K %c\tMacro %d", x + '0', x);
d625 1
a625 1
	snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Repeat %s%d", negarg ? "-" : "", unaarg);
@


1.21
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d29 2
d136 1
a136 1
	while (joe_isblank(buf[x]))
d238 1
a238 1
	while (joe_isblank(buf[x]))
d244 1
a244 1
		while (joe_isblank(buf[x]))
d586 1
a586 1
	if (wmkpw(bw->parent, US "No. times to repeat next command (^C to abort): ", NULL, doarg, NULL, NULL, utypebw, NULL, NULL, -1))
@


1.20
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d584 1
a584 1
	if (wmkpw(bw->parent, US "No. times to repeat next command (^C to abort): ", NULL, doarg, NULL, NULL, utypebw, NULL, NULL))
@


1.19
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d134 1
a134 1
	while (isblank(buf[x]))
d236 1
a236 1
	while (isblank(buf[x]))
d242 1
a242 1
		while (isblank(buf[x]))
@


1.18
log
@change 0 to NULL where we're talking about pointers
@
text
@d197 1
a197 1
					m = mkmacro(MAXINT, 1, 0, NULL);
d201 2
a202 2
				m = mkmacro(MAXINT, 1, 0, NULL);
			addmacro(m, mkmacro(buf[x], 1, 0, findcmd("type")));
d225 1
a225 1
					m = mkmacro(MAXINT, 1, 0, NULL);
d228 1
a228 1
				addmacro(m, mkmacro(MAXINT, 1, 0, cmd));
d230 1
a230 1
				m = mkmacro(MAXINT, 1, 0, cmd);
d257 1
a257 1
static char *ptr;
d261 1
a261 1
static char *unescape(char *ptr, int c)
d317 1
a317 1
char *mtext(char *s, MACRO *m)
d507 1
a507 1
			record(m = mkmacro(r->n + '0', 1, 0, findcmd("play"))), rmmacro(m);
d536 1
a536 1
	char buf[1024];
d544 1
a544 1
			snprintf(buf, JOE_MSGBUFSIZE, "\t^K %c\tMacro %d", x + '0', x);
d565 1
a565 1
static int doarg(BW *bw, char *s, void *object, int *notify)
d584 1
a584 1
	if (wmkpw(bw->parent, "No. times to repeat next command (^C to abort): ", NULL, doarg, NULL, NULL, utypebw, NULL, NULL))
d623 1
a623 1
	snprintf(msgbuf, JOE_MSGBUFSIZE, "Repeat %s%d", negarg ? "-" : "", unaarg);
@


1.17
log
@change type of variables holding string to unsigned char *
@
text
@d31 1
a31 1
MACRO *freemacros = 0;
d50 1
a50 1
	macro->steps = 0;
d220 1
a220 1
				return 0;
d334 1
a334 1
struct recmac *recmac = 0;
d361 1
a361 1
	recmac = 0;
d369 1
a369 1
MACRO *curmacro = 0;		/* Set if we're in a macro */
@


1.16
log
@fix segafults in isalpha()-like functions
@
text
@d127 1
a127 1
MACRO *mparse(MACRO *m, char *buf, int *sta)
@


1.15
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d270 1
@


1.14
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d43 4
a46 2
		for (x = 0; x != 64; ++x)	/* FIXME: why limit to 64? */
			macro[x].steps = (MACRO **) freemacros, freemacros = macro + x;
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d261 7
a267 5
	if (c == '"')
		*ptr++ = '\\', *ptr++ = '"';
	else if (c == '\'')
		*ptr++ = '\\', *ptr++ = '\'';
	else if (c < 32 || c > 126) {
d287 4
a290 2
		if (instr && strcmp(m->cmd->name, "type"))
			*ptr++ = '\"', instr = 0;
d296 4
a299 2
			if (!instr)
				*ptr++ = '\"', instr = 1;
d383 4
a386 2
		if (larg < 0)
			negarg = 1, larg = -larg;
@


1.12
log
@change indentation of cases in the switch() statement
@
text
@d42 2
a43 2
		macro = (MACRO *) malloc(sizeof(MACRO) * 64);
		for (x = 0; x != 64; ++x)
d67 1
a67 1
			free(macro->steps);
d80 1
a80 1
			macro->steps = (MACRO **) realloc(macro->steps, (macro->size += 8) * sizeof(MACRO *));
d82 1
a82 1
			macro->steps = (MACRO **) malloc((macro->size = 8) * sizeof(MACRO *));
d96 1
a96 1
		m->steps = (MACRO **) malloc((m->size = mac->n) * sizeof(MACRO *));
d462 1
a462 1
	r = (struct recmac *) malloc(sizeof(struct recmac));
d497 1
a497 1
		free(r);
@


1.11
log
@include only headers which are needed
@
text
@d142 1
a142 1
					case 'n':
d145 1
a145 1
					case 'r':
d148 1
a148 1
					case 'b':
d151 1
a151 1
					case 'f':
d154 1
a154 1
					case 'a':
d157 1
a157 1
					case 't':
d160 1
a160 1
					case 'x':
d172 10
a181 10
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@d17 2
d20 1
d22 1
a22 5
#include "pw.h"
#include "bw.h"
#include "vs.h"
#include "undo.h"
#include "cmd.h"
d24 1
d26 1
a26 2
#include "uedit.h"
#include "macro.h"
d28 1
@


1.9
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@a0 1

d2 6
a7 6
	Keyboard macros
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/

d9 1
@


1.8
log
@use mkqw(W *, ...) instead of mkqw(BASE *, ...) (ditto. mkqwna() and mkqwnsr())
@
text
@d533 1
a533 1
			snprintf(buf, MSGBUFSIZE, "\t^K %c\tMacro %d", x + '0', x);
d612 1
a612 1
	snprintf(msgbuf, MSGBUFSIZE, "Repeat %s%d", negarg ? "-" : "", unaarg);
@


1.7
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d475 1
a475 1
	else if (mkqw(bw, sc("Macro to record (0-9 or ^C to abort): "), dorecord, NULL, NULL, NULL))
d546 1
a546 1
	else if (mkqwna(bw, sc("Play-"), doplay, NULL, NULL, NULL))
d613 1
a613 1
	if (mkqwna(bw, sz(msgbuf), douarg, NULL, NULL, notify))
d625 1
a625 1
	else if (mkqwna(bw, sc("Repeat"), douarg, NULL, NULL, NULL))
@


1.6
log
@version 2.9.7-pre3
@
text
@d562 1
a562 1
		msgnw(bw, merr);
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d35 1
a35 2
MACRO *mkmacro(k, arg, n, cmd)
CMD *cmd;
d59 1
a59 2
void rmmacro(macro)
MACRO *macro;
d76 1
a76 2
void addmacro(macro, m)
MACRO *macro, *m;
d89 1
a89 2
MACRO *dupmacro(mac)
MACRO *mac;
d105 1
a105 2
MACRO *macstk(m, k)
MACRO *m;
d113 1
a113 2
MACRO *macsta(m, a)
MACRO *m;
d125 1
a125 4
MACRO *mparse(m, buf, sta)
MACRO *m;
char *buf;
int *sta;
d259 1
a259 2
char *unescape(ptr, c)
char *ptr;
d275 1
a275 2
void domtext(m)
MACRO *m;
d308 1
a308 3
char *mtext(s, m)
char *s;
MACRO *m;
d327 1
a327 1
static void unmac()
d333 1
a333 1
void chmac()
d339 1
a339 2
static void record(m)
MACRO *m;
d347 1
a347 2
int uquery(bw)
BW *bw;
d365 1
a365 2
int exmacro(m, u)
MACRO *m;
d440 1
a440 2
int exemac(m)
MACRO *m;
d448 1
a448 4
static int dorecord(bw, c, object, notify)
BW *bw;
void *object;
int *notify;
d471 1
a471 2
int urecord(bw, c)
BW *bw;
d483 1
a483 1
int ustop()
d502 1
a502 4
int doplay(bw, c, object, notify)
BW *bw;
void *object;
int *notify;
d522 1
a522 2
int umacros(bw)
BW *bw;
d542 1
a542 2
int uplay(bw, c)
BW *bw;
d554 1
a554 5
static int doarg(bw, s, object, notify)
BW *bw;
char *s;
void *object;
int *notify;
d571 1
a571 2
int uarg(bw)
BW *bw;
d582 1
a582 4
int douarg(bw, c, object, notify)
BW *bw;
void *object;
int *notify;
d619 1
a619 2
int uuarg(bw, c)
BW *bw;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d1 1
d9 2
d13 4
d29 1
a29 1
#include <ctype.h>
d35 2
a36 3
MACRO *
mkmacro (k, arg, n, cmd)
     CMD *cmd;
d39 8
a46 8
	if (!freemacros)
	  {
		  int x;
		  macro = (MACRO *) malloc (sizeof (MACRO) * 64);
		  for (x = 0; x != 64; ++x)
			  macro[x].steps = (MACRO **) freemacros,
				  freemacros = macro + x;
	  }
d60 14
a73 16
void
rmmacro (macro)
     MACRO *macro;
{
	if (macro)
	  {
		  if (macro->steps)
		    {
			    int x;
			    for (x = 0; x != macro->n; ++x)
				    rmmacro (macro->steps[x]);
			    free (macro->steps);
		    }
		  macro->steps = (MACRO **) freemacros;
		  freemacros = macro;
	  }
d78 2
a79 3
void
addmacro (macro, m)
     MACRO *macro, *m;
d81 1
a81 1
	if (macro->n == macro->size)
d83 1
a83 4
			macro->steps =
				(MACRO **) realloc (macro->steps,
						    (macro->size +=
						     8) * sizeof (MACRO *));
d85 2
a86 3
			macro->steps =
				(MACRO **) malloc ((macro->size = 8) *
						   sizeof (MACRO *));
d92 12
a103 14
MACRO *
dupmacro (mac)
     MACRO *mac;
{
	MACRO *m = mkmacro (mac->k, mac->arg, mac->n, mac->cmd);
	if (mac->steps)
	  {
		  int x;
		  m->steps =
			  (MACRO **) malloc ((m->size = mac->n) *
					     sizeof (MACRO *));
		  for (x = 0; x != m->n; ++x)
			  m->steps[x] = dupmacro (mac->steps[x]);
	  }
d109 2
a110 3
MACRO *
macstk (m, k)
     MACRO *m;
d118 2
a119 3
MACRO *
macsta (m, a)
     MACRO *m;
d131 4
a134 5
MACRO *
mparse (m, buf, sta)
     MACRO *m;
     char *buf;
     int *sta;
d141 1
a141 1
	while (isblank (buf[x]))
d145 6
a150 10
	if (buf[x] == '\"')
	  {
		  ++x;
		  while (buf[x] && buf[x] != '\"')
		    {
			    if (buf[x] == '\\' && buf[x + 1])
			      {
				      ++x;
				      switch (buf[x])
					{
d152 2
a153 2
						buf[x] = 10;
						break;
d155 2
a156 2
						buf[x] = 13;
						break;
d158 2
a159 2
						buf[x] = 8;
						break;
d161 2
a162 2
						buf[x] = 12;
						break;
d164 2
a165 2
						buf[x] = 7;
						break;
d167 2
a168 2
						buf[x] = 9;
						break;
d170 11
a180 31
						c = 0;
						if (buf[x + 1] >= '0'
						    && buf[x + 1] <= '9')
							c =
								c * 16 +
								buf[++x] -
								'0';
						else if (buf[x + 1] >= 'a'
							 && buf[x + 1] <= 'f'
							 || buf[x + 1] >= 'A'
							 && buf[x + 1] <= 'F')
							c =
								c * 16 +
								(buf[++x] &
								 0xF) + 9;
						if (buf[x + 1] >= '0'
						    && buf[x + 1] <= '9')
							c =
								c * 16 +
								buf[++x] -
								'0';
						else if (buf[x + 1] >= 'a'
							 && buf[x + 1] <= 'f'
							 || buf[x + 1] >= 'A'
							 && buf[x + 1] <= 'F')
							c =
								c * 16 +
								(buf[++x] &
								 0xF) + 9;
						buf[x] = c;
						break;
d191 24
a214 38
						c = buf[x] - '0';
						if (buf[x + 1] >= '0'
						    && buf[x + 1] <= '7')
							c =
								c * 8 +
								buf[++x] -
								'0';
						if (buf[x + 1] >= '0'
						    && buf[x + 1] <= '7')
							c =
								c * 8 +
								buf[++x] -
								'0';
						buf[x] = c;
						break;
					}
			      }
			    if (m)
			      {
				      if (!m->steps)
					{
						MACRO *macro = m;
						m =
							mkmacro (MAXINT, 1, 0,
								 NULL);
						addmacro (m, macro);
					}
			      }
			    else
				    m = mkmacro (MAXINT, 1, 0, NULL);
			    addmacro (m,
				      mkmacro (buf[x], 1, 0,
					       findcmd ("type")));
			    ++x;
		    }
		  if (buf[x] == '\"')
			  ++x;
	  }
d217 24
a240 35
	else
	  {
		  for (y = x;
		       buf[y] && buf[y] != ',' && buf[y] != ' '
		       && buf[y] != '\t' && buf[y] != '\n' && buf[x] != '\r';
		       ++y);
		  if (y != x)
		    {
			    CMD *cmd;
			    c = buf[y];
			    buf[y] = 0;
			    cmd = findcmd (buf + x);
			    if (!cmd)
			      {
				      *sta = -1;
				      return 0;
			      }
			    else if (m)
			      {
				      if (!m->steps)
					{
						MACRO *macro = m;
						m =
							mkmacro (MAXINT, 1, 0,
								 NULL);
						addmacro (m, macro);
					}
				      addmacro (m,
						mkmacro (MAXINT, 1, 0, cmd));
			      }
			    else
				    m = mkmacro (MAXINT, 1, 0, cmd);
			    buf[x = y] = c;
		    }
	  }
d243 1
a243 1
	while (isblank (buf[x]))
d247 9
a255 10
	if (buf[x] == ',')
	  {
		  ++x;
		  while (isblank (buf[x]))
			  ++x;
		  if (buf[x] && buf[x] != '\r' && buf[x] != '\n')
			  goto macroloop;
		  *sta = -2;
		  return m;
	  }
d268 2
a269 3
char *
unescape (ptr, c)
     char *ptr;
d275 6
a280 8
	else if (c < 32 || c > 126)
	  {
		  *ptr++ = '\\';
		  *ptr++ = 'x';
		  *ptr++ = "0123456789ABCDEF"[c >> 4];
		  *ptr++ = "0123456789ABCDEF"[c & 15];
	  }
	else
d285 2
a286 3
void
domtext (m)
     MACRO *m;
d289 1
d294 28
a321 38
			domtext (m->steps[x]);
	else
	  {
		  if (instr && strcmp (m->cmd->name, "type"))
			  *ptr++ = '\"', instr = 0;
		  if (first)
			  first = 0;
		  else if (!instr)
			  *ptr++ = ',';
		  if (!strcmp (m->cmd->name, "type"))
		    {
			    if (!instr)
				    *ptr++ = '\"', instr = 1;
			    ptr = unescape (ptr, m->k);
		    }
		  else
		    {
			    for (x = 0; m->cmd->name[x]; ++x)
				    *ptr++ = m->cmd->name[x];
			    if (!strcmp (m->cmd->name, "play") ||
				!strcmp (m->cmd->name, "gomark") ||
				!strcmp (m->cmd->name, "setmark") ||
				!strcmp (m->cmd->name, "record") ||
				!strcmp (m->cmd->name, "uarg"))
			      {
				      *ptr++ = ',';
				      *ptr++ = '"';
				      ptr = unescape (ptr, m->k);
				      *ptr++ = '"';
			      }
		    }
	  }
}

char *
mtext (s, m)
     char *s;
     MACRO *m;
d326 1
a326 1
	domtext (m);
d340 1
a340 2
static void
unmac ()
d343 1
a343 1
		rmmacro (recmac->m->steps[--recmac->m->n]);
d346 1
a346 2
void
chmac ()
d352 2
a353 3
static void
record (m)
     MACRO *m;
d356 1
a356 1
		addmacro (recmac->m, dupmacro (m));
d361 2
a362 3
int
uquery (bw)
     BW *bw;
d366 1
d368 1
a368 1
	ret = edloop (1);
d380 2
a381 3
int
exmacro (m, u)
     MACRO *m;
a386 1
	int n;
d389 27
a415 31
	if (argset)
	  {
		  larg = arg;
		  arg = 0;
		  argset = 0;
		  if (larg < 0)
			  negarg = 1, larg = -larg;
		  if (m->steps)
			  negarg = 0;
		  else
		    {
			    cmd = m->cmd;
			    if (!cmd->arg)
				    larg = 0;
			    else if (negarg)
				    if (cmd->negarg)
					    cmd = findcmd (cmd->negarg);
				    else
					    larg = 0;
		    }
	  }
	else
	  {
		  cmd = m->cmd;
		  larg = 1;
	  }

	if (m->steps ||
	    larg != 1 ||
	    !(cmd->flag & EMINOR) || maint->curwin->watom->what == TYPEQW	/* Undo work right for s & r */
		)
d419 1
a419 1
		umclear ();
d421 22
a442 23
		if (m->steps)
		  {
			  MACRO *tmpmac = curmacro;
			  int tmpptr = macroptr;
			  int x = 0;
			  int stk = nstack;
			  while (m && x != m->n && !leave && !ret)
			    {
				    MACRO *d;
				    d = m->steps[x++];
				    curmacro = m;
				    macroptr = x;
				    ret = exmacro (d, 0);
				    m = curmacro;
				    x = macroptr;
			    }
			  curmacro = tmpmac;
			  macroptr = tmpptr;
			  while (nstack > stk)
				  upop (NULL);
		  }
		else
			ret = execmd (cmd, m->k);
d446 1
a446 1
		umclear ();
d449 1
a449 1
		undomark ();
d456 2
a457 3
int
exemac (m)
     MACRO *m;
d459 2
a460 2
	record (m);
	return exmacro (m, 1);
d465 4
a468 5
static int
dorecord (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
d472 1
d475 4
a478 5
	if (c > '9' || c < '0')
	  {
		  nungetc (c);
		  return -1;
	  }
d482 3
a484 2
	r = (struct recmac *) malloc (sizeof (struct recmac));
	r->m = mkmacro (0, 1, 0, NULL);
d491 2
a492 3
int
urecord (bw, c)
     BW *bw;
d495 2
a496 5
		return dorecord (bw, c, NULL, NULL);
	else
		if (mkqw
		    (bw->parent, sc ("Macro to record (0-9 or ^C to abort): "),
		     dorecord, NULL, NULL, NULL))
d504 1
a504 2
int
ustop ()
d506 14
a519 16
	unmac ();
	if (recmac)
	  {
		  struct recmac *r = recmac;
		  MACRO *m;
		  dostaupd = 1;
		  recmac = r->next;
		  if (kbdmacro[r->n])
			  rmmacro (kbdmacro[r->n]);
		  kbdmacro[r->n] = r->m;
		  if (recmac)
			  record (m =
				  mkmacro (r->n + '0', 1, 0,
					   findcmd ("play"))), rmmacro (m);
		  free (r);
	  }
d523 4
a526 5
int
doplay (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
d530 14
a543 16
	if (c >= '0' && c <= '9')
	  {
		  int ret;
		  c -= '0';
		  if (playmode[c] || !kbdmacro[c])
			  return -1;
		  playmode[c] = 1;
		  ret = exmacro (kbdmacro[c], 0);
		  playmode[c] = 0;
		  return ret;
	  }
	else
	  {
		  nungetc (c);
		  return -1;
	  }
d546 2
a547 3
int
umacros (bw)
     BW *bw;
d551 2
a552 1
	p_goto_eol (bw->cursor);
d554 10
a563 11
		if (kbdmacro[x])
		  {
			  mtext (buf, kbdmacro[x]);
			  binss (bw->cursor, buf);
			  p_goto_eol (bw->cursor);
			  snprintf (buf, sizeof(buf), "\t^K %c\tMacro %d", x + '0', x);
			  binss (bw->cursor, buf);
			  p_goto_eol (bw->cursor);
			  binsc (bw->cursor, '\n');
			  pgetc (bw->cursor);
		  }
d567 2
a568 3
int
uplay (bw, c)
     BW *bw;
d571 2
a572 2
		return doplay (bw, c, NULL, NULL);
	else if (mkqwna (bw->parent, sc ("Play-"), doplay, NULL, NULL, NULL))
d580 5
a584 6
static int
doarg (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d587 1
d590 5
a594 6
	num = calc (bw, s);
	if (merr)
	  {
		  msgnw (bw, merr);
		  return -1;
	  }
d597 1
a597 1
	vsrm (s);
d601 4
a604 7
int
uarg (bw)
     BW *bw;
{
	if (wmkpw (bw->parent,
		   "No. times to repeat next command (^C to abort): ",
		   NULL, doarg, NULL, NULL, utypebw, NULL, NULL))
d613 4
a616 5
int
douarg (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
d627 21
a647 24
	else if (c == 7 || c == 3 || c == 32)
	  {
		  if (notify)
			  *notify = 1;
		  return -1;
	  }
	else
	  {
		  nungetc (c);
		  if (unaarg)
			  arg = unaarg;
		  else if (negarg)
			  arg = 1;
		  else
			  arg = 4;
		  if (negarg)
			  arg = -arg;
		  argset = 1;
		  if (notify)
			  *notify = 1;
		  return 0;
	  }
	snprintf (msgbuf, MSGBUFSIZE, "Repeat %s%d", negarg ? "-" : "", unaarg);
	if (mkqwna (bw->parent, sz (msgbuf), douarg, NULL, NULL, notify))
d653 2
a654 3
int
uuarg (bw, c)
     BW *bw;
d658 3
a660 3
	if (c >= '0' && c <= '9' || c == '-')
		return douarg (bw, c, NULL, NULL);
	else if (mkqwna (bw->parent, sc ("Repeat"), douarg, NULL, NULL, NULL))
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Keyboard macros
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d8 1
d21 1
d24 1
a24 1
MACRO *freemacros=0;
d28 23
a50 22
MACRO *mkmacro(k,arg,n,cmd)
CMD *cmd;
 {
 MACRO *macro;
 if(!freemacros)
  {
  int x;
  macro=(MACRO *)malloc(sizeof(MACRO)*64);
  for(x=0;x!=64;++x)
   macro[x].steps=(MACRO **)freemacros,
   freemacros=macro+x;
  }
 macro=freemacros;
 freemacros=(MACRO *)macro->steps;
 macro->steps=0;
 macro->size=0;
 macro->arg=arg;
 macro->n=n;
 macro->cmd=cmd;
 macro->k=k;
 return macro;
 }
d54 17
a70 15
void rmmacro(macro)
MACRO *macro;
 {
 if(macro)
  {
  if(macro->steps)
   {
   int x;
   for(x=0;x!=macro->n;++x) rmmacro(macro->steps[x]);
   free(macro->steps);
   }
  macro->steps=(MACRO **)freemacros;
  freemacros=macro;
  }
 }
d74 16
a89 10
void addmacro(macro,m)
MACRO *macro, *m;
 {
 if(macro->n==macro->size)
  if(macro->steps)
   macro->steps=(MACRO **)realloc(macro->steps,(macro->size+=8)*sizeof(MACRO *));
  else
   macro->steps=(MACRO **)malloc((macro->size=8)*sizeof(MACRO *));
 macro->steps[macro->n++]=m;
 }
d93 16
a108 12
MACRO *dupmacro(mac)
MACRO *mac;
 {
 MACRO *m=mkmacro(mac->k,mac->arg,mac->n,mac->cmd);
 if(mac->steps)
  {
  int x;
  m->steps=(MACRO **)malloc((m->size=mac->n)*sizeof(MACRO *));
  for(x=0;x!=m->n;++x) m->steps[x]=dupmacro(mac->steps[x]);
  }
 return m;
 }
d112 7
a118 6
MACRO *macstk(m,k)
MACRO *m;
 {
 m->k=k;
 return m;
 }
d122 7
a128 6
MACRO *macsta(m,a)
MACRO *m;
 {
 m->arg=a;
 return m;
 }
d136 181
a316 113
MACRO *mparse(m,buf,sta)
MACRO *m;
char *buf;
int *sta;
 {
 int y, c, x=0;

 macroloop:

 /* Skip whitespace */
 while(isblank(buf[x])) ++x;

 /* Do we have a string? */
 if(buf[x]=='\"')
  {
  ++x;
  while(buf[x] && buf[x]!='\"')
   {
   if(buf[x]=='\\' && buf[x+1])
    {
    ++x;
    switch(buf[x])
     {
    case 'n': buf[x]=10; break;
    case 'r': buf[x]=13; break;
    case 'b': buf[x]=8; break;
    case 'f': buf[x]=12; break;
    case 'a': buf[x]=7; break;
    case 't': buf[x]=9; break;
    case 'x':
     c=0;
     if(buf[x+1]>='0' && buf[x+1]<='9') c=c*16+buf[++x]-'0';
     else if(buf[x+1]>='a' && buf[x+1]<='f' ||
             buf[x+1]>='A' && buf[x+1]<='F') c=c*16+(buf[++x]&0xF)+9;
     if(buf[x+1]>='0' && buf[x+1]<='9') c=c*16+buf[++x]-'0';
     else if(buf[x+1]>='a' && buf[x+1]<='f' ||
             buf[x+1]>='A' && buf[x+1]<='F') c=c*16+(buf[++x]&0xF)+9;
     buf[x]=c;
     break;
    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
    case '8': case '9':
     c=buf[x]-'0';
     if(buf[x+1]>='0' && buf[x+1]<='7') c=c*8+buf[++x]-'0';
     if(buf[x+1]>='0' && buf[x+1]<='7') c=c*8+buf[++x]-'0';
     buf[x]=c;
     break;
     }
    }
   if(m)
    {
    if(!m->steps)
     {
     MACRO *macro=m;
     m=mkmacro(MAXINT,1,0,NULL);
     addmacro(m,macro);
     }
    }
   else m=mkmacro(MAXINT,1,0,NULL);
   addmacro(m,mkmacro(buf[x],1,0,findcmd("type")));
   ++x;
   }
  if(buf[x]=='\"') ++x;
  }

 /* Do we have a command? */
 else
  {
  for(y=x;
      buf[y] && buf[y]!=',' && buf[y]!=' ' && buf[y]!='\t' && buf[y]!='\n' && buf[x]!='\r';
      ++y);
  if(y!=x)
   {
   CMD *cmd;
   c=buf[y]; buf[y]=0;
   cmd=findcmd(buf+x);
   if(!cmd)
    {
    *sta = -1;
    return 0;
    }
   else if(m)
    {
    if(!m->steps)
     {
     MACRO *macro=m;
     m=mkmacro(MAXINT,1,0,NULL);
     addmacro(m,macro);
     }
    addmacro(m,mkmacro(MAXINT,1,0,cmd));
    }
   else m=mkmacro(MAXINT,1,0,cmd);
   buf[x=y]=c;
   }
  }

 /* Skip whitespace */
 while(isblank(buf[x])) ++x;

 /* Do we have a comma? */
 if(buf[x]==',')
  {
  ++x;
  while(isblank(buf[x])) ++x;
  if(buf[x] && buf[x]!='\r' && buf[x]!='\n') goto macroloop;
  *sta= -2;
  return m;
  }

 /* Done */
 *sta=x;
 return m;
 }
d324 77
a400 63
char *unescape(ptr,c)
char *ptr;
 {
 if(c=='"') *ptr++='\\', *ptr++='"';
 else if(c=='\'') *ptr++='\\', *ptr++='\'';
 else if(c<32 || c>126)
  {
  *ptr++='\\';
  *ptr++='x';
  *ptr++="0123456789ABCDEF"[c>>4];
  *ptr++="0123456789ABCDEF"[c&15];
  }
 else *ptr++=c;
 return ptr;
 }

void domtext(m)
MACRO *m;
 {
 int x;
 if(!m) return;
 if(m->steps)
  for(x=0;x!=m->n;++x) domtext(m->steps[x]);
 else
  {
  if(instr && strcmp(m->cmd->name,"type")) *ptr++='\"', instr=0;
  if(first) first=0;
  else if(!instr) *ptr++=',';
  if(!strcmp(m->cmd->name,"type"))
   {
   if(!instr) *ptr++='\"', instr=1;
   ptr=unescape(ptr,m->k);
   }
  else
   {
   for(x=0;m->cmd->name[x];++x) *ptr++=m->cmd->name[x];
   if(!strcmp(m->cmd->name,"play") ||
      !strcmp(m->cmd->name,"gomark") ||
      !strcmp(m->cmd->name,"setmark") ||
      !strcmp(m->cmd->name,"record") ||
      !strcmp(m->cmd->name,"uarg"))
    {
    *ptr++=',';
    *ptr++='"';
    ptr=unescape(ptr,m->k);
    *ptr++='"';
    }
   }
  }
 }

char *mtext(s,m)
char *s;
MACRO *m;
 {
 ptr=s;
 first=1;
 instr=0;
 domtext(m);
 if(instr) *ptr++='\"';
 *ptr=0;
 return s;
 }
d407 1
a407 1
struct recmac *recmac=0;
d409 21
a429 15
static void unmac()
 {
 if(recmac) rmmacro(recmac->m->steps[--recmac->m->n]);
 }

void chmac()
 {
 if(recmac && recmac->m->n) recmac->m->steps[recmac->m->n-1]->k=3;
 }

static void record(m)
MACRO *m;
 {
 if(recmac) addmacro(recmac->m,dupmacro(m));
 }
d433 11
a443 10
int uquery(bw)
BW *bw;
 {
 int ret;
 struct recmac *tmp=recmac;
 recmac=0;
 ret=edloop(1);
 recmac=tmp;
 return ret;
 }
d447 1
a447 1
MACRO *curmacro=0;		/* Set if we're in a macro */
d449 2
a450 2
static int arg=0;		/* Repeat argument */
static int argset=0;		/* Set if 'arg' is set */
d452 74
a525 63
int exmacro(m,u)
MACRO *m;
 {
 int larg;
 int negarg=0;
 int flg=0;
 CMD *cmd;
 int n;
 int ret=0;

 if(argset)
  {
  larg=arg;
  arg=0;
  argset=0;
  if(larg<0) negarg=1, larg= -larg;
  if(m->steps) negarg=0;
  else
   {
   cmd=m->cmd;
   if(!cmd->arg) larg=0;
   else if(negarg)
    if(cmd->negarg) cmd=findcmd(cmd->negarg);
    else larg=0;
   }
  }
 else
  {
  cmd=m->cmd;
  larg=1;
  }

 if( m->steps ||
     larg!=1 ||
     !(cmd->flag&EMINOR) ||
     maint->curwin->watom->what==TYPEQW		/* Undo work right for s & r */
   ) flg=1;

 if(flg && u) umclear();
 while(larg-- && !leave && !ret)
  if(m->steps)
   {
   MACRO *tmpmac=curmacro;
   int tmpptr=macroptr;
   int x=0;
   int stk=nstack;
   while(m && x!=m->n && !leave && !ret)
    {
    MACRO *d;
    d=m->steps[x++];
    curmacro=m;
    macroptr=x;
    ret=exmacro(d,0);
    m=curmacro;
    x=macroptr;
    }
   curmacro=tmpmac;
   macroptr=tmpptr;
   while(nstack>stk) upop(NULL);
   }
  else ret=execmd(cmd,m->k);
 if(leave) return ret;
 if(flg && u) umclear();
d527 2
a528 1
 if(u) undomark();
d530 2
a531 2
 return ret;
 }
d535 7
a541 6
int exemac(m)
MACRO *m;
 {
 record(m);
 return exmacro(m,1);
 }
d545 124
a668 101
static int dorecord(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 int n;
 struct recmac *r;
 if(notify) *notify=1;
 if(c>'9' || c<'0')
  {
  nungetc(c);
  return -1;
  }
 for(n=0;n!=10;++n) if(playmode[n]) return -1;
 r=(struct recmac *)malloc(sizeof(struct recmac));
 r->m=mkmacro(0,1,0,NULL);
 r->next=recmac;
 r->n=c-'0';
 recmac=r;
 return 0;
 }

int urecord(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return dorecord(bw,c,NULL,NULL);
 else
  if(mkqw(bw,sc("Macro to record (0-9 or ^C to abort): "),dorecord,NULL,NULL,NULL)) return 0;
  else return -1;
 }

extern int dostaupd;

int ustop()
 {
 unmac();
 if(recmac)
  {
  struct recmac *r=recmac;
  MACRO *m;
  dostaupd=1;
  recmac=r->next;
  if(kbdmacro[r->n]) rmmacro(kbdmacro[r->n]);
  kbdmacro[r->n]=r->m;
  if(recmac) record(m=mkmacro(r->n+'0',1,0,findcmd("play"))), rmmacro(m);
  free(r);
  }
 return 0;
 }

int doplay(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c>='0' && c<='9')
  {
  int ret;
  c-='0';
  if(playmode[c] || !kbdmacro[c]) return -1;
  playmode[c]=1;
  ret=exmacro(kbdmacro[c],0);
  playmode[c]=0;
  return ret;
  }
 else
  {
  nungetc(c);
  return -1;
  }
 }

int umacros(bw)
BW *bw;
 {
 int x;
 char buf[1024];
 peol(bw->cursor);
 for(x=0;x!=10;++x) if(kbdmacro[x])
  {
  mtext(buf,kbdmacro[x]);
  binss(bw->cursor,buf);
  peol(bw->cursor);
  sprintf(buf,"\t^K %c\tMacro %d",x+'0',x);
  binss(bw->cursor,buf);
  peol(bw->cursor);
  binsc(bw->cursor,'\n');
  pgetc(bw->cursor);
  }
 return 0;
 }

int uplay(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return doplay(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Play-"),doplay,NULL,NULL,NULL)) return 0;
  else return -1;
 }
d672 33
a704 24
static int doarg(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num;
 if(notify) *notify=1;
 num=calc(bw,s);
 if(merr) { msgnw(bw,merr); return -1; }
 arg=num;
 argset=1;
 vsrm(s);
 return 0;
 }

int uarg(bw)
BW *bw;
 {
 if(wmkpw(bw,
          "No. times to repeat next command (^C to abort): ",
          NULL,doarg,NULL,NULL,utypebw,NULL,NULL)) return 0;
 else return -1;
 }
d709 57
a765 41
int douarg(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='-') negarg= !negarg;
 else if(c>='0' && c<='9') unaarg=unaarg*10+c-'0';
 else if(c=='U'-'@@')
  if(unaarg) unaarg*=4;
  else unaarg=16;
 else if(c==7 || c==3 || c==32)
  {
  if(notify) *notify=1;
  return -1;
  }
 else
  {
  nungetc(c);
  if(unaarg) arg=unaarg;
  else if(negarg) arg=1;
  else arg=4;
  if(negarg) arg= -arg;
  argset=1;
  if(notify) *notify=1;
  return 0;
  }
 sprintf(msgbuf,"Repeat %s%d",negarg?"-":"",unaarg);
 if(mkqwna(bw,sz(msgbuf),douarg,NULL,NULL,notify)) return 0;
 else return -1;
 }

int uuarg(bw,c)
BW *bw;
 {
 unaarg=0;
 negarg=0;
 if(c>='0' && c<='9' || c=='-') return douarg(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Repeat"),douarg,NULL,NULL,NULL)) return 0;
  else return -1;
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@a29 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d19 1
d32 1
d141 1
a141 1
 while(cwhite(buf[x])) ++x;
d228 1
a228 1
 while(cwhite(buf[x])) ++x;
d234 1
a234 1
  while(cwhite(buf[x])) ++x;
d276 1
a276 1
  if(instr && zcmp(m->cmd->name,"type")) *ptr++='\"', instr=0;
d279 1
a279 1
  if(!zcmp(m->cmd->name,"type"))
d287 5
a291 5
   if(!zcmp(m->cmd->name,"play") ||
      !zcmp(m->cmd->name,"gomark") ||
      !zcmp(m->cmd->name,"setmark") ||
      !zcmp(m->cmd->name,"record") ||
      !zcmp(m->cmd->name,"uarg"))
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
