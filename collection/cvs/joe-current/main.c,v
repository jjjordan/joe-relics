head	1.81;
access;
symbols
	joe_3_5:1.70
	joe-3_4:1.63
	help:1.63
	joe_3_1:1.32
	joe_3_0:1.23
	joe_2_9_8:1.17
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.8
	joe_2_9_7_pre3:1.8
	joe_2_9_7_pre2:1.7
	joe_2_9_6:1.6
	joe_2_9_5:1.5
	joe_2_9_4:1.4
	joe_2_9_2:1.3
	joe_2_9_1:1.2
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2008.11.23.23.35.10;	author jhallen;	state Exp;
branches;
next	1.80;

1.80
date	2008.10.27.01.57.13;	author jhallen;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.26.16.44.13;	author jhallen;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.25.03.21.48;	author jhallen;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.04.01.13.32;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.31.02.31.55;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.23.14.52.30;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.19.00.05.55;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2006.06.15.18.18.28;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2006.06.02.15.01.26;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.01.03.08.20;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.24.15.06.17;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.14.17.50.51;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.12.02.07.05;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.05.20.36.26;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.05.20.20.17;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.01.00.06.38;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.28.15.13.13;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.26.05.47.31;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.22.03.22.38;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.21.18.16.50;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.20.03.50.59;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.18.04.25.23;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.18.03.29.32;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.17.23.54.46;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.16.16.18.45;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.14.19.29.46;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.14.03.21.36;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.14.00.07.49;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.05.05.06.18;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.03.03.12.24;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.02.18.55.39;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.28.00.30.07;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.27.05.29.32;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.16.18.54.29;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.13.00.23.45;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.07.19.43.29;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.04.20.06.31;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.30.21.49.55;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.25.00.53.41;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.15.19.40.04;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.15.14.29.07;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.08.00.34.58;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.30.05.10.15;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.05.07.12.21;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.04.17.39.02;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.20.07.18.19;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.48.08;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.55;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.55;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Check for math functions.
@
text
@/*
 *	Editor startup and main edit loop
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 * 	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef MOUSE_GPM
#include <gpm.h>
#endif

unsigned char *exmsg = NULL;		/* Message to display when exiting the editor */
int usexmouse=0;
int xmouse=0;
int nonotice;
int help;

Screen *maint;			/* Main edit screen */

/* Make windows follow cursor */

void dofollows(void)
{
	W *w = maint->curwin;

	do {
		if (w->y != -1 && w->watom->follow && w->object)
			w->watom->follow(w->object);
		w = (W *) (w->link.next);
	} while (w != maint->curwin);
}

/* Update screen */

volatile int dostaupd = 1;

void edupd(int flg)
{
	W *w;
	int wid, hei;
	unsigned char *gc = vsmk(1);

	/* dostaupd is set once a second to force status line update */
	if (dostaupd) {
		staupd = 1; /* Flag for status update in disptw */
		dostaupd = 0;
	}
	/* Resize screen if necessary */
	ttgtsz(&wid, &hei);
	if ((wid >= 2 && wid != maint->w) || (hei >= 1 && hei != maint->h)) {
		nresize(maint->t, wid, hei);
		sresize(maint);
#ifdef MOUSE_GPM
		gpm_mx = wid;
		gpm_my = hei;
#endif
	}
	/* Move windows so that cursors stays on screen */
	dofollows();
	ttflsh();
	/* Send scrolling commands to terminal */
	nscroll(maint->t, BG_COLOR(bg_text));
	/* Display help */
	help_display(maint);
	/* Update all windows */
	w = maint->curwin;
	do {
		if (w->y != -1) {
			if (w->object && w->watom->disp)
				w->watom->disp(w->object, flg);
			msgout(w);
		}
		w = (W *) (w->link.next);
	} while (w != maint->curwin);
	/* Set cursor position */
	cpos(maint->t, maint->curwin->x + maint->curwin->curx, maint->curwin->y + maint->curwin->cury);
	staupd = 0;
	obj_free(gc);
}

static int ahead = 0;	/* Set when typeahead from before editor started is exhausted */
static int ungot = 0;
static int ungotc = 0;

void nungetc(int c)
{
	if (c != 'C' - '@@' && c != 'M' - '@@' && c != -1) {
		chmac();
		ungot = 1;
		ungotc = c;
	}
}

/* Main loop */

int edloop()
{
	int ret = 0;

	/* Here is the loop.  Loop while we're not exiting the editor (or query is not done)... */
	while (!leave) {
		MACRO *m;
		int c;

		/* Free exit message if we're not leaving */
		if (exmsg) {
			obj_free(exmsg);
			exmsg = NULL;
		}
		/* Update the screen */
		edupd(1);
		/* Set ahead when typeahead from before editor startup is done */
		if (!ahead && !have)
			ahead = 1;
		/* Get next character (including nungetc() one) */
		if (ungot) {
			c = ungotc;
			ungot = 0;
		} else
			c = ttgetc();
		/* Deal with typeahead from before editor starting: tty was in
		   cooked mode so it converted carriage returns to line
		   feeds.  Convert them back here. */
		if (!ahead && c == 10)
			c = 13;
		/* Give key to current keyboard handler: it returns a macro to execute when
		   a full sequence is decoded.  */
		m = dokey(maint->curwin->kbd, c);
		/* Make sure main window of group has copy of current key sequence so that it
		   is displayed in the status line (why doesn't status line code figure this out?) */
		if (maint->curwin->main && maint->curwin->main != maint->curwin) {
			int x = maint->curwin->kbd->x;

			maint->curwin->main->kbd->x = x;
			if (x)
				maint->curwin->main->kbd->seq[x - 1] = maint->curwin->kbd->seq[x - 1];
		}
		/* Execute macro */
		if (m) {
			ret = co_call(exemac, m);
			/* ret = exemac(m); */
		}
	}
	/* prompt can force return of error, which aborts macro */
	return ret;
}

#ifdef __MSDOS__
extern void setbreak();
extern int breakflg;
#endif

unsigned char **mainenv;

B *startup_log;

unsigned char i_msg[128];

void internal_msg(unsigned char *s)
{
	P *t = pdup(startup_log->eof, USTR "internal_msg");
	binss(t, s);
	prm(t);
}

/* Determine name editor was invoked as and process <name>rc file */

CAP *cap;
unsigned char **argv;

int joerc()
{
	struct stat sbuf;
	int c;
	time_t time_rc;
	unsigned char *s;
	unsigned char *t;
	unsigned char *run;
#ifdef __MSDOS__
	unsigned char *rundir;
#endif

	/* Figure out name editor was invoked under */
#ifdef __MSDOS__
	_fmode = O_BINARY;
	s = vscpyz(NULL, argv[0]);
	joesep(s);
	run = namprt(s);
	rundir = dirprt(s);
	for (c = 0; run[c]; ++c)
		if (run[c] == '.') {
			run = vstrunc(run, c);
			break;
		}
#else
	run = namprt(argv[0]);
#endif

#ifdef __MSDOS__

	s = vsncpy(NULL, 0, sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr, (char *)joe_gettext(_("There were errors in '%s'.  Use it anyway?")), s);
		fflush(stderr);
		fgets(buf, 8, stdin);
		if (yn_checks(yes_key, buf))
			goto donerc;
	}

	s = vsncpy(NULL, 0, sv(rundir));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr, (char *)joe_gettext(_("There were errors in '%s'.  Use it anyway?")), s);
		fflush(stderr);
		fgets(buf, 8, stdin);
		if (yn_checks(yes_key, buf))
			goto donerc;
	}
#else

	/* Name of system joerc file.  Try to find one with matching language... */
	
	/* Try full language: like joerc.de_DE */
	t = vsncpy(NULL, 0, sc(JOERC));
	t = vsncpy(sv(t), sv(run));
	t = vsncpy(sv(t), sc("rc."));
	t = vsncpy(sv(t), sz(locale_msgs));
	if (!stat((char *)t,&sbuf))
		time_rc = sbuf.st_mtime;
	else {
		/* Try generic language: like joerc.de */
		if (locale_msgs[0] && locale_msgs[1] && locale_msgs[2]=='_') {
			t = vsncpy(NULL, 0, sc(JOERC));
			t = vsncpy(sv(t), sv(run));
			t = vsncpy(sv(t), sc("rc."));
			t = vsncpy(sv(t), locale_msgs, 2);
			if (!stat((char *)t,&sbuf))
				time_rc = sbuf.st_mtime;
			else
				goto nope;
		} else {
			nope:
			/* Try Joe's bad english */
			t = vsncpy(NULL, 0, sc(JOERC));
			t = vsncpy(sv(t), sv(run));
			t = vsncpy(sv(t), sc("rc"));
			if (!stat((char *)t,&sbuf))
				time_rc = sbuf.st_mtime;
			else
				time_rc = 0;
		}
	}

	/* User's joerc file */
	s = (unsigned char *)getenv("HOME");
	if (s) {
		unsigned char buf[8];

		s = vsncpy(NULL, 0, sz(s));
		s = vsncpy(sv(s), sc("/."));
		s = vsncpy(sv(s), sv(run));
		s = vsncpy(sv(s), sc("rc"));

		if (!stat((char *)s,&sbuf)) {
			if (sbuf.st_mtime < time_rc) {
				fprintf(stderr,(char *)joe_gettext(_("Warning: %s is newer than your %s.\n")),t,s);
				fprintf(stderr,(char *)joe_gettext(_("You should update or delete %s\n")),s);
				fprintf(stderr,(char *)joe_gettext(_("Hit enter to continue with %s ")),t);
				fflush(stderr);
				fgets((char *)buf, 8, stdin);
				goto use_sys;
			}
		}

		c = procrc(cap, s);
		if (c == 0) {
			goto donerc;
		}
		if (c == 1) {
			fprintf(stderr,(char *)joe_gettext(_("There were errors in '%s'.  Use it anyway (y,n)? ")), s);
			fflush(stderr);
			fgets((char *)buf, 8, stdin);
			if (ynchecks(yes_key, buf)) {
				goto donerc;
			}
		}
	}

	use_sys:
	s = t;
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr,(char *)joe_gettext(_("There were errors in '%s'.  Use it anyway (y,n)? ")), s);
		fflush(stderr);
		fgets((char *)buf, 8, stdin);
		if (ynchecks(yes_key, buf))
			goto donerc;
	}

	/* Try built-in joerc */
	s = vsncpy(NULL, 0, sc("*"));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c != 0 && c != 1) {
		/* If *fancyjoerc not present, use *joerc which is always there */
		s = vstrunc(s, 0);
		s = vsncpy(sv(s),sc("*joerc"));
		c = procrc(cap, s);
	}
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr,(char *)joe_gettext(_("There were errors in '%s'.  Use it anyway (y,n)? ")), s);
		fflush(stderr);
		fgets((char *)buf, 8, stdin);
		if (ynchecks(yes_key, buf))
			goto donerc;
	}
#endif

	fprintf(stderr,(char *)joe_gettext(_("Couldn't open '%s'\n")), s);
	return 1;

	donerc:

	if (validate_rc()) {
		fprintf(stderr,(char *)joe_gettext(_("rc file has no :main key binding section or no bindings.  Bye.\n")));
		return 1;
	}

	return 0;
}

/* Copy environment variables to global variables */

void process_env()
{
	unsigned char *s;

	if ((s = (unsigned char *)getenv("LINES")) != NULL)
		sscanf((char *)s, "%d", &lines);

	if ((s = (unsigned char *)getenv("COLUMNS")) != NULL)
		sscanf((char *)s, "%d", &columns);

	if ((s = (unsigned char *)getenv("BAUD")) != NULL)
		sscanf((char *)s, "%u", (unsigned *)&Baud);

	if (getenv("DOPADDING"))
		dopadding = 1;

	if (getenv("NOXON"))
		noxon = 1;

	if ((s = (unsigned char *)getenv("JOETERM")) != NULL)
		joeterm = s;

}

void setup_mouse()
{
	unsigned char *s;

	/* initialize mouse support */
	if (xmouse && (s=(unsigned char *)getenv("TERM")) && strstr((char *)s,"xterm"))
		usexmouse=1;
}

void process_global_options()
{
	int c;
	/* Process global options */
	for (c = 1; argv[c]; ++c) {
		if (argv[c][0] == '-') {
			if (argv[c][1])
				switch (glopt(argv[c] + 1, argv[c + 1], NULL, 1)) {
				case 0:
					fprintf(stderr,(char *)joe_gettext(_("Unknown option '%s'\n")), argv[c]);
					break;
				case 1:
					break;
				case 2:
					++c;
					break;
			} else
				idleout = 0;
		}
	}
}

void process_args()
{
	int c;
	int backopt;
	int omid;
	int opened = 0;

	/* The business with backopt is to load the file first, then apply file
	 * local options afterwords */

	/* orphan is not compatible with exemac()- macros need a window to exist */
	for (c = 1, backopt = 0; argv[c]; ++c)
		if (argv[c][0] == '+' && argv[c][1]>='0' && argv[c][1]<='9') {
			if (!backopt)
				backopt = c;
		} else if (argv[c][0] == '-' && argv[c][1]) {
			if (!backopt)
				backopt = c;
			if (glopt(argv[c] + 1, argv[c + 1], NULL, 0) == 2)
				++c;
		} else {
			B *b = bfind(argv[c]);
			BW *bw = NULL;
			int er = berror;

			/* This is too annoying */
			/* set_current_dir(argv[c],1); */

			setup_history(&filehist);
			append_history(filehist,sz(argv[c]));

			/* wmktw inserts the window before maint->curwin */
			if (!orphan || !opened) {
				bw = wmktw(maint, b);
				if (er)
					msgnwt(bw->parent, joe_gettext(msgs[-er]));
			} else {
				long line;
				b->orphan = 1;
				b->oldcur = pdup(b->bof, USTR "main");
				pline(b->oldcur, get_file_pos(b->name));
				p_goto_bol(b->oldcur);
				line = b->oldcur->line - (maint->h - 1) / 2;
				if (line < 0)
					line = 0;
				b->oldtop = pdup(b->oldcur, USTR "main");
				pline(b->oldtop, line);
				p_goto_bol(b->oldtop);
			}
			if (bw) {
				long lnum = 0;

				bw->o.readonly = bw->b->rdonly;
				if (backopt) {
					while (backopt != c) {
						if (argv[backopt][0] == '+') {
							sscanf((char *)(argv[backopt] + 1), "%ld", &lnum);
							++backopt;
						} else {
							if (glopt(argv[backopt] + 1, argv[backopt + 1], &bw->o, 0) == 2)
								backopt += 2;
							else
								backopt += 1;
							lazy_opts(bw->b, &bw->o);
						}
					}
				}
				bw->b->o = bw->o;
				bw->b->rdonly = bw->o.readonly;
				/* Put cursor in window, so macros work properly */
				maint->curwin = bw->parent;
				/* Execute macro */
				if (er == -1 && bw->o.mnew)
					exmacro(bw->o.mnew,1);
				if (er == 0 && bw->o.mold)
					exmacro(bw->o.mold,1);
				/* Hmm... window might not exist any more... depends on what macro does... */
				if (lnum > 0)
					pline(bw->cursor, lnum - 1);
				else
					pline(bw->cursor, get_file_pos(bw->b->name));
				p_goto_bol(bw->cursor);
				/* Go back to first window so windows are in same order as command line  */
				if (opened)
					wnext(maint);
				
			}
			opened = 1;
			backopt = 0;
		}
	if (opened) {
		/* Show all files on the screen */
		wshowall(maint);
		/* Temporarily set 'mid' option so that cursor is centered
		   in each window */
		omid = mid;
		mid = 1;
		dofollows();
		mid = omid;
	} else {
		/* Create empty window */
		BW *bw = wmktw(maint, bfind(USTR ""));

		if (bw->o.mnew)
			exmacro(bw->o.mnew,1);
	}
	/* Set window with cursor to first window on screen */
	maint->curwin = maint->topwin;
}

/* Show startup log if there were any messages */

void show_startup_log()
{
	if (startup_log->eof->byte) {
		BW *bw = wmktw(maint, startup_log);
		startup_log = 0;
		maint->curwin = bw->parent;
		wshowall(maint);
		uparserr(bw);
	}
}

/* Set up piping into JOE */

void setup_pipein()
{
	if (!idleout && modify_logic(maint->curwin->object, ((BW *)maint->curwin->object)->b)) {
		/* Start shell going in first window */
		/* This is silly- mpx should be able to just read from stdin */

		unsigned char **a = vamk(3);
		a = vaadd(a, vsncpy(NULL, 0, sc("/bin/sh")));
		a = vaadd(a, vsncpy(NULL, 0, sc("-c")));
		a = vaadd(a, vsncpy(NULL, 0, sc("/bin/cat")));

		cstart(maint->curwin->object, USTR "/bin/sh", a, NULL, 0, 1);
	}
}

/* Scheduler wants us to get some work */

SCRN *main_scrn;

unsigned char *startup_gc;

int main(int argc, char **real_argv, char **envv)
{
	/* Save arguments */
	argv = (unsigned char **)real_argv;

	/* Remember environment vector for sub-shells */
	mainenv = (unsigned char **)envv;

	/* Garbage collect startup process */
	startup_gc = vsmk(1);

	/* Set up locale (determines character set of terminal) */
	joe_locale();
	fdefault.charmap = locale_map;
	pdefault.charmap = locale_map;

	/* Copy some environment variables to global variables */
	process_env();

	/* Try to get termcap entry before we get too far */
#ifndef __MSDOS__
	if (!(cap = getcap(NULL, 9600, NULL, NULL))) {
		fprintf(stderr, (char *)joe_gettext(_("Couldn't load termcap/terminfo entry\n")));
		return 1;
	}
#endif

	/* Process JOERC file */
	if (joerc())
		return 1;

	/* Is somebody piping something into JOE, or is stdin the tty? */
	if (!isatty(fileno(stdin)))
		/* If stdin is not /dev/tty, set flag so that
		   nopen opens /dev/tty instead of using stdin/stdout */
		idleout = 0;

	/* First scan of argv: process global options on command line */
	process_global_options();

	/* Enable mouse if we're an xterm and mouse option was given in rc
	 * file or as a command line option */
	setup_mouse();

	/* Setup tty handler (sets cbreak mode, turns off cooked) */
	if (!(main_scrn = nopen(cap)))
		return 1;

	/* Initialize windowing system */
	maint = screate(main_scrn);

	/* Setup software virtual memory */
	vmem = vtmp();

	/* Create startup log buffer */
	startup_log = bfind_scratch(USTR "* Startup Log *");
	startup_log->internal = 1;

	/* Read in ~/.joe_state file */
	load_state();

	/* Read files given on command line and process local options */
	process_args();

	/* Show startup log if there were any messages */
	show_startup_log();

	/* Turn on help if requested by global option */
	if (help) {
		help_on(maint);
	}

	/* Display startup message unless disabled by global option */
	if (!nonotice) {
		msgnw(((BASE *)lastw(maint)->object)->parent,
		  vsfmt(NULL, 0, joe_gettext(_("\\i** Joe's Own Editor v%s ** (%s) ** Copyright %s 2008 **\\i")),VERSION,locale_map->name,(locale_map->type ? "©" : "(C)")));
	}

	/* Setup reading in from stdin to first window if something was
	   piped into JOE */
	setup_pipein();

	/* Clean up startup gargbage */
	obj_free(startup_gc);

	/* Run the editor */
	edloop();

	/* Write ~/.joe_state file */
	save_state();

	/* Delete all buffers so left over locks get eliminated */
	brmall();

	/* Delete temporary software virtual memory file */
	vclose(vmem);

	/* Close terminal (restores mode) */
	nclose(main_scrn);

	/* Display exit message */
	if (exmsg)
		fprintf(stderr, "\n%s\n", exmsg);

	return 0;
}
@


1.80
log
@Update copyright.
@
text
@d323 6
@


1.79
log
@Fix joe +2 problem with single line file
@
text
@d627 1
a627 1
		  vsfmt(NULL, 0, joe_gettext(_("\\i** Joe's Own Editor v%s ** (%s) ** Copyright %s 2006 **\\i")),VERSION,locale_map->name,(locale_map->type ? "©" : "(C)")));
@


1.78
log
@Look at LC_MESSAGES for language to use for editor messages.
@
text
@d447 1
d453 1
d487 1
@


1.77
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d241 1
a241 1
	t = vsncpy(sv(t), sz(locale_lang));
d246 1
a246 1
		if (locale_lang[0] && locale_lang[1] && locale_lang[2]=='_') {
d250 1
a250 1
			t = vsncpy(sv(t), locale_lang, 2);
@


1.76
log
@More work on coroutine refactoring.
@
text
@d605 1
@


1.75
log
@get uquery to use coroutines: eliminates recursive edloop calls.
@
text
@d98 1
a98 1
int edloop(int flg)
a99 1
	int term = 0;
a101 9
	if (flg) {
		/* Macro query requested if flg is set.  We return when user has finished the query */
		if (maint->curwin->watom->what == TYPETW)
			/* Query not allowed for regular windows: only prompts */
			return 0;
		else
			/* When prompt is done, it will set term */
			maint->curwin->notify = &term;
	}
d103 1
a103 1
	while (!leave && !term) {
d108 1
a108 1
		if (exmsg && !flg) {
d147 1
a147 4
	if (term == -1)
		return -1;
	else
		return ret;
d539 1
a539 1
		cstart(maint->curwin->object, USTR "/bin/sh", a, NULL, NULL, 0, 1);
a546 65
void get_work()
{
	MACRO *m;
	int c;

	/* Free exit message if we're not leaving */
	if (exmsg) {
		obj_free(exmsg);
		exmsg = NULL;
	}
	/* Update the screen */
	edupd(1);
	/* Set ahead when typeahead from before editor startup is done */
	if (!ahead && !have)
		ahead = 1;
	/* Get next character (including nungetc() one) */
	if (ungot) {
		c = ungotc;
		ungot = 0;
	} else
		c = ttgetc();
	/* Deal with typeahead from before editor starting: tty was in
	   cooked mode so it converted carriage returns to line
	   feeds.  Convert them back here. */
	if (!ahead && c == 10)
		c = 13;
	/* Give key to current keyboard handler: it returns a macro to execute when
	   a full sequence is decoded.  */
	m = dokey(maint->curwin->kbd, c);
	/* Make sure main window of group has copy of current key sequence so that it
	   is displayed in the status line (why doesn't status line code figure this out?) */
	if (maint->curwin->main && maint->curwin->main != maint->curwin) {
		int x = maint->curwin->kbd->x;

		maint->curwin->main->kbd->x = x;
		if (x)
			maint->curwin->main->kbd->seq[x - 1] = maint->curwin->kbd->seq[x - 1];
	}
	/* Execute macro */
	if (m)
		exemac(m);

	/* Exit editor? */
	if (leave) {
		/* Write ~/.joe_state file */
		save_state();

		/* Delete all buffer so left over locks get eliminated */
		brmall();

		/* Delete temporary software virtual memory file */
		vclose(vmem);
	
		/* Close terminal (restores mode) */
		nclose(main_scrn);

		/* Display exit message */
		if (exmsg)
			fprintf(stderr, "\n%s\n", exmsg);

		/* Bye */
		exit(0);
	}
}

d634 1
a634 1
	edloop(0);
@


1.74
log
@more refactoring
@
text
@d151 4
a154 2
		if (m)
			ret = exemac(m);
@


1.73
log
@coroutines
@
text
@d89 1
a89 1
	if (c != 'C' - '@@' && c != 'M' - '@@') {
@


1.72
log
@add comments
@
text
@d179 1
d181 2
d184 1
a184 1
int main(int argc, char **real_argv, char **envv)
a185 2
	CAP *cap;
	unsigned char **argv = (unsigned char **)real_argv;
d187 2
a190 1
	long time_rc;
a194 12
	SCRN *n;
	int opened = 0;
	int omid;
	int backopt;
	int c;
	unsigned char *gc = vsmk(1); /* Startup garbage collection */

	joe_locale();
	fdefault.charmap = locale_map;
	pdefault.charmap = locale_map;

	mainenv = (unsigned char **)envv;
d196 1
a211 20
	if ((s = (unsigned char *)getenv("LINES")) != NULL)
		sscanf((char *)s, "%d", &lines);
	if ((s = (unsigned char *)getenv("COLUMNS")) != NULL)
		sscanf((char *)s, "%d", &columns);
	if ((s = (unsigned char *)getenv("BAUD")) != NULL)
		sscanf((char *)s, "%u", (unsigned *)&Baud);
	if (getenv("DOPADDING"))
		dopadding = 1;
	if (getenv("NOXON"))
		noxon = 1;
	if ((s = (unsigned char *)getenv("JOETERM")) != NULL)
		joeterm = s;

#ifndef __MSDOS__
	if (!(cap = getcap(NULL, 9600, NULL, NULL))) {
		fprintf(stderr, (char *)joe_gettext(_("Couldn't load termcap/terminfo entry\n")));
		return 1;
	}
#endif

d357 26
d384 10
a393 2
	if (!isatty(fileno(stdin)))
		idleout = 0;
d395 4
d415 1
d417 6
a422 14
	/* initialize mouse support */
	if (xmouse && (s=(unsigned char *)getenv("TERM")) && strstr((char *)s,"xterm"))
		usexmouse=1;

	if (!(n = nopen(cap)))
		return 1;
	maint = screate(n);
	vmem = vtmp();

	startup_log = bfind_scratch(USTR "* Startup Log *");

	load_state();

	/* It would be better if this ran uedit() to load files */
a503 3

	

d505 1
d507 2
d514 1
d520 1
d522 3
d526 2
d535 1
d537 155
d695 2
d698 2
a699 2
		unsigned char *m = vsfmt(NULL, 0, joe_gettext(_("\\i** Joe's Own Editor v%s ** (%s) ** Copyright %s 2006 **\\i")),VERSION,locale_map->name,(locale_map->type ? "©" : "(C)"));
		msgnw(((BASE *)lastw(maint)->object)->parent, m);
d702 6
a707 17
	if (!idleout) {
		if (!isatty(fileno(stdin)) && modify_logic(maint->curwin->object, ((BW *)maint->curwin->object)->b)) {
			/* Start shell going in first window */
			unsigned char **a;
			unsigned char *cmd;

			a = vamk(10);
			cmd = vsncpy(NULL, 0, sc("/bin/sh"));
			a = vaadd(a, cmd);
			cmd = vsncpy(NULL, 0, sc("-c"));
			a = vaadd(a, cmd);
			cmd = vsncpy(NULL, 0, sc("/bin/cat"));
			a = vaadd(a, cmd);
			
			cstart (maint->curwin->object, USTR "/bin/sh", a, NULL, NULL, 0, 1);
		}
	}
d709 1
a709 1
	obj_free(gc); /* Clean up after startup */
d712 1
d715 1
a715 1
	/* Delete all buffer so left over locks get eliminated */
d718 1
a719 1
	nclose(n);
d721 4
d727 1
@


1.71
log
@semiautomatic variables
@
text
@d45 1
d47 1
a47 1
		staupd = 1;
d50 1
d60 1
d63 1
d65 1
d67 1
d77 1
d83 1
a83 1
static int ahead = 0;
d96 2
d104 1
d106 1
d109 1
d112 2
a113 1
	while (!leave && (!flg || !term)) {
d117 1
d122 1
d124 1
d127 1
d133 3
a135 1

d138 2
d141 2
d150 1
d154 1
a154 1

@


1.70
log
@UC -> USTR
@
text
@d43 1
d73 1
d105 1
a105 1
			vsrm(exmsg);
d174 1
d177 2
d184 4
a187 4
	zcpy(stdbuf, argv[0]);
	joesep(stdbuf);
	run = namprt(stdbuf);
	rundir = dirprt(stdbuf);
d211 1
a211 1
	if (!(cap = my_getcap(NULL, 9600, NULL, NULL))) {
a233 1
	vsrm(s);
a262 1
			vsrm(t);
a272 1
			vsrm(t);
a306 1
			vsrm(t);
a313 1
				vsrm(t);
a319 1
	vsrm(s);
d507 2
a508 3
		joe_snprintf_3(msgbuf,JOE_MSGBUFSIZE,joe_gettext(_("\\i** Joe's Own Editor v%s ** (%s) ** Copyright %s 2006 **\\i")),VERSION,locale_map->name,(locale_map->type ? "©" : "(C)"));

		msgnw(((BASE *)lastw(maint)->object)->parent, msgbuf);
d529 1
@


1.69
log
@more fixes
@
text
@d148 1
a148 1
	P *t = pdup(startup_log->eof, UC "internal_msg");
d393 1
a393 1
	startup_log = bfind_scratch(UC "* Startup Log *");
d431 1
a431 1
				b->oldcur = pdup(b->bof, UC "main");
d436 1
a436 1
				b->oldtop = pdup(b->oldcur, UC "main");
d489 1
a489 1
		BW *bw = wmktw(maint, bfind(UC ""));
d527 1
a527 1
			cstart (maint->curwin->object, UC "/bin/sh", a, NULL, NULL, 0, 1);
@


1.68
log
@change US to UC
@
text
@d206 1
a206 1
	if (!(cap = getcap(NULL, 9600, NULL, NULL))) {
@


1.67
log
@Add builtins.  Fix syntax error in python.jsf.in
@
text
@d148 1
a148 1
	P *t = pdup(startup_log->eof, US "internal_msg");
d393 1
a393 1
	startup_log = bfind_scratch(US "* Startup Log *");
d431 1
a431 1
				b->oldcur = pdup(b->bof, US "main");
d436 1
a436 1
				b->oldtop = pdup(b->oldcur, US "main");
d489 1
a489 1
		BW *bw = wmktw(maint, bfind(US ""));
d527 1
a527 1
			cstart (maint->curwin->object, US "/bin/sh", a, NULL, NULL, 0, 1);
@


1.66
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d334 17
@


1.65
log
@i18n yes/no
@
text
@d225 1
a225 1
		if (yn_checks(yes_string, buf))
d242 1
a242 1
		if (yn_checks(yes_string, buf))
d312 1
a312 1
			if (ynchecks(yes_string, buf)) {
d331 1
a331 1
		if (ynchecks(yes_string, buf))
@


1.64
log
@multi-line qw, startup log
@
text
@d225 1
a225 1
		if (buf[0] == 'y' || buf[0] == 'Y')
d242 1
a242 1
		if (buf[0] == 'y' || buf[0] == 'Y')
d312 1
a312 1
			if (buf[0] == 'y' || buf[0] == 'Y') {
d331 1
a331 1
		if (buf[0] == 'y' || buf[0] == 'Y')
@


1.63
log
@transpose menus
@
text
@d142 13
d376 2
d479 8
@


1.62
log
@Add Russian man page and joerc file.
Joe now looks for localized joerc file.
@
text
@d396 2
a397 1
			} else
d399 8
@


1.61
log
@gettext()
@
text
@d234 3
a236 1
	/* Name of system joerc file */
d239 2
a240 1
	t = vsncpy(sv(t), sc("rc"));
d243 25
a267 2
	else
		time_rc = 0;
d269 1
a269 1
	/* Local joerc file */
@


1.60
log
@A option for search
Restore cursor to old position
@
text
@d194 1
a194 1
		fprintf(stderr, "Couldn't load termcap/terminfo entry\n");
d209 1
a209 1
		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
d226 1
a226 1
		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
d255 3
a257 3
				fprintf(stderr, "Warning: %s is newer than your %s.\n",t,s);
				fprintf(stderr,"You should update or delete %s\n",s);
				fprintf(stderr,"Hit enter to continue with %s ",t);
d270 1
a270 1
			fprintf(stderr, "There were errors in '%s'.  Use it anyway (y,n)? ", s);
d289 1
a289 1
		fprintf(stderr, "There were errors in '%s'.  Use it anyway (y,n)? ", s);
d297 1
a297 1
	fprintf(stderr, "Couldn't open '%s'\n", s);
d303 1
a303 1
		fprintf(stderr, "rc file has no :main key binding section or no bindings.  Bye.\n");
d316 1
a316 1
					fprintf(stderr, "Unknown option '%s'\n", argv[c]);
d369 1
a369 1
					msgnwt(bw->parent, msgs[-er]);
d433 1
a433 4
		if (locale_map->type)
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright © 2005 **\\i",locale_map->name);
		else
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright (C) 2005 **\\i",locale_map->name);
@


1.59
log
@Change SCREEN to Screen
@
text
@d402 2
@


1.58
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d20 1
a20 1
SCREEN *maint;			/* Main edit screen */
@


1.57
log
@new cvs server
@
text
@a7 1
#include "config.h"
a9 5
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
a12 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
a13 27
#include "b.h"
#include "help.h"
#include "kbd.h"
#include "macro.h"
#include "path.h"
#include "rc.h"
#include "scrn.h"
#include "termcap.h"
#include "tw.h"
#include "vfile.h"
#include "va.h"
#include "vs.h"
#include "w.h"
#include "utf8.h"
#include "charmap.h"
#include "syntax.h"
#include "pw.h"
#include "ushell.h"

extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff, exask, skiptop, noxon, lines, staen, columns, Baud, dopadding, marking, joe_beep;

extern int idleout;		/* Clear to use /dev/tty for screen */
extern int bg_text;
extern unsigned char *joeterm;
int help = 0;			/* Set to have help on when starting */
int nonotice = 0;		/* Set to prevent copyright notice */
int orphan = 0;
d17 2
a20 3
int nowmarking;

extern B *filehist;		/* History of file names */
d37 1
a37 2
int dostaupd = 1;
extern int staupd;
d142 1
a142 1
int main(int argc, unsigned char **argv, unsigned char **envv)
d145 1
d149 1
a149 1
	long time_t;
d162 1
a162 1
	mainenv = envv;
d184 1
a184 1
		sscanf((char *)s, "%u", &Baud);
d239 1
a239 1
		time_t = sbuf.st_mtime;
d241 1
a241 1
		time_t = 0;
d254 1
a254 1
			if (sbuf.st_mtime<time_t) {
d357 1
a357 1
			int er = error;
@


1.56
log
@minor redirection fix
@
text
@d423 1
a423 1
							lazy_opts(&bw->o);
@


1.55
log
@fix input redirection
@
text
@d33 1
d477 1
a477 1
		if (!isatty(fileno(stdin)))
d479 13
a491 1
			dorun (maint->curwin->object, "/bin/cat", NULL, NULL);
@


1.54
log
@Don't run editor if rc file is bad.
@
text
@d39 1
d344 3
d475 6
@


1.53
log
@fix gcc-4.0.0 warnings
@
text
@d335 8
a342 1
      donerc:
@


1.52
log
@Background color for screen item
@
text
@a18 1
#include <string.h>
d201 1
a201 1
	strcpy(stdbuf, argv[0]);
@


1.51
log
@        Reformat mouse.c

        Apply diff patch

        Apply vpath patch

        Apply electrum's mouse patch (send mouse off code during
        shell escape)

        Mouse can now resize windows

        Mouse can position cursor in menus.  Double-click selects
        an item.  Need to add scroll.

@
text
@d44 1
d96 1
a96 1
	nscroll(maint->t);
@


1.50
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d49 1
a49 1
int ttisxterm=0;
d353 4
a361 9
#ifdef MOUSE_XTERM
	/* initialize mouse */
	if (xmouse && (s=(unsigned char *)getenv("TERM")) && strstr((char *)s,"xterm")) {
		ttisxterm=1;
		ttputs(US "\33[?1002h");
		ttflsh();
	}
#endif

a471 6
#ifdef MOUSE_XTERM
	if(ttisxterm) {
		ttputs(US "\33[?1002l");
		ttflsh();
	}
#endif
@


1.49
log
@Fix: segfault, xcol for hex, backspace
@
text
@d360 1
a360 1
	if (xmouse && (s=getenv("TERM")) && strstr(s,"xterm")) {
d362 1
a362 1
		ttputs("\33[?1002h");
d479 1
a479 1
		ttputs("\33[?1002l");
@


1.48
log
@hex edit mode
@
text
@d471 2
a484 2
	save_state();

@


1.47
log
@Get current directory from files on command line
@
text
@d389 2
a390 1
			set_current_dir(argv[c],1);
a393 1
			
@


1.46
log
@fix locks bug, jmacs improvements
@
text
@d389 2
d393 1
@


1.45
log
@parse rc file only once
@
text
@d467 4
@


1.44
log
@Save file names from command line in state file
@
text
@a335 1
	help_init(s);
@


1.43
log
@Get joe to compile on irix
@
text
@d39 1
d55 2
d368 2
d390 3
a466 2
	load_state();

@


1.42
log
@Fix line number accounting for joerc files.
Check if system joerc file is newer than home directory one.
@
text
@d40 1
a40 1
extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff, exask, skiptop, noxon, lines, staen, columns, Baud, dopadding, marking, beep;
@


1.41
log
@Add -break_links option.
@
text
@d12 3
d178 1
d180 2
d266 10
d278 2
d284 12
d297 2
a298 1
		if (c == 0)
d300 1
d302 1
a302 3
			unsigned char buf[8];

			fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
d305 2
a306 1
			if (buf[0] == 'y' || buf[0] == 'Y')
d308 1
d312 1
d314 1
a314 3
	s = vsncpy(NULL, 0, sc(JOERC));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
d321 1
a321 1
		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
@


1.40
log
@Perforce macro and support for it.
@
text
@d341 1
a341 1
		if (argv[c][0] == '+' && argv[c][1]) {
@


1.39
log
@file locking.
@
text
@d385 1
a385 1
					exemac(bw->o.mnew);
d387 1
a387 1
					exemac(bw->o.mold);
d412 1
a412 1
			exemac(bw->o.mnew);
@


1.38
log
@Fix -marking
@
text
@d334 6
d354 1
d381 3
a383 2
				if (!opened)
					maint->curwin = bw->parent;
d388 1
d391 4
d400 2
@


1.37
log
@Ignore <a/>
@
text
@d49 1
@


1.36
log
@option for mouse support
use \ for escape in joe_state
@
text
@d405 1
a405 1
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright © 2004 **\\i",locale_map->name);
d407 1
a407 1
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright (C) 2004 **\\i",locale_map->name);
@


1.35
log
@Fix lockup problem with ^G
@
text
@d46 1
d326 1
a326 1
	if ((s=getenv("TERM")) && strstr(s,"xterm")) {
@


1.34
log
@Jesse McGrew's xterm mouse support.
@
text
@d325 1
a325 1
	if ((s=getenv("TERM")) && !strcmp(s,"xterm")) {
@


1.33
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@d13 3
d45 1
d80 4
d323 9
d415 6
@


1.32
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d394 2
d399 3
@


1.31
log
@Fix -syntax and -encoding on command line.

Check for "pty.h" when openpty is used.
@
text
@d387 1
a387 1
			snprintf((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright © 2004 **\\i",locale_map->name);
d389 1
a389 1
			snprintf((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright (C) 2004 **\\i",locale_map->name);
@


1.30
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d344 7
a350 4
						} else if (glopt(argv[backopt] + 1, argv[backopt + 1], &bw->o, 0) == 2)
							backopt += 2;
						else
							backopt += 1;
@


1.29
log
@Warn if file changed on save.
@
text
@d148 1
@


1.28
log
@joe a b c, now windows are in order a, b, c.

TAB completion now works on last path in prompt window:
for example '!ls foo', tab will complete the foo.

Added menu_explorer option.  When set: menu stays up when
a directory is seleted.  When clear: directory is added
to path and menu is closed.

Menus are now 40% of window size (or smaller if they are
not filled).

Cursor is now position after selected menu entry.
@
text
@d331 1
a331 1
					msgnwt(bw->parent, msgs[5 + er]);
@


1.27
log
@Print locale on startup line.
Print encoding for ^K <space>.
Change koi8-T to koi8-t.
@
text
@d351 2
a352 1
				maint->curwin = bw->parent;
@


1.26
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d380 1
a380 1
	if (!nonotice)
d382 1
a382 1
			msgnw(((BASE *)lastw(maint)->object)->parent, US ("\\i** Joe's Own Editor v" VERSION " ** Copyright © 2004 **\\i"));
d384 5
a388 1
			msgnw(((BASE *)lastw(maint)->object)->parent, US ("\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2004 **\\i"));
@


1.25
log
@Improve Fortran again.

Added '-indentfirst' option to control
how smarthome works.

Now syntax files are loaded as needed.

New version of automake and autoconf

Print UTF-8 (c) if terminal is utf-8.
@
text
@d31 1
d381 1
a381 1
		if (utf8)
@


1.24
log
@Print <XXXX> for unicode control characters.
@
text
@d380 4
a383 1
		msgnw(((BASE *)lastw(maint)->object)->parent, US ("\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2004 **\\i"));
@


1.23
log
@First attempt at character set conversion iconv().
Now the file's coding can be different from the terminal's
coding.

Also, applied secure linux patch from RedHat.
@
text
@d380 1
a380 1
		msgnw(((BASE *)lastw(maint)->object)->parent, US ("\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2003 **\\i"));
@


1.22
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@a16 4
#if defined(HAVE_LOCALE_H) && defined(HAVE_SETLOCALE)
#	include <locale.h>
#       include <langinfo.h>
#endif
d30 1
a32 2
int utf8;	/* Set for UTF8 locale.  Means we should be in utf-8 mode by default. */

d174 1
a174 7
#ifdef HAVE_SETLOCALE
	setlocale(LC_ALL, "");
	printf("%s\n",nl_langinfo(CODESET));
	utf8 = !strcmp(nl_langinfo(CODESET),"UTF-8");
	if(utf8)
		printf("utf8! \n");
#endif
@


1.21
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d180 2
a181 1
	setlocale(LC_CTYPE, "");
d183 2
@


1.20
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d41 1
a41 1
extern char *joeterm;
d45 1
a45 1
char *exmsg = NULL;		/* Message to display when exiting the editor */
d163 1
a163 1
char **mainenv;
d165 1
a165 1
int main(int argc, char **argv, char **envv)
d169 1
a169 1
	char *run;
d171 1
a171 1
	char *rundir;
d201 6
a206 6
	if ((s = getenv("LINES")) != NULL)
		sscanf(s, "%d", &lines);
	if ((s = getenv("COLUMNS")) != NULL)
		sscanf(s, "%d", &columns);
	if ((s = getenv("BAUD")) != NULL)
		sscanf(s, "%u", &Baud);
d211 1
a211 1
	if ((s = getenv("JOETERM")) != NULL)
d229 1
a229 1
		char buf[8];
d246 1
a246 1
		char buf[8];
d256 1
a256 1
	s = getenv("HOME");
d266 1
a266 1
			char buf[8];
d270 1
a270 1
			fgets(buf, 8, stdin);
d284 1
a284 1
		char buf[8];
d288 1
a288 1
		fgets(buf, 8, stdin);
d348 1
a348 1
							sscanf(argv[backopt] + 1, "%ld", &lnum);
d377 1
a377 1
		BW *bw = wmktw(maint, bfind(""));
d388 1
a388 1
		msgnw(((BASE *)lastw(maint)->object)->parent, "\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2003 **\\i");
@


1.19
log
@Fix highlighting bug.  Assume terminal supports color if it appears to be
ansi.
@
text
@d19 1
d36 2
d181 1
@


1.18
log
@More changes for syntax highlighting.
@
text
@d135 1
@


1.17
log
@joe-2.9.8 release
@
text
@d33 1
@


1.16
log
@change 0 to NULL where we're talking about pointers
@
text
@d382 1
a382 1
		msgnw(((BASE *)lastw(maint)->object)->parent, "\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2001 **\\i");
@


1.15
log
@change type of variables holding string to unsigned char *
@
text
@d41 1
a41 1
char *exmsg = 0;		/* Message to display when exiting the editor */
d124 1
a124 1
			exmsg = 0;
d326 1
a326 1
			BW *bw = 0;
@


1.14
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d163 1
a163 1
	char *s;
@


1.13
log
@change indentation of cases in the switch() statement
@
text
@d68 4
a71 2
	if (dostaupd)
		staupd = 1, dostaupd = 0;
d129 4
a132 3
		if (ungot)
			c = ungotc, ungot = 0;
		else
@


1.12
log
@change indentation of do {} while() cycles
@
text
@d294 1
a294 1
					case 0:
d297 1
a297 1
					case 1:
d299 1
a299 1
					case 2:
@


1.11
log
@include only headers which are needed
@
text
@d55 1
a55 2
	}
	while (w != maint->curwin);
d87 1
a87 2
	}
	while (w != maint->curwin);
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@d20 2
a21 2
#include "w.h"
#include "tty.h"
a22 5
#include "rc.h"
#include "vfile.h"
#include "b.h"
#include "bw.h"
#include "tw.h"
a24 1
#include "vs.h"
d26 2
d29 4
a32 1
#include "main.h"
@


1.9
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d2 8
a9 5
	Editor startup and main edit loop
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.8
log
@version 2.9.7-pre3
@
text
@d330 1
a330 1
					msgnwt(bw, msgs[5 + er]);
d380 1
a380 1
		msgnw(lastw(maint)->object, "\\i** Joe's Own Editor v" VERSION " ** Copyright (C) 2001 **\\i");
@


1.7
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d46 1
a46 1
void dofollows()
d63 1
a63 1
void edupd(flg)
d97 1
a97 1
void nungetc(c)
d106 1
a106 1
int edloop(flg)
d158 1
a158 4
int main(argc, argv, envv)
int argc;
char *argv[];
char *envv[];
@


1.6
log
@changed as of joe-2.9.6
@
text
@d12 4
a15 1
#ifdef __JOE_USE_LOCALE
d33 1
a33 3
extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff,
	exask, skiptop, noxon, lines, staen, columns, Baud, dopadding,
	marking, beep;
d46 2
a47 1
void dofollows () {
d51 2
a52 3
		if (w->y != -1 && w->watom->follow && w->object) {
			w->watom->follow (w->object);
		}
d54 2
a55 1
	} while (w != maint->curwin);
d63 2
a64 1
void edupd (flg) {
d68 1
a68 1
	if (dostaupd) {
d70 9
a78 10
	}
	ttgtsz (&wid, &hei);
	if (wid >= 2 && wid != maint->w || hei >= 1 && hei != maint->h) {
		nresize (maint->t, wid, hei);
		sresize (maint);
	}
	dofollows ();
	ttflsh ();
	nscroll (maint->t);
	help_display (maint);
d82 3
a84 4
			if (w->object && w->watom->disp) {
				w->watom->disp (w->object, flg);
			}
			msgout (w);
d87 3
a89 2
	} while (w != maint->curwin);
	cpos (maint->t, maint->curwin->x + maint->curwin->curx, maint->curwin->y + maint->curwin->cury);
d97 2
a98 1
void nungetc (c) {
d100 3
a102 3
		  chmac ();
		  ungot = 1;
		  ungotc = c;
d106 2
a107 1
int edloop (flg) {
a109 1
	SCRN *n = maint->t;
d111 1
a111 1
	if (flg)
d116 1
d120 1
a120 1
	
d122 1
a122 1
			vsrm (exmsg);
d125 2
a126 2
		edupd (1);
		if (!ahead && !have) {
d128 1
a128 2
		}
		if (ungot) {
d130 3
a132 4
		} else {
			c = ttgetc ();
		}
		if (!ahead && c == 10) {
d134 1
a134 2
		}
		m = dokey (maint->curwin->kbd, c);
d137 1
d139 1
a139 1
			if (x) {
a140 4
			}
		}
		if (m) {
			ret = exemac (m);
d142 2
d145 1
a145 1
	if (term == -1) {
d147 1
a147 1
	} else {
a148 1
	}
d152 1
a152 1
extern void setbreak ();
d158 4
a161 4
int main (argc, argv, envv)
     int argc;
     char *argv[];
     char *envv[];
d166 1
d168 1
d175 2
a176 2
#ifdef __JOE_USE_LOCALE
	setlocale (LC_CTYPE, "");
d183 5
a187 5
	strcpy (stdbuf, argv[0]);
	joesep (stdbuf);
	run = namprt (stdbuf);
	rundir = dirprt (stdbuf);
	for (c = 0; run[c]; ++c) {
d189 1
a189 1
			run = vstrunc (run, c);
a191 1
	}
d193 1
a193 1
	run = namprt (argv[0]);
d196 7
a202 10
	if (s = getenv ("LINES")) {
		sscanf (s, "%d", &lines);
	}
	if (s = getenv ("COLUMNS")) {
		sscanf (s, "%d", &columns);
	}
	if (s = getenv ("BAUD")) {
		sscanf (s, "%u", &Baud);
	}
	if (getenv ("DOPADDING")) {
d204 1
a204 2
	}
	if (getenv ("NOXON")) {
d206 1
a206 2
	}
	if (s = getenv ("JOETERM")) {
a207 1
	}
d210 2
a211 2
	if (!(cap = getcap (NULL, 9600, NULL, NULL))) {
		fprintf (stderr, "Couldn't load termcap/terminfo entry\n");
d218 4
a221 4
	s = vsncpy (NULL, 0, sv (run));
	s = vsncpy (sv (s), sc ("rc"));
	c = procrc (cap, s);
	if (c == 0) {
a222 1
	}
d225 5
a229 4
		fprintf (stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush (stderr);
		fgets (buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y') {
a230 1
		}
d233 6
a238 6
	vsrm (s);
	s = vsncpy (NULL, 0, sv (rundir));
	s = vsncpy (sv (s), sv (run));
	s = vsncpy (sv (s), sc ("rc"));
	c = procrc (cap, s);
	if (c == 0) {
a239 1
	}
d242 5
a246 4
		fprintf (stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush (stderr);
		fgets (buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y') {
a247 1
		}
a248 1

d251 1
a251 1
	s = getenv ("HOME");
d253 6
a258 6
		s = vsncpy (NULL, 0, sz (s));
		s = vsncpy (sv (s), sc ("/."));
		s = vsncpy (sv (s), sv (run));
		s = vsncpy (sv (s), sc ("rc"));
		c = procrc (cap, s);
		if (c == 0) {
a259 1
		}
d262 5
a266 4
			fprintf (stderr, "There were errors in '%s'.  Use it anyway?", s);
			fflush (stderr);
			fgets (buf, 8, stdin);
			if (buf[0] == 'y' || buf[0] == 'Y') {
a267 1
			}
d271 6
a276 6
	vsrm (s);
	s = vsncpy (NULL, 0, sc (JOERC));
	s = vsncpy (sv (s), sv (run));
	s = vsncpy (sv (s), sc ("rc"));
	c = procrc (cap, s);
	if (c == 0) {
a277 1
	}
d280 5
a284 4
		fprintf (stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush (stderr);
		fgets (buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y') {
a285 1
		}
a286 1

d289 1
a289 1
	fprintf (stderr, "Couldn't open '%s'\n", s);
d292 2
a293 2
		donerc:
	help_to_array ();
d296 11
a306 12
			if (argv[c][1]) {
				switch (glopt (argv[c] + 1, argv[c + 1], NULL, 1)) {
				  case 0:
					  fprintf (stderr, "Unknown option '%s'\n", argv[c]);
					  break;
				  case 1:
					  break;
				  case 2:
					  ++c;
					  break;
				}
			} else {
a307 1
			}
d311 1
a311 1
	if (!(n = nopen (cap))) {
d313 2
a314 3
	}
	maint = screate (n);
	vmem = vtmp ();
d316 1
a316 1
	for (c = 1, backopt = 0; argv[c]; ++c) {
d318 1
a318 1
			if (!backopt) {
a319 1
			}
d321 1
a321 1
			if (!backopt) {
d323 1
a323 2
		  	}
			if (glopt (argv[c] + 1, argv[c + 1], NULL, 0) == 2) {
a324 1
			}
d326 1
a326 1
			B *b = bfind (argv[c]);
d329 1
d331 4
a334 5
				bw = wmktw (maint, b);
				if (er) {
					msgnwt (bw, msgs[5 + er]);
				}
			} else {
d336 1
a336 2
			}
		  	if (bw) {
d338 1
d341 1
a341 1
					while (backopt != c)
d343 1
a343 1
							sscanf (argv[backopt] + 1, "%ld", &lnum);
d345 1
a345 1
						} else if (glopt(argv[backopt] + 1, argv[backopt + 1], &bw->o, 0) == 2) {
d347 1
a347 1
						} else {
d349 1
a349 1
						}
d354 6
a359 9
				if (er == -1 && bw->o.mnew) {
					exemac (bw->o.mnew);
				}
				if (er == 0 && bw->o.mold) {
					exemac (bw->o.mold);
				}
				if (lnum > 0) {
					pline (bw->cursor, lnum - 1);
				}
d364 1
a364 1
	}
d366 1
a366 1
		wshowall (maint);
d369 1
a369 1
		dofollows ();
d372 4
a375 4
		BW *bw = wmktw (maint, bfind (""));
		if (bw->o.mnew) {
			exemac (bw->o.mnew);
		}
d380 1
a380 10
		help_on (maint);
	}
	if (!nonotice) {
		msgnw (lastw (maint)->object, "\\i** Joe's Own Editor v2.9.6 ** Copyright (C) 2001 **\\i");
	}
	edloop (0);
	vclose (vmem);
	nclose (n);
	if (exmsg) {
		fprintf (stderr, "\n%s\n", exmsg);
d382 7
@


1.5
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Editor startup and main edit loop
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d8 1
d12 3
a14 2
#include <locale.h>
#include "config.h"
d31 2
a32 2
           exask, skiptop, noxon, lines, staen, columns, Baud, dopadding,
           marking, beep;
d34 1
a34 1
extern int idleout;	/* Clear to use /dev/tty for screen */
d36 4
a39 4
int help=0;		/* Set to have help on when starting */
int nonotice=0;		/* Set to prevent copyright notice */
int orphan=0;
char *exmsg=0;		/* Message to display when exiting the editor */
d41 1
a41 1
SCREEN *maint;		/* Main edit screen */
d45 10
a54 10
void dofollows()
 {
 W *w=maint->curwin;
 do
  {
  if(w->y!= -1 && w->watom->follow && w->object) w->watom->follow(w->object);
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 }
d58 1
a58 1
int dostaupd=1;
d61 90
a150 81
void edupd(flg)
 {
 W *w;
 int wid,hei;
 if(dostaupd) staupd=1, dostaupd=0;
 ttgtsz(&wid,&hei);
 if(wid>=2 && wid!=maint->w ||
    hei>=1 && hei!=maint->h)
  {
  nresize(maint->t,wid,hei);
  sresize(maint);
  }
 dofollows();
 ttflsh();
 nscroll(maint->t);
 help_display(maint);
 w=maint->curwin; do
  {
  if(w->y!= -1)
   {
   if(w->object && w->watom->disp) w->watom->disp(w->object,flg);
   msgout(w);
   }
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 cpos(maint->t,
      maint->curwin->x+maint->curwin->curx,
      maint->curwin->y+maint->curwin->cury);
 staupd=0;
 }

static int ahead=0;
static int ungot=0;
static int ungotc=0;

void nungetc(c)
 {
 if(c!='C'-'@@' && c!='M'-'@@')
  {
  chmac();
  ungot=1;
  ungotc=c;
  }
 }

int edloop(flg)
 {
 int term=0;
 int ret=0;
 SCRN *n=maint->t;
 if(flg)
  if(maint->curwin->watom->what==TYPETW) return 0;
  else maint->curwin->notify= &term;
 while(!leave && (!flg || !term))
  {
  MACRO *m;
  int c;
  if(exmsg && !flg)
   {
   vsrm(exmsg);
   exmsg=0;
   }
  edupd(1);
  if(!ahead && !have) ahead=1;
  if(ungot) c=ungotc, ungot=0;
  else c=ttgetc();
  if(!ahead && c==10) c=13;
  m=dokey(maint->curwin->kbd,c);
  if(maint->curwin->main && maint->curwin->main!=maint->curwin)
   {
   int x=maint->curwin->kbd->x;
   maint->curwin->main->kbd->x=x;
   if(x)
    maint->curwin->main->kbd->seq[x-1]=maint->curwin->kbd->seq[x-1];
   }
  if(m) ret=exemac(m);
  }
 if(term== -1) return -1;
 else return ret;
 }
d153 1
a153 1
extern void setbreak();
d159 14
a172 14
int main(argc,argv,envv)
int argc;
char *argv[];
char *envv[];
 {
 CAP *cap;
 char *s;
 char *run;
 char *rundir;
 SCRN *n;
 int opened=0;
 int omid;
 int backopt;
 int c;
d174 3
a176 1
	setlocale(LC_CTYPE,"");
d178 1
a178 1
 mainenv=envv;
d181 11
a191 11
 _fmode=O_BINARY;
 strcpy(stdbuf,argv[0]);
 joesep(stdbuf);
 run=namprt(stdbuf);
 rundir=dirprt(stdbuf);
 for(c=0;run[c];++c)
  if(run[c]=='.')
   {
   run=vstrunc(run,c);
   break;
   }
d193 2
a194 2
 run=namprt(argv[0]);
#endif 
d196 18
a213 6
 if(s=getenv("LINES")) sscanf(s,"%d",&lines);
 if(s=getenv("COLUMNS")) sscanf(s,"%d",&columns);
 if(s=getenv("BAUD")) sscanf(s,"%u",&Baud);
 if(getenv("DOPADDING")) dopadding=1;
 if(getenv("NOXON")) noxon=1;
 if(s=getenv("JOETERM")) joeterm=s;
d216 4
a219 5
 if(!(cap=getcap(NULL,9600,NULL,NULL)))
  {
  fprintf(stderr,"Couldn't load termcap/terminfo entry\n");
  return 1;
  }
d224 33
a256 27
 s=vsncpy(NULL,0,sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

 vsrm(s);
 s=vsncpy(NULL,0,sv(rundir));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }
d260 38
a297 33
 s=getenv("HOME");
 if(s)
  {
  s=vsncpy(NULL,0,sz(s));
  s=vsncpy(sv(s),sc("/."));
  s=vsncpy(sv(s),sv(run));
  s=vsncpy(sv(s),sc("rc"));
  c=procrc(cap,s);
  if(c==0) goto donerc;
  if(c==1)
   {
   char buf[8];
   fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
   fflush(stderr);
   fgets(buf,8,stdin);
   if(buf[0]=='y' || buf[0]=='Y') goto donerc;
   }
  }

 vsrm(s);
 s=vsncpy(NULL,0,sc(JOERC));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }
d301 2
a302 2
 fprintf(stderr,"Couldn't open '%s'\n",s);
 return 1;
d304 110
a413 86
 donerc:
 help_to_array();
 for(c=1;argv[c];++c)
  if(argv[c][0]=='-')
   if(argv[c][1])
    switch(glopt(argv[c]+1,argv[c+1],NULL,1))
     {
     case 0: fprintf(stderr,"Unknown option '%s'\n",argv[c]); break;
     case 1: break;
     case 2: ++c; break;
     }
   else idleout=0;

 if(!(n=nopen(cap))) return 1;
 maint=screate(n);
 vmem=vtmp();

 for(c=1,backopt= 0;argv[c];++c)
  if(argv[c][0]=='+' && argv[c][1])
   {
   if(!backopt) backopt=c;
   }
  else if(argv[c][0]=='-' && argv[c][1])
   {
   if(!backopt) backopt=c;
   if(glopt(argv[c]+1,argv[c+1],NULL,0)==2) ++c;
   }
  else
   {
   B *b=bfind(argv[c]);
   BW *bw=0;
   int er=error;
   if(!orphan || !opened)
    {
    bw=wmktw(maint,b);
    if(er) msgnwt(bw,msgs[5+er]);
    }
   else b->orphan=1;
   if(bw)
    {
    long lnum=0;
    bw->o.readonly=bw->b->rdonly;
    if(backopt) while(backopt!=c)
     if(argv[backopt][0]=='+')
      {
      sscanf(argv[backopt]+1,"%ld",&lnum);
      ++backopt;
      }
     else
      if(glopt(argv[backopt]+1,argv[backopt+1],&bw->o,0)==2) backopt+=2;
      else backopt+=1;
    bw->b->o=bw->o;
    bw->b->rdonly=bw->o.readonly;
    maint->curwin=bw->parent;
    if(er== -1 && bw->o.mnew) exemac(bw->o.mnew);
    if(er==0 && bw->o.mold) exemac(bw->o.mold);
    if(lnum>0) pline(bw->cursor,lnum-1);
    }
   opened=1;
   backopt=0;
   }

 if(opened)
  {
  wshowall(maint);
  omid=mid; mid=1;
  dofollows();
  mid=omid;
  }
 else
  {
  BW *bw=wmktw(maint,bfind(""));
  if(bw->o.mnew) exemac(bw->o.mnew);
  }
 maint->curwin=maint->topwin;

 if(help) help_on(maint);

 if(!nonotice)
  msgnw(lastw(maint)->object,"\\i** Joe's Own Editor v2.9.5 ** Copyright (C) 2001 **\\i");
 edloop(0);
 vclose(vmem);
 nclose(n);
 if(exmsg) fprintf(stderr,"\n%s\n",exmsg);
 return 0;
 }
@


1.4
log
@changed as of joe-2.9.4
@
text
@a240 15
 s=vsncpy(NULL,0,sc("."));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

 vsrm(s);
d359 1
a359 1
  msgnw(lastw(maint)->object,"\\i** Joe's Own Editor v2.9.4 ** Copyright (C) 2001 **\\i");
@


1.3
log
@changed as of joe-2.9.2
@
text
@d1 1
a1 1
 /* Editor startup and main edit loop
d22 1
d85 1
a85 1
 dsphlp(maint);
d174 2
d296 1
a296 1
 izhelp();
d370 3
a372 1
 if(help) helpon(maint);
d374 1
a374 1
  msgnw(lastw(maint)->object,"\\i** Joe's Own Editor v2.8 ** Copyright (C) 1995 Joseph H. Allen **\\i");
@


1.2
log
@changes for joe-2.9.1
@
text
@d1 2
a2 3
/*
	Editor startup and main edit loop
	Copyright (C) 1992 Joseph H. Allen
d4 14
a17 2
	This file is part of JOE (Joe's Own Editor)
*/ 
d21 1
d53 10
a62 8
void dofollows() {
	W *w = maint->curwin;

	do {
		if (w->y!= -1 && w->watom->follow && w->object) w->watom->follow(w->object);
		w = (W *)(w->link.next);
	} while (w!=maint->curwin);
}
d69 31
a99 24
void edupd(flg) {
	W *w;
	int wid,hei;
	if (dostaupd) staupd=1, dostaupd=0;
	ttgtsz(&wid,&hei);
	if (wid>=2 && wid!=maint->w || hei>=1 && hei!=maint->h) {
		nresize(maint->t,wid,hei);
		sresize(maint);
	}
	dofollows();
	ttflsh();
	nscroll(maint->t);
	dsphlp(maint);
	w = maint->curwin; 
	do {
		if (w->y!= -1) {
			if (w->object && w->watom->disp) w->watom->disp(w->object,flg);
			msgout(w);
		}
		w = (W *)(w->link.next);
	}
	while (w!=maint->curwin); cpos(maint->t, maint->curwin->x+maint->curwin->curx, maint->curwin->y+maint->curwin->cury);
	staupd=0;
}
d105 30
a134 28
void nungetc(c) {
	if(c!='C'-'@@' && c!='M'-'@@') {
		chmac();
		ungot=1;
		ungotc=c;
	}
}

int edloop(flg) {
	int term=0;
	int ret=0;
	SCRN *n=maint->t;

	if (flg) 
		if (maint->curwin->watom->what==TYPETW) 
			return 0;
		else 
			maint->curwin->notify= &term;
		while(!leave && (!flg || !term)) {
			MACRO *m;
			int c;
			if (exmsg && !flg) {
				vsrm(exmsg);
				exmsg=0;
			}
			edupd(1);
			if (!ahead && !have) ahead=1;
			if (ungot) c=ungotc, ungot=0;
d177 1
a177 1
 zcpy(stdbuf,argv[0]);
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
 /* Editor startup and main edit loop
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d41 8
a48 10
void dofollows()
 {
 W *w=maint->curwin;
 do
  {
  if(w->y!= -1 && w->watom->follow && w->object) w->watom->follow(w->object);
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 }
d55 24
a78 31
void edupd(flg)
 {
 W *w;
 int wid,hei;
 if(dostaupd) staupd=1, dostaupd=0;
 ttgtsz(&wid,&hei);
 if(wid>=2 && wid!=maint->w ||
    hei>=1 && hei!=maint->h)
  {
  nresize(maint->t,wid,hei);
  sresize(maint);
  }
 dofollows();
 ttflsh();
 nscroll(maint->t);
 dsphlp(maint);
 w=maint->curwin; do
  {
  if(w->y!= -1)
   {
   if(w->object && w->watom->disp) w->watom->disp(w->object,flg);
   msgout(w);
   }
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 cpos(maint->t,
      maint->curwin->x+maint->curwin->curx,
      maint->curwin->y+maint->curwin->cury);
 staupd=0;
 }
d84 28
a111 30
void nungetc(c)
 {
 if(c!='C'-'@@' && c!='M'-'@@')
  {
  chmac();
  ungot=1;
  ungotc=c;
  }
 }

int edloop(flg)
 {
 int term=0;
 int ret=0;
 SCRN *n=maint->t;
 if(flg)
  if(maint->curwin->watom->what==TYPETW) return 0;
  else maint->curwin->notify= &term;
 while(!leave && (!flg || !term))
  {
  MACRO *m;
  int c;
  if(exmsg && !flg)
   {
   vsrm(exmsg);
   exmsg=0;
   }
  edupd(1);
  if(!ahead && !have) ahead=1;
  if(ungot) c=ungotc, ungot=0;
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
