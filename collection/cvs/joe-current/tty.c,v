head	1.51;
access;
symbols
	joe_3_5:1.47
	joe-3_4:1.43
	help:1.43
	joe_3_1:1.31
	joe_3_0:1.23
	joe_2_9_8:1.18
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2008.11.23.21.19.44;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.25.19.37.31;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.25.19.23.04;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.18.23.16.09;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.31.02.24.56;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.25.03.31.39;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.05.20.20.17;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.02.15.41.50;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.02.06.47.52;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.17.23.54.47;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.14.03.21.37;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.08.19.09.53;	author sonic_amiga;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.21.14.47.42;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.29.04.49.44;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.19.20.22.40;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.16.18.54.29;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.13.03.51.53;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.12.15.03.55;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.26.19.38.48;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.20.20.26.43;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.20.16.42.29;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.19.19.46.22;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.18.04.05.09;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.39.19;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.15.09.24.38;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.13.55.22;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.21.47;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.13.20.51;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.13.32.41;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.09;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.09;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Update status line when window size changes.
@
text
@/*
 *	UNIX Tty and Process interface
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef GWINSZ_IN_SYS_IOCTL
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#ifdef HAVE_OPENPTY
#ifdef HAVE_PTY_H
#include <pty.h>
#endif
#ifdef HAVE_LIBUTIL_H
#include <libutil.h>
#endif
#endif

#ifdef HAVE_LOGIN_TTY
#ifdef HAVE_UTMP_H
#include <utmp.h>
#endif
#endif

int idleout = 1;

#ifdef __amigaos
#undef SIGTSTP
#endif

/* We use the defines in sys/ioctl to determine what type
 * tty interface the system uses and what type of system
 * we actually have.
 */
#ifdef HAVE_POSIX_TERMIOS
#  include <termios.h>
#else
#  ifdef HAVE_SYSV_TERMIO
#    include <termio.h>
#    include <sys/termio.h>
#  else
#    include <sgtty.h>
#  endif
#endif

#ifdef HAVE_SETITIMER
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#endif

/* I'm not sure if SCO_UNIX and ISC have __svr4__ defined, but I think
   they might */
#ifdef M_SYS5
#ifndef M_XENIX
#include <sys/stream.h>
#include <sys/ptem.h>
#ifndef __svr4__
#define __svr4__ 1
#endif
#endif
#endif

#ifdef ISC
#ifndef __svr4__
#define __svr4__ 1
#endif
#endif

#ifdef __svr4__
#include <stropts.h>
#endif

/** Aliased defines **/

/* O_NDELAY, O_NONBLOCK, and FNDELAY are all synonyms for placing a descriptor
 * in non-blocking mode; we make whichever one we have look like O_NDELAY
 */
#ifndef O_NDELAY
#ifdef O_NONBLOCK
#define O_NDELAY O_NONBLOCK
#endif
#ifdef FNDELAY
#define O_NDELAY FNDELAY
#endif
#endif

/* Some systems define this, some don't */
#ifndef sigmask
#define sigmask(x) (1<<((x)-1))
#endif

/* Some BSDs don't have TILDE */
#ifndef TILDE
#define TILDE 0
#endif

/* Global configuration variables */

int noxon = 0;			/* Set if ^S/^Q processing should be disabled */
int Baud = 0;			/* Baud rate from joerc, cmd line or environment */

/* The terminal */

FILE *termin = NULL;
FILE *termout = NULL;

/* Original state of tty */

#ifdef HAVE_POSIX_TERMIOS
struct termios oldterm;
#else /* HAVE_POSIX_TERMIOS */
#ifdef HAVE_SYSV_TERMIO
static struct termio oldterm;
#else /* HAVE_SYSV_TERMIO */
static struct sgttyb oarg;
static struct tchars otarg;
static struct ltchars oltarg;
#endif /* HAVE_SYSV_TERMIO */
#endif /* HAVE_POSIX_TERMIOS */

/* Output buffer, index and size */

unsigned char *obuf = NULL;
int obufp = 0;
int obufsiz;

/* The baud rate */

unsigned baud;			/* Bits per second */
unsigned long upc;		/* Microseconds per character */

/* TTY Speed code to baud-rate conversion table (this is dumb- is it really
 * too much to ask for them to just use an integer for the baud-rate?)
 */

static int speeds[] = {
	B50, 50, B75, 75, B110, 110, B134, 134, B150, 150, B200, 200, B300,
	300, B600, 600,
	B1200, 1200, B1800, 1800, B2400, 2400, B4800, 4800, B9600, 9600
#ifdef EXTA
	    , EXTA, 19200
#endif
#ifdef EXTB
	    , EXTB, 38400
#endif
#ifdef B19200
	    , B19200, 19200
#endif
#ifdef B38400
	    , B38400, 38400
#endif
};

/* Input buffer */

int have = 0;			/* Set if we have pending input */
static unsigned char havec;	/* Character read in during pending input check */
int leave = 0;			/* When set, typeahead checking is disabled */

/* TTY mode flag.  1 for open, 0 for closed */
static int ttymode = 0;

/* Signal state flag.  1 for joe, 0 for normal */
static int ttysig = 0;

/* Stuff for shell windows */

static pid_t kbdpid;		/* PID of kbd client */
static int ackkbd = -1;		/* Editor acks keyboard client to this */

static int mpxfd;		/* Editor reads packets from this fd */
static int mpxsfd;		/* Clients send packets to this fd */

static int nmpx = 0;
static int acceptch = NO_MORE_DATA;	/* =-1 if we have last packet */

struct packet {
	MPX *who;
	int size;
	int ch;
	unsigned char data[1024];
} pack;

MPX asyncs[NPROC];

/* Set signals for JOE */
void sigjoe(void)
{
	if (ttysig)
		return;
	ttysig = 1;
	joe_set_signal(SIGHUP, ttsig);
	joe_set_signal(SIGTERM, ttsig);
	joe_set_signal(SIGABRT, ttsig);
	joe_set_signal(SIGINT, SIG_IGN);
	joe_set_signal(SIGPIPE, SIG_IGN);
}

/* Restore signals for exiting */
void signrm(void)
{
	if (!ttysig)
		return;
	ttysig = 0;
	joe_set_signal(SIGABRT, SIG_DFL);
	joe_set_signal(SIGHUP, SIG_DFL);
	joe_set_signal(SIGTERM, SIG_DFL);
	joe_set_signal(SIGINT, SIG_DFL);
	joe_set_signal(SIGPIPE, SIG_DFL);
}

/* Open terminal and set signals */

void ttopen(void)
{
	sigjoe();
	ttopnn();
}

/* Close terminal and restore signals */

void ttclose(void)
{
	ttclsn();
	signrm();
}

static int winched = 0;
#ifdef SIGWINCH
/* Window size interrupt handler */
static RETSIGTYPE winchd(int unused)
{
	++winched;
	REINSTALL_SIGHANDLER(SIGWINCH, winchd);
}
#endif

/* Second ticker */

int ticked = 0;
static RETSIGTYPE dotick(int unused)
{
	ticked = 1;
}

void tickoff(void)
{
#ifdef HAVE_SETITIMER
	struct itimerval val;
	val.it_value.tv_sec = 0;
	val.it_value.tv_usec = 0;
	val.it_interval.tv_sec = 0;
	val.it_interval.tv_usec = 0;
	setitimer(ITIMER_REAL,&val,NULL);
#else
	alarm(0);
#endif
}

void tickon(void)
{
#ifdef HAVE_SETITIMER
	struct itimerval val;
	val.it_interval.tv_sec = 0;
	val.it_interval.tv_usec = 0;
	if (auto_scroll) {
		int tim = auto_trig_time - mnow();
		if (tim < 0)
			tim = 1;
		tim *= 1000;
		val.it_value.tv_sec = 0;
		val.it_value.tv_usec = tim;
	} else {
		val.it_value.tv_sec = 1;
		val.it_value.tv_usec = 0;
	}
	ticked = 0;
	joe_set_signal(SIGALRM, dotick);
	setitimer(ITIMER_REAL,&val,NULL);
#else
	ticked = 0;
	joe_set_signal(SIGALRM, dotick);
	alarm(1);
#endif
}

/* Open terminal */

void ttopnn(void)
{
	int x, bbaud;

#ifdef HAVE_POSIX_TERMIOS
	struct termios newterm;
#else
#ifdef HAVE_SYSV_TERMIO
	struct termio newterm;
#else
	struct sgttyb arg;
	struct tchars targ;
	struct ltchars ltarg;
#endif
#endif

	if (!termin) {
		if (idleout ? (!(termin = stdin) || !(termout = stdout)) : (!(termin = fopen("/dev/tty", "r")) || !(termout = fopen("/dev/tty", "w")))) {
			fprintf(stderr, (char *)joe_gettext(_("Couldn\'t open /dev/tty\n")));
			exit(1);
		} else {
#ifdef SIGWINCH
			joe_set_signal(SIGWINCH, winchd);
#endif
		}
	}

	if (ttymode)
		return;
	ttymode = 1;
	fflush(termout);

#ifdef HAVE_POSIX_TERMIOS
	tcgetattr(fileno(termin), &oldterm);
	newterm = oldterm;
	newterm.c_lflag = 0;
	if (noxon)
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR | IXON | IXOFF);
	else
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR);
	newterm.c_oflag = 0;
	newterm.c_cc[VMIN] = 1;
	newterm.c_cc[VTIME] = 0;
	tcsetattr(fileno(termin), TCSADRAIN, &newterm);
	bbaud = cfgetospeed(&newterm);
#else
#ifdef HAVE_SYSV_TERMIO
	joe_ioctl(fileno(termin), TCGETA, &oldterm);
	newterm = oldterm;
	newterm.c_lflag = 0;
	if (noxon)
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR | IXON | IXOFF);
	else
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR);
	newterm.c_oflag = 0;
	newterm.c_cc[VMIN] = 1;
	newterm.c_cc[VTIME] = 0;
	joe_ioctl(fileno(termin), TCSETAW, &newterm);
	bbaud = (newterm.c_cflag & CBAUD);
#else
	joe_ioctl(fileno(termin), TIOCGETP, &arg);
	joe_ioctl(fileno(termin), TIOCGETC, &targ);
	joe_ioctl(fileno(termin), TIOCGLTC, &ltarg);
	oarg = arg;
	otarg = targ;
	oltarg = ltarg;
	arg.sg_flags = ((arg.sg_flags & ~(ECHO | CRMOD | XTABS | ALLDELAY | TILDE)) | CBREAK);
	if (noxon) {
		targ.t_startc = -1;
		targ.t_stopc = -1;
	}
	targ.t_intrc = -1;
	targ.t_quitc = -1;
	targ.t_eofc = -1;
	targ.t_brkc = -1;
	ltarg.t_suspc = -1;
	ltarg.t_dsuspc = -1;
	ltarg.t_rprntc = -1;
	ltarg.t_flushc = -1;
	ltarg.t_werasc = -1;
	ltarg.t_lnextc = -1;
	joe_ioctl(fileno(termin), TIOCSETN, &arg);
	joe_ioctl(fileno(termin), TIOCSETC, &targ);
	joe_ioctl(fileno(termin), TIOCSLTC, &ltarg);
	bbaud = arg.sg_ospeed;
#endif
#endif

	baud = 9600;
	upc = 0;
	for (x = 0; x != 30; x += 2)
		if (bbaud == speeds[x]) {
			baud = speeds[x + 1];
			break;
		}
	if (Baud)
		baud = Baud;
	upc = DIVIDEND / baud;
	if (obuf)
		joe_free(obuf);
	if (!(TIMES * upc))
		obufsiz = 4096;
	else {
		obufsiz = 1000000 / (TIMES * upc);
		if (obufsiz > 4096)
			obufsiz = 4096;
	}
	if (!obufsiz)
		obufsiz = 1;
	obuf = (unsigned char *) joe_malloc(obufsiz);
}

/* Close terminal */

void ttclsn(void)
{
	int oleave;

	if (ttymode)
		ttymode = 0;
	else
		return;

	oleave = leave;
	leave = 1;

	ttflsh();

#ifdef HAVE_POSIX_TERMIOS
	tcsetattr(fileno(termin), TCSADRAIN, &oldterm);
#else
#ifdef HAVE_SYSV_TERMIO
	joe_ioctl(fileno(termin), TCSETAW, &oldterm);
#else
	joe_ioctl(fileno(termin), TIOCSETN, &oarg);
	joe_ioctl(fileno(termin), TIOCSETC, &otarg);
	joe_ioctl(fileno(termin), TIOCSLTC, &oltarg);
#endif
#endif

	leave = oleave;
}

/* Timer interrupt handler */

static int yep;
static RETSIGTYPE dosig(int unused)
{
	yep = 1;
}

/* FLush output and check for typeahead */

#ifdef HAVE_SETITIMER
#ifdef SIG_SETMASK
static void maskit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigaddset(&set, SIGALRM);
	sigprocmask(SIG_SETMASK, &set, NULL);
}

static void unmaskit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigprocmask(SIG_SETMASK, &set, NULL);
}

static void pauseit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigsuspend(&set);
}

#else
static void maskit(void)
{
	sigsetmask(sigmask(SIGALRM));
}

static void unmaskit(void)
{
	sigsetmask(0);
}

static void pauseit(void)
{
	sigpause(0);
}

#endif
#endif

int ttflsh(void)
{
	/* Flush output */
	if (obufp) {
		unsigned long usec = obufp * upc;	/* No. usecs this write should take */

#ifdef HAVE_SETITIMER
		if (usec >= 50000 && baud < 9600) {
			struct itimerval a, b;

			a.it_value.tv_sec = usec / 1000000;
			a.it_value.tv_usec = usec % 1000000;
			a.it_interval.tv_usec = 0;
			a.it_interval.tv_sec = 0;
			alarm(0);
			joe_set_signal(SIGALRM, dosig);
			yep = 0;
			maskit();
			setitimer(ITIMER_REAL, &a, &b);
			joe_write(fileno(termout), obuf, obufp);
			while (!yep)
				pauseit();
			unmaskit();
		} else
			joe_write(fileno(termout), obuf, obufp);

#else

		joe_write(fileno(termout), obuf, obufp);

#ifdef FIORDCHK
		if (baud < 9600 && usec / 1000)
			nap(usec / 1000);
#endif

#endif

		obufp = 0;
	}

	/* Ack previous packet */
	if (ackkbd != -1 && acceptch != NO_MORE_DATA && !have) {
		unsigned char c = 0;

		if (pack.who && pack.who->func)
			joe_write(pack.who->ackfd, &c, 1);
		else
			joe_write(ackkbd, &c, 1);
		acceptch = NO_MORE_DATA;
	}

	/* Check for typeahead or next packet */

	if (!have && !leave) {
		if (ackkbd != -1) {
			fcntl(mpxfd, F_SETFL, O_NDELAY);
			if (read(mpxfd, &pack, sizeof(struct packet) - 1024) > 0) {
				fcntl(mpxfd, F_SETFL, 0);
				joe_read(mpxfd, pack.data, pack.size);
				have = 1;
				acceptch = pack.ch;
			} else
				fcntl(mpxfd, F_SETFL, 0);
		} else {
			/* Set terminal input to non-blocking */
			fcntl(fileno(termin), F_SETFL, O_NDELAY);

			/* Try to read */
			if (read(fileno(termin), &havec, 1) == 1)
				have = 1;

			/* Set terminal back to blocking */
			fcntl(fileno(termin), F_SETFL, 0);
		}
	}
	return 0;
}

/* Read next character from input */

void mpxdied(MPX *m);

long last_time;

int ttgetc(void)
{
	int stat;
	long new_time;
	int flg;


	tickon();

      loop:
      	flg = 0;
      	/* Status line clock */
	new_time = time(NULL);
	if (new_time != last_time) {
		last_time = new_time;
		dostaupd = 1;
		ticked = 1;
	}
	/* Autoscroller */
	if (auto_scroll && mnow() >= auto_trig_time) {
		do_auto_scroll();
		ticked = 1;
		flg = 1;
	}
	ttflsh();
	while (winched) {
		winched = 0;
		dostaupd = 1;
		edupd(1);
		ttflsh();
	}
	if (ticked) {
		edupd(flg);
		ttflsh();
		tickon();
	}
	if (ackkbd != -1) {
		if (!have) {	/* Wait for input */
			stat = read(mpxfd, &pack, sizeof(struct packet) - 1024);

			if (pack.size && stat > 0) {
				joe_read(mpxfd, pack.data, pack.size);
			} else if (stat < 1) {
				if (winched || ticked)
					goto loop;
				else
					ttsig(0);
			}
			acceptch = pack.ch;
		}
		have = 0;
		if (pack.who) {	/* Got bknd input */
			if (acceptch != NO_MORE_DATA) {
				if (pack.who->func) {
					pack.who->func(pack.who->object, pack.data, pack.size);
					edupd(1);
				}
			} else
				mpxdied(pack.who);
			goto loop;
		} else {
			if (acceptch != NO_MORE_DATA) {
				tickoff();
				return acceptch;
			}
			else {
				tickoff();
				ttsig(0);
				return 0;
			}
		}
	}
	if (have) {
		have = 0;
	} else {
		if (read(fileno(termin), &havec, 1) < 1) {
			if (winched || ticked)
				goto loop;
			else
				ttsig(0);
		}
	}
	tickoff();
	return havec;
}

/* Write string to output */

void ttputs(unsigned char *s)
{
	while (*s) {
		obuf[obufp++] = *s++;
		if (obufp == obufsiz)
			ttflsh();
	}
}

/* Get window size */

void ttgtsz(int *x, int *y)
{
#ifdef TIOCGSIZE
	struct ttysize getit;
#else
#ifdef TIOCGWINSZ
	struct winsize getit;
#endif
#endif

	*x = 0;
	*y = 0;

#ifdef TIOCGSIZE
	if (joe_ioctl(fileno(termout), TIOCGSIZE, &getit) != -1) {
		*x = getit.ts_cols;
		*y = getit.ts_lines;
	}
#else
#ifdef TIOCGWINSZ
	if (joe_ioctl(fileno(termout), TIOCGWINSZ, &getit) != -1) {
		*x = getit.ws_col;
		*y = getit.ws_row;
	}
#endif
#endif
}

int ttshell(unsigned char *cmd)
{
	int x, omode = ttymode;
	int stat= -1;
	unsigned char *s = (unsigned char *)getenv("SHELL");

	if (!s) {
		s = USTR "/bin/sh";
		/* return; */
	}
	ttclsn();
#ifdef HAVE_FORK
	if ((x = fork()) != 0) {
#else
	if ((x = vfork()) != 0) { /* For AMIGA only  */
#endif
		if (x != -1)
			wait(&stat);
		if (omode)
			ttopnn();
		return stat;
	} else {
		signrm();
		if (cmd)
			execl((char *)s, (char *)s, "-c", cmd, NULL);
		else {
			fprintf(stderr, (char *)joe_gettext(_("You are at the command shell.  Type 'exit' to return\n")));
			execl((char *)s, (char *)s, NULL);
		}
		_exit(0);
		return 0;
	}
}

/* Create keyboard task */

static void mpxresume(void)
{
	int fds[2];
	pipe(fds);
	acceptch = NO_MORE_DATA;
	have = 0;
	if (!(kbdpid = fork())) {
		close(fds[1]);
		do {
			unsigned char c;
			int sta;

			pack.who = 0;
			sta = joe_read(fileno(termin), &c, 1);
			if (sta == 0)
				pack.ch = NO_MORE_DATA;
			else
				pack.ch = c;
			pack.size = 0;
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024);
		} while (joe_read(fds[0], &pack, 1) == 1);
		_exit(0);
	}
	close(fds[0]);
	ackkbd = fds[1];
}

/* Kill keyboard task */

static void mpxsusp(void)
{
	if (ackkbd!=-1) {
		kill(kbdpid, 9);
		while (wait(NULL) < 0 && errno == EINTR)
			/* do nothing */;
		close(ackkbd);
	}
}

/* We used to leave the keyboard copy task around during suspend, but
   Cygwin gets confused when two processes are waiting for input and you
   change the tty from raw to cooked (on the call to ttopnn()): the keyboard
   process was stuck in cooked until he got a carriage return- then he
   switched back to raw (he's supposed to switch to raw without waiting for
   the end of line). Probably this should be done for ttshell() as well. */

void ttsusp(void)
{
	int omode;

#ifdef SIGTSTP
	omode = ttymode;
	mpxsusp();
	ttclsn();
	fprintf(stderr, (char *)joe_gettext(_("You have suspended the program.  Type 'fg' to return\n")));
	kill(0, SIGTSTP);
#ifdef junk
	/* Hmmm... this should not have been necessary */
	if (ackkbd != -1)
		kill(kbdpid, SIGCONT);
#endif
	if (omode)
		ttopnn();
	if (ackkbd!= -1)
		mpxresume();
#else
	ttshell(NULL);
#endif
}

/* Stuff for asynchronous I/O multiplexing.  We do not use streams or
   select() because joe needs to work on versions of UNIX which predate
   these calls.  Instead, when there is multiple async sources, we use
   helper processes which packetize data from the sources.  A header on each
   packet indicates the source.  There is no guarentee that packets getting
   written to the same pipe don't get interleaved, but you can reasonable
   rely on it with small packets. */

static void mpxstart(void)
{
	int fds[2];
	pipe(fds);
	mpxfd = fds[0];
	mpxsfd = fds[1];
	mpxresume();
}

static void mpxend(void)
{
	mpxsusp();
	ackkbd = -1;
	close(mpxfd);
	close(mpxsfd);
	if (have)
		havec = pack.ch;
}

/* Get a pty/tty pair.  Returns open pty in 'ptyfd' and returns tty name
 * string in static buffer or NULL if couldn't get a pair.
 */

#ifdef __svr4__
#define USEPTMX 1
#else
#ifdef __CYGWIN__
#define USEPTMX 1
#endif
#endif

#ifdef sgi

/* Newer sgi machines can do it the __svr4__ way, but old ones can't */

extern char *_getpty();

static unsigned char *getpty(int *ptyfd)
{
	return (unsigned char *)_getpty(ptyfd, O_RDWR, 0600, 0);
}

#else
#ifdef USEPTMX

/* Strange streams way */

extern char *ptsname();

static unsigned char *getpty(int *ptyfd)
{
	int fdm;
	*ptyfd = fdm = open("/dev/ptmx", O_RDWR);
	grantpt(fdm);
	unlockpt(fdm);
	return (unsigned char *)ptsname(fdm);
}

#else
#ifdef HAVE_OPENPTY

/* BSD function, present in libc5 and glibc2 */

static unsigned char *getpty(int *ptyfd)
{
	static unsigned char name[32];
	int ttyfd;

        if (openpty(ptyfd, &ttyfd, (char *)name, NULL, NULL) == 0)
           return(name);
        else
	   return (NULL);
}

#else
/* The normal way: for each possible pty/tty pair, try to open the pty and
 * then the corresponding tty.  If both could be opened, close them both and
 * then re-open the pty.  If that succeeded, return with the opened pty and the
 * name of the tty.
 *
 * Logically you should only have to succeed in opening the pty- but the
 * permissions may be set wrong on the tty, so we have to try that too.
 * We close them both and re-open the pty because we want the forked process
 * to open the tty- that way it gets to be the controlling tty for that
 * process and the process gets to be the session leader.
 */

static unsigned char *getpty(int *ptyfd)
{
	int x, fd;
	unsigned char *orgpwd = pwd();
	static unsigned char **ptys = NULL;
	static unsigned char *ttydir;
	static unsigned char *ptydir;
	static unsigned char ttyname[32];

	if (!ptys) {
		ttydir = USTR "/dev/pty/";
		ptydir = USTR "/dev/ptym/";	/* HPUX systems */
		if (chpwd(ptydir) || !(ptys = rexpnd(USTR "pty*")))
			if (!ptys) {
				ttydir = ptydir = USTR "/dev/";	/* Everyone else */
				if (!chpwd(ptydir))
					ptys = rexpnd(USTR "pty*");
			}
	}
	chpwd(orgpwd);

	if (ptys)
		for (fd = 0; ptys[fd]; ++fd) {
			zcpy(ttyname, ptydir);
			zcat(ttyname, ptys[fd]);
			if ((*ptyfd = open((char *)ttyname, O_RDWR)) >= 0) {
				ptys[fd][0] = 't';
				zcpy(ttyname, ttydir);
				zcat(ttyname, ptys[fd]);
				ptys[fd][0] = 'p';
				x = open((char *)ttyname, O_RDWR);
				if (x >= 0) {
					close(x);
					close(*ptyfd);
					zcpy(ttyname, ptydir);
					zcat(ttyname, ptys[fd]);
					*ptyfd = open((char *)ttyname, O_RDWR);
					ptys[fd][0] = 't';
					zcpy(ttyname, ttydir);
					zcat(ttyname, ptys[fd]);
					ptys[fd][0] = 'p';
					return ttyname;
				} else
					close(*ptyfd);
			}
		}
	return NULL;
}

#endif
#endif
#endif

/* Shell dies signal handler.  Puts pty in non-block mode so
 * that read returns with <1 when all data from process has
 * been read. */
int dead = 0;
int death_fd;
static RETSIGTYPE death(int unused)
{
	fcntl(death_fd,F_SETFL,O_NDELAY);
	wait(NULL);
	dead = 1;
}

#ifndef SIGCHLD
#define SIGCHLD SIGCLD
#endif

/* Build a new environment, but replace one variable */

static unsigned char **newenv(unsigned char **old, unsigned char *s)
{
	unsigned char **new;
	int x, y, z;

	for (x = 0; old[x]; ++x) ;
	new = (unsigned char **) joe_malloc((x + 2) * sizeof(unsigned char *));

	for (x = 0, y = 0; old[x]; ++x) {
		for (z = 0; s[z] != '='; ++z)
			if (s[z] != old[x][z])
				break;
		if (s[z] == '=') {
			if (s[z + 1])
				new[y++] = s;
		} else
			new[y++] = old[x];
	}
	if (x == y)
		new[y++] = s;
	new[y] = 0;
	return new;
}

/* Create a shell process */

/* If out_only is set, leave program's stdin attached to JOE's stdin */

MPX *mpxmk(int *ptyfd, unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj, int out_only)
{
	unsigned char buf[80];
	int fds[2];
	int comm[2];
	pid_t pid;
	int x;
	MPX *m = 0;
	unsigned char *name;

	/* Get pty/tty pair */
	if (!(name = getpty(ptyfd)))
		return NULL;

	/* Find free slot */
	for (x = 0; x != NPROC; ++x)
		if (!asyncs[x].func) {
			m = asyncs + x;
			break;
		}
	if (x==NPROC)
		return NULL;

	/* Fixes cygwin console bug: if you fork() with inverse video he assumes you want
	 * ESC [ 0 m to keep it in inverse video from then on. */
	set_attr(maint->t,0);

	/* Flush output */
	ttflsh();

	/* Bump no. current async inputs to joe */
	++nmpx;

	/* Start input multiplexer */
	if (ackkbd == -1)
		mpxstart();

	/* Remember callback function */
	m->func = func;
	m->object = object;
	m->die = die;
	m->dieobj = dieobj;

	/* Acknowledgement pipe */
	pipe(fds);
	m->ackfd = fds[1];

	/* PID number pipe */
	pipe(comm);


	/* Create processes... */
	if (!(m->kpid = fork())) {
		/* This process copies data from shell to joe */
		/* After each packet it sends to joe it waits for
		   an acknowledgement from joe so that it can not get
		   too far ahead with buffering */

		/* Close joe side of pipes */
		close(fds[1]);
		close(comm[0]);

		/* Flag which indicates child died */
		dead = 0;
		death_fd = *ptyfd;
		joe_set_signal(SIGCHLD, death);

		if (!(pid = fork())) {
			/* This process becomes the shell */
			signrm();

			/* Close pty (we only need tty) */
			close(*ptyfd);

			/* All of this stuff is for disassociating ourself from
			   controlling tty (session leader) and starting a new
			   session.  This is the most non-portable part of UNIX- second
			   only to pty/tty pair creation. */
#ifndef HAVE_LOGIN_TTY

#ifdef TIOCNOTTY
			x = open("/dev/tty", O_RDWR);
			joe_ioctl(x, TIOCNOTTY, 0);
#endif

			setsid();	/* I think you do setprgp(0,0) on systems with no setsid() */
#ifndef SETPGRP_VOID
			setpgrp(0, 0);
#else
			setpgrp();
#endif

#endif

			/* Close all fds */
			for (x = (out_only ? 1 : 0); x != 32; ++x)
				close(x);	/* Yes, this is quite a kludge... all in the
						   name of portability */


			/* Open the TTY */
			if ((x = open((char *)name, O_RDWR)) != -1) {	/* Standard input */
				unsigned char **env = newenv(mainenv, USTR "TERM=");


				if (!out_only) {
#ifdef HAVE_LOGIN_TTY
					login_tty(x);

#else
				/* This tells the fd that it's a tty (I think) */
#ifdef __svr4__
					joe_ioctl(x, I_PUSH, "ptem");
					joe_ioctl(x, I_PUSH, "ldterm");
#endif

				/* Open stdout, stderr */
					dup(x);
					dup(x);	/* Standard output, standard error */
					/* (yes, stdin, stdout, and stderr must all be open for reading and
					 * writing.  On some systems the shell assumes this */
#endif

#ifdef HAVE_POSIX_TERMIOS
					tcsetattr(0, TCSADRAIN, &oldterm);
#else
#ifdef HAVE_SYSV_TERMIO
					joe_ioctl(0, TCSETAW, &oldterm);
#else
					joe_ioctl(0, TIOCSETN, &oarg);
					joe_ioctl(0, TIOCSETC, &otarg);
					joe_ioctl(0, TIOCSLTC, &oltarg);
#endif
#endif
					/* We could probably have a special TTY set-up for JOE, but for now
					 * we'll just use the TTY setup for the TTY was was run on */

					/* Execute the shell */
					execve((char *)cmd, (char **)args, (char **)env);

					/* If shell didn't execute */
					joe_snprintf_1(buf,sizeof(buf),joe_gettext(_("Couldn't execute shell '%s'\n")),cmd);
					write(1,(char *)buf,zlen(buf));
					sleep(1);

				} else {
					unsigned char buf[1024];
					int len;
					dup(x); /* Standard error */
					
					for (;;) {
						len = read(0, buf, sizeof(buf));
						if (len > 0)
							write(1, buf, len);
						else
							break;
					}
				}


			}

			_exit(0);
		}

		/* Tell JOE PID of shell */
		joe_write(comm[1], &pid, sizeof(pid));

		/* sigpipe should be ignored here. */

		/* This process copies data from shell to JOE until EOF.  It creates a packet
		   for each data */


		/* We don't really get EOF from a pty- it would just wait forever
		   until someone else writes to the tty.  So: when the shell
		   dies, the child died signal handler death() puts pty in non-block
		   mode.  This allows us to read any remaining data- then
		   read returns 0 and we know we're done. */

	      loop:
		pack.who = m;
		pack.ch = 0;

		/* Read data from process */
		pack.size = joe_read(*ptyfd, pack.data, 1024);

		/* On SUNOS 5.8, the very first read from the pty returns 0 for some reason */
		if (!pack.size)
			pack.size = joe_read(*ptyfd, pack.data, 1024);

		if (pack.size > 0) {
			/* Send data to JOE, wait for ack */
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024 + pack.size);

			joe_read(fds[0], &pack, 1);
			goto loop;
		} else {
			/* Shell died: return */
			pack.ch = NO_MORE_DATA;
			pack.size = 0;
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024);

			_exit(0);
		}
	}
	joe_read(comm[0], &m->pid, sizeof(m->pid));

	/* We only need comm once */
	close(comm[0]);
	close(comm[1]);

	/* Close other side of copy process pipe */
	close(fds[0]);
	return m;
}

void mpxdied(MPX *m)
{
	if (!--nmpx)
		mpxend();
	while (wait(NULL) < 0 && errno == EINTR)
		/* do nothing */;
	if (m->die)
		m->die(m->dieobj);
	m->func = NULL;
	edupd(1);
}
@


1.50
log
@Check for EINTR from ioctl.  Improve xml.jsf.in a little mor.
@
text
@d612 1
@


1.49
log
@Allow > in content.  rename accept and chsize.
@
text
@d349 1
a349 1
	ioctl(fileno(termin), TCGETA, &oldterm);
d359 1
a359 1
	ioctl(fileno(termin), TCSETAW, &newterm);
d362 3
a364 3
	ioctl(fileno(termin), TIOCGETP, &arg);
	ioctl(fileno(termin), TIOCGETC, &targ);
	ioctl(fileno(termin), TIOCGLTC, &ltarg);
d383 3
a385 3
	ioctl(fileno(termin), TIOCSETN, &arg);
	ioctl(fileno(termin), TIOCSETC, &targ);
	ioctl(fileno(termin), TIOCSLTC, &ltarg);
d434 1
a434 1
	ioctl(fileno(termin), TCSETAW, &oldterm);
d436 3
a438 3
	ioctl(fileno(termin), TIOCSETN, &oarg);
	ioctl(fileno(termin), TIOCSETC, &otarg);
	ioctl(fileno(termin), TIOCSLTC, &oltarg);
d697 1
a697 1
	if (ioctl(fileno(termout), TIOCGSIZE, &getit) != -1) {
d703 1
a703 1
	if (ioctl(fileno(termout), TIOCGWINSZ, &getit) != -1) {
d1093 1
a1093 1
			ioctl(x, TIOCNOTTY, 0);
d1123 2
a1124 2
					ioctl(x, I_PUSH, "ptem");
					ioctl(x, I_PUSH, "ldterm");
d1138 1
a1138 1
					ioctl(0, TCSETAW, &oldterm);
d1140 3
a1142 3
					ioctl(0, TIOCSETN, &oarg);
					ioctl(0, TIOCSETC, &otarg);
					ioctl(0, TIOCSLTC, &oltarg);
@


1.48
log
@semiautomatic variables
@
text
@d188 1
a188 1
static int accept = NO_MORE_DATA;	/* =-1 if we have last packet */
d542 1
a542 1
	if (ackkbd != -1 && accept != NO_MORE_DATA && !have) {
d549 1
a549 1
		accept = NO_MORE_DATA;
d561 1
a561 1
				accept = pack.ch;
d632 1
a632 1
			accept = pack.ch;
d636 1
a636 1
			if (accept != NO_MORE_DATA) {
d645 1
a645 1
			if (accept != NO_MORE_DATA) {
d647 1
a647 1
				return accept;
d751 1
a751 1
	accept = NO_MORE_DATA;
@


1.47
log
@UC -> USTR
@
text
@a22 1

a25 1

a28 1

@


1.46
log
@change US to UC
@
text
@d721 1
a721 1
		s = UC "/bin/sh";
d925 3
a927 3
		ttydir = UC "/dev/pty/";
		ptydir = UC "/dev/ptym/";	/* HPUX systems */
		if (chpwd(ptydir) || !(ptys = rexpnd(UC "pty*")))
d929 1
a929 1
				ttydir = ptydir = UC "/dev/";	/* Everyone else */
d931 1
a931 1
					ptys = rexpnd(UC "pty*");
d1116 1
a1116 1
				unsigned char **env = newenv(mainenv, UC "TERM=");
@


1.45
log
@compiler warns
@
text
@d721 1
a721 1
		s = US "/bin/sh";
d925 3
a927 3
		ttydir = US "/dev/pty/";
		ptydir = US "/dev/ptym/";	/* HPUX systems */
		if (chpwd(ptydir) || !(ptys = rexpnd(US "pty*")))
d929 1
a929 1
				ttydir = ptydir = US "/dev/";	/* Everyone else */
d931 1
a931 1
					ptys = rexpnd(US "pty*");
d1116 1
a1116 1
				unsigned char **env = newenv(mainenv, US "TERM=");
@


1.44
log
@large file patch, makefile fix, tty.c fix.
@
text
@d23 1
d27 1
d31 7
d1021 1
a1021 1
	MPX *m;
@


1.43
log
@cygwin fixes
@
text
@d26 3
a42 1
#  include <sys/termios.h>
@


1.42
log
@don't call cat for joe <foo
@
text
@a868 2
	unsigned char *name;

@


1.41
log
@gettext()
@
text
@d1129 1
a1129 1
				tcsetattr(0, TCSADRAIN, &oldterm);
d1132 1
a1132 1
				ioctl(0, TCSETAW, &oldterm);
d1134 3
a1136 3
				ioctl(0, TIOCSETN, &oarg);
				ioctl(0, TIOCSETC, &otarg);
				ioctl(0, TIOCSLTC, &oltarg);
d1139 10
d1151 2
d1155 7
a1164 10
				/* We could probably have a special TTY set-up for JOE, but for now
				 * we'll just use the TTY setup for the TTY was was run on */

				/* Execute the shell */
				execve((char *)cmd, (char **)args, (char **)env);

				/* If shell didn't execute */
				joe_snprintf_1(buf,sizeof(buf),joe_gettext(_("Couldn't execute shell '%s'\n")),cmd);
				write(1,(char *)buf,zlen(buf));
				sleep(1);
@


1.40
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d312 1
a312 1
			fprintf(stderr, "Couldn\'t open /dev/tty\n");
d729 1
a729 1
			fprintf(stderr, "You are at the command shell.  Type 'exit' to return\n");
d793 1
a793 1
	fprintf(stderr, "You have suspended the program.  Type 'fg' to return\n");
d1153 1
a1153 1
				joe_snprintf_1((char *)buf,sizeof(buf),"Couldn't execute shell '%s'\n",cmd);
@


1.39
log
@fix input redirection
@
text
@a7 1
#include "config.h"
a9 4
#include <sys/types.h>
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
a14 4
#include <stdio.h>
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
a27 4
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

a29 2
#include "config.h"

a77 9
/* JOE include files */

#include "main.h"
#include "path.h"
#include "tty.h"
#include "utils.h"
#include "mouse.h"
#include "cmd.h"

a245 1
extern int dostaupd;
a250 2
extern int auto_scroll;

a264 3
extern int auto_scroll;
extern int auto_trig_time;

a883 1
	int fdm;
a976 2
extern unsigned char **mainenv;

@


1.38
log
@Match JOE to working Xterm-212
@
text
@d1036 3
a1038 1
MPX *mpxmk(int *ptyfd, unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj)
d1088 1
d1131 1
d1133 1
a1133 1
			for (x = 0; x != 32; ++x)
d1137 1
d1142 2
d1145 1
a1145 1
				login_tty(x);
d1150 2
a1151 2
				ioctl(x, I_PUSH, "ptem");
				ioctl(x, I_PUSH, "ldterm");
d1155 4
a1158 4
				dup(x);
				dup(x);	/* Standard output, standard error */
				/* (yes, stdin, stdout, and stderr must all be open for reading and
				 * writing.  On some systems the shell assumes this */
a1160 2
				/* We could probably have a special TTY set-up for JOE, but for now
				 * we'll just use the TTY setup for the TTY was was run on */
d1173 9
d1187 1
a1187 1
				write(0,(char *)buf,zlen(buf));
@


1.37
log
@fix gcc-4.0.0 warnings
@
text
@d223 1
d234 1
@


1.36
log
@Autoscroll
@
text
@a37 1
#include <string.h>
d958 2
a959 2
			strcpy((char *)ttyname, (char *)ptydir);
			strcat((char *)ttyname, (char  *)(ptys[fd]));
d962 2
a963 2
				strcpy((char *)ttyname, (char *)ttydir);
				strcat((char *)ttyname, (char *)(ptys[fd]));
d969 2
a970 2
					strcpy((char *)ttyname, (char *)ptydir);
					strcat((char *)ttyname, (char *)(ptys[fd]));
d973 2
a974 2
					strcpy((char *)ttyname, (char *)ttydir);
					strcat((char *)ttyname, (char *)(ptys[fd]));
d1171 1
a1171 1
				write(0,(char *)buf,strlen((char *)buf));
@


1.35
log
@Get joe to compile on irix
@
text
@d100 2
d275 2
d279 8
d288 1
d291 3
d296 19
d318 1
d610 1
d616 2
d624 6
d637 1
a637 1
		edupd(0);
@


1.34
log
@Perforce macro and support for it.
@
text
@d698 5
a702 1
	if ((x = vfork()) != 0) {
@


1.33
log
@
AmigaOS is now supported. See "README.AMIGA" file for details
@
text
@d687 1
a687 1
void ttshell(unsigned char *cmd)
d690 1
d700 1
a700 1
			wait(NULL);
d703 1
d713 1
@


1.32
log
@Fix -pedantic warnings.
@
text
@d46 4
d697 1
a697 1
	if ((x = fork()) != 0) {
@


1.31
log
@aspell support.
Added Home, End, Inserst, Delete key sequences.
@
text
@d861 1
a861 1
        if (openpty(ptyfd, &ttyfd, name, NULL, NULL) == 0)
@


1.30
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@a266 1
	dostaupd = 1;
d564 2
d569 2
d575 6
@


1.29
log
@More fixes for Cygwin: shell windows now work properly.
@
text
@d816 1
a816 1
extern unsigned char *_getpty();
d820 1
a820 1
	return _getpty(ptyfd, O_RDWR, 0600, 0);
d1106 1
a1106 1
				snprintf((char *)buf,80,"Couldn't execute shell '%s'\n",cmd);
@


1.28
log
@Fix -syntax and -encoding on command line.

Check for "pty.h" when openpty is used.
@
text
@d679 4
a682 2
	if (!s)
		return;
d701 48
d755 1
d759 2
d763 1
d766 2
d773 7
a779 6
/* Stuff for asynchronous I/O multiplexing.  We do not use streams or select() because joe
   needs to work on versions of UNIX which predate these calls.  Instead, when there is
   multiple async sources, we use helper processes which packetize data from the sources.  A
   header on each packet indicates the source.  There is no guarentee that packets getting
   written to the same pipe don't get interleaved, but you can reasonable rely on it with
   small packets. */
a783 1

d787 1
a787 22
	pipe(fds);
	accept = NO_MORE_DATA;
	have = 0;
	if (!(kbdpid = fork())) {
		close(fds[1]);
		do {
			unsigned char c;
			int sta;

			pack.who = 0;
			sta = joe_read(fileno(termin), &c, 1);
			if (sta == 0)
				pack.ch = NO_MORE_DATA;
			else
				pack.ch = c;
			pack.size = 0;
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024);
		} while (joe_read(fds[0], &pack, 1) == 1);
		_exit(0);
	}
	close(fds[0]);
	ackkbd = fds[1];
d792 1
a792 4
	kill(kbdpid, 9);
	while (wait(NULL) < 0 && errno == EINTR)
		/* do nothing */;
	close(ackkbd);
d993 4
d1047 1
d1061 1
a1061 1

d1071 4
d1086 1
@


1.27
log
@*** empty log message ***
@
text
@d30 1
d32 1
a33 1
#include <utmp.h>
d35 2
@


1.26
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@a304 1
			tickon();
a502 1
			tickon();
d566 2
d605 2
a606 1
			if (accept != NO_MORE_DATA)
d608 1
d610 1
d626 1
a699 1
	tickoff();
a711 1
	tickon();
@


1.25
log
@openpty() patch.
@
text
@d887 3
d891 1
a891 1

d894 1
d992 1
d1070 2
d1074 8
d1085 8
a1092 8
		if (dead)
			pack.size = 0;
		else {
			pack.size = read(*ptyfd, pack.data, 1024);
			/* On SUNOS 5.8, the very first read from the pty returns 0 for some reason */
			if (!pack.size)
				pack.size = read(*ptyfd, pack.data, 1024);
		}
d1094 1
d1100 1
@


1.24
log
@Fix rtarw: was not fixing xcol.

TAB key now does smart indenting.

smart home goes to real home first, then indentation point.
@
text
@d30 4
d805 15
d821 1
d885 1
@


1.23
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d787 1
a787 1
extern unsigned char *ptsname();
d797 1
a797 1
	return ptsname(fdm);
@


1.22
log
@
Better fix for missing SHELL variable
@
text
@d140 1
a140 1
char *obuf = NULL;
d192 1
a192 2
static int accept = MAXINT;	/* =MAXINT if we have last packet */
				/* FIXME: overloaded meaning of MAXINT */
d198 1
a198 1
	char data[1024];
d387 1
a387 1
	obuf = (char *) joe_malloc(obufsiz);
d519 2
a520 2
	if (ackkbd != -1 && accept != MAXINT && !have) {
		char c = 0;
d526 1
a526 1
		accept = MAXINT;
d592 1
a592 1
			if (accept != MAXINT) {
d601 1
a601 1
			if (accept != MAXINT)
d624 1
a624 1
void ttputs(char *s)
d663 1
a663 1
void ttshell(char *cmd)
d666 1
a666 1
	char *s = getenv("SHELL");
d679 1
a679 1
			execl(s, s, "-c", cmd, NULL);
d682 1
a682 1
			execl(s, s, NULL);
d723 1
a723 1
	accept = MAXINT;
d734 1
a734 1
				pack.ch = MAXINT;
d775 1
a775 1
extern char *_getpty();
d777 1
a777 1
static char *getpty(int *ptyfd)
d787 1
a787 1
extern char *ptsname();
d789 1
a789 1
static char *getpty(int *ptyfd)
d792 1
a792 1
	char *name;
d814 1
a814 1
static char *getpty(int *ptyfd)
d817 5
a821 5
	char *orgpwd = pwd();
	static char **ptys = NULL;
	static char *ttydir;
	static char *ptydir;
	static char ttyname[32];
d824 3
a826 3
		ttydir = "/dev/pty/";
		ptydir = "/dev/ptym/";	/* HPUX systems */
		if (chpwd(ptydir) || !(ptys = rexpnd("pty*")))
d828 1
a828 1
				ttydir = ptydir = "/dev/";	/* Everyone else */
d830 1
a830 1
					ptys = rexpnd("pty*");
d837 3
a839 3
			strcpy(ttyname, ptydir);
			strcat(ttyname, ptys[fd]);
			if ((*ptyfd = open(ttyname, O_RDWR)) >= 0) {
d841 2
a842 2
				strcpy(ttyname, ttydir);
				strcat(ttyname, ptys[fd]);
d844 1
a844 1
				x = open(ttyname, O_RDWR);
d848 3
a850 3
					strcpy(ttyname, ptydir);
					strcat(ttyname, ptys[fd]);
					*ptyfd = open(ttyname, O_RDWR);
d852 2
a853 2
					strcpy(ttyname, ttydir);
					strcat(ttyname, ptys[fd]);
d880 1
a880 1
extern char **mainenv;
d882 1
a882 1
static char **newenv(char **old, char *s)
d884 1
a884 1
	char **new;
d888 1
a888 1
	new = (char **) joe_malloc((x + 2) * sizeof(char *));
d908 1
a908 1
MPX *mpxmk(int *ptyfd, char *cmd, char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj)
d910 1
a910 1
	char buf[80];
d916 1
a916 1
	char *name;
d1000 2
a1001 2
			if ((x = open(name, O_RDWR)) != -1) {	/* Standard input */
				char **env = newenv(mainenv, "TERM=");
d1030 1
a1030 1
				execve(cmd, args, env);
d1033 2
a1034 2
				snprintf(buf,80,"Couldn't execute shell '%s'\n",cmd);
				write(0,buf,strlen(buf));
d1063 1
a1063 1
			pack.ch = MAXINT;
@


1.21
log
@Improve shell windows for Cygwin.
@
text
@d709 7
d879 1
a879 1
/* Build a new environment */
d907 2
d911 1
d919 1
d922 2
d927 1
a927 1
			goto ok;
d929 4
a932 2
	return NULL;
      ok:
d934 2
d937 2
d941 2
d947 2
d950 3
d954 2
a955 1
	m->ackfd = fds[1];
d957 6
d965 2
d971 1
d973 2
d977 5
d994 2
d1000 1
d1004 1
d1009 2
d1032 5
d1041 2
d1045 2
d1073 1
d1076 2
@


1.20
log
@Fix shell window for SunOS 5.8
(where first read from pty returns 0)
@
text
@d757 8
d777 1
a777 1
#ifdef __svr4__
@


1.19
log
@Fixed ^C and ^D in shell windows.
This will require more work: basically if setsid() doesn't
exist, setpgrp(0,0) should be used instead.  I think the latter
is only for BSD.
@
text
@d986 1
a986 1
		else
d988 4
@


1.18
log
@change 0 to NULL where we're talking about pointers
@
text
@d936 1
@


1.17
log
@fix segafults in isalpha()-like functions
@
text
@d121 2
a122 2
FILE *termin = 0;
FILE *termout = 0;
d140 1
a140 1
char *obuf = 0;
d804 1
a804 1
	static char **ptys = 0;
d846 1
a846 1
	return 0;
d902 1
a902 1
		return 0;
d908 1
a908 1
	return 0;
d1016 1
a1016 1
	m->func = 0;
@


1.16
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d193 1
@


1.15
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d345 4
a348 2
	if (noxon)
		targ.t_startc = -1, targ.t_stopc = -1;
@


1.14
log
@cleanup signals handling (sigaction() / sigvec() / signal())
@
text
@d535 2
a536 1
				have = 1, accept = pack.ch;
d564 10
a573 4
	while (winched)
		winched = 0, edupd(1), ttflsh();
	if (ticked)
		edupd(0), ttflsh(), tickon();
d591 4
a594 2
				if (pack.who->func)
					pack.who->func(pack.who->object, pack.data, pack.size), edupd(1);
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@a20 1
#include <signal.h>
a177 1

a180 1

a203 1

d209 4
a212 4
	signal(SIGHUP, ttsig);
	signal(SIGTERM, ttsig);
	signal(SIGINT, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
a215 1

d221 4
a224 4
	signal(SIGHUP, SIG_DFL);
	signal(SIGTERM, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	signal(SIGPIPE, SIG_DFL);
d243 2
a245 3

static int winched = 0;

d249 2
a250 5
#ifdef SIGWINCH
	signal(SIGWINCH, winchd);
#ifdef HAVE_SIGINTERRUPT
	siginterrupt(SIGWINCH, 1);
#endif
a251 1
}
a267 2
struct sigaction vnew;

d271 1
a271 13
	vnew.sa_handler = dotick;

#ifdef SA_INTERRUPT
	vnew.sa_flags = SA_INTERRUPT;
	sigaction(SIGALRM, &vnew, NULL);
#else
#ifdef SV_INTERRUPT
	vnew.sa_flags = SV_INTERRUPT;
	sigvec(SIGALRM, &vnew, NULL);
#else
	signal(SIGALRM, dotick);
#endif
#endif
d299 1
a299 4
			signal(SIGWINCH, winchd);
#ifdef HAVE_SIGINTERRUPT
			siginterrupt(SIGWINCH, 1);
#endif
d490 1
a490 1
			signal(SIGALRM, dosig);
a851 2
struct sigaction inew;

d913 1
a913 12
		inew.sa_handler = death;
#ifdef SA_INTERRUPT
		inew.sa_flags = SA_INTERRUPT;
		sigaction(SIGCHLD, &inew, (struct sigaction *) 0);
#else
#ifdef SV_INTERRUPT
		inew.sa_flags = SV_INTERRUPT;
		sigvec(SIGCHLD, &inew, (struct sigvec *) 0);
#else
		signal(SIGCHLD, death);
#endif
#endif
@


1.12
log
@check if siginterrupt() is available
@
text
@d402 1
a402 1
		free(obuf);
d412 1
a412 1
	obuf = (char *) malloc(obufsiz);
d891 1
a891 1
	new = (char **) malloc((x + 2) * sizeof(char *));
@


1.11
log
@move pwd() into path.c
@
text
@d257 1
d260 1
d324 1
d326 1
@


1.10
log
@move jread() / jwrite() into utils.c
@
text
@a90 21
/* The pwd function */
#ifdef HAVE_GETCWD
char *pwd(void)
{
	static char buf[1024];

	return getcwd(buf, 1024);
}
#else
#ifdef HAVE_GETWD
char *pwd(void)
{
	static char buf[1024];

	return getwd(buf);
}
#else
#error "Don't know how to get current directory"
#endif
#endif

@


1.9
log
@change indentation of do {} while() cycles
@
text
@a35 2
extern int errno;

d89 1
a226 23
/* Versions of 'read' and 'write' which automatically retry during signals
 * (yuck, yuck, yuck... we the #$%#$@@ did they have to do this?) */

int jread(int fd, void *buf, int siz)
{
	int rt;

	do {
		rt = read(fd, buf, siz);
	} while (rt < 0 && errno == EINTR);
	return rt;
}

int jwrite(int fd, void *buf, int siz)
{
	int rt;

	do {
		rt = write(fd, buf, siz);
	} while (rt < 0 && errno == EINTR);
	return rt;
}

d538 1
a538 1
			jwrite(fileno(termout), obuf, obufp);
d544 1
a544 1
			jwrite(fileno(termout), obuf, obufp);
d548 1
a548 1
		jwrite(fileno(termout), obuf, obufp);
d565 1
a565 1
			jwrite(pack.who->ackfd, &c, 1);
d567 1
a567 1
			jwrite(ackkbd, &c, 1);
d578 1
a578 1
				jread(mpxfd, pack.data, pack.size);
d616 1
a616 1
				jread(mpxfd, pack.data, pack.size);
d758 1
a758 1
			sta = jread(fileno(termin), &c, 1);
d764 2
a765 2
			jwrite(mpxsfd, &pack, sizeof(struct packet) - 1024);
		} while (jread(fds[0], &pack, 1) == 1);
d1023 1
a1023 1
		jwrite(comm[1], &pid, sizeof(pid));
d1033 1
a1033 1
			jwrite(mpxsfd, &pack, sizeof(struct packet) - 1024 + pack.size);
d1035 1
a1035 1
			jread(fds[0], &pack, 1);
d1040 1
a1040 1
			jwrite(mpxsfd, &pack, sizeof(struct packet) - 1024);
d1045 1
a1045 1
	jread(comm[0], &m->pid, sizeof(m->pid));
@


1.8
log
@put struct definitions and other goodies into types.h
@
text
@d235 1
a235 1
	do
d237 1
a237 1
	while (rt < 0 && errno == EINTR);
d245 1
a245 1
	do
d247 1
a247 1
	while (rt < 0 && errno == EINTR);
d789 1
a789 2
		}
		while (jread(fds[0], &pack, 1) == 1);
d799 2
a800 1
	while (wait(NULL) < 0 && errno == EINTR) ;
d1081 2
a1082 1
	while (wait(NULL) < 0 && errno == EINTR) ;
@


1.7
log
@make use of pid_t type
@
text
@a0 1

d2 6
a7 8
	UNIX Tty and Process interface
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/

/** System include files **/

d9 1
@


1.6
log
@version 2.9.7-pre3
@
text
@d212 1
a212 1
static int kbdpid;		/* PID of kbd client */
d956 1
a956 1
	int pid;
d1049 1
a1049 1
		jwrite(comm[1], &pid, sizeof(int));
d1071 1
a1071 1
	jread(comm[0], &m->pid, sizeof(int));
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d233 1
a233 2
int jread(fd, buf, siz)
char *buf;
d243 1
a243 2
int jwrite(fd, buf, siz)
char *buf;
d255 1
a255 1
void sigjoe()
d268 1
a268 1
void signrm()
d281 1
a281 1
void ttopen()
d289 1
a289 1
void ttclose()
d318 1
a318 1
void tickoff()
d325 1
a325 1
void tickon()
d346 1
a346 1
void ttopnn()
d460 1
a460 1
void ttclsn()
d501 1
a501 1
void maskit(void)
d510 1
a510 1
void unmaskit(void)
d518 1
a518 1
void pauseit(void)
d527 1
a527 1
void maskit(void)
d532 1
a532 1
void unmaskit(void)
d537 1
a537 1
void pauseit(void)
d545 1
a545 1
int ttflsh()
d625 1
a625 1
void mpxdied();
d627 1
a627 1
int ttgetc()
d683 1
a683 2
void ttputs(s)
char *s;
d694 1
a694 2
void ttgtsz(x, y)
int *x, *y;
d722 1
a722 2
void ttshell(cmd)
char *cmd;
d747 1
a747 1
void ttsusp()
d767 1
a767 1
void mpxstart()
d799 1
a799 1
void mpxend()
d821 1
a821 2
char *getpty(ptyfd)
int *ptyfd;
d833 1
a833 2
char *getpty(ptyfd)
int *ptyfd;
d858 1
a858 2
char *getpty(ptyfd)
int *ptyfd;
d912 1
a912 1
RETSIGTYPE death(int unused)
d928 1
a928 2
char **newenv(old, s)
char **old, *s;
d952 1
a952 8
MPX *mpxmk(ptyfd, cmd, args, func, object, die, dieobj)
int *ptyfd;
char *cmd;
char *args[];
void (*func) ();
void *object;
void (*die) ();
void *dieobj;
d1079 1
a1079 2
void mpxdied(m)
MPX *m;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d1 1
d11 2
a12 1
/* These should exist on every UNIX system */
d14 1
d16 3
d20 2
d24 1
d26 7
d36 1
a41 2
#include <sys/param.h>

d48 10
a57 20
#ifdef TTYPOSIX

#ifdef SYSPOSIX
#include <sys/termios.h>
#else
#include <termios.h>
#endif

#else
#ifdef TTYSV

#ifdef SYSSV
#include <sys/termio.h>
#else
#include <termio.h>
#endif

#else
#include <sgtty.h>
#endif
d60 2
a61 8
/* If the signal SIGVTALRM exists, assume we have the setitimer system call
 * and the include file necessary for it.  I'm not so sure that this method
 * of detecting 'setitimer' is foolproof, so this is the only place where
 * SIGVTALRM will be checked... after here the itimer code will look for
 * ITIMER_REAL (which is defined in sys/time.h).
 */
#ifndef _SEQUENT_
#ifdef SIGVTALRM
d90 1
a90 1
#include "config.h"
d95 2
a96 4
#ifdef TTYPOSIX
char *getcwd ();
char *
pwd ()
d99 2
a100 1
	return getcwd (buf, 1024);
d103 2
a104 4
#ifdef TTYSV
char *getcwd ();
char *
pwd ()
d107 2
a108 1
	return getcwd (buf, 1024);
d111 1
a111 7
char *getwd ();
char *
pwd ()
{
	static char buf[1024];
	return getwd (buf);
}
d151 1
a151 1
#ifdef TTYPOSIX
d153 2
a154 2
#else
#ifdef TTYSV
d156 1
a156 1
#else
d160 2
a161 2
#endif
#endif
d180 1
a180 1
		300, B600, 600,
d183 1
a183 1
		, EXTA, 19200
d186 1
a186 1
		, EXTB, 38400
d189 1
a189 1
		, B19200, 19200
d192 1
a192 1
		, B38400, 38400
d221 1
a221 2
struct packet
{
d226 1
a226 2
}
pack;
d233 2
a234 3
int
jread (fd, buf, siz)
     char *buf;
d237 1
d239 1
a239 1
		rt = read (fd, buf, siz);
d244 2
a245 3
int
jwrite (fd, buf, siz)
     char *buf;
d248 1
d250 1
a250 1
		rt = write (fd, buf, siz);
d257 1
a257 2
void
sigjoe ()
d262 4
a265 4
	signal (SIGHUP, ttsig);
	signal (SIGTERM, ttsig);
	signal (SIGINT, SIG_IGN);
	signal (SIGPIPE, SIG_IGN);
d270 1
a270 2
void
signrm ()
d275 4
a278 4
	signal (SIGHUP, SIG_DFL);
	signal (SIGTERM, SIG_DFL);
	signal (SIGINT, SIG_DFL);
	signal (SIGPIPE, SIG_DFL);
d283 1
a283 2
void
ttopen ()
d285 2
a286 2
	sigjoe ();
	ttopnn ();
d291 1
a291 2
void
ttclose ()
d293 2
a294 2
	ttclsn ();
	signrm ();
d301 1
a301 2
static void
winchd ()
d305 2
a306 1
	signal (SIGWINCH, winchd);
d314 1
a314 2
static void
dotick ()
d319 2
a320 2
void
tickoff ()
d322 1
a322 1
	alarm (0);
d327 3
a329 1
void tickon() {
d331 1
d334 1
d338 1
a338 6
#endif
#endif

	ticked = 0;
#ifdef SA_INTERRUPT
	sigaction (SIGALRM, &vnew, (struct sigaction *) 0);
d340 1
a340 4
#ifdef SV_INTERRUPT
	sigvec (SIGALRM, &vnew, (struct sigvec *) 0);
#else
	signal (SIGALRM, dotick);
d343 1
a343 1
	alarm (1);
d348 1
a348 2
void
ttopnn ()
d352 1
a352 1
#ifdef TTYPOSIX
d355 1
a355 1
#ifdef TTYSV
d364 5
a368 10
	if (!termin)
		if (idleout ? (!(termin = stdin) || !(termout = stdout)) :
		    (!(termin = fopen ("/dev/tty", "r")) ||
		     !(termout = fopen ("/dev/tty", "w"))))
		  {
			  fprintf (stderr, "Couldn\'t open /dev/tty\n");
			  exit (1);
		  }
		else
		  {
d370 2
a371 1
			  signal (SIGWINCH, winchd);
d373 3
a375 2
			  tickon ();
		  }
d380 1
a380 1
	fflush (termout);
d382 2
a383 2
#ifdef TTYPOSIX
	tcgetattr (fileno (termin), &oldterm);
d393 2
a394 2
	tcsetattr (fileno (termin), TCSADRAIN, &newterm);
	bbaud = cfgetospeed (&newterm);
d396 2
a397 2
#ifdef TTYSV
	ioctl (fileno (termin), TCGETA, &oldterm);
d407 1
a407 1
	ioctl (fileno (termin), TCSETAW, &newterm);
d410 3
a412 3
	ioctl (fileno (termin), TIOCGETP, &arg);
	ioctl (fileno (termin), TIOCGETC, &targ);
	ioctl (fileno (termin), TIOCGLTC, &ltarg);
d416 1
a416 4
	arg.sg_flags =
		((arg.
		  sg_flags & ~(ECHO | CRMOD | XTABS | ALLDELAY | TILDE)) |
		 CBREAK);
d429 3
a431 3
	ioctl (fileno (termin), TIOCSETN, &arg);
	ioctl (fileno (termin), TIOCSETC, &targ);
	ioctl (fileno (termin), TIOCSLTC, &ltarg);
d439 4
a442 5
		if (bbaud == speeds[x])
		  {
			  baud = speeds[x + 1];
			  break;
		  }
d447 1
a447 1
		free (obuf);
d450 5
a454 6
	else
	  {
		  obufsiz = 1000000 / (TIMES * upc);
		  if (obufsiz > 4096)
			  obufsiz = 4096;
	  }
d457 1
a457 1
	obuf = (char *) malloc (obufsiz);
d462 1
a462 2
void
ttclsn ()
d474 1
a474 1
	ttflsh ();
d476 2
a477 2
#ifdef TTYPOSIX
	tcsetattr (fileno (termin), TCSADRAIN, &oldterm);
d479 2
a480 2
#ifdef TTYSV
	ioctl (fileno (termin), TCSETAW, &oldterm);
d482 3
a484 3
	ioctl (fileno (termin), TIOCSETN, &oarg);
	ioctl (fileno (termin), TIOCSETC, &otarg);
	ioctl (fileno (termin), TIOCSLTC, &oltarg);
d494 1
a494 2
static void
dosig ()
d501 1
a501 1
#ifdef ITIMER_REAL
d503 1
a503 1
maskit ()
d506 4
a509 3
	sigemptyset (&set);
	sigaddset (&set, SIGALRM);
	sigprocmask (SIG_SETMASK, &set, NULL);
d511 2
a512 1
unmaskit ()
d515 3
a517 2
	sigemptyset (&set);
	sigprocmask (SIG_SETMASK, &set, NULL);
d519 2
a520 1
pauseit ()
d523 3
a525 2
	sigemptyset (&set);
	sigsuspend (&set);
d527 1
d529 1
a529 1
maskit ()
d531 1
a531 1
	sigsetmask (sigmask (SIGALRM));
d533 2
a534 1
unmaskit ()
d536 1
a536 1
	sigsetmask (0);
d538 2
a539 1
pauseit ()
d541 1
a541 1
	sigpause (0);
d543 1
d547 1
a547 2
int
ttflsh ()
d550 23
a572 24
	if (obufp)
	  {
		  unsigned long usec = obufp * upc;	/* No. usecs this write should take */
#ifdef ITIMER_REAL
		  if (usec >= 500000 / HZ && baud < 9600)
		    {
			    struct itimerval a, b;
			    a.it_value.tv_sec = usec / 1000000;
			    a.it_value.tv_usec = usec % 1000000;
			    a.it_interval.tv_usec = 0;
			    a.it_interval.tv_sec = 0;
			    alarm (0);
			    signal (SIGALRM, dosig);
			    yep = 0;
			    maskit ();
			    setitimer (ITIMER_REAL, &a, &b);
			    jwrite (fileno (termout), obuf, obufp);
			    while (!yep)
				    pauseit (0);
			    unmaskit ();
			    tickon ();
		    }
		  else
			  jwrite (fileno (termout), obuf, obufp);
d576 1
a576 1
		  jwrite (fileno (termout), obuf, obufp);
d579 2
a580 2
		  if (baud < 9600 && usec / 1000)
			  nap (usec / 1000);
d585 2
a586 2
		  obufp = 0;
	  }
d589 9
a597 9
	if (ackkbd != -1 && accept != MAXINT && !have)
	  {
		  char c = 0;
		  if (pack.who && pack.who->func)
			  jwrite (pack.who->ackfd, &c, 1);
		  else
			  jwrite (ackkbd, &c, 1);
		  accept = MAXINT;
	  }
d601 21
a621 27
	if (!have && !leave)
		if (ackkbd != -1)
		  {
			  fcntl (mpxfd, F_SETFL, O_NDELAY);
			  if (read
			      (mpxfd, &pack,
			       sizeof (struct packet) - 1024) > 0)
			    {
				    fcntl (mpxfd, F_SETFL, 0);
				    jread (mpxfd, pack.data, pack.size);
				    have = 1, accept = pack.ch;
			    }
			  else
				  fcntl (mpxfd, F_SETFL, 0);
		  }
		else
		  {
			  /* Set terminal input to non-blocking */
			  fcntl (fileno (termin), F_SETFL, O_NDELAY);

			  /* Try to read */
			  if (read (fileno (termin), &havec, 1) == 1)
				  have = 1;

			  /* Set terminal back to blocking */
			  fcntl (fileno (termin), F_SETFL, 0);
		  }
d627 1
a627 1
void mpxdied ();
d629 1
a629 2
int
ttgetc ()
d632 1
d634 1
a634 1
	ttflsh ();
d636 1
a636 1
		winched = 0, edupd (1), ttflsh ();
d638 33
a670 45
		edupd (0), ttflsh (), tickon ();
	if (ackkbd != -1)
	  {
		  if (!have)	/* Wait for input */
		    {
			    stat =
				    read (mpxfd, &pack,
					  sizeof (struct packet) - 1024);
			    if (pack.size && stat > 0)
				    jread (mpxfd, pack.data, pack.size);
			    else if (stat < 1)
				    if (winched || ticked)
					    goto loop;
				    else
					    ttsig (0);
			    accept = pack.ch;
		    }
		  have = 0;
		  if (pack.who)	/* Got bknd input */
		    {
			    if (accept != MAXINT)
			      {
				      if (pack.who->func)
					      pack.who->func (pack.who->
							      object,
							      pack.data,
							      pack.size),
						      edupd (1);
			      }
			    else
				    mpxdied (pack.who);
			    goto loop;
		    }
		  else
		    {
			    if (accept != MAXINT)
				    return accept;
			    else
			      {
				      ttsig (0);
				      return 0;
			      }
		    }
	  }
	if (have)
d672 8
a679 8
	else
	  {
		  if (read (fileno (termin), &havec, 1) < 1)
			  if (winched || ticked)
				  goto loop;
			  else
				  ttsig (0);
	  }
d685 8
a692 10
void
ttputs (s)
     char *s;
{
	while (*s)
	  {
		  obuf[obufp++] = *s++;
		  if (obufp == obufsiz)
			  ttflsh ();
	  }
d697 2
a698 3
void
ttgtsz (x, y)
     int *x, *y;
d712 4
a715 5
	if (ioctl (fileno (termout), TIOCGSIZE, &getit) != -1)
	  {
		  *x = getit.ts_cols;
		  *y = getit.ts_lines;
	  }
d718 4
a721 5
	if (ioctl (fileno (termout), TIOCGWINSZ, &getit) != -1)
	  {
		  *x = getit.ws_col;
		  *y = getit.ws_row;
	  }
d726 2
a727 3
void
ttshell (cmd)
     char *cmd;
d730 2
a731 1
	char *s = getenv ("SHELL");
d734 16
a749 21
	ttclsn ();
	if (x = fork ())
	  {
		  if (x != -1)
			  wait (NULL);
		  if (omode)
			  ttopnn ();
	  }
	else
	  {
		  signrm ();
		  if (cmd)
			  execl (s, s, "-c", cmd, NULL);
		  else
		    {
			    fprintf (stderr,
				     "You are at the command shell.  Type 'exit' to return\n");
			    execl (s, s, NULL);
		    }
		  _exit (0);
	  }
d752 1
a752 2
void
ttsusp ()
d755 2
a756 1
	tickoff ();
d759 3
a761 4
	ttclsn ();
	fprintf (stderr,
		 "You have suspended the program.  Type 'fg' to return\n");
	kill (0, SIGTSTP);
d763 1
a763 1
		kill (kbdpid, SIGCONT);
d765 1
a765 1
		ttopnn ();
d767 1
a767 1
	ttshell (NULL);
d769 1
a769 1
	tickon ();
d772 1
a772 2
void
mpxstart ()
d775 2
a776 1
	pipe (fds);
d779 1
a779 1
	pipe (fds);
d782 19
a800 21
	if (!(kbdpid = fork ()))
	  {
		  close (fds[1]);
		  do
		    {
			    unsigned char c;
			    int sta;
			    pack.who = 0;
			    sta = jread (fileno (termin), &c, 1);
			    if (sta == 0)
				    pack.ch = MAXINT;
			    else
				    pack.ch = c;
			    pack.size = 0;
			    jwrite (mpxsfd, &pack,
				    sizeof (struct packet) - 1024);
		    }
		  while (jread (fds[0], &pack, 1) == 1);
		  _exit (0);
	  }
	close (fds[0]);
d804 1
a804 2
void
mpxend ()
d806 3
a808 3
	kill (kbdpid, 9);
	while (wait (NULL) < 0 && errno == EINTR);
	close (ackkbd);
d810 2
a811 2
	close (mpxfd);
	close (mpxsfd);
d824 1
a824 1
extern char *_getpty ();
d826 2
a827 3
char *
getpty (ptyfd)
     int *ptyfd;
d829 1
a829 1
	return _getpty (ptyfd, O_RDWR, 0600, 0);
d837 1
a837 1
extern char *ptsname ();
d839 2
a840 3
char *
getpty (ptyfd)
     int *ptyfd;
d844 5
a848 4
	*ptyfd = fdm = open ("/dev/ptmx", O_RDWR);
	grantpt (fdm);
	unlockpt (fdm);
	return ptsname (fdm);
d865 2
a866 3
char *
getpty (ptyfd)
     int *ptyfd;
d869 1
a869 1
	char *orgpwd = pwd ();
d875 11
a885 13
	if (!ptys)
	  {
		  ttydir = "/dev/pty/";
		  ptydir = "/dev/ptym/";	/* HPUX systems */
		  if (chpwd (ptydir) || !(ptys = rexpnd ("pty*")))
			  if (!ptys)
			    {
				    ttydir = ptydir = "/dev/";	/* Everyone else */
				    if (!chpwd (ptydir))
					    ptys = rexpnd ("pty*");
			    }
	  }
	chpwd (orgpwd);
d888 24
a911 28
		for (fd = 0; ptys[fd]; ++fd)
		  {
			  strcpy (ttyname, ptydir);
			  strcat (ttyname, ptys[fd]);
			  if ((*ptyfd = open (ttyname, O_RDWR)) >= 0)
			    {
				    ptys[fd][0] = 't';
				    strcpy (ttyname, ttydir);
				    strcat (ttyname, ptys[fd]);
				    ptys[fd][0] = 'p';
				    x = open (ttyname, O_RDWR);
				    if (x >= 0)
				      {
					      close (x);
					      close (*ptyfd);
					      strcpy (ttyname, ptydir);
					      strcat (ttyname, ptys[fd]);
					      *ptyfd = open (ttyname, O_RDWR);
					      ptys[fd][0] = 't';
					      strcpy (ttyname, ttydir);
					      strcat (ttyname, ptys[fd]);
					      ptys[fd][0] = 'p';
					      return ttyname;
				      }
				    else
					    close (*ptyfd);
			    }
		  }
d920 1
a920 2
void
death ()
d922 1
a922 1
	wait (NULL);
d936 2
a937 3
char **
newenv (old, s)
     char **old, *s;
d941 14
a954 15
	for (x = 0; old[x]; ++x);
	new = (char **) malloc ((x + 2) * sizeof (char *));
	for (x = 0, y = 0; old[x]; ++x)
	  {
		  for (z = 0; s[z] != '='; ++z)
			  if (s[z] != old[x][z])
				  break;
		  if (s[z] == '=')
		    {
			    if (s[z + 1])
				    new[y++] = s;
		    }
		  else
			  new[y++] = old[x];
	  }
d961 8
a968 9
MPX *
mpxmk (ptyfd, cmd, args, func, object, die, dieobj)
     int *ptyfd;
     char *cmd;
     char *args[];
     void (*func) ();
     void *object;
     void (*die) ();
     void *dieobj;
d976 2
a977 1
	if (!(name = getpty (ptyfd)))
d980 4
a983 5
		if (!asyncs[x].func)
		  {
			  m = asyncs + x;
			  goto ok;
		  }
d986 1
a986 1
	ttflsh ();
d989 1
a989 1
		mpxstart ();
d994 2
a995 2
	pipe (fds);
	pipe (comm);
d997 5
a1001 6
	if (!(m->kpid = fork ()))
	  {
		  close (fds[1]);
		  close (comm[0]);
		  dead = 0;
		  inew.sa_handler = death;
d1003 2
a1004 2
		  inew.sa_flags = SA_INTERRUPT;
		  sigaction (SIGCHLD, &inew, (struct sigaction *) 0);
d1007 2
a1008 2
		 inew.sa_flags = SV_INTERRUPT;
		  sigvec (SIGCHLD, &inew, (struct sigvec *) 0);
d1010 1
a1010 1
		  signal (SIGCHLD, death);
d1014 3
a1016 4
		  if (!(pid = fork ()))
		    {
			    signrm ();
			    close (*ptyfd);
d1019 2
a1020 2
			    x = open ("/dev/tty", O_RDWR);
			    ioctl (x, TIOCNOTTY, 0);
d1023 5
a1027 1
			    setpgrp (0, 0);
d1029 2
a1030 2
			    for (x = 0; x != 32; ++x)
				    close (x);	/* Yes, this is quite a kludge... all in the
d1033 3
a1035 3
			    if ((x = open (name, O_RDWR)) != -1)	/* Standard input */
			      {
				      char **env = newenv (mainenv, "TERM=");
d1037 2
a1038 2
				      ioctl (x, I_PUSH, "ptem");
				      ioctl (x, I_PUSH, "ldterm");
d1040 16
a1055 16
				      dup (x);
				      dup (x);	/* Standard output, standard error */
				      /* (yes, stdin, stdout, and stderr must all be open for reading and
				       * writing.  On some systems the shell assumes this */

				      /* We could probably have a special TTY set-up for JOE, but for now
				       * we'll just use the TTY setup for the TTY was was run on */
#ifdef TTYPOSIX
				      tcsetattr (0, TCSADRAIN, &oldterm);
#else
#ifdef TTYSV
				      ioctl (0, TCSETAW, &oldterm);
#else
				      ioctl (0, TIOCSETN, &oarg);
				      ioctl (0, TIOCSETC, &otarg);
				      ioctl (0, TIOCSLTC, &oltarg);
d1059 33
a1091 36
				      /* Execute the shell */
				      execve (cmd, args, env);
			      }

			    _exit (0);
		    }
		  jwrite (comm[1], &pid, sizeof (int));

		loop:
		  pack.who = m;
		  pack.ch = 0;
		  if (dead)
			  pack.size = 0;
		  else
			  pack.size = read (*ptyfd, pack.data, 1024);
		  if (pack.size > 0)
		    {
			    jwrite (mpxsfd, &pack,
				    sizeof (struct packet) - 1024 +
				    pack.size);
			    jread (fds[0], &pack, 1);
			    goto loop;
		    }
		  else
		    {
			    pack.ch = MAXINT;
			    pack.size = 0;
			    jwrite (mpxsfd, &pack,
				    sizeof (struct packet) - 1024);
			    _exit (0);
		    }
	  }
	jread (comm[0], &m->pid, sizeof (int));
	close (comm[0]);
	close (comm[1]);
	close (fds[0]);
d1095 2
a1096 3
void
mpxdied (m)
     MPX *m;
d1099 2
a1100 2
		mpxend ();
	while (wait (NULL) < 0 && errno == EINTR);
d1102 1
a1102 1
		m->die (m->dieobj);
d1104 1
a1104 1
	edupd (1);
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* UNIX Tty and Process interface
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d19 2
d23 1
a23 1
int idleout=1;
d97 7
a103 1
char *getcwd(); char *pwd() { static char buf[1024]; return getcwd(buf,1024); }
d106 15
a120 3
char *getcwd(); char *pwd() { static char buf[1024]; return getcwd(buf,1024); }
#else
char *getwd(); char *pwd() { static char buf[1024]; return getwd(buf); }
d150 2
a151 2
int noxon=0;	/* Set if ^S/^Q processing should be disabled */
int Baud=0;	/* Baud rate from joerc, cmd line or environment */
d155 2
a156 2
FILE *termin=0;
FILE *termout=0;
d174 2
a175 2
char *obuf=0;
int obufp=0;
d180 2
a181 2
unsigned baud;		/* Bits per second */
unsigned long upc;	/* Microseconds per character */
d187 4
a190 4
static int speeds[]=
 {
 B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,
 B1200,1200,B1800,1800,B2400,2400,B4800,4800,B9600,9600
d192 1
a192 1
 ,EXTA,19200
d195 1
a195 1
 ,EXTB,38400
d198 1
a198 1
 ,B19200,19200
d201 1
a201 1
 ,B38400,38400
d203 1
a203 1
 };
d207 1
a207 1
int have=0;		/* Set if we have pending input */
d209 1
a209 1
int leave=0;		/* When set, typeahead checking is disabled */
d213 1
a213 1
static int ttymode=0;
d217 1
a217 1
static int ttysig=0;
d222 1
a222 1
static int ackkbd= -1;		/* Editor acks keyboard client to this */
d227 2
a228 2
static int nmpx=0;
static int accept=MAXINT;	/* =MAXINT if we have last packet */
d231 7
a237 6
 {
 MPX *who;
 int size;
 int ch;
 char data[1024];
 } pack;
d244 21
a264 19
int jread(fd,buf,siz)
char *buf;
 {
 int rt;
 do
  rt=read(fd,buf,siz);
  while(rt<0 && errno==EINTR);
 return rt;
 }

int jwrite(fd,buf,siz)
char *buf;
 {
 int rt;
 do
  rt=write(fd,buf,siz);
  while(rt<0 && errno==EINTR);
 return rt;
 }
d268 11
a278 9
void sigjoe()
 {
 if(ttysig) return;
 ttysig=1;
 signal(SIGHUP,ttsig);
 signal(SIGTERM,ttsig);
 signal(SIGINT,SIG_IGN);
 signal(SIGPIPE,SIG_IGN);
 }
d282 11
a292 9
void signrm()
 {
 if(!ttysig) return;
 ttysig=0;
 signal(SIGHUP,SIG_DFL);
 signal(SIGTERM,SIG_DFL);
 signal(SIGINT,SIG_DFL);
 signal(SIGPIPE,SIG_DFL);
 }
d296 6
a301 5
void ttopen()
 {
 sigjoe();
 ttopnn();
 }
d305 6
a310 5
void ttclose()
 {
 ttclsn();
 signrm();
 }
d314 1
a314 1
static int winched=0;
d316 4
a319 3
static void winchd()
 {
 ++winched;
d321 1
a321 1
 signal(SIGWINCH,winchd);
d323 1
a323 1
 }
d327 1
a327 1
int ticked=0;
d329 11
a339 2
static void dotick() { ticked=1; dostaupd=1; }
void tickoff() { alarm(0); }
d341 4
d346 1
a346 1
struct sigaction vnew={dotick,0,SA_INTERRUPT};
d349 1
a349 1
struct sigvec vnew={dotick,0,SV_INTERRUPT};
d353 1
a353 3
void tickon()
 {
 ticked=0;
d355 1
a355 1
 sigaction(SIGALRM,&vnew,(struct sigaction *)0);
d358 1
a358 1
 sigvec(SIGALRM,&vnew,(struct sigvec *)0);
d360 1
a360 1
 signal(SIGALRM,dotick);
d363 2
a364 2
 alarm(1);
 }
d368 5
a372 4
void ttopnn()
 {
 int x, bbaud;
 
d374 1
a374 1
 struct termios newterm;
d377 1
a377 1
 struct termio newterm;
d379 16
a394 16
 struct sgttyb arg;
 struct tchars targ;
 struct ltchars ltarg;
#endif
#endif
 
 if(!termin)
  if(idleout ? (!(termin=stdin) || !(termout=stdout)) :
               (!(termin=fopen("/dev/tty","r")) || 
               !(termout=fopen("/dev/tty","w"))))
   {
   fprintf(stderr,"Couldn\'t open /dev/tty\n");
   exit(1);
   }
  else
   {
d396 1
a396 1
   signal(SIGWINCH,winchd);
d398 8
a405 7
   tickon();
   }
 
 if(ttymode) return;
 ttymode=1;
 fflush(termout);
 
d407 12
a418 10
 tcgetattr(fileno(termin),&oldterm);
 newterm=oldterm;
 newterm.c_lflag=0;
 if(noxon)  newterm.c_iflag&=~(ICRNL|IGNCR|INLCR|IXON|IXOFF);
 else newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
 newterm.c_oflag=0;
 newterm.c_cc[VMIN]=1;
 newterm.c_cc[VTIME]=0;
 tcsetattr(fileno(termin),TCSADRAIN,&newterm);
 bbaud=cfgetospeed(&newterm);
d421 67
a487 53
 ioctl(fileno(termin),TCGETA,&oldterm);
 newterm=oldterm;
 newterm.c_lflag=0;
 if(noxon)  newterm.c_iflag&=~(ICRNL|IGNCR|INLCR|IXON|IXOFF);
 else newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
 newterm.c_oflag=0;
 newterm.c_cc[VMIN]=1;
 newterm.c_cc[VTIME]=0;
 ioctl(fileno(termin),TCSETAW,&newterm);
 bbaud=(newterm.c_cflag&CBAUD);
#else
 ioctl(fileno(termin),TIOCGETP,&arg);
 ioctl(fileno(termin),TIOCGETC,&targ);
 ioctl(fileno(termin),TIOCGLTC,&ltarg);
 oarg=arg; otarg=targ; oltarg=ltarg;
 arg.sg_flags=( (arg.sg_flags&~(ECHO|CRMOD|XTABS|ALLDELAY|TILDE) ) | CBREAK) ;
 if(noxon) targ.t_startc= -1, targ.t_stopc= -1;
 targ.t_intrc= -1;
 targ.t_quitc= -1;
 targ.t_eofc= -1;
 targ.t_brkc= -1;
 ltarg.t_suspc= -1;
 ltarg.t_dsuspc= -1;
 ltarg.t_rprntc= -1;
 ltarg.t_flushc= -1;
 ltarg.t_werasc= -1;
 ltarg.t_lnextc= -1;
 ioctl(fileno(termin),TIOCSETN,&arg);
 ioctl(fileno(termin),TIOCSETC,&targ);
 ioctl(fileno(termin),TIOCSLTC,&ltarg);
 bbaud=arg.sg_ospeed;
#endif
#endif
 
 baud=9600; upc=0;
 for(x=0;x!=30;x+=2)
  if(bbaud==speeds[x])
   {
   baud=speeds[x+1];
   break;
   }
 if(Baud) baud=Baud;
 upc=DIVIDEND/baud;
 if(obuf) free(obuf);
 if(!(TIMES*upc)) obufsiz=4096;
 else
  {
  obufsiz=1000000/(TIMES*upc);
  if(obufsiz>4096) obufsiz=4096;
  }
 if(!obufsiz) obufsiz=1;
 obuf=(char *)malloc(obufsiz);
 }
d491 15
a505 11
void ttclsn()
 {
 int oleave;
 
 if(ttymode) ttymode=0;
 else return;
 
 oleave=leave; leave=1;
 
 ttflsh();
 
d507 1
a507 1
 tcsetattr(fileno(termin),TCSADRAIN,&oldterm);
d510 1
a510 1
 ioctl(fileno(termin),TCSETAW,&oldterm);
d512 3
a514 3
 ioctl(fileno(termin),TIOCSETN,&oarg);
 ioctl(fileno(termin),TIOCSETC,&otarg);
 ioctl(fileno(termin),TIOCSLTC,&oltarg);
d517 3
a519 3
 
 leave=oleave;
 }
d524 5
a528 1
static void dosig() { yep=1; } 
d534 32
a565 23
maskit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigaddset(&set,SIGALRM);
 sigprocmask(SIG_SETMASK,&set,NULL);
 }
unmaskit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigprocmask(SIG_SETMASK,&set,NULL);
 }
pauseit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigsuspend(&set);
 }
#else
maskit() { sigsetmask(sigmask(SIGALRM)); }
unmaskit() { sigsetmask(0); }
pauseit() { sigpause(0); }
d569 7
a575 6
int ttflsh()
 {
 /* Flush output */
 if(obufp)
  {
  unsigned long usec=obufp*upc;		/* No. usecs this write should take */
d577 21
a597 18
  if(usec>=500000/HZ && baud<9600)
   {
   struct itimerval a,b;
   a.it_value.tv_sec=usec/1000000;
   a.it_value.tv_usec=usec%1000000;
   a.it_interval.tv_usec=0;
   a.it_interval.tv_sec=0;
   alarm(0);
   signal(SIGALRM,dosig); yep=0;
   maskit();
   setitimer(ITIMER_REAL,&a,&b);
   jwrite(fileno(termout),obuf,obufp);
   while(!yep) pauseit(0);
   unmaskit();
   tickon();
   }
  else jwrite(fileno(termout),obuf,obufp);
 
d599 2
a600 2
 
  jwrite(fileno(termout),obuf,obufp);
d603 2
a604 1
  if(baud<9600 && usec/1000) nap(usec/1000);
d608 46
a653 40
 
  obufp=0;
  }
 
 /* Ack previous packet */
 if(ackkbd!= -1 && accept!=MAXINT && !have)
  {
  char c=0;
  if(pack.who && pack.who->func) jwrite(pack.who->ackfd,&c,1);
  else jwrite(ackkbd,&c,1);
  accept=MAXINT;
  }
 
 /* Check for typeahead or next packet */
 
 if(!have && !leave)
  if(ackkbd!= -1)
   {
   fcntl(mpxfd,F_SETFL,O_NDELAY);
   if(read(mpxfd,&pack,sizeof(struct packet)-1024)>0)
    {
    fcntl(mpxfd,F_SETFL,0);
    jread(mpxfd,pack.data,pack.size);
    have=1, accept=pack.ch;
    }
   else fcntl(mpxfd,F_SETFL,0);
   }
  else
   {
   /* Set terminal input to non-blocking */
   fcntl(fileno(termin),F_SETFL,O_NDELAY);
  
   /* Try to read */
   if(read(fileno(termin),&havec,1)==1) have=1;
  
   /* Set terminal back to blocking */
   fcntl(fileno(termin),F_SETFL,0);
   }
 return 0;
 }
d657 1
a657 1
void mpxdied();
d659 65
a723 45
int ttgetc()
 {
 int stat;
 loop:
 ttflsh();
 while(winched) winched=0, edupd(1), ttflsh();
 if(ticked) edupd(0), ttflsh(), tickon();
 if(ackkbd!= -1)
  {
  if(!have)					/* Wait for input */
   {
   stat=read(mpxfd,&pack,sizeof(struct packet)-1024);
   if(pack.size && stat>0) jread(mpxfd,pack.data,pack.size);
   else if(stat<1)
    if(winched || ticked) goto loop;
    else ttsig(0);
   accept=pack.ch;
   }
  have=0;
  if(pack.who)					/* Got bknd input */
   {
   if(accept!=MAXINT)
    {
    if(pack.who->func)
     pack.who->func(pack.who->object,pack.data,pack.size),
     edupd(1);
    }
   else mpxdied(pack.who);
   goto loop;
   }
  else
   {
   if(accept!=MAXINT) return accept;
   else { ttsig(0); return 0; }
   }
  }
 if(have) have=0;
 else
  {
  if(read(fileno(termin),&havec,1)<1)
   if(winched || ticked) goto loop;
   else ttsig(0);
  }
 return havec;
 }
d727 11
a737 9
void ttputs(s)
char *s;
 {
 while(*s)
  {
  obuf[obufp++]= *s++;
  if(obufp==obufsiz) ttflsh();
  }
 }
d741 4
a744 3
void ttgtsz(x,y)
int *x, *y;
 {
d746 1
a746 1
 struct ttysize getit;
d749 1
a749 1
 struct winsize getit;
d752 4
a755 3
 
 *x=0; *y=0;
 
d757 5
a761 5
 if(ioctl(fileno(termout),TIOCGSIZE,&getit)!= -1)
  {
  *x=getit.ts_cols;
  *y=getit.ts_lines;
  }
d764 45
a808 38
 if(ioctl(fileno(termout),TIOCGWINSZ,&getit)!= -1)
  {
  *x=getit.ws_col;
  *y=getit.ws_row;
  }
#endif
#endif
 }

void ttshell(cmd)
char *cmd;
 {
 int x,omode=ttymode;
 char *s=getenv("SHELL");
 if(!s) return;
 ttclsn();
 if(x=fork())
  {
  if(x!= -1) wait(NULL);
  if(omode) ttopnn();
  }
 else
  {
  signrm();
  if(cmd) execl(s,s,"-c",cmd,NULL);
  else
   {
   fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
   execl(s,s,NULL);
   }
  _exit(0);
  }
 }

void ttsusp()
 {
 int omode;
 tickoff();
d810 61
a870 51
 omode=ttymode;
 ttclsn();
 fprintf(stderr,"You have suspended the program.  Type 'fg' to return\n");
 kill(0,SIGTSTP);
 if(ackkbd!= -1)
  kill(kbdpid,SIGCONT);
 if(omode) ttopnn();
#else
 ttshell(NULL);
#endif
 tickon();
 }

void mpxstart()
 {
 int fds[2];
 pipe(fds);
 mpxfd=fds[0];
 mpxsfd=fds[1];
 pipe(fds);
 accept=MAXINT; have=0;
 if(!(kbdpid=fork()))
  {
  close(fds[1]);
  do
   {
   unsigned char c;
   int sta;
   pack.who=0;
   sta=jread(fileno(termin),&c,1);
   if(sta==0) pack.ch=MAXINT;
   else pack.ch=c;
   pack.size=0;
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024);
   }
   while(jread(fds[0],&pack,1)==1);
  _exit(0);
  }
 close(fds[0]);
 ackkbd=fds[1];
 }

void mpxend()
 {
 kill(kbdpid,9);
 while(wait(NULL)<0 && errno==EINTR);
 close(ackkbd); ackkbd= -1;
 close(mpxfd);
 close(mpxsfd);
 if(have) havec=pack.ch;
 }
d880 1
a880 1
extern char *_getpty();
d882 6
a887 5
char *getpty(ptyfd)
int *ptyfd;
 {
 return _getpty(ptyfd,O_RDWR,0600,0);
 }
d894 1
a894 1
extern char *ptsname();
d896 11
a906 10
char *getpty(ptyfd)
int *ptyfd;
 {
 int fdm;
 char *name;
 *ptyfd=fdm=open("/dev/ptmx",O_RDWR);
 grantpt(fdm);
 unlockpt(fdm);
 return ptsname(fdm);
 }
d922 68
a989 58
char *getpty(ptyfd)
int *ptyfd;
 {
 int x, fd;
 char *orgpwd=pwd();
 static char **ptys=0;
 static char *ttydir;
 static char *ptydir;
 static char ttyname[32];

 if(!ptys)
  {
  ttydir="/dev/pty/"; ptydir="/dev/ptym/";	/* HPUX systems */
  if(chpwd(ptydir) || !(ptys=rexpnd("pty*")))
  if(!ptys)
   {
   ttydir=ptydir="/dev/";			/* Everyone else */
   if(!chpwd(ptydir)) ptys=rexpnd("pty*");
   }
  }
 chpwd(orgpwd);

 if(ptys) for(fd=0;ptys[fd];++fd)
  {
  strcpy(ttyname,ptydir); strcat(ttyname,ptys[fd]);
  if((*ptyfd=open(ttyname,O_RDWR))>=0)
   {
   ptys[fd][0]='t';
   strcpy(ttyname,ttydir); strcat(ttyname,ptys[fd]);
   ptys[fd][0]='p';
   x=open(ttyname,O_RDWR);
   if(x>=0)
    {
    close(x);
    close(*ptyfd);
    strcpy(ttyname,ptydir); strcat(ttyname,ptys[fd]);
    *ptyfd=open(ttyname,O_RDWR);
    ptys[fd][0]='t';
    strcpy(ttyname,ttydir); strcat(ttyname,ptys[fd]);
    ptys[fd][0]='p';
    return ttyname;
    }
   else close(*ptyfd);
   }
  }
 return 0;
 }

#endif
#endif

int dead=0;

void death()
 {
 wait(NULL);
 dead=1;
 }
d995 1
a995 7
#ifdef SA_INTERRUPT
struct sigaction inew={death,0,SA_INTERRUPT};
#else
#ifdef SV_INTERRUPT
struct sigvec inew={death,0,SV_INTERRUPT};
#endif
#endif
d1001 70
a1070 54
char **newenv(old,s)
char **old, *s;
 {
 char **new;
 int x,y,z;
 for(x=0;old[x];++x);
 new=(char **)malloc((x+2)*sizeof(char *));
 for(x=0,y=0;old[x];++x)
  {
  for(z=0;s[z]!='=';++z) if(s[z]!=old[x][z]) break;
  if(s[z]=='=')
   { if(s[z+1]) new[y++]=s; }
  else new[y++]=old[x];
  }
 if(x==y) new[y++]=s;
 new[y]=0;
 return new;
 }

MPX *mpxmk(ptyfd,cmd,args,func,object,die,dieobj)
int *ptyfd;
char *cmd;
char *args[];
void (*func)();
void *object;
void (*die)();
void *dieobj;
 {
 int fds[2];
 int comm[2];
 int pid;
 int x;
 MPX *m;
 char *name;
 if(!(name=getpty(ptyfd))) return 0;
 for(x=0;x!=NPROC;++x) 
  if(!asyncs[x].func) { m=asyncs+x; goto ok; }
 return 0;
 ok:
 ttflsh();
 ++nmpx;
 if(ackkbd== -1) mpxstart();
 m->func=func;
 m->object=object;
 m->die=die;
 m->dieobj=dieobj;
 pipe(fds);
 pipe(comm);
 m->ackfd=fds[1];
 if(!(m->kpid=fork()))
  {
  close(fds[1]);
  close(comm[0]);
  dead=0;
d1072 2
a1073 1
  sigaction(SIGCHLD,&inew,(struct sigaction *)0);
d1076 2
a1077 1
  sigvec(SIGCHLD,&inew,(struct sigvec *)0);
d1079 1
a1079 1
  signal(SIGCHLD,death);
d1083 5
a1087 5
  if(!(pid=fork()))
   {
   signrm();
   close(*ptyfd);
  
d1089 2
a1090 2
   x=open("/dev/tty",O_RDWR);
   ioctl(x,TIOCNOTTY,0);
d1092 10
a1101 9
  
   setpgrp(0,0);
  
   for(x=0;x!=32;++x) close(x); /* Yes, this is quite a kludge... all in the
                                   name of portability */
  
   if((x=open(name,O_RDWR))!= -1)    /* Standard input */
    {
    char **env=newenv(mainenv,"TERM=");
d1103 2
a1104 2
    ioctl(x,I_PUSH,"ptem");
    ioctl(x,I_PUSH,"ldterm");
d1106 7
a1112 6
    dup(x); dup(x);		/* Standard output, standard error */
    /* (yes, stdin, stdout, and stderr must all be open for reading and
     * writing.  On some systems the shell assumes this */
  
    /* We could probably have a special TTY set-up for JOE, but for now
     * we'll just use the TTY setup for the TTY was was run on */
d1114 1
a1114 1
    tcsetattr(0,TCSADRAIN,&oldterm);
d1117 1
a1117 1
    ioctl(0,TCSETAW,&oldterm);
d1119 57
a1175 48
    ioctl(0,TIOCSETN,&oarg);
    ioctl(0,TIOCSETC,&otarg);
    ioctl(0,TIOCSLTC,&oltarg);
#endif
#endif
  
    /* Execute the shell */
    execve(cmd,args,env);
    }

   _exit(0);
   }
  jwrite(comm[1],&pid,sizeof(int));

  loop:
  pack.who=m;
  pack.ch=0;
  if(dead) pack.size=0;
  else pack.size=read(*ptyfd,pack.data,1024);
  if(pack.size>0)
   {
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024+pack.size);
   jread(fds[0],&pack,1);
   goto loop;
   }
  else
   {
   pack.ch=MAXINT;
   pack.size=0;
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024);
   _exit(0);
   }
  }
 jread(comm[0],&m->pid,sizeof(int));
 close(comm[0]); close(comm[1]);
 close(fds[0]);
 return m;
 }

void mpxdied(m)
MPX *m;
 {
 if(!--nmpx) mpxend();
 while(wait(NULL)<0 && errno==EINTR);
 if(m->die) m->die(m->dieobj);
 m->func=0;
 edupd(1);
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@d24 1
@


1.1
log
@Initial revision
@
text
@d28 1
d826 1
a826 1
  zcpy(ttyname,ptydir); zcat(ttyname,ptys[fd]);
d830 1
a830 1
   zcpy(ttyname,ttydir); zcat(ttyname,ptys[fd]);
d837 1
a837 1
    zcpy(ttyname,ptydir); zcat(ttyname,ptys[fd]);
d840 1
a840 1
    zcpy(ttyname,ttydir); zcat(ttyname,ptys[fd]);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
