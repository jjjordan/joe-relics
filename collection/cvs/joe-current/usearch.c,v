head	1.73;
access;
symbols
	joe_3_5:1.64
	joe-3_4:1.54
	help:1.54
	joe_3_1:1.32
	joe_3_0:1.23
	joe_2_9_8:1.17
	joe_2_9_8_pre1:1.12
	joe_2_9_7:1.5
	joe_2_9_7_pre3:1.5
	joe_2_9_7_pre2:1.4
	joe_2_9_6:1.3
	joe_2_9_5:1.2
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.2
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.02.18.15.00;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.01.02.07.46;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2008.10.30.15.33.21;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.23.05.27.50;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.13.22.02.53;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.13.19.45.20;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.07.05.17.09;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.07.02.29.49;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.03.23.37.01;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.03.13.23.02;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.02.15.01.26;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.30.15.34.24;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.21.16.29.49;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.05.18.34.32;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.05.18.18.45;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.06.06.36.38;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.05.04.17.53;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.27.07.04.45;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.27.21.59.00;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.24.04.30.52;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.01.04.25.21;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.16.21.37.37;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.14.16.35.54;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.06.15.42.49;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.25.20.04.45;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.09.18.13.48;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.24.20.57.26;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.10.20.31.19;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.08.22.42.44;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.08.04.42.41;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.07.20.05.46;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.05.22.05.56;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.03.22.55.53;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.17.13.13.17;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.20.22.27.40;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.19.19.46.23;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.19.02.29.59;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.18.16.03.49;	author marx_sk;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.04.17.39.29;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.10.45.26;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.13.32;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.53.40;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.48.08;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/*
 *	Search & Replace system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int wrap = 0;			/* Allow wrap */
int smode = 0;			/* Decremented to zero by execmd */
int csmode = 0;			/* Set for continued search mode */
int icase = 0;			/* Set to force case insensitive search */
int pico = 0;			/* Pico search prompting */

B *findhist = NULL;		/* Search string history */
B *replhist = NULL;		/* Replacement string history */

SRCH *globalsrch = NULL;	/* Most recent completed search data */

SRCHREC fsr = { {&fsr, &fsr} };

/* Completion stuff: should go somewhere else */

unsigned char **word_list;

#define MAX_WORD_SIZE 64
unsigned char **get_word_list(B *b,int ignore)
{
	unsigned char buf[MAX_WORD_SIZE];
	unsigned char *s;
	unsigned char **list = 0;
	HASH *h;
	HENTRY *t;
	P *p;
	int c;
	int idx;
	int start = 0;

	h = htmk(1024);

	p = pdup(b->bof, USTR "get_word_list");
	idx = 0;
	while ((c=pgetc(p))!=NO_MORE_DATA)
		if (idx) {
			if (joe_isalnum_(b->o.charmap, c)) {
				if (idx!=MAX_WORD_SIZE)
					buf[idx++] = c;
			} else {
				if (idx!=MAX_WORD_SIZE && start!=ignore) {
					buf[idx] = 0;
					if (!htfind(h,buf)) {
						s = vsncpy(NULL,0,buf,idx);
						htadd(h, s, s);
					}
				}
				idx = 0;
			}
		} else {
			start=p->byte-1;
			if (joe_isalpha_(b->o.charmap, c))
				buf[idx++] = c;
		}
	prm(p);

	list = vatrunc(list, 0);
	vaperm(list);

	for (idx = 0;idx != h->len;++idx)
		for (t = h->tab[idx];t;t=t->next)
			list = vaadd(list, t->name);
	if (list)
		vasort(av(list));	

	htrm(h);

	return list;
}

void fcmplt_ins(BW *bw, unsigned char *line)
{
	P *p = pdup(bw->cursor, USTR "fcmplt_ins");
	int c;

	if (!piseol(bw->cursor)) {
		int c = brch(bw->cursor);
		if (joe_isalnum_(bw->b->o.charmap,c))
			return;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor, USTR "fcmplt_ins");
	do
		c = prgetc(p);
		while (joe_isalnum_(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		/* Insert single match */
		bdel(p,bw->cursor);
		binsm(bw->cursor,sv(line));
		pfwrd(bw->cursor,vslen(line));
		bw->cursor->xcol = piscol(bw->cursor);
		prm(p);
	} else {
		prm(p);
	}
}

int fcmplt_abrt(BW *bw, int x, unsigned char *line)
{
	if (line) {
		fcmplt_ins(bw, line);
	}
	return -1;
}

int fcmplt_rtn(MENU *m, int x, unsigned char *line)
{
	fcmplt_ins(m->parent->win->object, m->list[x]);
	m->object = NULL;
	wabort(m->parent);
	return 0;
}

int ufinish(BW *bw)
{
	unsigned char *line;
	unsigned char *line1;
	unsigned char **lst;
	P *p;
	int c;
	MENU *m;

	/* Make sure we're not in a word */

	if (!piseol(bw->cursor)) {
		int c = brch(bw->cursor);
		if (joe_isalnum_(bw->b->o.charmap,c))
			return -1;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor, USTR "ufinish");
	do
		c = prgetc(p);
		while (joe_isalnum_(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		line = brvs(NULL, p, bw->cursor->byte-p->byte);
		obj_perm(line);

		/* We have a word */

		/* Get word list */
		if (word_list)
			varm(word_list);

		word_list = get_word_list(bw->b, p->byte);

		if (!word_list) {
			prm(p);
			return -1;
		}

		line1 = vsncpy(NULL,0,sv(line));
		line1 = vsadd(line1,'*');
		lst = regsub(av(word_list), line1);

		if (!lst) {
			ttputc(7);
			return -1;
		}
		vaperm(lst);

		m = mkmenu(bw->parent, bw->parent, lst, fcmplt_rtn, fcmplt_abrt, NULL, 0, line);
		if (!m) {
			varm(lst);
			return -1;
		}

		/* Possible match list is now in lst */

		if (valen(lst) == 1)
			return fcmplt_rtn(m, 0, line);
		else if (smode)
			return 0;
		else {
			unsigned char *com = mcomplete(m);
			obj_free(m->object);
			m->object = com;
			obj_perm(com);
			wabort(m->parent);
			smode = 2;
			ttputc(7);
			return 0;
		}
	} else {
		prm(p);
		return -1;
	}
}

static int srch_cmplt(BW *bw)
{
	if (word_list)
		varm(word_list);

	word_list = get_word_list(((BW *)bw->parent->win->object)->b, -1);

	if (!word_list) {
		ttputc(7);
		return 0;
	}

	return simple_cmplt(bw,word_list);
}

/* Search forward.
   bw, pattern and ignore must be set

   The first possible string we can find is the one beginning under p

   Returns p if we found a string:
     The found string is placed in entire/pieces
     p is placed right after the found string

   Return 0 if we did not find the string:
     p is left in its orignal spot
*/

static P *searchf(BW *bw,SRCH *srch, P *p)
{
	unsigned char *pattern;
	P *start;
	P *end;
	int x;

	pattern = srch->pattern;
	start = pdup(p, USTR "searchf");
	end = pdup(p, USTR "searchf");

	try_again:

	for (x = 0; x != vslen(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
		if (srch->ignore)
			pattern[x] = joe_tolower(p->b->o.charmap,pattern[x]);
	wrapped:
	while (srch->ignore ? pifind(start, pattern, x) : pfind(start, pattern, x)) {
		pset(end, start);
		pfwrd(end, (long) x);
		if (srch->wrap_flag && start->byte>=srch->wrap_p->byte)
			break;
		if (pmatch(srch->pieces, pattern + x, vslen(pattern) - x, end, 0, srch->ignore)) {
			if (end->byte == srch->last_repl) {
				/* Stuck? */
				pattern = srch->pattern;
				pset(start, p);
				if (pgetc(start) == NO_MORE_DATA)
					break;
				pset(end, start);
				goto try_again;
			} else {
				srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
				obj_perm(srch->entire);
				brmem(start, srch->entire, (int) (end->byte - start->byte));
				pset(p, end);
				prm(start);
				prm(end);
				return p;
			}
		}
		if (pgetc(start) == NO_MORE_DATA)
			break;
	}
	if (srch->allow_wrap && !srch->wrap_flag && srch->wrap_p) {
		msgnw(bw->parent, joe_gettext(_("Wrapped")));
		srch->wrap_flag = 1;
		p_goto_bof(start);
		goto wrapped;
	}
	srch->last_repl = -1;
	prm(start);
	prm(end);
	return NULL;
}

/* Search backwards.
   bw, pattern and ignore must be set

   The first possible string we can find is the one beginning one position
   to the left of p.

   Returns 1 if we found a string:
     The found string is placed in entire
     p is placed at the beginning of the string

   Return 0 if we did not find the string:
     p is left in its orignal spot
*/

static P *searchb(BW *bw,SRCH *srch, P *p)
{
	unsigned char *pattern = srch->pattern;
	P *start;
	P *end;
	int x;

	start = pdup(p, USTR "searchb");
	end = pdup(p, USTR "searchb");

	try_again:

	for (x = 0; x != vslen(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
		if (srch->ignore)
			pattern[x] = joe_tolower(p->b->o.charmap,pattern[x]);

	wrapped:
	while (pbkwd(start, 1L)
	       && (srch->ignore ? prifind(start, pattern, x) : prfind(start, pattern, x))) {
		pset(end, start);
		pfwrd(end, (long) x);
		if (srch->wrap_flag && start->byte<srch->wrap_p->byte)
			break;
		if (pmatch(srch->pieces, pattern + x, vslen(pattern) - x, end, 0, srch->ignore)) {
			if (start->byte == srch->last_repl) {
				/* Stuck? */
				pattern = srch->pattern;
				pset(start, p);
				if (prgetc(start) == NO_MORE_DATA)
					break;
				pset(end, start);
				goto try_again;
			} else {
				srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
				obj_perm(srch->entire);
				brmem(start, srch->entire, (int) (end->byte - start->byte));
				pset(p, start);
				prm(start);
				prm(end);
				return p;
			}
		}
	}

	if (srch->allow_wrap && !srch->wrap_flag && srch->wrap_p) {
		msgnw(bw->parent, joe_gettext(_("Wrapped")));
		srch->wrap_flag = 1;
		p_goto_eof(start);
		goto wrapped;
	}
	srch->last_repl = -1;
	prm(start);
	prm(end);
	return NULL;
}

/* Make a search stucture */

static SRCH *setmark(SRCH *srch)
{
	if (markv(0))
		srch->valid = 1;

	srch->markb = markb;
	if (srch->markb)
		srch->markb->owner = &srch->markb;
	markb = NULL;

	srch->markk = markk;
	if (srch->markk)
		srch->markk->owner = &srch->markk;
	markk = NULL;

	return srch;
}

SRCH *mksrch(unsigned char *pattern, unsigned char *replacement, int ignore, int backwards, int repeat, int replace, int rest, int all)
{
	SRCH *srch = (SRCH *) joe_malloc(sizeof(SRCH));
	int x;

	obj_perm(pattern);
	obj_perm(replacement);

	srch->first = NULL;
	srch->current = NULL;
	srch->all = all;
	srch->pattern = pattern;
	srch->replacement = replacement;
	srch->ignore = ignore;
	srch->backwards = backwards;
	srch->repeat = repeat;
	srch->replace = replace;
	srch->rest = rest;
	srch->entire = NULL;
	srch->flg = 0;
	srch->addr = -1;
	srch->last_repl = -1;
	srch->markb = NULL;
	srch->markk = NULL;
	srch->wrap_p = NULL;
	srch->allow_wrap = wrap;
	srch->wrap_flag = 0;
	srch->valid = 0;
	srch->block_restrict = 0;
	izque(SRCHREC, link, &srch->recs);
	for (x = 0; x != 26; ++x)
		srch->pieces[x] = NULL;
	return srch;
}

/* Eliminate a search structure */

void rmsrch(SRCH *srch)
{
	int x;

	prm(markb);
	prm(markk);
	prm(srch->wrap_p);
	if (srch->markb) {
		markb = srch->markb;
		markb->owner = &markb;
		markb->xcol = piscol(markb);
	}
	if (srch->markk) {
		markk = srch->markk;
		markk->owner = &markk;
		markk->xcol = piscol(markk);
	}
	for (x = 0; x != 26; ++x)
		obj_free(srch->pieces[x]);
	frchn(&fsr, &srch->recs);
	obj_free(srch->pattern);
	obj_free(srch->replacement);
	obj_free(srch->entire);
	joe_free(srch);
	updall();
}

/* Insert a replacement string
 * p is advanced past the inserted text
 */

static P *insert(SRCH *srch, P *p, unsigned char *s, int len)
{
	int x;
	long starting = p->byte;

	while (len) {
		for (x = 0; x != len && s[x] != '\\'; ++x) ;
		if (x) {
			binsm(p, s, x);
			pfwrd(p, (long) x);
			len -= x;
			s += x;
		} else if (len >= 2) {
			if (((s[1] >= 'a' && s[1] <= 'z') || (s[1] >= 'A' && s[1] <= 'Z'))
				 && srch->pieces[(s[1] & 0x1f) - 1]) {
				binsm(p, sv(srch->pieces[(s[1] & 0x1f) - 1]));
				pfwrd(p, (long) vslen(srch->pieces[(s[1] & 0x1f) - 1]));
				s += 2;
				len -= 2;
			} else if (s[1] >= '0' && s[1] <= '9' && srch->pieces[s[1] - '0']) {
				binsm(p, sv(srch->pieces[s[1] - '0']));
				pfwrd(p, (long) vslen(srch->pieces[s[1] - '0']));
				s += 2;
				len -= 2;
			} else if (s[1] == '&' && srch->entire) {
				binsm(p, sv(srch->entire));
				pfwrd(p, (long) vslen(srch->entire));
				s += 2;
				len -= 2;
			} else {
				unsigned char *a=(unsigned char *)s+x;
				int l=len-x;
				binsc(p,escape(p->b->o.charmap->type,&a,&l));
				pgetc(p);
				len -= a - (unsigned char *)s;
				s = a;
			}
		} else
			len = 0;
	}

	if (srch->backwards)
		pbkwd (p, p->byte - starting);

	return p;
}

/* Search system user interface */

/* Query for search string, search options, possible replacement string,
 * and execute first search */

unsigned char srchstr[] = "Search";	/* Context sensitive help identifier */
unsigned char srchopt[] = "SearchOptions";

static int pfsave(BW *bw, SRCH *srch)
{
	if (srch) {
		if (globalsrch)
			rmsrch(globalsrch);
		globalsrch = srch;
		srch->rest = 0;
		srch->repeat = -1;
		srch->flg = 0;

		prm(markb);
		prm(markk);
		if (srch->markb) {
			markb = srch->markb;
			markb->owner = &markb;
			markb->xcol = piscol(markb);
		}
		if (srch->markk) {
			markk = srch->markk;
			markk->owner = &markk;
			markk->xcol = piscol(markk);
		}
		srch->markb = NULL;
		srch->markk = NULL;

		updall();
	}
	return -1;
}

/* Option characters */

unsigned char *all_key = (unsigned char *) _("|all files|aA");
unsigned char *list_key = (unsigned char *) _("|error list files|eE");
unsigned char *replace_key = (unsigned char *) _("|search and replace|rR");
unsigned char *backwards_key = (unsigned char *) _("|backwards|bB");
unsigned char *ignore_key = (unsigned char *) _("|ignore case|iI");
unsigned char *block_key = (unsigned char *) _("|restrict to highlighted block|kK");
unsigned char *noignore_key = (unsigned char *) _("|don't ignore case|sS");
unsigned char *wrap_key = (unsigned char *) _("|wrap|wW");
unsigned char *nowrap_key = (unsigned char *) _("|don't wrap|nN");

int dofirst(BW *bw, int back, int repl, unsigned char *hint)
{
	SRCH *srch;
	unsigned char bf1[32];
	unsigned char *s = 0;

	if (smode && globalsrch) {
		globalsrch->backwards = back;
		globalsrch->replace = repl;
		return pfnext(bw);
	}
	if (bw->parent->huh == srchstr) {
		long byte;

		p_goto_eol(bw->cursor);
		byte = bw->cursor->byte;
		p_goto_bol(bw->cursor);
		if (byte == bw->cursor->byte)
			prgetc(bw->cursor);
		return urtn((BASE *)bw, -1);
	}
	srch = mksrch(NULL, NULL, 0, back, -1, repl, 0, 0);
	srch->addr = bw->cursor->byte;
	srch->wrap_p = pdup(bw->cursor, USTR "dofirst");
	srch->wrap_p->owner = &srch->wrap_p;
	if (pico && globalsrch && globalsrch->pattern) {
		unesc_genfmt(bf1, sv(globalsrch->pattern), sizeof(bf1)-2);
		s = vsfmt(s, 0, joe_gettext(_("Find (^C to abort) [%s]: ")),bf1);
	} else
		s = vsdupz(joe_gettext(_("Find (^C to abort): ")));

	s = ask(bw->parent, s, &findhist, srchstr, srch_cmplt, bw->b->o.charmap, 0, 0, hint);

	if (s) {
		unsigned char *p;
		unsigned char buf[80];
		unsigned char *bufp;
		if (icase)
			p = joe_gettext(_("case (S)ensitive (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): "));
		else
			p = joe_gettext(_("(I)gnore (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): "));

		obj_free(srch->pattern);
		if (vslen(s) || !globalsrch || !pico) {
			srch->pattern = s;
			obj_perm(s);
		} else {
			srch->pattern = vsdup(globalsrch->pattern);
			obj_perm(srch->pattern);
		}

		bufp = buf;
		if (srch->ignore) {
			unsigned char *t = joe_gettext(ignore_key);
			copy_c(&bufp, &t);
		}
		if (srch->replace) {
			unsigned char *t = joe_gettext(replace_key);
			copy_c(&bufp, &t);
		}
		if (srch->backwards) {
			unsigned char *t = joe_gettext(backwards_key);
			copy_c(&bufp, &t);
		}
		if (srch->repeat >= 0) {
			joe_snprintf_1(bufp, sizeof(buf) - (bufp - buf), "%d", srch->repeat);
			bufp += zlen(bufp);
		}
		srch->ignore = 0;
		srch->replace = 0;
		srch->backwards = 0;
		srch->repeat = -1;

		*bufp = 0;

		s = ask(bw->parent, p, NULL, srchopt, utypebw, bw->b->o.charmap, 0, 0, buf);

		if (s) {
			unsigned char *t;

			srch->ignore = icase;

			t = s;
			while (*t) {
				int c = fwrd_c(&t);
				if (yncheck(all_key, c))
					srch->all = 1;
				else if (yncheck(list_key, c))
					srch->all = 2;
				else if (yncheck(replace_key, c))
					srch->replace = 1;
				else if (yncheck(backwards_key, c))
					srch->backwards = 1;
				else if (yncheck(ignore_key, c))
					srch->ignore = 1;
				else if (yncheck(noignore_key, c))
					srch->ignore = 0;
				else if (yncheck(wrap_key, c))
					srch->allow_wrap = 1;
				else if (yncheck(nowrap_key, c))
					srch->allow_wrap = 0;
				else if (yncheck(block_key, c))
					srch->block_restrict = 1;
				else if (c >= '0' && c <= '9') {
					if (srch->repeat == -1)
						srch->repeat = 0;
					srch->repeat = srch->repeat * 10 + c - '0';
				}
			}	
			if (srch->replace) {
				/* if (pico && globalsrch && globalsrch->replacement) {
					joe_snprintf_1(bf1,30,"%s",globalsrch->replacement);
					if (zlen(globalsrch->replacement)>29)
						zcat(bf1,USTR "$");
					joe_snprintf_1(buf,sizeof(buf),joe_gettext(_("Replace with (^C to abort) [%s]: ")),bf1);
				} else
					zcpy(buf, joe_gettext(_("Replace with (^C to abort): "))); */

				s = ask(bw->parent, joe_gettext(_("Replace with (^C to abort): ")), &replhist, srchstr, srch_cmplt, bw->b->o.charmap, 0, 0, NULL);
				if (s) {
					if (vslen(s) || !globalsrch || !pico) {
						srch->replacement = s;
						obj_perm(s);
					} else {
						/* Use previous string: this prevents replace with empty string */
						/* vsrm(s);
						srch->replacement = vsdup(globalsrch->replacement); */
						srch->replacement = s;
						obj_perm(s);
					}
					return dopfnext(bw, setmark(srch));
				} else
					return -1;
			} else
				return dopfnext(bw, setmark(srch));
			return 0;
		} else {
			rmsrch(srch);
			return -1;
		}
	} else {
		rmsrch(srch);
		return -1;
	}
}

int pffirst(BW *bw)
{
	return dofirst(bw, 0, 0, NULL);
}

int prfirst(BW *bw)
{
	return dofirst(bw, 1, 0, NULL);
}

int pqrepl(BW *bw)
{
	return dofirst(bw, 0, 1, NULL);
}

/* Execute next search */

static int doreplace(BW *bw, SRCH *srch)
{
	P *q;

	if (!modify_logic(bw,bw->b))
		return -1;
	if (markk)
		markk->end = 1;
	if (srch->markk)
		srch->markk->end = 1;
	q = pdup(bw->cursor, USTR "doreplace");
	if (srch->backwards) {
		q = pfwrd(q, (long) vslen(srch->entire));
		bdel(bw->cursor, q);
		prm(q);
	} else {
		q = pbkwd(q, (long) vslen(srch->entire));
		bdel(q, bw->cursor);
		prm(q);
	}
	insert(srch, bw->cursor, sv(srch->replacement));
	srch->addr = bw->cursor->byte;
	srch->last_repl = bw->cursor->byte;
	if (markk)
		markk->end = 0;
	if (srch->markk)
		srch->markk->end = 0;
	return 0;
}

static void visit(SRCH *srch, BW *bw, int yn)
{
	SRCHREC *r = (SRCHREC *) alitem(&fsr, sizeof(SRCHREC));
	r->addr = bw->cursor->byte;
	r->yn = yn;
	r->wrap_flag = srch->wrap_flag;
	r->last_repl = srch->last_repl;
	r->b = bw->b;
	enqueb(SRCHREC, link, &srch->recs, r);
}

static void goback(SRCH *srch, BW *bw)
{
	SRCHREC *r = srch->recs.link.prev;

	if (r != &srch->recs) {
		srch->current = r->b;
		if (r->yn) {
			uundo(bw);
		}
		if (r->b != bw->b) {
			W *w = bw->parent;
			get_buffer_in_window(bw, r->b);
			bw = (BW *)w->object;
		}
		if (bw->cursor->byte != r->addr)
			pgoto(bw->cursor, r->addr);
		srch->wrap_flag = r->wrap_flag;
		srch->last_repl = r->last_repl;
		demote(SRCHREC, link, &fsr, r);
	}
}

unsigned char *rest_key = (unsigned char *) _("|rest of file|rR");
unsigned char *backup_key = (unsigned char *) _("|backup|bB");

static int dopfrepl(BW *bw, int c, SRCH *srch)
{
	again:
	srch->addr = bw->cursor->byte;
	/* for jamcs backspace means no */
	if (c == 8 || c == 127 || c == NO_CODE || yncheck(no_key, c))
		return dopfnext(bw, srch);
	else if (c == YES_CODE || yncheck(yes_key, c) || c == ' ') {
		srch->recs.link.prev->yn = 1;
		if (doreplace(bw, srch)) {
			pfsave(bw, srch);
			return -1;
		} else
			return dopfnext(bw, srch);
	} else if (yncheck(rest_key, c) || c == '!') {
		if (doreplace(bw, srch))
			return -1;
		srch->rest = 1;
		return dopfnext(bw, srch);
	} else if (/* c == 8 || c == 127 || */ yncheck(backup_key, c)) {
		W *w = bw->parent;
		goback(srch, bw);
		goback(srch, (BW *)w->object);
		return dopfnext((BW *)w->object, srch);
	} else if (c != -1) {
		pfsave(bw, srch);
		nungetc(c);
		return 0;
	}
	c = query(bw->parent, sz(joe_gettext(_("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"))), QW_SR);
	if (c != -1)
		goto again;
	else
		return pfsave(bw, srch);
}

/* Test if found text is within region
 * return 0 if it is,
 * -1 if we should keep searching
 * 1 if we're done
 */

static int restrict_to_block(BW *bw, SRCH *srch)
{
	if (!srch->valid || !srch->block_restrict)
		return 0;
	bw->cursor->xcol = piscol(bw->cursor);
	if (srch->backwards)
		if (!square) {
			if (bw->cursor->byte < srch->markb->byte)
				return 1;
			else if (bw->cursor->byte + vslen(srch->entire) > srch->markk->byte)
				return -1;
		} else {
			if (bw->cursor->line < srch->markb->line)
				return 1;
			else if (bw->cursor->line > srch->markk->line)
				return -1;
			else if (piscol(bw->cursor) + vslen(srch->entire) > srch->markk->xcol || piscol(bw->cursor) < srch->markb->xcol)
				return -1;
	} else if (!square) {
		if (bw->cursor->byte > srch->markk->byte)
			return 1;
		else if (bw->cursor->byte - vslen(srch->entire) < srch->markb->byte)
			return -1;
	} else {
		if (bw->cursor->line > srch->markk->line)
			return 1;
		if (bw->cursor->line < srch->markb->line)
			return -1;
		if (piscol(bw->cursor) > srch->markk->xcol || piscol(bw->cursor) - vslen(srch->entire) < srch->markb->xcol)
			return -1;
	}
	return 0;
}

/* Possible results:
 *   0) Search or search & replace is finished.
 *   1) Search string was not found.
 *   2) Search string was found.
 *   3) Abort due to infinite loop
 */

static int fnext(BW *bw, SRCH *srch)
{
	P *sta;

	if (!srch->first) {
		srch->first = bw->b;
		srch->current = bw->b;
	}

	next:
	if (srch->repeat != -1) {
		if (!srch->repeat)
			return 0;
		else
			--srch->repeat;
	}
	again:
	if (srch->backwards)
		sta = searchb(bw, srch, bw->cursor);
	else
		sta = searchf(bw, srch, bw->cursor);
	if (!sta && srch->all) {
		B *b;
		if (srch->all == 2)
			b = beafter(srch->current);
		else {
			berror = 0;
			b = bafter(srch->current);
		}
		if (b && b != srch->first && !berror) {
			W *w = bw->parent;
			srch->current = b;
			/* this bumps reference count of b */
			get_buffer_in_window(bw, b);
			bw = (BW *)w->object;
			p_goto_bof(bw->cursor);
			goto again;
		} else if (berror) {
			msgnw(bw->parent, joe_gettext(msgs[-berror]));
		}
	}
	if (!sta) {
		srch->repeat = -1;
		return 1;
	}
	if (srch->rest || (srch->repeat != -1 && srch->replace)) {
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				return !srch->rest;
			}
		if (doreplace(bw, srch))
			return 0;
		goto next;
	} else if (srch->repeat != -1) {
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				return 1;
			}
		srch->addr = bw->cursor->byte;
		goto next;
	} else
		return 2;
}

int dopfnext(BW *bw, SRCH *srch)
{
	W *w;
	int fnr;
	int orgmid = mid;	/* Original mid status */
	int ret = 0;

	printf("dopfnext\n"); fflush(stdout); sleep(1);

	mid = 1;		/* Screen recenters mode during search */
	if (csmode)
		smode = 2;	/* We have started a search mode */
	if (srch->replace)
		visit(srch, bw, 0);
again:	w = bw->parent;
	fnr = fnext(bw, srch);
	bw  = (BW *)w->object;
	switch (fnr) {
	case 0:
		break;
	case 1:
bye:		if (!srch->flg && !srch->rest) {
			if (srch->valid && srch->block_restrict)
				msgnw(bw->parent, joe_gettext(_("Not found (search restricted to marked block)")));
			else
				msgnw(bw->parent, joe_gettext(_("Not found")));
			ret = -1;
		}
		break;
	case 3:
		msgnw(bw->parent, joe_gettext(_("Infinite loop aborted: your search repeatedly matched same place")));
		ret = -1;
		break;
	case 2:
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				goto bye;
			}
		srch->addr = bw->cursor->byte;

		/* Make sure found text is fully on screen */
		if(srch->backwards) {
			bw->offset=0;
			pfwrd(bw->cursor,vslen(srch->entire));
			bw->cursor->xcol = piscol(bw->cursor);
			dofollows();
			pbkwd(bw->cursor,vslen(srch->entire));
		} else {
			bw->offset=0;
			pbkwd(bw->cursor,vslen(srch->entire));
			bw->cursor->xcol = piscol(bw->cursor);
			dofollows();
			pfwrd(bw->cursor,vslen(srch->entire));
		}

		if (srch->replace) {
			if (square)
				bw->cursor->xcol = piscol(bw->cursor);
			if (srch->backwards) {
				pdupown(bw->cursor, &markb, USTR "dopfnext");
				markb->xcol = piscol(markb);
				pdupown(markb, &markk, USTR "dopfnext");
				pfwrd(markk, (long) vslen(srch->entire));
				markk->xcol = piscol(markk);
			} else {
				pdupown(bw->cursor, &markk, USTR "dopfnext");
				markk->xcol = piscol(markk);
				pdupown(bw->cursor, &markb, USTR "dopfnext");
				pbkwd(markb, (long) vslen(srch->entire));
				markb->xcol = piscol(markb);
			}
			srch->flg = 1;
			/* This call should not be here... */
			if (dopfrepl(bw, -1, srch))
				ret = -1;
			srch = 0;
		}
		break;
	}
	bw->cursor->xcol = piscol(bw->cursor);
	dofollows();
	mid = orgmid;
	printf("update\n"); fflush(stdout); sleep(1);
	if (srch)
		pfsave(bw, srch);
	else
		updall();
	return ret;
}

int pfnext(BW *bw)
{
	if (!globalsrch) {	/* Query for search string if there isn't any */
		return pffirst(bw);
	} else {
		SRCH *srch = globalsrch;

		globalsrch = 0;
		srch->addr = bw->cursor->byte;
		if (!srch->wrap_p || srch->wrap_p->b!=bw->b) {
			prm(srch->wrap_p);
			srch->wrap_p = pdup(bw->cursor, USTR "pfnext");
			srch->wrap_p->owner = &srch->wrap_p;
			srch->wrap_flag = 0;
		}
		return dopfnext(bw, setmark(srch));
	}
}

void save_srch(FILE *f)
{
	if(globalsrch) {
		if(globalsrch->pattern) {
			fprintf(f,"	pattern ");
			emit_string(f,sv(globalsrch->pattern));
			fprintf(f,"\n");
		}
		if(globalsrch->replacement) {
			fprintf(f,"	replacement ");
			emit_string(f,sv(globalsrch->replacement));
			fprintf(f,"\n");
		}
		fprintf(f,"	backwards %d\n",globalsrch->backwards);
		fprintf(f,"	ignore %d\n",globalsrch->ignore);
		fprintf(f,"	replace %d\n",globalsrch->replace);
		fprintf(f,"	block_restrict %d\n",globalsrch->block_restrict);
	}
	fprintf(f,"done\n");
}

void load_srch(FILE *f)
{
	unsigned char *buf = 0;
	unsigned char *bf = 0;
	unsigned char *pattern = 0;
	unsigned char *replacement = 0;
	int backwards = 0;
	int ignore = 0;
	int replace = 0;
	int block_restrict = 0;
	while(vsgets(&buf,f) && zcmp(buf,USTR "done")) {
		unsigned char *p=buf;
		parse_ws(&p,'#');
		if(!parse_kw(&p,USTR "pattern")) {
			int len;
			parse_ws(&p,'#');
			len = parse_string(&p,&bf);
			if (len>0)
				pattern = vsdup(bf);
		} else if(!parse_kw(&p,USTR "replacement")) {
			int len;
			parse_ws(&p,'#');
			len = parse_string(&p,&bf);
			if (len>0)
				replacement = vsdup(bf);
		} else if(!parse_kw(&p,USTR "backwards")) {
			parse_ws(&p,'#');
			parse_int(&p,&backwards);
		} else if(!parse_kw(&p,USTR "ignore")) {
			parse_ws(&p,'#');
			parse_int(&p,&ignore);
		} else if(!parse_kw(&p,USTR "replace")) {
			parse_ws(&p,'#');
			parse_int(&p,&replace);
		} else if(!parse_kw(&p,USTR "block_restrict")) {
			parse_ws(&p,'#');
			parse_int(&p,&block_restrict);
		}
	}
	globalsrch = mksrch(pattern,replacement,ignore,backwards,-1,replace,0,0);
	globalsrch->block_restrict = block_restrict;
}
@


1.72
log
@Improve jmacs mode slightly.
@
text
@a505 7
static int pfabort(BW *bw, SRCH *srch)
{
	if (srch)
		rmsrch(srch);
	return -1;
}

a625 1
			unsigned char buf[80];
@


1.71
log
@quoting fixes
@
text
@d789 2
a790 1
	if (c == NO_CODE || yncheck(no_key, c))
d804 1
a804 1
	} else if (c == 8 || c == 127 || yncheck(backup_key, c)) {
@


1.70
log
@! means replace all in search & replace
@
text
@d581 1
a581 1
		unesc_genfmt(bf1, globalsrch->pattern, sizeof(bf1)-2);
@


1.69
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d798 1
a798 1
	} else if (yncheck(rest_key, c)) {
@


1.68
log
@More work on coroutine refactoring.
@
text
@d287 1
a287 1

d357 1
a357 1

@


1.67
log
@more refactoring
@
text
@d181 1
a181 1
		m = mkmenu(bw->parent, bw->parent, lst, fcmplt_rtn, fcmplt_abrt, NULL, 0, line, NULL);
d686 1
a686 1
					return dopfnext(bw, setmark(srch), NULL);
d690 1
a690 1
				return dopfnext(bw, setmark(srch), NULL);
d785 1
a785 1
static int dopfrepl(BW *bw, int c, SRCH *srch, int *notify)
d787 1
d790 1
a790 1
		return dopfnext(bw, srch, notify);
d797 1
a797 1
			return dopfnext(bw, srch, notify);
d802 1
a802 1
		return dopfnext(bw, srch, notify);
d807 1
a807 1
		return dopfnext((BW *)w->object, srch, notify);
a808 2
		if (notify)
			*notify = 1;
d813 3
a815 2
	if (mkqwnsr(bw->parent, sz(joe_gettext(_("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"))), dopfrepl, pfsave, srch, notify))
		return 0;
d941 1
a941 1
int dopfnext(BW *bw, SRCH *srch, int *notify)
d948 2
d1018 2
a1019 1
			if (dopfrepl(bw, -1, srch, notify))
a1020 1
			notify = 0;
d1028 1
a1028 2
	if (notify)
		*notify = 1;
d1051 1
a1051 1
		return dopfnext(bw, setmark(srch), NULL);
@


1.66
log
@more wmkpw elimination
@
text
@d586 1
a586 1
	s = ask(bw->parent, s, &findhist, srchstr, srch_cmplt, NULL, bw->b->o.charmap, 0, 0, hint);
d630 1
a630 1
		s = ask(bw->parent, p, NULL, srchopt, utypebw, NULL, bw->b->o.charmap, 0, 0, buf);
d674 1
a674 1
				s = ask(bw->parent, joe_gettext(_("Replace with (^C to abort): ")), &replhist, srchstr, srch_cmplt, NULL, bw->b->o.charmap, 0, 0, NULL);
@


1.65
log
@semiautomatic variables
@
text
@a542 15
static int set_replace(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	if (vslen(s) || !globalsrch || !pico) {
		srch->replacement = s;
		obj_perm(s);
	} else {
		/* Use previous string: this prevents replace with empty string */
		/* vsrm(s);
		srch->replacement = vsdup(globalsrch->replacement); */
		srch->replacement = s;
		obj_perm(s);
	}
	return dopfnext(bw, setmark(srch), notify);
}

a554 126
/* Get next character from string and advance it, locale dependent */

int fwrd_c(unsigned char **s)
{
	if (locale_map->type)
		return utf8_decode_fwrd(s, NULL);
	else {
		int c = **s;
		*s = *s + 1;
		return c;
	}
}

static int set_options(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	unsigned char buf[80];
	unsigned char *t;

	srch->ignore = icase;

	t = s;
	while (*t) {
		int c = fwrd_c(&t);
		if (yncheck(all_key, c))
			srch->all = 1;
		else if (yncheck(list_key, c))
			srch->all = 2;
		else if (yncheck(replace_key, c))
			srch->replace = 1;
		else if (yncheck(backwards_key, c))
			srch->backwards = 1;
		else if (yncheck(ignore_key, c))
			srch->ignore = 1;
		else if (yncheck(noignore_key, c))
			srch->ignore = 0;
		else if (yncheck(wrap_key, c))
			srch->allow_wrap = 1;
		else if (yncheck(nowrap_key, c))
			srch->allow_wrap = 0;
		else if (yncheck(block_key, c))
			srch->block_restrict = 1;
		else if (c >= '0' && c <= '9') {
			if (srch->repeat == -1)
				srch->repeat = 0;
			srch->repeat = srch->repeat * 10 + c - '0';
		}
	}	
	if (srch->replace) {
		/* if (pico && globalsrch && globalsrch->replacement) {
			joe_snprintf_1(bf1,30,"%s",globalsrch->replacement);
			if (zlen(globalsrch->replacement)>29)
				zcat(bf1,USTR "$");
			joe_snprintf_1(buf,sizeof(buf),joe_gettext(_("Replace with (^C to abort) [%s]: ")),bf1);
		} else */
			zcpy(buf, joe_gettext(_("Replace with (^C to abort): ")));
		if (wmkpw(bw->parent, buf, &replhist, set_replace, srchstr, pfabort, srch_cmplt, srch, notify, bw->b->o.charmap, 0))
			return 0;
		else
			return -1;
	} else
		return dopfnext(bw, setmark(srch), notify);
}

static int set_pattern(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	BW *pbw;
	unsigned char *p;

	if (icase)
		p = joe_gettext(_("case (S)ensitive (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): "));
	else
		p = joe_gettext(_("(I)gnore (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): "));

	obj_free(srch->pattern);
	if (vslen(s) || !globalsrch || !pico) {
		srch->pattern = s;
		obj_perm(s);
	} else {
		srch->pattern = vsdup(globalsrch->pattern);
		obj_perm(srch->pattern);
	}
	if ((pbw = wmkpw(bw->parent, p, NULL, set_options, srchopt, pfabort, utypebw, srch, notify, bw->b->o.charmap, 0)) != NULL) {
		unsigned char buf[10];

		if (srch->ignore) {
			unsigned char *t = joe_gettext(ignore_key);
			binsc(pbw->cursor, fwrd_c(&t));
		}
		if (srch->replace) {
			unsigned char *t = joe_gettext(replace_key);
			binsc(pbw->cursor, fwrd_c(&t));
		}
		if (srch->backwards) {
			unsigned char *t = joe_gettext(backwards_key);
			binsc(pbw->cursor, fwrd_c(&t));
		}
		if (srch->repeat >= 0)
			joe_snprintf_1(buf, sizeof(buf), "%d", srch->repeat), binss(pbw->cursor, buf);
		pset(pbw->cursor, pbw->b->eof);
		pbw->cursor->xcol = piscol(pbw->cursor);
		srch->ignore = 0;
		srch->replace = 0;
		srch->backwards = 0;
		srch->repeat = -1;
		return 0;
	} else {
		rmsrch(srch);
		return -1;
	}
}

/* Unescape for text going to genfmt */

void unesc_genfmt(unsigned char *d, unsigned char *s, int max)
{
	while (max && *s) {
		if (*s == '\\')
			*d++ = '\\';
		*d++ = *s++;
		--max;
	}
	if (*s)
		*d++ = '$';
	*d = 0;
}

a557 1
	BW *pbw;
d559 1
a559 1
	unsigned char *buf = 0;
d582 1
a582 1
		buf = vsfmt(buf, 0, joe_gettext(_("Find (^C to abort) [%s]: ")),bf1);
d584 111
a694 6
		buf = vsdupz(joe_gettext(_("Find (^C to abort): ")));
	if ((pbw=wmkpw(bw->parent, buf, &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap, 0))) {
		if (hint) {
			binss(pbw->cursor, hint);
			pset(pbw->cursor, pbw->b->eof);
			pbw->cursor->xcol = piscol(pbw->cursor);
a695 1
		return 0;
@


1.64
log
@UC -> USTR
@
text
@d66 3
d73 1
a73 1
		vasort(list,sLEN(list));	
d104 1
a104 1
		pfwrd(bw->cursor,sLEN(line));
a115 1
		vsrm(line);
a122 1
	vsrm(line);
d155 2
a156 1
		line = brvs(p, bw->cursor->byte-p->byte);
a166 1
			vsrm(line);
d173 1
a173 2
		lst = regsub(word_list, aLEN(word_list), line1);
		vsrm(line1);
a176 1
			vsrm(line);
d179 1
a183 1
			vsrm(line);
d189 1
a189 1
		if (aLEN(lst) == 1)
d195 1
a195 1
			vsrm(m->object);
d197 1
d250 1
a250 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
d259 1
a259 1
		if (pmatch(srch->pieces, pattern + x, sLEN(pattern) - x, end, 0, srch->ignore)) {
d270 1
d319 1
a319 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
d330 1
a330 1
		if (pmatch(srch->pieces, pattern + x, sLEN(pattern) - x, end, 0, srch->ignore)) {
d341 1
d388 3
d438 1
a438 1
		vsrm(srch->pieces[x]);
d440 3
a442 3
	vsrm(srch->pattern);
	vsrm(srch->replacement);
	vsrm(srch->entire);
d467 1
a467 1
				pfwrd(p, (long) sLEN(srch->pieces[(s[1] & 0x1f) - 1]));
d472 1
a472 1
				pfwrd(p, (long) sLEN(srch->pieces[s[1] - '0']));
d477 1
a477 1
				pfwrd(p, (long) sLEN(srch->entire));
d545 1
a545 1
	if (sLEN(s) || !globalsrch || !pico)
d547 2
a548 1
	else {
d553 1
a616 1
	vsrm(s);
d643 2
a644 2
	vsrm(srch->pattern);
	if (sLEN(s) || !globalsrch || !pico)
d646 2
a647 2
	else {
		vsrm(s);
d649 1
d700 2
a701 2
	unsigned char bf1[80];
	unsigned char buf[80];
d723 2
a724 2
		unesc_genfmt(bf1, globalsrch->pattern, 30);
		joe_snprintf_1(buf,sizeof(buf),joe_gettext(_("Find (^C to abort) [%s]: ")),bf1);
d726 1
a726 1
		zcpy(buf, joe_gettext(_("Find (^C to abort): ")));
d769 1
a769 1
		q = pfwrd(q, (long) sLEN(srch->entire));
d773 1
a773 1
		q = pbkwd(q, (long) sLEN(srch->entire));
d873 1
a873 1
			else if (bw->cursor->byte + sLEN(srch->entire) > srch->markk->byte)
d880 1
a880 1
			else if (piscol(bw->cursor) + sLEN(srch->entire) > srch->markk->xcol || piscol(bw->cursor) < srch->markb->xcol)
d885 1
a885 1
		else if (bw->cursor->byte - sLEN(srch->entire) < srch->markb->byte)
d892 1
a892 1
		if (piscol(bw->cursor) > srch->markk->xcol || piscol(bw->cursor) - sLEN(srch->entire) < srch->markb->xcol)
d1025 1
a1025 1
			pfwrd(bw->cursor,sLEN(srch->entire));
d1028 1
a1028 1
			pbkwd(bw->cursor,sLEN(srch->entire));
d1031 1
a1031 1
			pbkwd(bw->cursor,sLEN(srch->entire));
d1034 1
a1034 1
			pfwrd(bw->cursor,sLEN(srch->entire));
d1044 1
a1044 1
				pfwrd(markk, (long) sLEN(srch->entire));
d1050 1
a1050 1
				pbkwd(markb, (long) sLEN(srch->entire));
d1097 1
a1097 1
			emit_string(f,globalsrch->pattern,sLEN(globalsrch->pattern));
d1102 1
a1102 1
			emit_string(f,globalsrch->replacement,sLEN(globalsrch->replacement));
d1115 2
a1116 2
	unsigned char buf[1024];
	unsigned char bf[1024];
d1123 1
a1123 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,USTR "done\n")) {
d1129 1
a1129 2
			bf[0] = 0;
			len = parse_string(&p,bf,sizeof(bf));
d1131 1
a1131 1
				pattern = vsncpy(NULL,0,bf,len);
d1135 1
a1135 2
			bf[0] = 0;
			len = parse_string(&p,bf,sizeof(bf));
d1137 1
a1137 1
				replacement = vsncpy(NULL,0,bf,len);
@


1.63
log
@change US to UC
@
text
@d42 1
a42 1
	p = pdup(b->bof, UC "get_word_list");
d79 1
a79 1
	P *p = pdup(bw->cursor, UC "fcmplt_ins");
d90 1
a90 1
	p = pdup(bw->cursor, UC "fcmplt_ins");
d146 1
a146 1
	p = pdup(bw->cursor, UC "ufinish");
d245 2
a246 2
	start = pdup(p, UC "searchf");
	end = pdup(p, UC "searchf");
d313 2
a314 2
	start = pdup(p, UC "searchb");
	end = pdup(p, UC "searchb");
d615 1
a615 1
				zcat(bf1,UC "$");
d713 1
a713 1
	srch->wrap_p = pdup(bw->cursor, UC "dofirst");
d760 1
a760 1
	q = pdup(bw->cursor, UC "doreplace");
d1034 1
a1034 1
				pdupown(bw->cursor, &markb, UC "dopfnext");
d1036 1
a1036 1
				pdupown(markb, &markk, UC "dopfnext");
d1040 1
a1040 1
				pdupown(bw->cursor, &markk, UC "dopfnext");
d1042 1
a1042 1
				pdupown(bw->cursor, &markb, UC "dopfnext");
d1077 1
a1077 1
			srch->wrap_p = pdup(bw->cursor, UC "pfnext");
d1116 1
a1116 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,UC "done\n")) {
d1119 1
a1119 1
		if(!parse_kw(&p,UC "pattern")) {
d1126 1
a1126 1
		} else if(!parse_kw(&p,UC "replacement")) {
d1133 1
a1133 1
		} else if(!parse_kw(&p,UC "backwards")) {
d1136 1
a1136 1
		} else if(!parse_kw(&p,UC "ignore")) {
d1139 1
a1139 1
		} else if(!parse_kw(&p,UC "replace")) {
d1142 1
a1142 1
		} else if(!parse_kw(&p,UC "block_restrict")) {
@


1.62
log
@repl string fix
@
text
@d42 1
a42 1
	p = pdup(b->bof, US "get_word_list");
d79 1
a79 1
	P *p = pdup(bw->cursor, US "fcmplt_ins");
d90 1
a90 1
	p = pdup(bw->cursor, US "fcmplt_ins");
d146 1
a146 1
	p = pdup(bw->cursor, US "ufinish");
d245 2
a246 2
	start = pdup(p, US "searchf");
	end = pdup(p, US "searchf");
d313 2
a314 2
	start = pdup(p, US "searchb");
	end = pdup(p, US "searchb");
d615 1
a615 1
				zcat(bf1,US "$");
d713 1
a713 1
	srch->wrap_p = pdup(bw->cursor, US "dofirst");
d760 1
a760 1
	q = pdup(bw->cursor, US "doreplace");
d1034 1
a1034 1
				pdupown(bw->cursor, &markb, US "dopfnext");
d1036 1
a1036 1
				pdupown(markb, &markk, US "dopfnext");
d1040 1
a1040 1
				pdupown(bw->cursor, &markk, US "dopfnext");
d1042 1
a1042 1
				pdupown(bw->cursor, &markb, US "dopfnext");
d1077 1
a1077 1
			srch->wrap_p = pdup(bw->cursor, US "pfnext");
d1116 1
a1116 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,US "done\n")) {
d1119 1
a1119 1
		if(!parse_kw(&p,US "pattern")) {
d1126 1
a1126 1
		} else if(!parse_kw(&p,US "replacement")) {
d1133 1
a1133 1
		} else if(!parse_kw(&p,US "backwards")) {
d1136 1
a1136 1
		} else if(!parse_kw(&p,US "ignore")) {
d1139 1
a1139 1
		} else if(!parse_kw(&p,US "replace")) {
d1142 1
a1142 1
		} else if(!parse_kw(&p,US "block_restrict")) {
@


1.61
log
@fix bugs
@
text
@d540 1
a540 1
	if (s[0] || !globalsrch || !pico)
@


1.60
log
@more key set comments
@
text
@d638 1
a638 1
	if (s[0] || !globalsrch || !pico)
@


1.59
log
@|comments| in gettext strings
@
text
@d553 4
a556 4
unsigned char *all_key = (unsigned char *) _("aA");
unsigned char *list_key = (unsigned char *) _("eE");
unsigned char *replace_key = (unsigned char *) _("rR");
unsigned char *backwards_key = (unsigned char *) _("bB");
d558 4
a561 4
unsigned char *block_key = (unsigned char *) _("kK");
unsigned char *noignore_key = (unsigned char *) _("sS");
unsigned char *wrap_key = (unsigned char *) _("wW");
unsigned char *nowrap_key = (unsigned char *) _("nN");
d813 2
a814 2
unsigned char *rest_key = (unsigned char *) _("rR");
unsigned char *backup_key = (unsigned char *) _("bB");
@


1.58
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d557 1
a557 1
unsigned char *ignore_key = (unsigned char *) _("iI");
@


1.57
log
@hash table
@
text
@d551 25
a577 1
	int x;
d579 1
d583 4
a586 4
	for (x = 0; s[x]; ++x) {
		switch (s[x]) {
		case 'a':
		case 'A':
d588 1
a588 3
			break;
		case 'e':
		case 'E':
d590 1
a590 3
			break;
		case 'r':
		case 'R':
d592 1
a592 3
			break;
		case 'b':
		case 'B':
d594 1
a594 3
			break;
		case 'i':
		case 'I':
d596 1
a596 3
			break;
		case 's':
		case 'S':
d598 1
a598 3
			break;
		case 'w':
		case 'W':
d600 1
a600 3
			break;
		case 'n':
		case 'N':
d602 1
a602 3
			break;
		case 'k':
		case 'K':
d604 1
a604 11
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
d607 1
a607 2
			srch->repeat = srch->repeat * 10 + s[x] - '0';
			break;
d609 1
a609 1
	}
d647 12
a658 6
		if (srch->ignore)
			binsc(pbw->cursor, 'i');
		if (srch->replace)
			binsc(pbw->cursor, 'r');
		if (srch->backwards)
			binsc(pbw->cursor, 'b');
d813 2
a814 2
unsigned char *rest_string = (unsigned char *) _("rR");
unsigned char *backup_string = (unsigned char *) _("bB");
d819 1
a819 1
	if (c == NO_CODE || yncheck(no_string, c))
d821 1
a821 1
	else if (c == YES_CODE || yncheck(yes_string, c) || c == ' ') {
d828 1
a828 1
	} else if (yncheck(rest_string, c)) {
d833 1
a833 1
	} else if (c == 8 || c == 127 || yncheck(backup_string, c)) {
@


1.56
log
@add m4, fix some things...
@
text
@d809 2
a810 2
unsigned char *rest_string = _("rR");
unsigned char *backup_string = _("bB");
@


1.55
log
@i18n yes/no
@
text
@d809 2
a810 2
unsigned char *rest_string = _("rR<>rR");
unsigned char *backup_string = _("bB<>bB");
d824 1
a824 1
	} else if (c == yncheck(rest_string, c)) {
@


1.54
log
@fix make, add search options help screen
@
text
@d809 3
d815 1
a815 1
	if (c == 'N' || c == 'n')
d817 1
a817 1
	else if (c == 'Y' || c == 'y' || c == ' ') {
d824 1
a824 1
	} else if (c == 'R' || c == 'r') {
d829 1
a829 1
	} else if (c == 8 || c == 127 || c == 'b' || c == 'B') {
@


1.53
log
@gettext()
@
text
@d499 1
d646 1
a646 1
	if ((pbw = wmkpw(bw->parent, p, NULL, set_options, srchstr, pfabort, utypebw, srch, notify, bw->b->o.charmap, 0)) != NULL) {
@


1.52
log
@e option for s&r
@
text
@d281 1
a281 1
		msgnw(bw->parent, US "Wrapped");
d350 1
a350 1
		msgnw(bw->parent, US "Wrapped");
d614 1
a614 1
			joe_snprintf_1((char *)bf1,30,"%s",globalsrch->replacement);
d617 1
a617 1
			joe_snprintf_1((char *)buf,sizeof(buf),"Replace with (^C to abort) [%s]: ",bf1);
d619 1
a619 1
			zcpy(buf, US "Replace with (^C to abort): ");
d634 1
a634 1
		p = US "case (S)ensitive (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): ";
d636 1
a636 1
		p = US "(I)gnore (R)eplace (B)ackwards Bloc(K) (A)ll files NNN (^C to abort): ";
d655 1
a655 1
			joe_snprintf_1((char *)buf, sizeof(buf), "%d", srch->repeat), binss(pbw->cursor, buf);
d712 1
a712 1
		joe_snprintf_1((char *)buf,sizeof(buf),"Find (^C to abort) [%s]: ",bf1);
d714 1
a714 1
		zcpy(buf, US "Find (^C to abort): ");
d837 1
a837 1
	if (mkqwnsr(bw->parent, sc("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"), dopfrepl, pfsave, srch, notify))
d928 1
a928 1
			msgnw(bw->parent, msgs[-berror]);
d985 1
a985 1
				msgnw(bw->parent, US "Not found (search restricted to marked block)");
d987 1
a987 1
				msgnw(bw->parent, US "Not found");
d992 1
a992 1
		msgnw(bw->parent, US "Infinite loop aborted: your search repeatedly matched same place");
@


1.51
log
@A option for search
Restore cursor to old position
@
text
@d563 4
d912 8
a919 2
		B *b = bafter(srch->current);
		if (b != srch->first) {
d922 1
d927 2
@


1.50
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d381 1
a381 1
SRCH *mksrch(unsigned char *pattern, unsigned char *replacement, int ignore, int backwards, int repeat, int replace, int rest)
d386 3
d559 4
d630 1
a630 1
		p = US "case (S)ensitive (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";
d632 1
a632 1
		p = US "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";
d702 1
a702 1
	srch = mksrch(NULL, NULL, 0, back, -1, repl, 0);
a773 1

d778 1
d787 2
a788 1
		if (r->yn)
d790 6
d822 1
d824 2
a825 2
		goback(srch, bw);
		return dopfnext(bw, srch, notify);
d890 5
d907 11
d953 2
d963 4
a966 1
again:	switch (fnext(bw, srch)) {
d1126 1
a1126 1
	globalsrch = mksrch(pattern,replacement,ignore,backwards,-1,replace,0);
@


1.49
log
@Fix ^L so that it works the first time
@
text
@a7 1
#include "config.h"
a9 22
#include <stdio.h>

#include "b.h"
#include "bw.h"
#include "main.h"
#include "pw.h"
#include "queue.h"
#include "qw.h"
#include "regex.h"
#include "ublock.h"
#include "uedit.h"
#include "undo.h"
#include "usearch.h"
#include "utils.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"
#include "va.h"
#include "tty.h"
#include "menu.h"
#include "hash.h"

d38 1
a38 1
	int start;
a549 1
	unsigned char bf1[80];
d704 1
a704 1
	if (pbw=wmkpw(bw->parent, buf, &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap, 0)) {
@


1.48
log
@Allow escape sequences in strings.
@
text
@d1035 1
a1035 1
	if (!globalsrch)	/* Query for search string if there isn't any */
d1037 1
a1037 1
	else {
d1114 1
a1114 1
	globalsrch = mksrch(pattern,replacement,ignore,backwards,0,replace,0);
@


1.47
log
@add joe_debug
@
text
@d1057 1
a1057 1
			emit_hdlc(f,globalsrch->pattern,sLEN(globalsrch->pattern));
d1062 1
a1062 1
			emit_hdlc(f,globalsrch->replacement,sLEN(globalsrch->replacement));
d1090 1
a1090 1
			len = parse_hdlc(&p,bf,1023);
d1097 1
a1097 1
			len = parse_hdlc(&p,bf,1023);
@


1.46
log
@fix search bugs
@
text
@d65 1
a65 1
	p = pdup(b->bof);
d102 1
a102 1
	P *p = pdup(bw->cursor);
d113 1
a113 1
	p = pdup(bw->cursor);
d169 1
a169 1
	p = pdup(bw->cursor);
d268 2
a269 2
	start = pdup(p);
	end = pdup(p);
d336 2
a337 2
	start = pdup(p);
	end = pdup(p);
d721 1
a721 1
	srch->wrap_p = pdup(bw->cursor);
d768 1
a768 1
	q = pdup(bw->cursor);
d1001 1
a1001 1
				pdupown(bw->cursor, &markb);
d1003 1
a1003 1
				pdupown(markb, &markk);
d1007 1
a1007 1
				pdupown(bw->cursor, &markk);
d1009 1
a1009 1
				pdupown(bw->cursor, &markb);
d1044 1
a1044 1
			srch->wrap_p = pdup(bw->cursor);
@


1.45
log
@File selection menu is now above prompt instead of below it.
@
text
@d262 1
a262 1
	unsigned char *pattern = srch->pattern;
d267 1
d271 2
d283 16
a298 6
			srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
			brmem(start, srch->entire, (int) (end->byte - start->byte));
			pset(p, end);
			prm(start);
			prm(end);
			return p;
d339 2
d353 16
a368 6
			srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
			brmem(start, srch->entire, (int) (end->byte - start->byte));
			pset(p, start);
			prm(start);
			prm(end);
			return p;
d419 1
d469 1
d506 4
d780 1
d795 1
d809 1
d892 1
d899 1
a899 1
      next:
d906 2
a907 1
      again:if (srch->backwards)
d914 2
a915 1
	} else if (srch->rest || (srch->repeat != -1 && srch->replace)) {
d966 4
@


1.44
log
@show properly escaped previous search string
@
text
@d204 1
a204 1
		m = mkmenu(bw->parent, lst, fcmplt_rtn, fcmplt_abrt, NULL, 0, line, NULL);
@


1.43
log
@
Allow entry of replacement blank replacement strings when search
prompting is enabled (basically eliminate automatic replace-string
prompting).

"bufed" now works like other file name commands (it prompts for a
buffer name, and allows completion).

H-scroll jumps left ~ 10 cols (this needs more work: it should be an
option).
@
text
@d651 15
d693 1
a693 3
		joe_snprintf_1((char *)bf1,30,"%s",globalsrch->pattern);
		if (zlen(globalsrch->pattern)>29)
			zcat(bf1,US "$");
@


1.42
log
@fix gcc-4.0.0 warnings
@
text
@d531 4
a534 2
		vsrm(s);
		srch->replacement = vsdup(globalsrch->replacement);
d595 1
a595 1
		if (pico && globalsrch && globalsrch->replacement) {
d600 1
a600 1
		} else
@


1.41
log
@Add search prompting for better jpico
@
text
@d595 2
a596 2
			if (strlen((char *)globalsrch->replacement)>29)
				strcat((char *)bf1,"$");
d599 1
a599 1
			strcpy((char *)buf, "Replace with (^C to abort): ");
d677 2
a678 2
		if (strlen((char *)globalsrch->pattern)>29)
			strcat((char *)bf1,"$");
d681 1
a681 1
		strcpy((char *)buf, "Find (^C to abort): ");
d1027 1
a1027 1
	while(fgets((char *)buf,1023,f) && strcmp((char *)buf,"done\n")) {
@


1.40
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d37 1
d528 6
a533 1
	srch->replacement = s;
d540 2
d593 8
a600 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, srch_cmplt, srch, notify, bw->b->o.charmap, 0))
d619 6
a624 1
	srch->pattern = s;
d653 2
d675 8
a682 1
	if (pbw=wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap, 0)) {
@


1.39
log
@fix locks bug, jmacs improvements
@
text
@d998 1
a998 1
	while(fgets(buf,1023,f) && strcmp(buf,"done\n")) {
@


1.38
log
@Fix ~ expansion insanity
@
text
@d289 1
a289 1
	if (wrap && !srch->wrap_flag && srch->wrap_p) {
d346 1
a346 1
	if (wrap && !srch->wrap_flag && srch->wrap_p) {
d396 1
d555 8
@


1.37
log
@FIx some math and first change bugs.
@
text
@d576 1
a576 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, srch_cmplt, srch, notify, bw->b->o.charmap))
d596 1
a596 1
	if ((pbw = wmkpw(bw->parent, p, NULL, set_options, srchstr, pfabort, utypebw, srch, notify, bw->b->o.charmap)) != NULL) {
d644 1
a644 1
	if (pbw=wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap)) {
@


1.36
log
@Fix bug where ^KC to search prompt was not working
@
text
@d678 1
a678 2
	if (bw->b->rdonly) {
		msgnw(bw->parent, US "Read only");
a679 1
	}
@


1.35
log
@Ctrl-G starts a search if it doesn't know word under cursor.
@
text
@d527 1
a527 1
	return dopfnext(bw, srch, notify);
d581 1
a581 1
		return dopfnext(bw, srch, notify);
d640 1
a640 1
	srch = setmark(mksrch(NULL, NULL, 0, back, -1, repl, 0));
@


1.34
log
@Clean up .joe_state file stuff some more.
@
text
@d620 1
a620 1
static int dofirst(BW *bw, int back, int repl)
d623 1
d644 6
a649 1
	if (wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap))
d651 1
a651 1
	else {
d659 1
a659 1
	return dofirst(bw, 0, 0);
d664 1
a664 1
	return dofirst(bw, 1, 0);
d669 1
a669 1
	return dofirst(bw, 0, 1);
@


1.33
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@d992 3
a994 2
			len = parse_hdlc(&p,bf,1024);
			pattern = vsncpy(NULL,0,bf,len);
d999 3
a1001 2
			len = parse_hdlc(&p,bf,1024);
			replacement = vsncpy(NULL,0,bf,len);
@


1.32
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d953 64
@


1.31
log
@Smart indent and backspace now work even if cursor
is not right at indentation point.  Also autoindent
does not happen if cursor is on a space or tab character.

Jmacs: ^W (cut) now works if mark is after point.  (Added -autoswap
mode).  Also: preserve mark and point positions during block
operations.
@
text
@d606 1
a606 1
			snprintf((char *)buf, sizeof(buf), "%d", srch->repeat), binss(pbw->cursor, buf);
@


1.30
log
@Added -wrap flag so that search wraps.
@
text
@d362 1
a362 1
	if (markv(1))
@


1.29
log
@Fix bug in text buffer completion.  Moved completion key
to ^K <return>.
@
text
@d33 1
d259 1
a259 1
static P *searchf(SRCH *srch, P *p)
d262 2
a263 2
	P *start = pdup(p);
	P *end = pdup(p);
d266 3
d272 1
d276 2
d289 7
d315 1
a315 1
static P *searchb(SRCH *srch, P *p)
d318 2
a319 2
	P *start = pdup(p);
	P *end = pdup(p);
d322 3
d328 2
d334 2
d345 8
d395 2
d413 1
d641 2
d705 1
d718 1
d815 1
a815 1
		sta = searchb(srch, bw->cursor);
d817 1
a817 1
		sta = searchf(srch, bw->cursor);
d944 6
@


1.28
log
@Tab completion insanity!  Completion in ^K F plus ESC-TAB in text windows.
@
text
@d44 201
d544 1
a544 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, utypebw, srch, notify, bw->b->o.charmap))
a587 197
unsigned char **word_list;

#define MAX_WORD_SIZE 64
unsigned char **get_word_list(B *b)
{
	unsigned char buf[MAX_WORD_SIZE];
	unsigned char *s;
	unsigned char **list = 0;
	HASH *h;
	HENTRY *t;
	P *p;
	int c;
	int idx;

	h = htmk(1024);

	p = pdup(b->bof);
	idx = 0;
	while ((c=pgetc(p))!=NO_MORE_DATA)
		if (idx) {
			if (joe_isalnum_(b->o.charmap, c)) {
				if (idx!=MAX_WORD_SIZE)
					buf[idx++] = c;
			} else {
				if (idx!=MAX_WORD_SIZE) {
					buf[idx] = 0;
					if (!htfind(h,buf)) {
						s = vsncpy(NULL,0,buf,idx);
						htadd(h, s, s);
					}
				}
				idx = 0;
			}
		} else {
			if (joe_isalpha_(b->o.charmap, c))
				buf[idx++] = c;
		}
	prm(p);

	for (idx = 0;idx != h->len;++idx)
		for (t = h->tab[idx];t;t=t->next)
			list = vaadd(list, t->name);
	if (list)
		vasort(list,sLEN(list));	

	htrm(h);

	return list;
}

void fcmplt_ins(BW *bw, unsigned char *line)
{
	P *p = pdup(bw->cursor);
	int c;

	if (!piseol(bw->cursor)) {
		int c = brch(bw->cursor);
		if (joe_isalnum_(bw->b->o.charmap,c))
			return;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor);
	do
		c = prgetc(p);
		while (joe_isalnum_(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		/* Insert single match */
		bdel(p,bw->cursor);
		binsm(bw->cursor,sv(line));
		pfwrd(bw->cursor,sLEN(line));
		bw->cursor->xcol = piscol(bw->cursor);
		prm(p);
	} else {
		prm(p);
	}
}

int fcmplt_abrt(BW *bw, int x, unsigned char *line)
{
	if (line) {
		fcmplt_ins(bw, line);
		vsrm(line);
	}
	return -1;
}

int fcmplt_rtn(MENU *m, int x, unsigned char *line)
{
	fcmplt_ins(m->parent->win->object, m->list[x]);
	vsrm(line);
	m->object = NULL;
	wabort(m->parent);
	return 0;
}

int ufinish(BW *bw)
{
	unsigned char *line;
	unsigned char *line1;
	unsigned char **lst;
	P *p;
	int c;
	MENU *m;

	/* Make sure we're not in a word */

	if (!piseol(bw->cursor)) {
		int c = brch(bw->cursor);
		if (joe_isalnum_(bw->b->o.charmap,c))
			return -1;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor);
	do
		c = prgetc(p);
		while (joe_isalnum_(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		line = brvs(p, bw->cursor->byte-p->byte);

		/* We have a word */

		/* Get word list */
		if (word_list)
			varm(word_list);

		word_list = get_word_list(bw->b);

		if (!word_list) {
			vsrm(line);
			prm(p);
			return -1;
		}

		line1 = vsncpy(NULL,0,sv(line));
		line1 = vsadd(line1,'*');
		lst = regsub(word_list, aLEN(word_list), line1);
		vsrm(line1);

		if (!lst) {
			ttputc(7);
			vsrm(line);
			return -1;
		}

		m = mkmenu(bw->parent, lst, fcmplt_rtn, fcmplt_abrt, NULL, 0, line, NULL);
		if (!m) {
			varm(lst);
			vsrm(line);
			return -1;
		}

		/* Possible match list is now in lst */

		if (aLEN(lst) == 1)
			return fcmplt_rtn(m, 0, line);
		else if (smode)
			return 0;
		else {
			unsigned char *com = mcomplete(m);
			vsrm(m->object);
			m->object = com;
			wabort(m->parent);
			smode = 2;
			ttputc(7);
			return 0;
		}
	} else {
		prm(p);
		return -1;
	}
}

static int srch_cmplt(BW *bw)
{
	if (word_list)
		varm(word_list);

	word_list = get_word_list(((BW *)bw->parent->win->object)->b);

	if (!word_list) {
		ttputc(7);
		return 0;
	}

	return simple_cmplt(bw,word_list);
}

@


1.27
log
@Added -icase: make search case insensitive by default.
@
text
@d28 4
d387 197
d605 1
a605 1
	if (wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, utypebw, srch, NULL, bw->b->o.charmap))
@


1.26
log
@Regex search now works properly with UTF-8 chars.
Incremental search now works with UTF-8.
@
text
@d31 1
d297 2
d313 4
d350 6
d359 1
a359 1
	if ((pbw = wmkpw(bw->parent, US "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ", NULL, set_options, srchstr, pfabort, utypebw, srch, notify, bw->b->o.charmap)) != NULL) {
@


1.25
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d231 1
a231 1
				binsc(p,escape(&a,&l)); /* Should this be a byte or a char? Probably a char. */
@


1.24
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d59 1
a59 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.utf8); ++x)
d61 1
a61 1
			pattern[x] = joe_toupper(p->b->o.charmap,pattern[x]);
d102 1
a102 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.utf8); ++x)
d104 1
a104 1
			pattern[x] = joe_toupper(p->b->o.charmap,pattern[x]);
d332 1
a332 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, utypebw, srch, notify, bw->b->o.utf8))
d346 1
a346 1
	if ((pbw = wmkpw(bw->parent, US "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ", NULL, set_options, srchstr, pfabort, utypebw, srch, notify, bw->b->o.utf8)) != NULL) {
d391 1
a391 1
	if (wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, utypebw, srch, NULL, bw->b->o.utf8))
@


1.23
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@a10 1
#include <ctype.h>
d26 1
d61 1
a61 1
			pattern[x] = toupper(pattern[x]);
d104 1
a104 1
			pattern[x] = toupper(pattern[x]);
@


1.22
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d59 1
a59 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\'; ++x)
d102 1
a102 1
	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\'; ++x)
d231 1
a231 1
				binsc(p,escape(&a,&l));
d332 1
a332 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, utypebw, srch, notify))
d346 1
a346 1
	if ((pbw = wmkpw(bw->parent, US "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ", NULL, set_options, srchstr, pfabort, utypebw, srch, notify)) != NULL) {
d391 1
a391 1
	if (wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, utypebw, srch, NULL))
@


1.21
log
@Search tries to keep found text fully on screen.  Also tries to keep screen
scrolled all the way to the left.
@
text
@d54 1
a54 1
	char *pattern = srch->pattern;
d97 1
a97 1
	char *pattern = srch->pattern;
d143 1
a143 1
SRCH *mksrch(char *pattern, char *replacement, int ignore, int backwards, int repeat, int replace, int rest)
d200 1
a200 1
static P *insert(SRCH *srch, P *p, char *s, int len)
d247 1
a247 1
char srchstr[] = "Search";	/* Context sensitive help identifier */
d286 1
a286 1
static int set_replace(BW *bw, char *s, SRCH *srch, int *notify)
d292 1
a292 1
static int set_options(BW *bw, char *s, SRCH *srch, int *notify)
d332 1
a332 1
		if (wmkpw(bw->parent, "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, utypebw, srch, notify))
d340 1
a340 1
static int set_pattern(BW *bw, char *s, SRCH *srch, int *notify)
d346 2
a347 2
	if ((pbw = wmkpw(bw->parent, "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ", NULL, set_options, srchstr, pfabort, utypebw, srch, notify)) != NULL) {
		char buf[10];
d356 1
a356 1
			snprintf(buf, sizeof(buf), "%d", srch->repeat), binss(pbw->cursor, buf);
d387 1
a387 1
		return urtn((BASE *)bw, MAXINT);
d391 1
a391 1
	if (wmkpw(bw->parent, "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, utypebw, srch, NULL))
d421 1
a421 1
		msgnw(bw->parent, "Read only");
d490 1
a490 1
	} else if (c != MAXINT) {	/* FIXME: what's the meaning of MAXINT here? */
d612 1
a612 1
				msgnw(bw->parent, "Not found (search restricted to marked block)");
d614 1
a614 1
				msgnw(bw->parent, "Not found");
d662 1
a662 1
			if (dopfrepl(bw, MAXINT, srch, notify))
@


1.20
log
@Fix shell window for SunOS 5.8
(where first read from pty returns 0)
@
text
@d629 16
@


1.19
log
@Allow full escape sequences in replacement strings
@
text
@d216 2
d221 2
d226 2
d229 1
a229 1
				unsigned char *a=s+x;
d233 2
a235 2
			s += 2;
			len -= 2;
@


1.18
log
@

Bad buffer boundary
@
text
@d212 1
a212 7
			if (s[1] == '\\') {
				binsc(p, '\\');
				pgetc(p);
			} else if (s[1] == 'n') {
				binsc(p, '\n');
				pgetc(p);
			} else if (((s[1] >= 'a' && s[1] <= 'z') || (s[1] >= 'A' && s[1] <= 'Z'))
d222 5
@


1.17
log
@change 0 to NULL where we're talking about pointers
@
text
@d351 1
a351 1
			snprintf(buf, JOE_MSGBUFSIZE, "%d", srch->repeat), binss(pbw->cursor, buf);
@


1.16
log
@fix segafults in isalpha()-like functions
@
text
@d32 2
a33 2
B *findhist = 0;		/* Search string history */
B *replhist = 0;		/* Replacement string history */
d35 1
a35 1
SRCH *globalsrch = 0;		/* Most recent completed search data */
d78 1
a78 1
	return 0;
d120 1
a120 1
	return 0;
d133 1
a133 1
	markb = 0;
d138 1
a138 1
	markk = 0;
d155 1
a155 1
	srch->entire = 0;
d158 2
a159 2
	srch->markb = 0;
	srch->markk = 0;
d164 1
a164 1
		srch->pieces[x] = 0;
d273 2
a274 2
		srch->markb = 0;
		srch->markk = 0;
@


1.15
log
@rename restrict() and restrict member of struct search
@
text
@d73 1
a73 1
		if (pgetc(start) == MAXINT)
d485 1
a485 1
	} else if (c != MAXINT) {
@


1.14
log
@kill some warnings when compiled with -Wall
@
text
@d161 1
a161 1
	srch->restrict = 0;
d307 1
a307 1
			srch->restrict = 1;
d504 1
a504 1
static int restrict(BW *bw, SRCH *srch)
d506 1
a506 1
	if (!srch->valid || !srch->restrict)
d564 1
a564 1
			switch (restrict(bw, srch)) {
d577 1
a577 1
			switch (restrict(bw, srch)) {
d606 1
a606 1
			if (srch->valid && srch->restrict)
d615 1
a615 1
			switch (restrict(bw, srch)) {
@


1.13
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d382 1
a382 1
		return urtn(bw, MAXINT);
@


1.12
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d212 7
a218 5
			if (s[1] == '\\')
				binsc(p, '\\'), pgetc(p);
			else if (s[1] == 'n')
				binsc(p, '\n'), pgetc(p);
			else if (((s[1] >= 'a' && s[1] <= 'z') || (s[1] >= 'A' && s[1] <= 'Z'))
@


1.11
log
@change indentation of cases in the switch() statement
@
text
@a12 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d25 1
d145 1
a145 1
	SRCH *srch = (SRCH *) malloc(sizeof(SRCH));
d192 1
a192 1
	free(srch);
@


1.10
log
@include only headers which are needed
@
text
@d291 1
a291 1
	for (x = 0; s[x]; ++x)
d293 2
a294 2
			case 'r':
			case 'R':
d297 2
a298 2
			case 'b':
			case 'B':
d301 2
a302 2
			case 'i':
			case 'I':
d305 2
a306 2
			case 'k':
			case 'K':
d309 10
a318 10
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
d324 1
d565 1
a565 1
				case -1:
d567 1
a567 1
				case 1:
d578 1
a578 1
				case -1:
d580 1
a580 1
				case 1:
d601 2
a602 2
      again:switch (fnext(bw, srch)) {
		case 0:
d604 2
a605 3

		case 1:
	      bye:if (!srch->flg && !srch->rest) {
d613 1
a613 2

		case 2:
d616 1
a616 1
				case -1:
d618 1
a618 1
				case 1:
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@d16 4
d21 1
a22 1
#include "vs.h"
a25 1
#include "main.h"
d28 2
@


1.8
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d1 9
a9 1
/* Search & Replace system */
a10 1
#include "config.h"
@


1.7
log
@use mkqw(W *, ...) instead of mkqw(BASE *, ...) (ditto. mkqwna() and mkqwnsr())
@
text
@d338 1
a338 1
			snprintf(buf, MSGBUFSIZE, "%d", srch->repeat), binss(pbw->cursor, buf);
@


1.6
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d479 1
a479 1
	if (mkqwnsr(bw, sc("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"), dopfrepl, pfsave, srch, notify))
@


1.5
log
@version 2.9.7-pre3
@
text
@d403 1
a403 1
		msgnw(bw, "Read only");
d595 1
a595 1
				msgnw(bw, "Not found (search restricted to marked block)");
d597 1
a597 1
				msgnw(bw, "Not found");
@


1.4
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d42 1
a42 3
P *searchf(srch, p)
SRCH *srch;
P *p;
d85 1
a85 3
P *searchb(srch, p)
SRCH *srch;
P *p;
d115 1
a115 2
SRCH *setmark(srch)
SRCH *srch;
d133 1
a133 2
SRCH *mksrch(pattern, replacement, ignore, backwards, repeat, replace, rest)
char *pattern, *replacement;
d160 1
a160 2
void rmsrch(srch)
SRCH *srch;
d190 1
a190 4
P *insert(srch, p, s, len)
SRCH *srch;
P *p;
char *s;
d232 1
a232 3
static int pfabort(bw, srch)
BW *bw;
SRCH *srch;
d239 1
a239 3
static int pfsave(bw, srch)
BW *bw;
SRCH *srch;
d269 1
a269 5
static int set_replace(bw, s, srch, notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
d275 1
a275 5
static int set_options(bw, s, srch, notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
d322 1
a322 5
static int set_pattern(bw, s, srch, notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
d352 1
a352 2
static int dofirst(bw, back, repl)
BW *bw;
d381 1
a381 2
int pffirst(bw)
BW *bw;
d386 1
a386 2
int prfirst(bw)
BW *bw;
d391 1
a391 2
int pqrepl(bw)
BW *bw;
d398 1
a398 3
static int doreplace(bw, srch)
BW *bw;
SRCH *srch;
d429 1
a429 3
static void visit(srch, bw, yn)
SRCH *srch;
BW *bw;
d438 1
a438 3
static void goback(srch, bw)
SRCH *srch;
BW *bw;
d451 1
a451 4
static int dopfrepl(bw, c, srch, notify)
BW *bw;
SRCH *srch;
int *notify;
d491 1
a491 3
int restrict(bw, srch)
BW *bw;
SRCH *srch;
d531 1
a531 3
static int fnext(bw, srch)
BW *bw;
SRCH *srch;
d578 1
a578 4
int dopfnext(bw, srch, notify)
BW *bw;
SRCH *srch;
int *notify;
d649 1
a649 2
int pfnext(bw)
BW *bw;
@


1.3
log
@changed as of joe-2.9.6
@
text
@d3 1
d6 3
d42 3
a44 4
P *
searchf (srch, p)
     SRCH *srch;
     P *p;
d47 2
a48 2
	P *start = pdup (p);
	P *end = pdup (p);
d50 2
a51 1
	for (x = 0; x != sLEN (pattern) && pattern[x] != '\\'; ++x)
d53 17
a69 26
			pattern[x] = toupper (pattern[x]);
	while (srch->
	       ignore ? pifind (start, pattern, x) : pfind (start, pattern,
							    x))
	  {
		  pset (end, start);
		  pfwrd (end, (long) x);
		  if (pmatch
		      (srch->pieces, pattern + x, sLEN (pattern) - x, end, 0,
		       srch->ignore))
		    {
			    srch->entire =
				    vstrunc (srch->entire,
					     (int) (end->byte - start->byte));
			    brmem (start, srch->entire,
				   (int) (end->byte - start->byte));
			    pset (p, end);
			    prm (start);
			    prm (end);
			    return p;
		    }
		  if (pgetc (start) == MAXINT)
			  break;
	  }
	prm (start);
	prm (end);
d87 3
a89 4
P *
searchb (srch, p)
     SRCH *srch;
     P *p;
d92 2
a93 2
	P *start = pdup (p);
	P *end = pdup (p);
d95 2
a96 1
	for (x = 0; x != sLEN (pattern) && pattern[x] != '\\'; ++x)
d98 16
a113 26
			pattern[x] = toupper (pattern[x]);
	while (pbkwd (start, 1L)
	       && (srch->
		   ignore ? prifind (start, pattern, x) : prfind (start,
								  pattern,
								  x)))
	  {
		  pset (end, start);
		  pfwrd (end, (long) x);
		  if (pmatch
		      (srch->pieces, pattern + x, sLEN (pattern) - x, end, 0,
		       srch->ignore))
		    {
			    srch->entire =
				    vstrunc (srch->entire,
					     (int) (end->byte - start->byte));
			    brmem (start, srch->entire,
				   (int) (end->byte - start->byte));
			    pset (p, start);
			    prm (start);
			    prm (end);
			    return p;
		    }
	  }
	prm (start);
	prm (end);
d119 2
a120 3
SRCH *
setmark (srch)
     SRCH *srch;
d122 1
a122 1
	if (markv (1))
d138 2
a139 3
SRCH *
mksrch (pattern, replacement, ignore, backwards, repeat, replace, rest)
     char *pattern, *replacement;
d141 1
a141 1
	SRCH *srch = (SRCH *) malloc (sizeof (SRCH));
d143 1
d158 1
a158 1
	izque (SRCHREC, link, &srch->recs);
d166 2
a167 3
void
rmsrch (srch)
     SRCH *srch;
d170 13
a182 14
	prm (markb);
	prm (markk);
	if (srch->markb)
	  {
		  markb = srch->markb;
		  markb->owner = &markb;
		  markb->xcol = piscol (markb);
	  }
	if (srch->markk)
	  {
		  markk = srch->markk;
		  markk->owner = &markk;
		  markk->xcol = piscol (markk);
	  }
d184 7
a190 7
		vsrm (srch->pieces[x]);
	frchn (&fsr, &srch->recs);
	vsrm (srch->pattern);
	vsrm (srch->replacement);
	vsrm (srch->entire);
	free (srch);
	updall ();
d197 4
a200 5
P *
insert (srch, p, s, len)
     SRCH *srch;
     P *p;
     char *s;
d203 29
a231 49
	while (len)
	  {
		  for (x = 0; x != len && s[x] != '\\'; ++x);
		  if (x)
		    {
			    binsm (p, s, x);
			    pfwrd (p, (long) x);
			    len -= x;
			    s += x;
		    }
		  else if (len >= 2)
		    {
			    if (s[1] == '\\')
				    binsc (p, '\\'), pgetc (p);
			    else if (s[1] == 'n')
				    binsc (p, '\n'), pgetc (p);
			    else if (((s[1] >= 'a' && s[1] <= 'z') ||
				      (s[1] >= 'A' && s[1] <= 'Z'))
				     && srch->pieces[(s[1] & 0x1f) - 1])
			      {
				      binsm (p,
					     sv (srch->
						 pieces[(s[1] & 0x1f) - 1]));
				      pfwrd (p,
					     (long) sLEN (srch->
							  pieces[(s[1] & 0x1f)
								 - 1]));
			      }
			    else if (s[1] >= '0' && s[1] <= '9'
				     && srch->pieces[s[1] - '0'])
			      {
				      binsm (p,
					     sv (srch->pieces[s[1] - '0']));
				      pfwrd (p,
					     (long) sLEN (srch->
							  pieces[s[1] -
								 '0']));
			      }
			    else if (s[1] == '&' && srch->entire)
			      {
				      binsm (p, sv (srch->entire));
				      pfwrd (p, (long) sLEN (srch->entire));
			      }
			    s += 2;
			    len -= 2;
		    }
		  else
			  len = 0;
	  }
d242 3
a244 4
static int
pfabort (bw, srch)
     BW *bw;
     SRCH *srch;
d247 1
a247 1
		rmsrch (srch);
d251 26
a276 30
static int
pfsave (bw, srch)
     BW *bw;
     SRCH *srch;
{
	if (srch)
	  {
		  if (globalsrch)
			  rmsrch (globalsrch);
		  globalsrch = srch;
		  srch->rest = 0;
		  srch->repeat = -1;
		  srch->flg = 0;

		  prm (markb);
		  prm (markk);
		  if (srch->markb)
		    {
			    markb = srch->markb;
			    markb->owner = &markb;
			    markb->xcol = piscol (markb);
		    }
		  if (srch->markk)
		    {
			    markk = srch->markk;
			    markk->owner = &markk;
			    markk->xcol = piscol (markk);
		    }
		  srch->markb = 0;
		  srch->markk = 0;
d278 2
a279 2
		  updall ();
	  }
d283 5
a287 6
static int
set_replace (bw, s, srch, notify)
     BW *bw;
     char *s;
     SRCH *srch;
     int *notify;
d290 1
a290 1
	return dopfnext (bw, srch, notify);
d293 5
a297 6
static int
set_options (bw, s, srch, notify)
     BW *bw;
     char *s;
     SRCH *srch;
     int *notify;
d300 1
d302 40
a341 46
		switch (s[x])
		  {
		  case 'r':
		  case 'R':
			  srch->replace = 1;
			  break;
		  case 'b':
		  case 'B':
			  srch->backwards = 1;
			  break;
		  case 'i':
		  case 'I':
			  srch->ignore = 1;
			  break;
		  case 'k':
		  case 'K':
			  srch->restrict = 1;
			  break;
		  case '0':
		  case '1':
		  case '2':
		  case '3':
		  case '4':
		  case '5':
		  case '6':
		  case '7':
		  case '8':
		  case '9':
			  if (srch->repeat == -1)
				  srch->repeat = 0;
			  srch->repeat = srch->repeat * 10 + s[x] - '0';
			  break;
		  }
	vsrm (s);
	if (srch->replace)
	  {
		  if (wmkpw (bw->parent,
			     "Replace with (^C to abort): ", &replhist,
			     set_replace, srchstr, pfabort, utypebw, srch,
			     notify))
			  return 0;
		  else
			  return -1;
	  }
	else
		return dopfnext (bw, srch, notify);
d344 5
a348 6
static int
set_pattern (bw, s, srch, notify)
     BW *bw;
     char *s;
     SRCH *srch;
     int *notify;
d351 2
a352 1
	vsrm (srch->pattern);
d354 22
a375 29
	if (pbw = wmkpw (bw->parent,
			 "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ",
			 NULL, set_options, srchstr, pfabort, utypebw, srch,
			 notify))
	  {
#define BUFLEN 10	  
		char buf[BUFLEN];
		  if (srch->ignore)
			  binsc (pbw->cursor, 'i');
		  if (srch->replace)
			  binsc (pbw->cursor, 'r');
		  if (srch->backwards)
			  binsc (pbw->cursor, 'b');
		  if (srch->repeat >= 0)
			  snprintf (buf,BUFLEN, "%d", srch->repeat),
				  binss (pbw->cursor, buf);
		  pset (pbw->cursor, pbw->b->eof);
		  pbw->cursor->xcol = piscol (pbw->cursor);
		  srch->ignore = 0;
		  srch->replace = 0;
		  srch->backwards = 0;
		  srch->repeat = -1;
		  return 0;
	  }
	else
	  {
		  rmsrch (srch);
		  return -1;
	  }
d378 2
a379 3
static int
dofirst (bw, back, repl)
     BW *bw;
d382 17
a398 17
	if (smode && globalsrch)
	  {
		  globalsrch->backwards = back;
		  globalsrch->replace = repl;
		  return pfnext (bw);
	  }
	if (bw->parent->huh == srchstr)
	  {
		  long byte;
		  p_goto_eol (bw->cursor);
		  byte = bw->cursor->byte;
		  p_goto_bol (bw->cursor);
		  if (byte == bw->cursor->byte)
			  prgetc (bw->cursor);
		  return urtn (bw, MAXINT);
	  }
	srch = setmark (mksrch (NULL, NULL, 0, back, -1, repl, 0));
d400 1
a400 3
	if (wmkpw
	    (bw->parent, "Find (^C to abort): ", &findhist, set_pattern, srchstr,
	     pfabort, utypebw, srch, NULL))
d402 4
a405 5
	else
	  {
		  rmsrch (srch);
		  return -1;
	  }
d408 2
a409 3
int
pffirst (bw)
     BW *bw;
d411 1
a411 1
	return dofirst (bw, 0, 0);
d414 2
a415 3
int
prfirst (bw)
     BW *bw;
d417 1
a417 1
	return dofirst (bw, 1, 0);
d420 2
a421 3
int
pqrepl (bw)
     BW *bw;
d423 1
a423 1
	return dofirst (bw, 0, 1);
d428 3
a430 4
static int
doreplace (bw, srch)
     BW *bw;
     SRCH *srch;
d433 5
a437 5
	if (bw->b->rdonly)
	  {
		  msgnw (bw, "Read only");
		  return -1;
	  }
d442 11
a452 14
	q = pdup (bw->cursor);
	if (srch->backwards)
	  {
		  q = pfwrd (q, (long) sLEN (srch->entire));
		  bdel (bw->cursor, q);
		  prm (q);
	  }
	else
	  {
		  q = pbkwd (q, (long) sLEN (srch->entire));
		  bdel (q, bw->cursor);
		  prm (q);
	  }
	insert (srch, bw->cursor, sv (srch->replacement));
d461 3
a463 4
static void
visit (srch, bw, yn)
     SRCH *srch;
     BW *bw;
d465 2
a466 1
	SRCHREC *r = (SRCHREC *) alitem (&fsr, sizeof (SRCHREC));
d469 1
a469 1
	enqueb (SRCHREC, link, &srch->recs, r);
d472 3
a474 4
static void
goback (srch, bw)
     SRCH *srch;
     BW *bw;
d477 8
a484 8
	if (r != &srch->recs)
	  {
		  if (r->yn)
			  uundo (bw);
		  if (bw->cursor->byte != r->addr)
			  pgoto (bw->cursor, r->addr);
		  demote (SRCHREC, link, &fsr, r);
	  }
d487 4
a490 5
static int
dopfrepl (bw, c, srch, notify)
     BW *bw;
     SRCH *srch;
     int *notify;
d494 25
a518 36
		return dopfnext (bw, srch, notify);
	else if (c == 'Y' || c == 'y' || c == ' ')
	  {
		  srch->recs.link.prev->yn = 1;
		  if (doreplace (bw, srch))
		    {
			    pfsave (bw, srch);
			    return -1;
		    }
		  else
			  return dopfnext (bw, srch, notify);
	  }
	else if (c == 'R' || c == 'r')
	  {
		  if (doreplace (bw, srch))
			  return -1;
		  srch->rest = 1;
		  return dopfnext (bw, srch, notify);
	  }
	else if (c == 8 || c == 127 || c == 'b' || c == 'B')
	  {
		  goback (srch, bw);
		  goback (srch, bw);
		  return dopfnext (bw, srch, notify);
	  }
	else if (c != MAXINT)
	  {
		  if (notify)
			  *notify = 1;
		  pfsave (bw, srch);
		  nungetc (c);
		  return 0;
	  }
	if (mkqwnsr
	    (bw->parent, sc ("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"),
	     dopfrepl, pfsave, srch, notify))
d521 1
a521 1
		return pfsave (bw, srch);
d530 3
a532 4
int
restrict (bw, srch)
     BW *bw;
     SRCH *srch;
d536 1
a536 1
	bw->cursor->xcol = piscol (bw->cursor);
d538 25
a562 35
		if (!square)
		  {
			  if (bw->cursor->byte < srch->markb->byte)
				  return 1;
			  else if (bw->cursor->byte + sLEN (srch->entire) >
				   srch->markk->byte) return -1;
		  }
		else
		  {
			  if (bw->cursor->line < srch->markb->line)
				  return 1;
			  else if (bw->cursor->line > srch->markk->line)
				  return -1;
			  else if (piscol (bw->cursor) + sLEN (srch->entire) >
				   srch->markk->xcol
				   || piscol (bw->cursor) <
				   srch->markb->xcol) return -1;
		  }
	else if (!square)
	  {
		  if (bw->cursor->byte > srch->markk->byte)
			  return 1;
		  else if (bw->cursor->byte - sLEN (srch->entire) <
			   srch->markb->byte) return -1;
	  }
	else
	  {
		  if (bw->cursor->line > srch->markk->line)
			  return 1;
		  if (bw->cursor->line < srch->markb->line)
			  return -1;
		  if (piscol (bw->cursor) > srch->markk->xcol ||
		      piscol (bw->cursor) - sLEN (srch->entire) <
		      srch->markb->xcol) return -1;
	  }
d572 3
a574 4
static int
fnext (bw, srch)
     BW *bw;
     SRCH *srch;
d577 1
d579 1
a579 1
	if (srch->repeat != -1)
d584 1
d586 1
a586 39
		sta = searchb (srch, bw->cursor);
	else
		sta = searchf (srch, bw->cursor);
	if (!sta)
	  {
		  srch->repeat = -1;
		  return 1;
	  }
	else if (srch->rest || (srch->repeat != -1 && srch->replace))
	  {
		  if (srch->valid)
			  switch (restrict (bw, srch))
			    {
			    case -1:
				    goto again;
			    case 1:
				    if (srch->addr >= 0)
					    pgoto (bw->cursor, srch->addr);
				    return !srch->rest;
			    }
		  if (doreplace (bw, srch))
			  return 0;
		  goto next;
	  }
	else if (srch->repeat != -1)
	  {
		  if (srch->valid)
			  switch (restrict (bw, srch))
			    {
			    case -1:
				    goto again;
			    case 1:
				    if (srch->addr >= 0)
					    pgoto (bw->cursor, srch->addr);
				    return 1;
			    }
		  srch->addr = bw->cursor->byte;
		  goto next;
	  }
d588 30
d621 4
a624 5
int
dopfnext (bw, srch, notify)
     BW *bw;
     SRCH *srch;
     int *notify;
d628 1
d633 52
a684 62
		visit (srch, bw, 0);
      again:switch (fnext (bw, srch))
	  {
	  case 0:
		  break;

	  case 1:
		bye:if (!srch->flg && !srch->rest)
		    {
			    if (srch->valid && srch->restrict)
				    msgnw (bw,
					   "Not found (search restricted to marked block)");
			    else
				    msgnw (bw, "Not found");
			    ret = -1;
		    }
		  break;

	  case 2:
		  if (srch->valid)
			  switch (restrict (bw, srch))
			    {
			    case -1:
				    goto again;
			    case 1:
				    if (srch->addr >= 0)
					    pgoto (bw->cursor, srch->addr);
				    goto bye;
			    }
		  srch->addr = bw->cursor->byte;
		  if (srch->replace)
		    {
			    if (square)
				    bw->cursor->xcol = piscol (bw->cursor);
			    if (srch->backwards)
			      {
				      pdupown (bw->cursor, &markb);
				      markb->xcol = piscol (markb);
				      pdupown (markb, &markk);
				      pfwrd (markk,
					     (long) sLEN (srch->entire));
				      markk->xcol = piscol (markk);
			      }
			    else
			      {
				      pdupown (bw->cursor, &markk);
				      markk->xcol = piscol (markk);
				      pdupown (bw->cursor, &markb);
				      pbkwd (markb,
					     (long) sLEN (srch->entire));
				      markb->xcol = piscol (markb);
			      }
			    srch->flg = 1;
			    if (dopfrepl (bw, MAXINT, srch, notify))
				    ret = -1;
			    notify = 0;
			    srch = 0;
		    }
		  break;
	  }
	bw->cursor->xcol = piscol (bw->cursor);
	dofollows ();
d689 1
a689 1
		pfsave (bw, srch);
d691 1
a691 1
		updall ();
d695 2
a696 3
int
pfnext (bw)
     BW *bw;
d699 8
a706 8
		return pffirst (bw);
	else
	  {
		  SRCH *srch = globalsrch;
		  globalsrch = 0;
		  srch->addr = bw->cursor->byte;
		  return dopfnext (bw, setmark (srch), NULL);
	  }
@


1.2
log
@changes for joe-2.9.1
@
text
@d4 1
d15 2
a16 2
int smode=0;		/* Decremented to zero by execmd */
int csmode=0;		/* Set for continued search mode */
d18 2
a19 2
B *findhist=0;		/* Search string history */
B *replhist=0;		/* Replacement string history */
d21 1
a21 1
SRCH *globalsrch=0;	/* Most recent completed search data */
d23 1
a23 1
SRCHREC fsr={{&fsr,&fsr}};
d38 39
a76 27
P *searchf(srch,p)
SRCH *srch;
P *p;
 {
 char *pattern=srch->pattern;
 P *start=pdup(p);
 P *end=pdup(p);
 int x;
 for(x=0;x!=sLEN(pattern) && pattern[x]!='\\';++x)
  if(srch->ignore) pattern[x]=toupper(pattern[x]);
 while(srch->ignore?pifind(start,pattern,x):pfind(start,pattern,x))
  {
  pset(end,start);
  pfwrd(end,(long)x);
  if(pmatch(srch->pieces,pattern+x,sLEN(pattern)-x,end,0,srch->ignore))
   {
   srch->entire=vstrunc(srch->entire,(int)(end->byte-start->byte));
   brmem(start,srch->entire,(int)(end->byte-start->byte));
   pset(p,end);
   prm(start); prm(end);
   return p;
   }
  if(pgetc(start)== MAXINT) break;
  }
 prm(start); prm(end);
 return 0;
 }
d92 39
a130 26
P *searchb(srch,p)
SRCH *srch;
P *p;
 {
 char *pattern=srch->pattern;
 P *start=pdup(p);
 P *end=pdup(p);
 int x;
 for(x=0;x!=sLEN(pattern) && pattern[x]!='\\';++x)
  if(srch->ignore) pattern[x]=toupper(pattern[x]);
 while(pbkwd(start,1L) && (srch->ignore?prifind(start,pattern,x):prfind(start,pattern,x)))
  {
  pset(end,start);
  pfwrd(end,(long)x);
  if(pmatch(srch->pieces,pattern+x,sLEN(pattern)-x,end,0,srch->ignore))
   {
   srch->entire=vstrunc(srch->entire,(int)(end->byte-start->byte));
   brmem(start,srch->entire,(int)(end->byte-start->byte));
   pset(p,start);
   prm(start); prm(end);
   return p;
   }
  }
 prm(start); prm(end);
 return 0;
 }
d134 45
a178 39
SRCH *setmark(srch)
SRCH *srch;
 {
 if(markv(1)) srch->valid=1;

 srch->markb=markb;
 if(srch->markb) srch->markb->owner= &srch->markb;
 markb=0;

 srch->markk=markk;
 if(srch->markk) srch->markk->owner= &srch->markk;
 markk=0;

 return srch;
 }

SRCH *mksrch(pattern,replacement,ignore,backwards,repeat,replace,rest)
char *pattern, *replacement;
 {
 SRCH *srch=(SRCH *)malloc(sizeof(SRCH));
 int x;
 srch->pattern=pattern;
 srch->replacement=replacement;
 srch->ignore=ignore;
 srch->backwards=backwards;
 srch->repeat=repeat;
 srch->replace=replace;
 srch->rest=rest;
 srch->entire=0;
 srch->flg=0;
 srch->addr= -1;
 srch->markb=0;
 srch->markk=0;
 srch->valid=0;
 srch->restrict=0;
 izque(SRCHREC,link,&srch->recs);
 for(x=0;x!=26;++x) srch->pieces[x]=0;
 return srch;
 }
d182 28
a209 25
void rmsrch(srch)
SRCH *srch;
 {
 int x;
 prm(markb); prm(markk);
 if(srch->markb)
  {
  markb=srch->markb;
  markb->owner= &markb;
  markb->xcol=piscol(markb);
  }
 if(srch->markk)
  {
  markk=srch->markk;
  markk->owner= &markk;
  markk->xcol=piscol(markk);
  }
 for(x=0;x!=26;++x) vsrm(srch->pieces[x]);
 frchn(&fsr,&srch->recs);
 vsrm(srch->pattern);
 vsrm(srch->replacement);
 vsrm(srch->entire);
 free(srch);
 updall();
 }
d215 58
a272 42
P *insert(srch,p,s,len)
SRCH *srch;
P *p;
char *s;
 {
 int x;
 while(len)
  {
  for(x=0;x!=len && s[x]!='\\';++x);
  if(x)
   {
   binsm(p,s,x);
   pfwrd(p,(long)x);
   len-=x;
   s+=x;
   }
  else if(len>=2)
   {
   if(s[1]=='\\') binsc(p,'\\'), pgetc(p);
   else if(s[1]=='n') binsc(p,'\n'), pgetc(p);
   else if((s[1]>='a' && s[1]<='z' ||
           s[1]>='A' && s[1]<='Z') && srch->pieces[(s[1]&0x1f)-1])
    {
    binsm(p,sv(srch->pieces[(s[1]&0x1f)-1]));
    pfwrd(p,(long)sLEN(srch->pieces[(s[1]&0x1f)-1]));
    }
   else if(s[1]>='0' && s[1]<='9' && srch->pieces[s[1]-'0'])
    {
    binsm(p,sv(srch->pieces[s[1]-'0']));
    pfwrd(p,(long)sLEN(srch->pieces[s[1]-'0']));
    }
   else if(s[1]=='&' && srch->entire)
    {
    binsm(p,sv(srch->entire));
    pfwrd(p,(long)sLEN(srch->entire));
    }
   s+=2; len-=2;
   }
  else len=0;
  }
 return p;
 }
d279 1
a279 1
char srchstr[]="Search";	/* Context sensitive help identifier */
d281 209
a489 160
static int pfabort(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(srch) rmsrch(srch);
 return -1;
 }

static int pfsave(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(srch)
  {
  if(globalsrch) rmsrch(globalsrch);
  globalsrch=srch;
  srch->rest=0;
  srch->repeat= -1;
  srch->flg=0;

  prm(markb); prm(markk);
  if(srch->markb)
   {
   markb=srch->markb;
   markb->owner= &markb;
   markb->xcol=piscol(markb);
   }
  if(srch->markk)
   {
   markk=srch->markk;
   markk->owner= &markk;
   markk->xcol=piscol(markk);
   }
  srch->markb=0; srch->markk=0;

  updall();
  }
 return -1;
 }

static int set_replace(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 srch->replacement=s;
 return dopfnext(bw,srch,notify);
 }

static int set_options(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 int x;
 for(x=0;s[x];++x)
  switch(s[x])
   {
  case 'r': case 'R': srch->replace=1; break;
  case 'b': case 'B': srch->backwards=1; break;
  case 'i': case 'I': srch->ignore=1; break;
  case 'k': case 'K': srch->restrict=1; break;
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
   if(srch->repeat== -1) srch->repeat=0;
   srch->repeat=srch->repeat*10+s[x]-'0';
   break;
   }
 vsrm(s);
 if(srch->replace)
  {
  if(wmkpw(bw,
           "Replace with (^C to abort): ",&replhist,set_replace,srchstr,pfabort,utypebw,srch,notify))
   return 0;
  else return -1;
  }
 else return dopfnext(bw,srch,notify);
 }

static int set_pattern(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 BW *pbw;
 vsrm(srch->pattern); srch->pattern=s;
 if(pbw=wmkpw(bw,
          "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ",
          NULL,set_options,srchstr,pfabort,utypebw,srch,notify))
  {
  char buf[10];
  if(srch->ignore) binsc(pbw->cursor,'i');
  if(srch->replace) binsc(pbw->cursor,'r');
  if(srch->backwards) binsc(pbw->cursor,'b');
  if(srch->repeat>=0) sprintf(buf,"%d",srch->repeat), binss(pbw->cursor,buf);
  pset(pbw->cursor,pbw->b->eof);
  pbw->cursor->xcol=piscol(pbw->cursor);
  srch->ignore=0;
  srch->replace=0;
  srch->backwards=0;
  srch->repeat= -1;
  return 0;
  }
 else
  {
  rmsrch(srch);
  return -1;
  }
 }

static int dofirst(bw,back,repl)
BW *bw;
 {
 SRCH *srch;
 if(smode && globalsrch)
  {
  globalsrch->backwards=back;
  globalsrch->replace=repl;
  return pfnext(bw);
  }
 if(bw->parent->huh==srchstr)
  {
  long byte;
  peol(bw->cursor);
  byte=bw->cursor->byte;
  pbol(bw->cursor);
  if(byte==bw->cursor->byte) prgetc(bw->cursor);
  return urtn(bw,MAXINT);
  }
 srch=setmark(mksrch(NULL,NULL,0,back,-1,repl,0));
 srch->addr=bw->cursor->byte;
 if(wmkpw(bw,"Find (^C to abort): ",&findhist,set_pattern,srchstr,pfabort,utypebw,srch,NULL))
  return 0;
 else
  {
  rmsrch(srch);
  return -1;
  }
 }

int pffirst(bw)
BW *bw;
 {
 return dofirst(bw,0,0);
 }

int prfirst(bw)
BW *bw;
 {
 return dofirst(bw,1,0);
 }

int pqrepl(bw)
BW *bw;
 {
 return dofirst(bw,0,1);
 }
d493 112
a604 84
static int doreplace(bw,srch)
BW *bw;
SRCH *srch;
 {
 P *q;
 if(bw->b->rdonly) { msgnw(bw,"Read only"); return -1; }
 if(markk) markk->end=1;
 if(srch->markk) srch->markk->end=1;
 q=pdup(bw->cursor);
 if(srch->backwards)
  {
  q=pfwrd(q,(long)sLEN(srch->entire));
  bdel(bw->cursor,q);
  prm(q);
  }
 else
  {
  q=pbkwd(q,(long)sLEN(srch->entire));
  bdel(q,bw->cursor);
  prm(q);
  }
 insert(srch,bw->cursor,sv(srch->replacement));
 srch->addr=bw->cursor->byte;
 if(markk) markk->end=0;
 if(srch->markk) srch->markk->end=0;
 return 0;
 }

static void visit(srch,bw,yn)
SRCH *srch;
BW *bw;
 {
 SRCHREC *r=(SRCHREC *)alitem(&fsr,sizeof(SRCHREC));
 r->addr=bw->cursor->byte;
 r->yn=yn;
 enqueb(SRCHREC,link,&srch->recs,r);
 }

static void goback(srch,bw)
SRCH *srch;
BW *bw;
 {
 SRCHREC *r=srch->recs.link.prev;
 if(r!=&srch->recs)
  {
  if(r->yn) uundo(bw);
  if(bw->cursor->byte!=r->addr) pgoto(bw->cursor,r->addr);
  demote(SRCHREC,link,&fsr,r);
  }
 }

static int dopfrepl(bw,c,srch,notify)
BW *bw;
SRCH *srch;
int *notify;
 {
 srch->addr=bw->cursor->byte;
 if(c=='N' || c=='n')
  return dopfnext(bw,srch,notify);
 else if(c=='Y' || c=='y' || c==' ')
  {
  srch->recs.link.prev->yn=1;
  if(doreplace(bw,srch))
   {
   pfsave(bw,srch);
   return -1;
   }
  else return dopfnext(bw,srch,notify);
  }
 else if(c=='R' || c=='r')
  { if(doreplace(bw,srch)) return -1; srch->rest=1; return dopfnext(bw,srch,notify); }
 else if(c==8 || c==127 || c=='b' || c=='B')
  { goback(srch,bw); goback(srch,bw); return dopfnext(bw,srch,notify); }
 else if(c!=MAXINT)
  {
  if(notify) *notify=1;
  pfsave(bw,srch);
  nungetc(c);
  return 0;
  }
 if(mkqwnsr(bw,sc("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"),dopfrepl,pfsave,srch,notify))
  return 0;
 else return pfsave(bw,srch);
 }
d612 46
a657 34
int restrict(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(!srch->valid || !srch->restrict) return 0;
 bw->cursor->xcol=piscol(bw->cursor);
 if(srch->backwards)
  if(!square)
   {
   if(bw->cursor->byte<srch->markb->byte) return 1;
   else if(bw->cursor->byte+sLEN(srch->entire)>srch->markk->byte) return -1;
   }
  else
   {
   if(bw->cursor->line<srch->markb->line) return 1;
   else if(bw->cursor->line>srch->markk->line) return -1;
   else if(piscol(bw->cursor)+sLEN(srch->entire)>srch->markk->xcol ||
           piscol(bw->cursor)<srch->markb->xcol) return -1;
   }
 else
  if(!square)
   {
   if(bw->cursor->byte>srch->markk->byte) return 1;
   else if(bw->cursor->byte-sLEN(srch->entire)<srch->markb->byte) return -1;
   }
  else
   {
   if(bw->cursor->line>srch->markk->line) return 1;
   if(bw->cursor->line<srch->markb->line) return -1;
   if(piscol(bw->cursor)>srch->markk->xcol ||
      piscol(bw->cursor)-sLEN(srch->entire)<srch->markb->xcol) return -1;
   }
 return 0;
 }
d665 154
a818 121
static int fnext(bw,srch)
BW *bw;
SRCH *srch;
 {
 P *sta;
 next:
 if(srch->repeat!= -1)
  if(!srch->repeat) return 0;
  else --srch->repeat;
 again: if(srch->backwards) sta=searchb(srch,bw->cursor);
 else sta=searchf(srch,bw->cursor);
 if(!sta)
  {
  srch->repeat= -1;
  return 1;
  }
 else
  if(srch->rest || srch->repeat!= -1 && srch->replace)
   {
   if(srch->valid)
    switch(restrict(bw,srch))
     {
     case -1: goto again;
     case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); return !srch->rest;
     }
   if(doreplace(bw,srch)) return 0;
   goto next;
   }
  else if(srch->repeat!= -1)
   {
   if(srch->valid)
    switch(restrict(bw,srch))
     {
     case -1: goto again;
     case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); return 1;
     }
   srch->addr=bw->cursor->byte;
   goto next;
   }
  else return 2;
 }

int dopfnext(bw,srch,notify)
BW *bw;
SRCH *srch;
int *notify;
 {
 int orgmid=mid;	/* Original mid status */
 int ret=0;
 mid=1;			/* Screen recenters mode during search */
 if(csmode) smode=2;	/* We have started a search mode */
 if(srch->replace) visit(srch,bw,0);
 again: switch(fnext(bw,srch))
  {
  case 0:
  break;
  
  case 1:
  bye: if(!srch->flg && !srch->rest)
   {
   if(srch->valid && srch->restrict)
    msgnw(bw,"Not found (search restricted to marked block)");
   else msgnw(bw,"Not found");
   ret= -1;
   }
  break;

  case 2:
  if(srch->valid)
   switch(restrict(bw,srch))
    {
    case -1: goto again;
    case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); goto bye;
    }
  srch->addr=bw->cursor->byte;
  if(srch->replace)
   {
   if(square) bw->cursor->xcol=piscol(bw->cursor);
   if(srch->backwards)
    {
    pdupown(bw->cursor,&markb); markb->xcol=piscol(markb);
    pdupown(markb,&markk);
    pfwrd(markk,(long)sLEN(srch->entire));
    markk->xcol=piscol(markk);
    }
   else
    {
    pdupown(bw->cursor,&markk); markk->xcol=piscol(markk);
    pdupown(bw->cursor,&markb);
    pbkwd(markb,(long)sLEN(srch->entire));
    markb->xcol=piscol(markb);
    }
   srch->flg=1;
   if(dopfrepl(bw,MAXINT,srch,notify)) ret= -1;
   notify=0;
   srch=0;
   }
  break;
  }
 bw->cursor->xcol=piscol(bw->cursor);
 dofollows();
 mid=orgmid;
 if(notify) *notify=1;
 if(srch) pfsave(bw,srch);
 else updall();
 return ret;
 }

int pfnext(bw)
BW *bw;
 {
 if(!globalsrch)	/* Query for search string if there isn't any */
  return pffirst(bw);
 else
  {
  SRCH *srch=globalsrch;
  globalsrch=0;
  srch->addr=bw->cursor->byte;
  return dopfnext(bw,setmark(srch),NULL);
  }
 }
@


1.1
log
@Initial revision
@
text
@d3 1
d46 1
a46 1
  if(srch->ignore) pattern[x]=toup(pattern[x]);
d88 1
a88 1
  if(srch->ignore) pattern[x]=toup(pattern[x]);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
