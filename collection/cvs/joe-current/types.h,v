head	1.64;
access;
symbols
	joe_3_5:1.58
	joe-3_4:1.50
	help:1.50
	joe_3_1:1.26
	joe_3_0:1.17
	joe_2_9_8:1.5
	joe_2_9_8_pre1:1.2;
locks; strict;
comment	@ * @;


1.64
date	2008.10.30.22.30.03;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.26.23.20.47;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.07.19.00.05.55;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.02.16.54.06;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.15.18.18.28;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.03.23.37.01;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.01.03.08.20;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.26.22.56.58;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.23.21.44.04;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.14.17.50.51;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.12.19.39.30;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.05.14.46.18;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.03.21.01.31;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.06.06.36.38;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.22.18.44.33;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.10.18.24.28;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.28.05.05.36;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.21.02.15.56;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.19.03.02.50;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.16.21.37.36;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.16.00.00.57;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.14.03.21.37;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.14.00.07.50;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.27.05.29.33;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.21.03.19.16;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.07.19.59.51;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.14.04.23.09;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.12.02.06.37;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.10.20.31.19;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.05.22.05.56;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.03.22.55.52;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.30.21.49.55;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.23.02.14.08;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.22.03.40.21;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.22.01.07.12;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.20.14.45.53;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.16.21.10.16;	author jhallen;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.09.22.01.06;	author jhallen;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.08.15.20.39;	author jhallen;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.00.19.20;	author jhallen;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.30.05.10.15;	author jhallen;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.02.10.45.26;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.13.15.29.05;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.15.09.26.04;	author vsamel;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Syntax highlighter stack
@
text
@/* JOE global header file */

#include "config.h"

/* Common header files */

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#include <stdarg.h>

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#else
typedef int pid_t;
#endif

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif

#ifdef HAVE_TIME_H
#include <time.h>
#endif

#ifdef HAVE_UCONTEXT_H

#ifndef __sparc /* Makecontext is broken in many version of solaris */
#define USE_UCONTEXT 1
#endif

#endif

#ifdef USE_UCONTEXT
#include <ucontext.h>
#else
#include <setjmp.h>
#endif

#define joe_gettext(s) my_gettext((unsigned char *)(s))

/* Strings needing translation are marked with this macro */
#define _(s) (s)

/* Global Defines */

/* Prefix to make string constants unsigned */
#define USTR (unsigned char *)

/* Doubly-linked list node */
#define LINK(type) struct { type *next; type *prev; }

#ifdef HAVE_SNPRINTF

#define joe_snprintf_0(buf,len,fmt) snprintf((char *)(buf),(len),(char *)(fmt))
#define joe_snprintf_1(buf,len,fmt,a) snprintf((char *)(buf),(len),(char *)(fmt),(a))
#define joe_snprintf_2(buf,len,fmt,a,b) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b))
#define joe_snprintf_3(buf,len,fmt,a,b,c) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c))
#define joe_snprintf_4(buf,len,fmt,a,b,c,d) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d))
#define joe_snprintf_5(buf,len,fmt,a,b,c,d,e) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e))
#define joe_snprintf_6(buf,len,fmt,a,b,c,d,e,f) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e),(f))
#define joe_snprintf_7(buf,len,fmt,a,b,c,d,e,f,g) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g))
#define joe_snprintf_8(buf,len,fmt,a,b,c,d,e,f,g,h) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h))
#define joe_snprintf_9(buf,len,fmt,a,b,c,d,e,f,g,h,i) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define joe_snprintf_10(buf,len,fmt,a,b,c,d,e,f,g,h,i,j) snprintf((char *)(buf),(len),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i),(j))

#define i_printf_0(fmt) (snprintf((char *)(i_msg),sizeof(i_msg),(char *)(fmt)), internal_msg(i_msg))
#define i_printf_1(fmt,a) (snprintf((char *)(i_msg),sizeof(i_msg),(char *)(fmt),(a)), internal_msg(i_msg))
#define i_printf_2(fmt,a,b) (snprintf((char *)(i_msg),sizeof(i_msg),(char *)(fmt),(a),(b)), internal_msg(i_msg))
#define i_printf_3(fmt,a,b,c) (snprintf((char *)(i_msg),sizeof(i_msg),(char *)(fmt),(a),(b),(c)), internal_msg(i_msg))
#define i_printf_4(fmt,a,b,c,d) (snprintf((char *)(i_msg),sizeof(i_msg),(char *)(fmt),(a),(b),(c),(d)), internal_msg(i_msg))

#else

#define joe_snprintf_0(buf,len,fmt) sprintf((char *)(buf),(char *)(fmt))
#define joe_snprintf_1(buf,len,fmt,a) sprintf((char *)(buf),(char *)(fmt),(a))
#define joe_snprintf_2(buf,len,fmt,a,b) sprintf((char *)(buf),(char *)(fmt),(a),(b))
#define joe_snprintf_3(buf,len,fmt,a,b,c) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c))
#define joe_snprintf_4(buf,len,fmt,a,b,c,d) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d))
#define joe_snprintf_5(buf,len,fmt,a,b,c,d,e) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e))
#define joe_snprintf_6(buf,len,fmt,a,b,c,d,e,f) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e),(f))
#define joe_snprintf_7(buf,len,fmt,a,b,c,d,e,f,g) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g))
#define joe_snprintf_8(buf,len,fmt,a,b,c,d,e,f,g,h) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h))
#define joe_snprintf_9(buf,len,fmt,a,b,c,d,e,f,g,h,i) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define joe_snprintf_10(buf,len,fmt,a,b,c,d,e,f,g,h,i,j) sprintf((char *)(buf),(char *)(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i),(j))

#define i_printf_0(fmt) (sprintf((char *)(i_msg),(char *)(fmt)), internal_msg(i_msg))
#define i_printf_1(fmt,a) (sprintf((char *)(i_msg),(char *)(fmt),(a)), internal_msg(i_msg))
#define i_printf_2(fmt,a,b) (sprintf((char *)(i_msg),(char *)(fmt),(a),(b)), internal_msg(i_msg))
#define i_printf_3(fmt,a,b,c) (sprintf((char *)(i_msg),(char *)(fmt),(a),(b),(c)), internal_msg(i_msg))
#define i_printf_4(fmt,a,b,c,d) (sprintf((char *)(i_msg),(char *)(fmt),(a),(b),(c),(d)), internal_msg(i_msg))

#endif

/* Largest signed integer */
#define MAXINT  ((((unsigned int)-1)/2)-1)

/* Largest signed long */
#define MAXLONG ((((unsigned long)-1L)/2)-1)

/* Largest signed long long */
#define MAXLONGLONG ((((unsigned long long)-1L)/2)-1)

/* Largest off_t */
/* BSD provides a correct OFF_MAX macro, but AIX provides a broken one,
   so do it ourselves. */
#if (SIZEOF_OFF_T == SIZEOF_INT)
#define MAXOFF MAXINT
#elif (SIZEOF_OFF_T == SIZEOF_LONG)
#define MAXOFF MAXLONG
#elif (SIZEOF_OFF_T == SIZEOF_LONG_LONG)
#define MAXOFF MAXLONGLONG
#else
#error off_t is not an int, long, or long long?
#endif

#include <stdio.h>
#ifndef EOF
#define EOF -1
#endif
#define NO_MORE_DATA EOF

#if defined __MSDOS__ && SIZEOF_INT == 2 /* real mode ms-dos compilers */
#if SIZEOF_VOID_P == 4 /* real mode ms-dos compilers with 'far' memory model or something like that */
#define physical(a)  (((unsigned long)(a)&0xFFFF)+(((unsigned long)(a)&0xFFFF0000)>>12))
#define normalize(a) ((void *)(((unsigned long)(a)&0xFFFF000F)+(((unsigned long)(a)&0x0000FFF0)<<12)))
#else
#define physical(a) ((unsigned long)(a))
#define normalize(a) (a)
#endif /* sizeof(void *) == 4 */

#define SEGSIZ 1024
#define PGSIZE 1024
#define LPGSIZE 10
#define ILIMIT (PGSIZE*96L)
#define HTSIZE 128

#else /* not real mode ms-dos */

#define physical(a) ((unsigned long)(a))
#define normalize(a) (a)

/* Log2 of page size */
#define LPGSIZE 12
/* No. bytes in page */
#define PGSIZE (1<<LPGSIZE)
/* Gap buffer size (must be same as page size) */
#define SEGSIZ PGSIZE

/* Max number of pages allowed in core */
#define NPAGES 8192
/* Max core memory used in bytes */
#define ILIMIT (PGSIZE*NPAGES)
/* Hash table size (should be double the max number of pages) */
#define HTSIZE (NPAGES*2)

#endif /* real mode ms-dos */


/* These do not belong here. */

/* #define KEYS		256 */
#define KEYS 267	/* 256 ascii + mdown, mup, mdrag, m2down, m2up, m2drag,
                                        m3down, m3up, m3drag */
#define KEY_MDOWN	256
#define KEY_MUP		257
#define KEY_MDRAG	258
#define KEY_M2DOWN	259
#define KEY_M2UP	260
#define KEY_M2DRAG	261
#define KEY_M3DOWN	262
#define KEY_M3UP	263
#define KEY_M3DRAG	264
#define KEY_MWUP	265
#define KEY_MWDOWN	266

#define FITHEIGHT	4		/* Minimum text window height */
#define LINCOLS		10
#define NPROC		8		/* Number of processes we keep track of */
#define INC		16		/* Pages to allocate each time */

#define TYPETW		0x0100
#define TYPEPW		0x0200
#define TYPEMENU	0x0800
#define TYPEQW		0x1000

/* Typedefs */

typedef struct header H;
typedef struct buffer B;
typedef struct point P;
typedef struct options OPTIONS;
typedef struct macro MACRO;
typedef struct cmd CMD;
typedef struct entry HENTRY;
typedef struct hash HASH;
typedef struct kmap KMAP;
typedef struct kbd KBD;
typedef struct key KEY;
typedef struct watom WATOM; /* \ odd character */
typedef struct screen Screen;
typedef struct window W;
typedef struct base BASE;
typedef struct bw BW;
typedef struct menu MENU;
typedef struct scrn SCRN;
typedef struct cap CAP;
typedef struct pw PW;
typedef struct stditem STDITEM;
typedef struct query QW;
typedef struct tw TW;
typedef struct undo UNDO;
typedef struct undorec UNDOREC;
typedef struct search SRCH;
typedef struct srchrec SRCHREC;
typedef struct vpage VPAGE;
typedef struct vfile VFILE;
typedef struct highlight_state HIGHLIGHT_STATE;
typedef struct mpx MPX;
typedef struct jfile JFILE;
typedef struct obj Obj;
typedef struct coroutine Coroutine;

/* Structure which are passed by value */

struct highlight_state {
	struct high_frame *stack;   /* Pointer to the current frame in the call stack */
	int state;                  /* Current state in the current subroutine */
	unsigned char saved_s[24];  /* Buffer for saved delimiters */
};

/* Include files */

#include "obj.h"
#include "coroutine.h"
#include "b.h"
#include "blocks.h"
#include "bw.h"
#include "charmap.h"
#include "cmd.h"
#include "hash.h"
#include "help.h"
#include "i18n.h"
#include "kbd.h"
#include "lattr.h"
#include "macro.h"
#include "main.h"
#include "menu.h"
#include "mouse.h"
#include "path.h"
#include "poshist.h"
#include "pw.h"
#include "queue.h"
#include "qw.h"
#include "rc.h"
#include "regex.h"
#include "scrn.h"
#include "syntax.h"
#include "tab.h"
#include "termcapj.h"
#include "tty.h"
#include "tw.h"
#include "ublock.h"
#include "uedit.h"
#include "uerror.h"
#include "ufile.h"
#include "uformat.h"
#include "uisrch.h"
#include "umath.h"
#include "undo.h"
#include "usearch.h"
#include "ushell.h"
#include "utag.h"
#include "utf8.h"
#include "utils.h"
#include "vfile.h"
#include "w.h"
#include "gettext.h"
#include "builtin.h"
@


1.63
log
@More work on coroutine refactoring.
@
text
@d244 3
a246 2
	int	state;
	unsigned char saved_s[24];
@


1.62
log
@fix tags.
switch more wmkpw to ask
@
text
@d250 2
a295 2
#include "obj.h"
#include "coroutine.h"
@


1.61
log
@solaris fixes
@
text
@d217 1
a217 1
typedef struct watom WATOM;
@


1.60
log
@coroutines
@
text
@d44 5
a48 1
/* #define USE_UCONTEXT 1 */
@


1.59
log
@semiautomatic variables
@
text
@d11 1
d43 3
a45 1
#define joe_gettext(s) my_gettext((unsigned char *)(s))
d47 2
a48 4
/*
#ifdef ENABLE_NLS
#include <libintl.h>
#define joe_gettext(s) (unsigned char *)gettext((char *)(s))
d50 1
a50 1
#define joe_gettext(s) ((unsigned char *)(s))
d52 2
a53 1
*/
d235 1
d291 1
@


1.58
log
@UC -> USTR
@
text
@a187 1
#define stdsiz		8192
d232 1
a282 1
#include "va.h"
a283 1
#include "vs.h"
d287 1
@


1.57
log
@more fixes
@
text
@d59 1
a59 1
#define UC (unsigned char *)
@


1.56
log
@change US to UC
@
text
@d267 1
a267 1
#include "termcap.h"
@


1.55
log
@allow setting undo
@
text
@d59 1
a59 1
#define US (unsigned char *)
@


1.54
log
@Add builtins.  Fix syntax error in python.jsf.in
@
text
@a191 1
#define UNDOKEEP	100
@


1.53
log
@large file patch, makefile fix, tty.c fix.
@
text
@d233 1
d289 1
@


1.52
log
@hash table
@
text
@d112 16
@


1.51
log
@multi-line qw, startup log
@
text
@d42 1
a42 1
#define joe_gettext(s) my_gettext((char *)(s))
@


1.50
log
@more columns for line numbers
@
text
@d78 6
d98 6
@


1.49
log
@remove gnu-gettext from joe
@
text
@d162 1
a162 1
#define LINCOLS		6
@


1.48
log
@gettext()
@
text
@d42 3
d51 1
d259 1
@


1.47
log
@Change SCREEN to Screen
@
text
@d42 10
d62 11
a72 11
#define joe_snprintf_0(buf,len,fmt) snprintf((buf),(len),(fmt))
#define joe_snprintf_1(buf,len,fmt,a) snprintf((buf),(len),(fmt),(a))
#define joe_snprintf_2(buf,len,fmt,a,b) snprintf((buf),(len),(fmt),(a),(b))
#define joe_snprintf_3(buf,len,fmt,a,b,c) snprintf((buf),(len),(fmt),(a),(b),(c))
#define joe_snprintf_4(buf,len,fmt,a,b,c,d) snprintf((buf),(len),(fmt),(a),(b),(c),(d))
#define joe_snprintf_5(buf,len,fmt,a,b,c,d,e) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e))
#define joe_snprintf_6(buf,len,fmt,a,b,c,d,e,f) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e),(f))
#define joe_snprintf_7(buf,len,fmt,a,b,c,d,e,f,g) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e),(f),(g))
#define joe_snprintf_8(buf,len,fmt,a,b,c,d,e,f,g,h) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e),(f),(g),(h))
#define joe_snprintf_9(buf,len,fmt,a,b,c,d,e,f,g,h,i) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define joe_snprintf_10(buf,len,fmt,a,b,c,d,e,f,g,h,i,j) snprintf((buf),(len),(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i),(j))
d76 11
a86 11
#define joe_snprintf_0(buf,len,fmt) sprintf((buf),(fmt))
#define joe_snprintf_1(buf,len,fmt,a) sprintf((buf),(fmt),(a))
#define joe_snprintf_2(buf,len,fmt,a,b) sprintf((buf),(fmt),(a),(b))
#define joe_snprintf_3(buf,len,fmt,a,b,c) sprintf((buf),(fmt),(a),(b),(c))
#define joe_snprintf_4(buf,len,fmt,a,b,c,d) sprintf((buf),(fmt),(a),(b),(c),(d))
#define joe_snprintf_5(buf,len,fmt,a,b,c,d,e) sprintf((buf),(fmt),(a),(b),(c),(d),(e))
#define joe_snprintf_6(buf,len,fmt,a,b,c,d,e,f) sprintf((buf),(fmt),(a),(b),(c),(d),(e),(f))
#define joe_snprintf_7(buf,len,fmt,a,b,c,d,e,f,g) sprintf((buf),(fmt),(a),(b),(c),(d),(e),(f),(g))
#define joe_snprintf_8(buf,len,fmt,a,b,c,d,e,f,g,h) sprintf((buf),(fmt),(a),(b),(c),(d),(e),(f),(g),(h))
#define joe_snprintf_9(buf,len,fmt,a,b,c,d,e,f,g,h,i) sprintf((buf),(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define joe_snprintf_10(buf,len,fmt,a,b,c,d,e,f,g,h,i,j) sprintf((buf),(fmt),(a),(b),(c),(d),(e),(f),(g),(h),(i),(j))
@


1.46
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d172 1
a172 1
typedef struct screen SCREEN;
@


1.45
log
@fix lattr bugs
@
text
@d1 1
a1 2
#ifndef _JOE_TYPES_H
#define _JOE_TYPES_H
d5 39
d47 42
a88 2
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>				/* we need pid_t */
d90 37
d128 2
a129 1
#define LINK(type) struct { type *next; type *prev; }
d158 1
a158 10
#ifdef junk					/* These are now defined in config.h */

/* Minimum page size for MS-DOS is 128 (for 32K vheaders table) or 256 (for
 * 64K vheaders table) */
#define PGSIZE 512		/* Page size in bytes (Must be power of 2) */
#define LPGSIZE 9		/* LOG base 2 of PGSIZE */
#define ILIMIT (PGSIZE*128L)	/* Max amount to buffer */
#define HTSIZE 128		/* Entries in hash table.  Must be pwr of 2 */
#endif

a182 1
typedef struct irec IREC;
d190 1
d192 1
a192 311
/* A buffer is made up of a doubly-linked list of gap buffer.  These are the
 * buffer headers.  The buffers themselves can be swapped out.  A buffer with
 * point referring to it is guaranteed to be swapped in.
 */

struct header {
	LINK(H)	link;		/* Doubly-linked list of gap buffer headers */
	long	seg;		/* Swap file offset to gap buffer */
	int	hole;		/* Offset to gap */
	int	ehole;		/* Offset to after gap */
	int	nlines;		/* No. '\n's in this buffer */
};

/* A pointer to some location within a buffer.  After an insert or delete,
 * all of the pointers following the insertion or deletion point are
 * adjusted so that they keep pointing to the same character. */

struct point {
	LINK(P)	link;		/* Doubly-linked list of pointers for a particular buffer */

	B	*b;		/* Buffer */
	int	ofst;		/* Gap buffer offset */
	unsigned char	*ptr;	/* Gap buffer address */
	H	*hdr;		/* Gap buffer header */

	long	byte;		/* Buffer byte offset */
	long	line;		/* Line number */
	long	col;		/* current column */
	long	xcol;		/* cursor column (can be different from actual column) */
	int	valcol;		/* bool: is col valid? */
	int	end;		/* set if this is end of file pointer */

	P	**owner;	/* owner of this pointer.  owner gets cleared if pointer is deleted. */
	unsigned char *tracker;	/* Name of function who pdup()ed me */
};

/* Options: both BWs and Bs have one of these */

struct options {
	OPTIONS	*next;
	unsigned char	*name_regex;
	unsigned char	*contents_regex;
	int	overtype;
	int	lmargin;
	int	rmargin;
	int	autoindent;
	int	wordwrap;
	int	tab;
	int	indentc;
	int	istep;
	unsigned char	*context;
	unsigned char	*lmsg;
	unsigned char	*rmsg;
	int	linums;
	int	readonly;
	int	french;
	int	spaces;
	int	crlf;
	int	highlight;	/* Set to enable highlighting */
	unsigned char *syntax_name;	/* Name of syntax to use */
	struct high_syntax *syntax;	/* Syntax for highlighting (load_dfa() from syntax_name happens in setopt()) */
	unsigned char *map_name;	/* Name of character set */
	struct charmap *charmap;	/* Character set */
	int	smarthome;	/* Set for smart home key */
	int	indentfirst;	/* Smart home goes to indentation point first */
	int	smartbacks;	/* Set for smart backspace key */
	int	purify;		/* Purify indentation */
	int	picture;	/* Picture mode */
	int	single_quoted;	/* Ignore '  ' for ^G */
	int	c_comment;	/* Ignore text in C comments */
	int	cpp_comment;	/* Ignore text after // comments */
	int	pound_comment;	/* Ignore text after # comments */
	int	vhdl_comment;	/* Ignore text after -- comments */
	int	semi_comment;	/* Ignore text after ; comments */
	int	hex;		/* Hex edit mode */
	unsigned char *text_delimiters;	/* Define word delimiters */
	unsigned char *cpara;	/* Characters which can indent paragraphcs */
	MACRO	*mnew;		/* Macro to execute for new files */
	MACRO	*mold;		/* Macro to execute for existing files */
	MACRO	*msnew;		/* Macro to execute before saving new files */
	MACRO	*msold;		/* Macro to execute before saving existing files */
	MACRO	*mfirst;	/* Macro to execute on first change */
};

struct macro {
	int k; /* Keycode */
	int flg; /* Flags: bit 0: this step wants the negative arg,
	                   bit 1: ignore return value of this step, but use it as return value of macro */
	CMD *cmd; /* Command address */
	int n; /* Number of steps */
	int size; /* Malloc size of steps */
	MACRO **steps; /* Block */
};

struct recmac {
	struct recmac *next;
	int	n;
	MACRO	*m;
};


/* Command entry */

struct cmd {
	unsigned char	*name;		/* Command name */
	int	flag;		/* Execution flags */
	int	(*func) ();	/* Function bound to name */
	MACRO	*m;		/* Macro bound to name */
	int	arg;		/* 0= arg is meaningless, 1= ok */
	unsigned char	*negarg;	/* Command to use if arg was negative */
};

/* A buffer */

struct buffer {
	LINK(B)	link;		/* Doubly-linked list of all buffers */
	P	*bof;		/* Beginning of file pointer */
	P	*eof;		/* End of file pointer */
	unsigned char	*name;	/* File name */
	int locked;		/* Set if we created a lock for this file */
	int ignored_lock;	/* Set if we didn't create a lock and we don't care (locked set in this case) */
	int didfirst;		/* Set after user attempted first change */
	long    mod_time;	/* Last modification time for file */
	long	check_time;	/* Last time we checked the file on disk */
	int	orphan;
	int	count;
	int	changed;
	int	backup;
	void	*undo;
	P	*marks[11];	/* Bookmarks */
	OPTIONS	o;		/* Options */
	P	*oldcur;	/* Last cursor position before orphaning */
	P	*oldtop;	/* Last top screen position before orphaning */
	int	rdonly;		/* Set for read-only */
	int	internal;	/* Set for internal buffers */
	int	scratch;	/* Set for scratch buffers */
	int	er;		/* Error code when file was loaded */
	pid_t	pid;		/* Process id */
	int	out;		/* fd to write to process */
	struct lattr_db *db;	/* Linked list of line attribute databases */
};


struct entry {
	unsigned char	*name;
	HENTRY	*next;
	void	*val;
};

struct hash {
	int	len;
	HENTRY	**tab;
};


struct help {
	unsigned char	*text;		/* help text with attributes */
	unsigned int	lines;		/* number of lines */
	struct help	*prev;		/* previous help screen */
	struct help	*next;		/* nex help screen */
	unsigned char	*name;		/* context name for context sensitive help */
};

/* A key binding */
struct key {
	int	k;			/* Flag: 0=binding, 1=submap */
	union {
		void	*bind;		/* What key is bound to */
		KMAP	*submap;	/* Sub KMAP address (for prefix keys) */
	} value;
};

/* A map of keycode to command/sub-map bindings */
struct kmap {
	KEY	keys[KEYS];	/* KEYs */
};

/** A keyboard handler **/
struct kbd {
	KMAP	*curmap;	/* Current keymap */
	KMAP	*topmap;	/* Top-level keymap */
	int	seq[16];	/* Current sequence of keys */
	int	x;		/* What we're up to */
};


struct watom {
	unsigned char	*context;	/* Context name */
	void	(*disp) ();	/* Display window */
	void	(*follow) ();	/* Called to have window follow cursor */
	int	(*abort) ();	/* Common user functions */
	int	(*rtn) ();
	int	(*type) ();
	void	(*resize) ();	/* Called when window changed size */
	void	(*move) ();	/* Called when window moved */
	void	(*ins) ();	/* Called on line insertions */
	void	(*del) ();	/* Called on line deletions */
	int	what;		/* Type of this thing */
};

/* A screen with windows */

struct screen {
	SCRN	*t;		/* Screen data on this screen is output to */

	int	wind;		/* Number of help lines on this screen */

	W	*topwin;	/* Top-most window showing on screen */
	W	*curwin;	/* Window cursor is in */

	int	w, h;		/* Width and height of this screen */
};

/* A window (base class) */

struct window {
	LINK(W)	link;		/* Linked list of windows in order they
				   appear on the screen */

	SCREEN	*t;		/* Screen this thing is on */

	int	x, y, w, h;	/* Position and size of window */
				/* Currently, x = 0, w = width of screen. */
				/* y == -1 if window is not on screen */

	int	ny, nh;		/* Temporary values for wfit */

	int	reqh;		/* Requested new height or 0 for same */
				/* This is an argument for wfit */

	int	fixed;		/* If this is zero, use 'hh'.  If not, this
				   is a fixed size window and this variable
				   gives its height */

	int	hh;		/* Height window would be on a screen with
				   1000 lines.  When the screen size changes
				   this is used to calculate the window's
				   real height */

	W	*win;		/* Window this one operates on */
	W	*main;		/* Main window of this family */
	W	*orgwin;	/* Window where space from this window came */
	int	curx, cury;	/* Cursor position within window */
	KBD	*kbd;		/* Keyboard handler for this window */
	WATOM	*watom;		/* The type of this window */
	void	*object;	/* Object which inherits this */
#if 0
	union {			/* FIXME: instead of void *object we should */
		BW	*bw;	/* use this union to get strict type checking */
		PW	*pw;	/* from C compiler (need to check and change */
		QW	*qw;	/* all of the occurrencies of ->object) */
		TW	*tw;
		MENU	*menu;
		BASE	*base;
	} object;
#endif

	unsigned char	*msgt;		/* Message at top of window */
	unsigned char	*msgb;		/* Message at bottom of window */
	unsigned char	*huh;		/* Name of window for context sensitive hlp */
	int	*notify;	/* Address of kill notification flag */
};

/* Anything which goes in window.object must start like this: */
struct base {
	W	*parent;
};

/* A buffer window: there are several kinds, depending on what is in 'object' */

struct bw {
	W	*parent;
	B	*b;
	P	*top;
	P	*cursor;
	long	offset;
	SCREEN	*t;
	int	h, w, x, y;

	OPTIONS	o;
	void	*object;

	int	linums;
	int	top_changed;	/* Top changed */
	struct lattr_db *db;	/* line attribute database */
};

/* A menu window */

struct menu {
	W	*parent;	/* Window we're in */
	unsigned char	**list;		/* List of items */
	int	top;		/* First item on screen */
	int	cursor;		/* Item cursor is on */
	int	width;		/* Width of widest item, up to 'w' max */
	int	perline;	/* Number of items on each line */
	int	nitems;		/* No. items in list */
	SCREEN	*t;		/* Screen we're on */
	int	h, w, x, y;
	int	(*abrt) ();	/* Abort callback function */
	int	(*func) ();	/* Return callback function */
	int	(*backs) ();	/* Backspace callback function */
	void	*object;
};

struct hentry {
	int	next;
	int	loc;
};

/* Try to be only one cache line */
d199 1
a199 310
/* Each terminal has one of these: terminal capability database */

#ifdef __MSDOS__

struct scrn {
	int	li;		/* Height of screen */
	int	co;		/* Width of screen */
	short	*scrn;		/* Buffer */
	int	scroll;
	int	insdel;
	int	*updtab;	/* Lines which need to be updated */
	HIGHLIGHT_STATE *syntax;
	int	*compose;
	int	*sary;
};

#else
struct scrn {
	CAP	*cap;		/* Termcap/Terminfo data */

	int	li;		/* Screen height */
	int	co;		/* Screen width */

	unsigned char	*ti;		/* Initialization string */
	unsigned char	*cl;		/* Home and clear screen... really an
				   init. string */
	unsigned char	*cd;		/* Clear to end of screen */
	unsigned char	*te;		/* Restoration string */

	int	haz;		/* Terminal can't print ~s */
	int	os;		/* Terminal overstrikes */
	int	eo;		/* Can use blank to erase even if os */
	int	ul;		/* _ overstrikes */
	int	am;		/* Terminal has autowrap, but not magicwrap */
	int	xn;		/* Terminal has magicwrap */

	unsigned char	*so;		/* Enter standout (inverse) mode */
	unsigned char	*se;		/* Exit standout mode */

	unsigned char	*us;		/* Enter underline mode */
	unsigned char	*ue;		/* Exit underline mode */
	unsigned char	*uc;		/* Single time underline character */

	int	ms;		/* Ok to move when in standout/underline mode */

	unsigned char	*mb;		/* Enter blinking mode */
	unsigned char	*md;		/* Enter bold mode */
	unsigned char	*mh;		/* Enter dim mode */
	unsigned char	*mr;		/* Enter inverse mode */
	unsigned char	*me;		/* Exit above modes */

	unsigned char	*Sb;		/* Set background color */
	unsigned char	*Sf;		/* Set foregrond color */
	int	Co;			/* No. of colors */
	int	ut;		/* Screen erases with background color */

	int	da, db;		/* Extra lines exist above, below */
	unsigned char	*al, *dl, *AL, *DL;	/* Insert/delete lines */
	unsigned char	*cs;		/* Set scrolling region */
	int	rr;		/* Set for scrolling region relative addressing */
	unsigned char	*sf, *SF, *sr, *SR;	/* Scroll */

	unsigned char	*dm, *dc, *DC, *ed;	/* Delete characters */
	unsigned char	*im, *ic, *IC, *ip, *ei;	/* Insert characters */
	int	mi;		/* Set if ok to move while in insert mode */

	unsigned char	*bs;		/* Move cursor left 1 */
	int	cbs;
	unsigned char	*lf;		/* Move cursor down 1 */
	int	clf;
	unsigned char	*up;		/* Move cursor up 1 */
	int	cup;
	unsigned char	*nd;		/* Move cursor right 1 */

	unsigned char	*ta;		/* Move cursor to next tab stop */
	int	cta;
	unsigned char	*bt;		/* Move cursor to previous tab stop */
	int	cbt;
	int	tw;		/* Tab width */

	unsigned char	*ho;		/* Home cursor to upper left */
	int	cho;
	unsigned char	*ll;		/* Home cursor to lower left */
	int	cll;
	unsigned char	*cr;		/* Move cursor to left edge */
	int	ccr;
	unsigned char	*RI;		/* Move cursor right n */
	int	cRI;
	unsigned char	*LE;		/* Move cursor left n */
	int	cLE;
	unsigned char	*UP;		/* Move cursor up n */
	int	cUP;
	unsigned char	*DO;		/* Move cursor down n */
	int	cDO;
	unsigned char	*ch;		/* Set cursor column */
	int	cch;
	unsigned char	*cv;		/* Set cursor row */
	int	ccv;
	unsigned char	*cV;		/* Goto beginning of specified line */
	int	ccV;
	unsigned char	*cm;		/* Set cursor row and column */
	int	ccm;

	unsigned char	*ce;		/* Clear to end of line */
	int	cce;

	/* Basic abilities */
	int	scroll;		/* Set to use scrolling */
	int	insdel;		/* Set to use insert/delete within line */

	/* Current state of terminal */
	int	*scrn;		/* Characters on screen */
	int	*attr;		/* Attributes on screen */
	int	x, y;		/* Current cursor position (-1 for unknown) */
	int	top, bot;	/* Current scrolling region */
	int	attrib;		/* Current character attributes */
	int	ins;		/* Set if we're in insert mode */

	int	*updtab;	/* Dirty lines table */
	int	avattr;		/* Bits set for available attributes */
	int	*sary;		/* Scroll buffer array */

	int	*compose;	/* Line compose buffer */
	int	*ofst;		/* stuff for magic */
	struct hentry	*htab;
	struct hentry	*ary;
};
#endif


struct sortentry {
	unsigned char	*name;
	unsigned char	*value;
};

struct cap {
	unsigned char	*tbuf;		/* Termcap entry loaded here */

	struct sortentry *sort;	/* Pointers to each capability stored in here */
	int	sortlen;	/* Number of capabilities */

	unsigned char	*abuf;		/* For terminfo compatible version */
	unsigned char	*abufp;

	int	div;		/* tenths of MS per char */
	int	baud;		/* Baud rate */
	unsigned char	*pad;		/* Padding string or NULL to use NUL */
	void	(*out) (unsigned char *, unsigned char);		/* Character output routine */
	void	*outptr;	/* First arg passed to output routine.  Second
				   arg is character to write */
	int	dopadding;	/* Set if pad characters should be used */
};

/* Prompt window (a BW) */

struct pw {
	int	(*pfunc) ();	/* Func which gets called when RTN is hit */
	int	(*abrt) ();	/* Func which gets called when window is aborted */
	int	(*tab) ();	/* Func which gets called when TAB is hit */
	unsigned char	*prompt;	/* Prompt string */
	int	promptlen;	/* Width of prompt string */
	int	promptofst;	/* Prompt scroll offset */
	B	*hist;		/* History buffer */
	void	*object;	/* Object */
	int	file_prompt;	/* Set if this is a file name prompt, so do ~ expansion */
};

struct stditem {
	LINK(STDITEM)	link;
};

/* Single-key Query window */

struct query {
	W	*parent;	/* Window we're in */
	int	(*func) ();	/* Func. which gets called when key is hit */
	int	(*abrt) ();
	void	*object;
	unsigned char	*prompt;	/* Prompt string */
	int	promptlen;	/* Width of prompt string */
	int	promptofst;	/* Prompt scroll offset */
};


typedef struct mpx MPX;
struct mpx {
	int	ackfd;		/* Packetizer response descriptor */
	int	kpid;		/* Packetizer process id */
	int	pid;		/* Client process id */
	void	(*func) ();	/* Function to call when read occures */
	void	*object;	/* First arg to pass to function */
	void	(*die) ();	/* Function: call when client dies or closes */
	void	*dieobj;
};

/* Text window (a BW) */

struct tw {
	unsigned char	*stalin;	/* Status line info */
	unsigned char	*staright;
	int	staon;		/* Set if status line was on */
	long	prevline;	/* Previous cursor line number */
	int	changed;	/* Previous changed value */
	B	*prev_b;	/* Previous buffer (we need to update status line on nbuf/pbuf) */
};

struct irec {
	LINK(IREC)	link;
	int	what;		/* 0 repeat, >0 append n chars */
	long	start;		/* Cursor search position */
	long	disp;		/* Original cursor position */
	int	wrap_flag;	/* Wrap flag */
};

struct isrch {
	IREC	irecs;		/* Linked list of positions */
	unsigned char *pattern;	/* Search pattern string */
	unsigned char *prompt;	/* Prompt (usually same as pattern unless utf-8/byte conversion) */
	int	ofst;		/* Offset in pattern past prompt */
	int	dir;		/* 0=fwrd, 1=bkwd */
	int	quote;		/* Set to quote next char */
};


struct undorec {
	LINK(UNDOREC)	link;
	UNDOREC	*unit;
	int	min;
	int	changed;	/* Status of modified flag before this record */
	long	where;		/* Buffer address of this record */
	long	len;		/* Length of insert or delete */
	int	del;		/* Set if this is a delete */
	B	*big;		/* Set to buffer containing a large amount of deleted data */
	unsigned char	*small;		/* Set to malloc block containg a small amount of deleted data */
};

struct undo {
	LINK(UNDO)	link;
	B	*b;
	int	nrecs;
	UNDOREC	recs;
	UNDOREC	*ptr;
	UNDOREC	*first;
	UNDOREC	*last;
};

struct srchrec {
	LINK(SRCHREC)	link;	/* Linked list of search & replace locations */
	int	yn;		/* Did we replace? */
	int	wrap_flag;	/* Did we wrap? */
	long	addr;		/* Where we were */
	long	last_repl;
};

struct search {
	unsigned char	*pattern;	/* Search pattern */
	unsigned char	*replacement;	/* Replacement string */
	int	backwards;	/* Set if search should go backwards */
	int	ignore;		/* Set if we should ignore case */
	int	repeat;		/* Set with repeat count (or -1 for no repeat count) */
	int	replace;	/* Set if this is search & replace */
	int	rest;		/* Set to do remainder of search & replace w/o query */
	unsigned char	*entire;	/* Entire matched string */
	unsigned char	*pieces[26];	/* Peices of the matched string */
	int	flg;		/* Set after prompted for first replace */
	SRCHREC	recs;		/* Search & replace position history */
	P	*markb, *markk;	/* Original marks */
	P	*wrap_p;	/* Wrap point */
	int	wrap_flag;	/* Set if we've wrapped */
	int	allow_wrap;	/* Set to allow wrapping */
	int	valid;		/* Set if original marks are a valid block */
	long	addr;		/* Where to place cursor after failed restruct_to_block() test */
	long	last_repl;	/* Address of last replacement (prevents infinite loops) */
	int	block_restrict;	/* Search restricted to marked block */
};



/* Page header */

struct vpage {
	VPAGE	*next;		/* Next page with same hash value */
	VFILE	*vfile;		/* Owner vfile */
	long	addr;		/* Address of this page */
	int	count;		/* Reference count */
	int	dirty;		/* Set if page changed */
	unsigned char	*data;		/* The data in the page */
};

/* File structure */

struct vfile {
	LINK(VFILE)	link;	/* Doubly linked list of vfiles */
	long	size;		/* Number of bytes in physical file */
	long	alloc;		/* Number of bytes allocated to file */
	int	fd;		/* Physical file */
	int	writeable;	/* Set if we can write */
	unsigned char	*name;		/* File name.  0 if unnamed */
	int	flags;		/* Set if this is only a temporary file */

	/* For array I/O */
	unsigned char	*vpage1;	/* Page address */
	long	addr;		/* File address of above page */

	/* For stream I/O */
	unsigned char	*bufp;		/* Buffer pointer */
	unsigned char	*vpage;		/* Buffer pointer points in here */
	int	left;		/* Space left in bufp */
	int	lv;		/* Amount of append space at end of buffer */
};
d201 9
d211 34
a244 2

#endif
@


1.44
log
@New -cpara option
@
text
@d85 5
d91 5
a95 5
	LINK(H)	link;		/* LINK ??? */
	long	seg;		/* ??? */
	int	hole;		/* ??? */
	int	ehole;		/* ??? */
	int	nlines;		/* ??? */
d98 4
d103 1
a103 1
	LINK(P)	link;		/* ?LINK ??? */
d105 4
a108 4
	B	*b;		/* ?B ??? */
	int	ofst;		/* ??? */
	unsigned char	*ptr;	/* ??? */
	H	*hdr;		/* ?H ??? */
d110 2
a111 2
	long	byte;		/* ??? */
	long	line;		/* ??? */
d113 1
a113 1
	long	xcol;		/* ??? */
d115 1
a115 1
	int	end;		/* ??? */
d117 1
a117 1
	P	**owner;	/* ??? */
d121 2
d197 1
a197 1

d200 4
a203 4
	LINK(B)	link;
	P	*bof;
	P	*eof;
	unsigned char	*name;
d285 2
d298 2
d353 2
d372 2
d402 1
a402 1
/* Each terminal has one of these */
d555 1
d573 2
d597 1
@


1.43
log
@New line attribute cache.
@
text
@d150 1
@


1.42
log
@add joe_debug
@
text
@d212 1
a500 1
	HIGHLIGHT_STATE *syntab;
@


1.41
log
@fix search bugs
@
text
@d109 1
@


1.40
log
@Some more highlighting cache fixes.
@
text
@d628 1
d648 2
a649 1
	long	addr;		/* Addr of last replacement or -1 for none */
@


1.39
log
@Improve highlighting performance.
@
text
@a210 1
	struct lattr_db *db;	/* line attribute database */
d349 1
@


1.38
log
@Fix some resize window bugs, add 256 color support.
@
text
@d211 1
d686 2
@


1.37
log
@Add wheel mouse support
@
text
@d432 1
@


1.36
log
@hex edit mode
@
text
@d16 1
a16 1
#define KEYS 265	/* 256 ascii + mdown, mup, mdrag, m2down, m2up, m2drag,
d27 3
@


1.35
log
@fix locks bug, jmacs improvements
@
text
@d144 1
@


1.34
log
@improve macro language...
@
text
@d639 1
@


1.33
log
@Fix ~ expansion insanity
@
text
@d152 8
a159 3
struct macro { int k; /* Keycode */ int arg; /* Repeat argument */ CMD *cmd;
	/* Command address */ int n; /* Number of steps */ int size; /*
	Malloc size of steps */ MACRO **steps; /* Block */
@


1.32
log
@File changed check.
@
text
@d533 1
@


1.31
log
@Perforce macro and support for it.
@
text
@d186 1
@


1.30
log
@file locking.
@
text
@d149 1
d184 1
@


1.29
log
@Jesse McGrew's xterm mouse support.
@
text
@d181 2
@


1.28
log
@Fix perl highlighter bug, enhance ^G
@
text
@d15 12
a26 1
#define KEYS		256
@


1.27
log
@Highlighter state now includes a saved string.
This improves shell and perl highlighters.
@
text
@d127 7
d140 3
a142 7
struct macro {
	int	k;		/* Keycode */
	int	arg;		/* Repeat argument */
	CMD	*cmd;		/* Command address */
	int	n;		/* Number of steps */
	int	size;		/* Malloc size of steps */
	MACRO	**steps;	/* Block */
@


1.26
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d69 1
a69 1

d344 7
d362 1
a362 2
	/* HIGHLIGHT_STATE *syntab; */ /* Syntax highlight state at start of each line */
	int	*syntab;
d469 1
a469 1
	int	*syntab;
@


1.25
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d181 2
a318 2
	pid_t	pid;		/* Process id */
	int	out;		/* fd to write to process */
d543 1
@


1.24
log
@Added "upper" and "lower" functions (no longer depend on "tr" command).
Fix jmacs transpose word command.
@
text
@d179 1
@


1.23
log
@Warn if file changed on save.
@
text
@d173 1
a173 1
	P	*marks[10];	/* Bookmarks */
@


1.22
log
@Added -wrap flag so that search wraps.
@
text
@d167 1
@


1.21
log
@Regex search now works properly with UTF-8 chars.
Incremental search now works with UTF-8.
@
text
@d548 1
d586 1
d603 2
@


1.20
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d552 2
a553 1
	unsigned char	*pattern;	/* Search pattern string/prompt */
@


1.19
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d120 2
a121 3
	int	utf8;		/* Set for UTF-8 mode, otherwise we're in byte mode */
	unsigned char *map_name;	/* Name of byte mode character set */
	struct charmap *charmap;	/* Character set if file is in byte mode */
@


1.18
log
@Improve Fortran again.

Added '-indentfirst' option to control
how smarthome works.

Now syntax files are loaded as needed.

New version of automake and autoconf

Print UTF-8 (c) if terminal is utf-8.
@
text
@d120 3
a122 1
	int	utf8;		/* Set for UTF-8 mode */
@


1.17
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@d118 2
a119 1
	struct high_syntax *syntax;	/* Syntax for highlighting */
d122 1
@


1.16
log
@Added -purify option.
@
text
@d123 1
@


1.15
log
@Added 'smartbacks' option.
@
text
@d122 1
@


1.14
log
@Applied David Phillips' smart home key patch.

Changed  ` u to ` x.
@
text
@d121 1
@


1.13
log
@Fixed bug where '-syntax' on command line had
no effect.

Now if terminal is UTF-8, the default file type
is assumed to be UTF-8.
@
text
@d120 1
@


1.12
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d118 1
a118 1
	unsigned char	*syntax;	/* Syntax name for highlighting */
a311 1
	struct high_syntax *syntax;	/* Syntax table */
@


1.11
log
@Fix lockup bug in UTF-8: hit down arrow on last line.  Bug was in pcol().

Start replacement of 'char *' with 'unsigned char *'.  I want to be able to
assign characters to integers and not get -1 (this finishes the conversion
to NO_MORE_DATA from MAXINT).
@
text
@d6 3
d99 2
a100 2
	char	*name_regex;
	char	*contents_regex;
d109 3
a111 3
	char	*context;
	char	*lmsg;
	char	*rmsg;
d118 1
a118 1
	char	*syntax;	/* Syntax name for highlighting */
d145 1
a145 1
	char	*name;		/* Command name */
d150 1
a150 1
	char	*negarg;	/* Command to use if arg was negative */
d159 1
a159 1
	char	*name;
d176 1
a176 1
	char	*name;
d219 1
a219 1
	char	*context;	/* Context name */
d285 3
a287 3
	char	*msgt;		/* Message at top of window */
	char	*msgb;		/* Message at bottom of window */
	char	*huh;		/* Name of window for context sensitive hlp */
d317 1
a317 1
	char	**list;		/* List of items */
d360 2
a361 2
	char	*ti;		/* Initialization string */
	char	*cl;		/* Home and clear screen... really an
d363 2
a364 2
	char	*cd;		/* Clear to end of screen */
	char	*te;		/* Restoration string */
d373 2
a374 2
	char	*so;		/* Enter standout (inverse) mode */
	char	*se;		/* Exit standout mode */
d376 3
a378 3
	char	*us;		/* Enter underline mode */
	char	*ue;		/* Exit underline mode */
	char	*uc;		/* Single time underline character */
d382 5
a386 5
	char	*mb;		/* Enter blinking mode */
	char	*md;		/* Enter bold mode */
	char	*mh;		/* Enter dim mode */
	char	*mr;		/* Enter inverse mode */
	char	*me;		/* Exit above modes */
d388 2
a389 2
	char	*Sb;		/* Set background color */
	char	*Sf;		/* Set foregrond color */
d393 2
a394 2
	char	*al, *dl, *AL, *DL;	/* Insert/delete lines */
	char	*cs;		/* Set scrolling region */
d396 1
a396 1
	char	*sf, *SF, *sr, *SR;	/* Scroll */
d398 2
a399 2
	char	*dm, *dc, *DC, *ed;	/* Delete characters */
	char	*im, *ic, *IC, *ip, *ei;	/* Insert characters */
d402 1
a402 1
	char	*bs;		/* Move cursor left 1 */
d404 1
a404 1
	char	*lf;		/* Move cursor down 1 */
d406 1
a406 1
	char	*up;		/* Move cursor up 1 */
d408 1
a408 1
	char	*nd;		/* Move cursor right 1 */
d410 1
a410 1
	char	*ta;		/* Move cursor to next tab stop */
d412 1
a412 1
	char	*bt;		/* Move cursor to previous tab stop */
d416 1
a416 1
	char	*ho;		/* Home cursor to upper left */
d418 1
a418 1
	char	*ll;		/* Home cursor to lower left */
d420 1
a420 1
	char	*cr;		/* Move cursor to left edge */
d422 1
a422 1
	char	*RI;		/* Move cursor right n */
d424 1
a424 1
	char	*LE;		/* Move cursor left n */
d426 1
a426 1
	char	*UP;		/* Move cursor up n */
d428 1
a428 1
	char	*DO;		/* Move cursor down n */
d430 1
a430 1
	char	*ch;		/* Set cursor column */
d432 1
a432 1
	char	*cv;		/* Set cursor row */
d434 1
a434 1
	char	*cV;		/* Goto beginning of specified line */
d436 1
a436 1
	char	*cm;		/* Set cursor row and column */
d439 1
a439 1
	char	*ce;		/* Clear to end of line */
d468 2
a469 2
	char	*name;
	char	*value;
d473 1
a473 1
	char	*tbuf;		/* Termcap entry loaded here */
d478 2
a479 2
	char	*abuf;		/* For terminfo compatible version */
	char	*abufp;
d483 2
a484 2
	char	*pad;		/* Padding string or NULL to use NUL */
	void	(*out) (char *, char);		/* Character output routine */
d495 1
a495 1
	char	*prompt;	/* Prompt string */
d511 1
a511 1
	char	*prompt;	/* Prompt string */
d530 2
a531 2
	char	*stalin;	/* Status line info */
	char	*staright;
d546 1
a546 1
	char	*pattern;	/* Search pattern string/prompt */
d562 1
a562 1
	char	*small;		/* Set to malloc block containg a small amount of deleted data */
d582 2
a583 2
	char	*pattern;	/* Search pattern */
	char	*replacement;	/* Replacement string */
d589 2
a590 2
	char	*entire;	/* Entire matched string */
	char	*pieces[26];	/* Peices of the matched string */
d609 1
a609 1
	char	*data;		/* The data in the page */
d620 1
a620 1
	char	*name;		/* File name.  0 if unnamed */
d624 1
a624 1
	char	*vpage1;	/* Page address */
d628 2
a629 2
	char	*bufp;		/* Buffer pointer */
	char	*vpage;		/* Buffer pointer points in here */
@


1.10
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d81 1
a81 1
	char	*ptr;		/* ??? */
@


1.9
log
@Fix screen update bug introduced with Apr 7th change.

Option settings now can be based on file contents as well as
file name.

Added syntax indicator for status line.
@
text
@d116 1
d444 2
a445 1
	int	*scrn;		/* Current contents of screen */
@


1.8
log
@Clean up meaning of default color.

Allow syntax to be specified in joerc file: "-syntax perl"

Add class definitions to syntax files.

Add perl and verilog definitions (they need work).

Change joerc to assume files with . in their name do not want word
wrap enabled (except for .txt).
@
text
@d96 2
a97 1
	char	*name;
@


1.7
log
@More changes for syntax highlighting.
@
text
@d114 1
@


1.6
log
@Syntax highlighting baby steps.
@
text
@a75 1

d306 1
a306 1
	int	state;		/* Highlight state of line following window */
d341 2
a342 1
	int	*syntab;	/* Syntax highlight state at start of each line */
@


1.5
log
@rename restrict() and restrict member of struct search
@
text
@d114 1
d306 2
d336 3
a338 3
	int	li;
	int	co;
	short	*scrn;
d341 2
a342 1
	int	*updtab;
d382 4
d448 1
@


1.4
log
@add comments - explain what is the function doing
@
text
@d580 1
a580 1
	int	restrict;	/* Search restricted to marked block */
@


1.3
log
@get back context help
@
text
@d87 1
a87 1
	long	col;		/* ??? */
d89 1
a89 1
	int	valcol;		/* ??? */
@


1.2
log
@include only headers which are needed
@
text
@d186 1
@


1.1
log
@put struct definitions and other goodies into types.h
@
text
@d12 12
a23 12
#define KEYS 256
#define stdsiz 8192
#define FITHEIGHT 4				/* Minimum text window height */
#define LINCOLS 6
#define TYPEMENU 0x800
#define TYPEPW 0x200
#define TYPEQW 0x1000
#define NPROC 8					/* Number of processes we keep track of */
#define TYPETW 0x100
#define UNDOKEEP 100
#define INC 16			/* Pages to allocate each time */

a35 1

d69 5
a73 5
	LINK(H) link;		/* LINK ??? */
	long seg;		/* ??? */
	int hole;		/* ??? */
	int ehole;		/* ??? */
	int nlines;		/* ??? */
d78 1
a78 1
	LINK(P) link;		/* ?LINK ??? */
d80 11
a90 11
	B *b;			/* ?B ??? */
	int ofst;		/* ??? */
	char *ptr;		/* ??? */
	H *hdr;			/* ?H ??? */

	long byte;		/* ??? */
	long line;		/* ??? */
	long col;		/* ??? */
	long xcol;		/* ??? */
	int valcol;		/* ??? */
	int end;		/* ??? */
d92 1
a92 1
	P **owner;		/* ??? */
d96 22
a117 22
	OPTIONS *next;
	char *name;
	int overtype;
	int lmargin;
	int rmargin;
	int autoindent;
	int wordwrap;
	int tab;
	int indentc;
	int istep;
	char *context;
	char *lmsg;
	char *rmsg;
	int linums;
	int readonly;
	int french;
	int spaces;
	int crlf;
	MACRO *mnew;		/* Macro to execute for new files */
	MACRO *mold;		/* Macro to execute for existing files */
	MACRO *msnew;		/* Macro to execute before saving new files */
	MACRO *msold;		/* Macro to execute before saving existing files */
d121 6
a126 6
	int k;			/* Keycode */
	int arg;		/* Repeat argument */
	CMD *cmd;		/* Command address */
	int n;			/* Number of steps */
	int size;		/* Malloc size of steps */
	MACRO **steps;		/* Block */
d131 2
a132 2
	int n;
	MACRO *m;
d139 6
a144 6
	char *name;		/* Command name */
	int flag;		/* Execution flags */
	int (*func) ();		/* Function bound to name */
	MACRO *m;		/* Macro bound to name */
	int arg;		/* 0= arg is meaningless, 1= ok */
	char *negarg;		/* Command to use if arg was negative */
d150 16
a165 16
	LINK(B) link;
	P *bof;
	P *eof;
	char *name;
	int orphan;
	int count;
	int changed;
	int backup;
	void *undo;
	P *marks[10];		/* Bookmarks */
	OPTIONS o;		/* Options */
	P *oldcur;		/* Last cursor position before orphaning */
	P *oldtop;		/* Last top screen position before orphaning */
	int rdonly;		/* Set for read-only */
	int internal;		/* Set for internal buffers */
	int er;			/* Error code when file was loaded */
d170 3
a172 3
	char *name;
	HENTRY *next;
	void *val;
d176 2
a177 2
	int len;
	HENTRY **tab;
d182 4
a185 4
	unsigned char *text;		/* help text with attributes */
	unsigned int lines;		/* number of lines */
	struct help *prev;		/* previous help screen */
	struct help *next;		/* nex help screen */
d190 1
a190 1
	int k;			/* Flag: 0=binding, 1=submap */
d192 2
a193 2
		void *bind;	/* What key is bound to */
		KMAP *submap;	/* Sub KMAP address (for prefix keys) */
d199 1
a199 1
	KEY keys[KEYS];		/* KEYs */
d204 4
a207 4
	KMAP *curmap;		/* Current keymap */
	KMAP *topmap;		/* Top-level keymap */
	int seq[16];		/* Current sequence of keys */
	int x;			/* What we're up to */
d212 11
a222 11
	char *context;		/* Context name */
	void (*disp) ();	/* Display window */
	void (*follow) ();	/* Called to have window follow cursor */
	int (*abort) ();	/* Common user functions */
	int (*rtn) ();
	int (*type) ();
	void (*resize) ();	/* Called when window changed size */
	void (*move) ();	/* Called when window moved */
	void (*ins) ();		/* Called on line insertions */
	void (*del) ();		/* Called on line deletions */
	int what;		/* Type of this thing */
d226 1
a226 1
	SCRN *t;		/* Screen data on this screen is output to */
d228 1
a228 1
	int wind;		/* Number of help lines on this screen */
d230 2
a231 2
	W *topwin;		/* Top-most window showing on screen */
	W *curwin;		/* Window cursor is in */
d233 1
a233 1
	int w, h;		/* Width and height of this screen */
d237 1
a237 1
	LINK(W) link;		/* Linked list of windows in order they
d240 1
a240 1
	SCREEN *t;		/* Screen this thing is on */
d242 1
a242 1
	int x, y, w, h;		/* Position and size of window */
d246 1
a246 1
	int ny, nh;		/* Temporary values for wfit */
d248 1
a248 1
	int reqh;		/* Requested new height or 0 for same */
d251 1
a251 1
	int fixed;		/* If this is zero, use 'hh'.  If not, this
d255 1
a255 1
	int hh;			/* Height window would be on a screen with
d260 7
a266 7
	W *win;			/* Window this one operates on */
	W *main;		/* Main window of this family */
	W *orgwin;		/* Window where space from this window came */
	int curx, cury;		/* Cursor position within window */
	KBD *kbd;		/* Keyboard handler for this window */
	WATOM *watom;		/* The type of this window */
	void *object;		/* Object which inherits this */
d278 4
a281 7
	char *msgt;		/* Message at top of window */

	char *msgb;		/* Message at bottom of window */

	char *huh;		/* Name of window for context sensitive hlp */

	int *notify;		/* Address of kill notification flag */
d286 1
a286 1
	W *parent;
d290 14
a303 14
	W *parent;
	B *b;
	P *top;
	P *cursor;
	long offset;
	SCREEN *t;
	int h, w, x, y;

	OPTIONS o;
	void *object;

	pid_t pid;		/* Process id */
	int out;		/* fd to write to process */
	int linums;
d307 13
a319 13
	W *parent;		/* Window we're in */
	char **list;		/* List of items */
	int top;		/* First item on screen */
	int cursor;		/* Item cursor is on */
	int width;		/* Width of widest item, up to 'w' max */
	int perline;		/* Number of items on each line */
	int nitems;		/* No. items in list */
	SCREEN *t;		/* Screen we're on */
	int h, w, x, y;
	int (*abrt) ();		/* Abort callback function */
	int (*func) ();		/* Return callback function */
	int (*backs) ();	/* Backspace callback function */
	void *object;
d323 2
a324 2
	int next;
	int loc;
d332 8
a339 8
	int li;
	int co;
	short *scrn;
	int scroll;
	int insdel;
	int *updtab;
	int *compose;
	int *sary;
d344 1
a344 1
	CAP *cap;		/* Termcap/Terminfo data */
d346 2
a347 2
	int li;			/* Screen height */
	int co;			/* Screen width */
d349 2
a350 2
	char *ti;		/* Initialization string */
	char *cl;		/* Home and clear screen... really an
d352 2
a353 2
	char *cd;		/* Clear to end of screen */
	char *te;		/* Restoration string */
d355 68
a422 68
	int haz;		/* Terminal can't print ~s */
	int os;			/* Terminal overstrikes */
	int eo;			/* Can use blank to erase even if os */
	int ul;			/* _ overstrikes */
	int am;			/* Terminal has autowrap, but not magicwrap */
	int xn;			/* Terminal has magicwrap */

	char *so;		/* Enter standout (inverse) mode */
	char *se;		/* Exit standout mode */

	char *us;		/* Enter underline mode */
	char *ue;		/* Exit underline mode */
	char *uc;		/* Single time underline character */

	int ms;			/* Ok to move when in standout/underline mode */

	char *mb;		/* Enter blinking mode */
	char *md;		/* Enter bold mode */
	char *mh;		/* Enter dim mode */
	char *mr;		/* Enter inverse mode */
	char *me;		/* Exit above modes */

	int da, db;		/* Extra lines exist above, below */
	char *al, *dl, *AL, *DL;	/* Insert/delete lines */
	char *cs;		/* Set scrolling region */
	int rr;			/* Set for scrolling region relative addressing */
	char *sf, *SF, *sr, *SR;	/* Scroll */

	char *dm, *dc, *DC, *ed;	/* Delete characters */
	char *im, *ic, *IC, *ip, *ei;	/* Insert characters */
	int mi;			/* Set if ok to move while in insert mode */

	char *bs;		/* Move cursor left 1 */
	int cbs;
	char *lf;		/* Move cursor down 1 */
	int clf;
	char *up;		/* Move cursor up 1 */
	int cup;
	char *nd;		/* Move cursor right 1 */

	char *ta;		/* Move cursor to next tab stop */
	int cta;
	char *bt;		/* Move cursor to previous tab stop */
	int cbt;
	int tw;			/* Tab width */

	char *ho;		/* Home cursor to upper left */
	int cho;
	char *ll;		/* Home cursor to lower left */
	int cll;
	char *cr;		/* Move cursor to left edge */
	int ccr;
	char *RI;		/* Move cursor right n */
	int cRI;
	char *LE;		/* Move cursor left n */
	int cLE;
	char *UP;		/* Move cursor up n */
	int cUP;
	char *DO;		/* Move cursor down n */
	int cDO;
	char *ch;		/* Set cursor column */
	int cch;
	char *cv;		/* Set cursor row */
	int ccv;
	char *cV;		/* Goto beginning of specified line */
	int ccV;
	char *cm;		/* Set cursor row and column */
	int ccm;
d424 2
a425 2
	char *ce;		/* Clear to end of line */
	int cce;
d428 2
a429 2
	int scroll;		/* Set to use scrolling */
	int insdel;		/* Set to use insert/delete within line */
d432 14
a445 14
	int *scrn;		/* Current contents of screen */
	int x, y;		/* Current cursor position (-1 for unknown) */
	int top, bot;		/* Current scrolling region */
	int attrib;		/* Current character attributes */
	int ins;		/* Set if we're in insert mode */

	int *updtab;		/* Dirty lines table */
	int avattr;		/* Bits set for available attributes */
	int *sary;		/* Scroll buffer array */

	int *compose;		/* Line compose buffer */
	int *ofst;		/* stuff for magic */
	struct hentry *htab;
	struct hentry *ary;
d451 2
a452 2
	char *name;
	char *value;
d456 1
a456 1
	char *tbuf;		/* Termcap entry loaded here */
d459 1
a459 1
	int sortlen;		/* Number of capabilities */
d461 2
a462 2
	char *abuf;		/* For terminfo compatible version */
	char *abufp;
d464 5
a468 5
	int div;		/* tenths of MS per char */
	int baud;		/* Baud rate */
	char *pad;		/* Padding string or NULL to use NUL */
	void (*out) (char *, char);		/* Character output routine */
	void *outptr;		/* First arg passed to output routine.  Second
d470 1
a470 1
	int dopadding;		/* Set if pad characters should be used */
d475 8
a482 8
	int (*pfunc) ();	/* Func which gets called when RTN is hit */
	int (*abrt) ();		/* Func which gets called when window is aborted */
	int (*tab) ();		/* Func which gets called when TAB is hit */
	char *prompt;		/* Prompt string */
	int promptlen;		/* Width of prompt string */
	int promptofst;		/* Prompt scroll offset */
	B *hist;		/* History buffer */
	void *object;		/* Object */
d486 1
a486 1
	LINK(STDITEM) link;
d490 7
a496 7
	W *parent;		/* Window we're in */
	int (*func) ();		/* Func. which gets called when key is hit */
	int (*abrt) ();
	void *object;
	char *prompt;		/* Prompt string */
	int promptlen;		/* Width of prompt string */
	int promptofst;		/* Prompt scroll offset */
d502 7
a508 7
	int ackfd;		/* Packetizer response descriptor */
	int kpid;		/* Packetizer process id */
	int pid;		/* Client process id */
	void (*func) ();	/* Function to call when read occures */
	void *object;		/* First arg to pass to function */
	void (*die) ();		/* Function: call when client dies or closes */
	void *dieobj;
d513 5
a517 6
	/* Status line info */
	char *stalin;
	char *staright;
	int staon;		/* Set if status line was on */
	long prevline;		/* Previous cursor line number */
	int changed;		/* Previous changed value */
d521 4
a524 4
	LINK(IREC) link;
	int what;		/* 0 repeat, >0 append n chars */
	long start;		/* Cursor search position */
	long disp;		/* Original cursor position */
d528 5
a532 5
	IREC irecs;		/* Linked list of positions */
	char *pattern;		/* Search pattern string/prompt */
	int ofst;		/* Offset in pattern past prompt */
	int dir;		/* 0=fwrd, 1=bkwd */
	int quote;		/* Set to quote next char */
d537 9
a545 9
	LINK(UNDOREC) link;
	UNDOREC *unit;
	int min;
	int changed;		/* Status of modified flag before this record */
	long where;		/* Buffer address of this record */
	long len;		/* Length of insert or delete */
	int del;		/* Set if this is a delete */
	B *big;			/* Set to buffer containing a large amount of deleted data */
	char *small;		/* Set to malloc block containg a small amount of deleted data */
d549 7
a555 7
	LINK(UNDO) link;
	B *b;
	int nrecs;
	UNDOREC recs;
	UNDOREC *ptr;
	UNDOREC *first;
	UNDOREC *last;
d559 3
a561 3
	LINK(SRCHREC) link;	/* Linked list of search & replace locations */
	int yn;			/* Did we replace? */
	long addr;		/* Where we were */
d565 15
a579 15
	char *pattern;		/* Search pattern */
	char *replacement;	/* Replacement string */
	int backwards;		/* Set if search should go backwards */
	int ignore;		/* Set if we should ignore case */
	int repeat;		/* Set with repeat count (or -1 for no repeat count) */
	int replace;		/* Set if this is search & replace */
	int rest;		/* Set to do remainder of search & replace w/o query */
	char *entire;		/* Entire matched string */
	char *pieces[26];	/* Peices of the matched string */
	int flg;		/* Set after prompted for first replace */
	SRCHREC recs;		/* Search & replace position history */
	P *markb, *markk;	/* Original marks */
	int valid;		/* Set if original marks are a valid block */
	long addr;		/* Addr of last replacement or -1 for none */
	int restrict;		/* Search restricted to marked block */
d587 6
a592 6
	VPAGE *next;		/* Next page with same hash value */
	VFILE *vfile;		/* Owner vfile */
	long addr;		/* Address of this page */
	int count;		/* Reference count */
	int dirty;		/* Set if page changed */
	char *data;		/* The data in the page */
d598 7
a604 7
	LINK(VFILE) link;	/* Doubly linked list of vfiles */
	long size;		/* Number of bytes in physical file */
	long alloc;		/* Number of bytes allocated to file */
	int fd;			/* Physical file */
	int writeable;		/* Set if we can write */
	char *name;		/* File name.  0 if unnamed */
	int flags;		/* Set if this is only a temporary file */
d607 2
a608 2
	char *vpage1;		/* Page address */
	long addr;		/* File address of above page */
d611 4
a614 4
	char *bufp;		/* Buffer pointer */
	char *vpage;		/* Buffer pointer points in here */
	int left;		/* Space left in bufp */
	int lv;			/* Amount of append space at end of buffer */
d617 1
a617 1
#endif@

