head	1.76;
access;
symbols
	joe_3_5:1.74
	joe-3_4:1.68
	help:1.68
	joe_3_1:1.43
	joe_3_0:1.33
	joe_2_9_8:1.19
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.7
	joe_2_9_7_pre2:1.6
	joe_2_9_6:1.5
	joe_2_9_5:1.4
	joe_2_9_4:1.3
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.18.23.31.53;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.18.19.32.08;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.17.22.32.02;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.15.18.18.28;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.26.22.56.58;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.21.16.29.49;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.03.21.01.30;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.08.04.38.07;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.28.23.36.52;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.22.18.44.33;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.19.15.59.58;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.10.18.24.28;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.27.21.59.00;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.24.04.30.49;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.30.04.40.47;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.28.15.13.09;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.28.06.17.07;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.22.03.22.37;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.21.04.46.59;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.21.03.41.36;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.21.02.15.55;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.02.15.17.35;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.07.19.59.47;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.28.17.06.21;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.14.04.23.03;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.11.18.05.38;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.04.20.06.31;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.04.16.35.11;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.03.22.55.46;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.03.12.28.47;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.03.12.17.01;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.25.15.52.36;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.25.00.53.41;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.18.02.26.36;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.16.21.10.15;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.15.14.29.07;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.13.20.41.32;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.12.20.11.16;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.12.14.14.50;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.09.22.01.06;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.08.15.20.38;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.08.00.34.58;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.07.00.19.20;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.30.05.10.15;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.24.19.47.49;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.04.17.38.56;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.27.13.31.30;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.13.32;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.12.09.38;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.13.57.21;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.33;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.34;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.34;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.76
log
@more work on coroutine refactor
prompt window experiment
@
text
@/*
 *	Edit buffer window generation
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Display modes */
int dspasis = 0;
int marking = 0;

static P *getto(P *p, P *cur, P *top, long int line)
{

	if (p == NULL) {
		P *best = cur;
		long dist = MAXLONG;
		long d;

		d = (line >= cur->line ? line - cur->line : cur->line - line);
		if (d < dist) {
			dist = d;
			best = cur;
		}
		d = (line >= top->line ? line - top->line : top->line - line);
		if (d < dist) {
			dist = d;
			best = top;
		}
		p = pdup(best, USTR "getto");
		p_goto_bol(p);
	}
	while (line > p->line)
		if (!pnextl(p))
			break;
	if (line < p->line) {
		while (line < p->line)
			pprevl(p);
		p_goto_bol(p);
	}
	return p;
}

/* Scroll window to follow cursor */

int mid = 0;

/* For hex */

void bwfllwh(BW *w)
{
	/* Top must be a muliple of 16 bytes */
	if (w->top->byte%16) {
		pbkwd(w->top,w->top->byte%16);
	}

	/* Move backward */
	if (w->cursor->byte < w->top->byte) {
		long new_top = w->cursor->byte/16;
		if (mid) {
			if (new_top >= w->h / 2)
				new_top -= w->h / 2;
			else
				new_top = 0;
		}
		if (w->top->byte/16 - new_top < w->h)
			nscrldn(w->t->t, w->y, w->y + w->h, (int) (w->top->byte/16 - new_top));
		else
			msetI(w->t->t->updtab + w->y, 1, w->h);
		pgoto(w->top,new_top*16);
	}

	/* Move forward */
	if (w->cursor->byte >= w->top->byte+(w->h*16)) {
		long new_top;
		if (mid) {
			new_top = w->cursor->byte/16 - w->h / 2;
		} else {
			new_top = w->cursor->byte/16 - (w->h - 1);
		}
		if (new_top - w->top->byte/16 < w->h)
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (new_top - w->top->byte/16));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		}
		pgoto(w->top, new_top*16);
	}

	/* Adjust scroll offset */
	if (w->cursor->byte%16+60 < w->offset) {
		w->offset = w->cursor->byte%16+60;
		msetI(w->t->t->updtab + w->y, 1, w->h);
	} else if (w->cursor->byte%16+60 >= w->offset + w->w) {
		w->offset = w->cursor->byte%16+60 - (w->w - 1);
		msetI(w->t->t->updtab + w->y, 1, w->h);
	}
}

/* For text */

void bwfllwt(BW *w)
{
	P *newtop;

	if (!pisbol(w->top)) {
		p_goto_bol(w->top);
	}

	if (w->cursor->line < w->top->line) {
		newtop = pdup(w->cursor, USTR "bwfllwt");
		p_goto_bol(newtop);
		if (mid) {
			if (newtop->line >= w->h / 2)
				pline(newtop, newtop->line - w->h / 2);
			else
				pset(newtop, newtop->b->bof);
		}
		if (w->top->line - newtop->line < w->h)
			nscrldn(w->t->t, w->y, w->y + w->h, (int) (w->top->line - newtop->line));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		}
		pset(w->top, newtop);
		prm(newtop);
	} else if (w->cursor->line >= w->top->line + w->h) {
		/* newtop = pdup(w->top); */
		/* getto() creates newtop */
		if (mid)
			newtop = getto(NULL, w->cursor, w->top, w->cursor->line - w->h / 2);
		else
			newtop = getto(NULL, w->cursor, w->top, w->cursor->line - (w->h - 1));
		if (newtop->line - w->top->line < w->h)
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (newtop->line - w->top->line));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		}
		pset(w->top, newtop);
		prm(newtop);
	}

/* Adjust column */
	if (w->cursor->xcol < w->offset) {
		long target = w->cursor->xcol;
		if (target < 5)
			target = 0;
		else {
			target -= 5;
			target -= (target % 5);
		}
		w->offset = target;
		msetI(w->t->t->updtab + w->y, 1, w->h);
	}
	if (w->cursor->xcol >= w->offset + w->w) {
		w->offset = w->cursor->xcol - (w->w - 1);
		msetI(w->t->t->updtab + w->y, 1, w->h);
	}
}

/* For either */

void bwfllw(BW *w)
{
	if (w->o.hex)
		bwfllwh(w);
	else
		bwfllwt(w);
}

/* Determine highlighting state of a particular line on the window.
   If the state is not known, it is computed and the state for all
   of the remaining lines of the window are also recalculated. */

HIGHLIGHT_STATE get_highlight_state(BW *w, P *p, int line)
{
	HIGHLIGHT_STATE state;

	if(!w->o.highlight || !w->o.syntax) {
		invalidate_state(&state);
		return state;
	}

	return lattr_get(w->db, w->o.syntax, p, line);

	/* Old way... */
#ifdef junk

	ln = line;

	lattr_get(w->db, &ln, &state);

	if (ln != line) {
		tmp = pdup(p, USTR "get_highlight_state");
		pline(tmp, ln);
		while (tmp->line < line && !piseof(tmp)) {
			state = parse(w->o.syntax, tmp, state);
		}
		if (tmp->line == line)
			lattr_set(w->db, line, state);
		prm(tmp);
	}
	return state;
#endif

#ifdef junk
	P *tmp = 0;
	HIGHLIGHT_STATE state;

	/* Screen y position of requested line */
	int y = line-w->top->line+w->y;

	if(!w->o.highlight || !w->o.syntax) {
		invalidate_state(&state);
		return state;
	}

	/* If we know the state, just return it */
	if (w->parent->t->t->syntab[y].state>=0)
		return w->parent->t->t->syntab[y];

	/* Scan upwards until we have a line with known state or
	   we're on the first line */
	while (y > w->y && w->parent->t->t->syntab[y].state < 0) --y;

	/* If we don't have state for this line, calculate by going 100 lines back */
	if (w->parent->t->t->syntab[y].state<0) {
		/* We must be on the top line */
		clear_state(&state);
		tmp = pdup(w->top, USTR "get_highlight_state");
		if(w->o.syntax->sync_lines >= 0 && tmp->line > w->o.syntax->sync_lines)
			pline(tmp, tmp->line-w->o.syntax->sync_lines);
		else
			p_goto_bof(tmp);
		while(tmp->line!=y-w->y+w->top->line)
			state = parse(w->o.syntax,tmp,state);
		w->parent->t->t->syntab[y] = state;
		w->parent->t->t->updtab[y] = 1;
		prm(tmp);
	}

	/* Color to end of screen */
	tmp = pdup(w->top, USTR "get_highlight_state");
	pline(tmp, y-w->y+w->top->line);
	state = w->parent->t->t->syntab[y];
	while(tmp->line!=w->top->line+w->h-1 && !piseof(tmp)) {
		state = parse(w->o.syntax,tmp,state);
		w->parent->t->t->syntab[++y] = state;
		w->parent->t->t->updtab[y] = 1; /* This could be smarter: update only if we changed what was there before */
		}
	prm(tmp);
	while(y<w->y+w->h-1) {
		w->parent->t->t->syntab[++y] = state;
		}

	/* Line after window */
	/* state = parse_c(state,syn,tmp); */

	/* If we changed, fix other windows */
	/* w->state = state; */

	/* Return state of requested line */
	y = line - w->top->line + w->y;
	return w->parent->t->t->syntab[y];
#endif
}

/* Scroll a buffer window after an insert occured.  'flg' is set to 1 if
 * the first line was split
 */

void bwins(BW *w, long int l, long int n, int flg)
{
	/* If highlighting is enabled... */
	if (w->o.highlight && w->o.syntax) {
		/* Invalidate cache */
		/* lattr_cut(w->db, l + 1); */
		/* Force updates */
		if (l < w->top->line) {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		} else if ((l + 1) < w->top->line + w->h) {
			int start = l + 1 - w->top->line;
			int size = w->h - start;
			msetI(w->t->t->updtab + w->y + start, 1, size);
		}
	}

	/* Scroll */
	if (l + flg + n < w->top->line + w->h && l + flg >= w->top->line && l + flg <= w->b->eof->line) {
		if (flg)
			w->t->t->sary[w->y + l - w->top->line] = w->t->t->li;
		nscrldn(w->t->t, (int) (w->y + l + flg - w->top->line), w->y + w->h, (int) n);
	}

	/* Force update of lines in opened hole */
	if (l < w->top->line + w->h && l >= w->top->line) {
		if (n >= w->h - (l - w->top->line)) {
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
		} else {
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, (int) n + 1);
		}
	}
}

/* Scroll current windows after a delete */

void bwdel(BW *w, long int l, long int n, int flg)
{
	/* If highlighting is enabled... */
	if (w->o.highlight && w->o.syntax) {
		/* lattr_cut(w->db, l + 1); */
		if (l < w->top->line) {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		} else if ((l + 1) < w->top->line + w->h) {
			int start = l + 1 - w->top->line;
			int size = w->h - start;
			msetI(w->t->t->updtab + w->y + start, 1, size);
		}
	}

	/* Update the line where the delete began */
	if (l < w->top->line + w->h && l >= w->top->line)
		w->t->t->updtab[w->y + l - w->top->line] = 1;

	/* Update the line where the delete ended */
	if (l + n < w->top->line + w->h && l + n >= w->top->line)
		w->t->t->updtab[w->y + l + n - w->top->line] = 1;

	if (l < w->top->line + w->h && (l + n >= w->top->line + w->h || (l + n == w->b->eof->line && w->b->eof->line >= w->top->line + w->h))) {
		if (l >= w->top->line)
			/* Update window from l to end */
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
		else
			/* Update entire window */
			msetI(w->t->t->updtab + w->y, 1, w->h);
	} else if (l < w->top->line + w->h && l + n == w->b->eof->line && w->b->eof->line < w->top->line + w->h) {
		if (l >= w->top->line)
			/* Update window from l to end of file */
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, (int) n);
		else
			/* Update from beginning of window to end of file */
			msetI(w->t->t->updtab + w->y, 1, (int) (w->b->eof->line - w->top->line));
	} else if (l + n < w->top->line + w->h && l + n > w->top->line && l + n < w->b->eof->line) {
		if (l + flg >= w->top->line)
			nscrlup(w->t->t, (int) (w->y + l + flg - w->top->line), w->y + w->h, (int) n);
		else
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (l + n - w->top->line));
	}
}

/* Update a single line */

static int lgen(SCRN *t, int y, int *screen, int *attr, int x, int w, P *p, long int scr, long int from, long int to,HIGHLIGHT_STATE st,BW *bw)
        
      
            			/* Screen line address */
      				/* Window */
     				/* Buffer pointer */
         			/* Starting column to display */
              			/* Range for marked block */
{
	int ox = x;
	int tach;
	int done = 1;
	long col = 0;
	long byte = p->byte;
	unsigned char *bp;	/* Buffer pointer, 0 if not set */
	int amnt;		/* Amount left in this segment of the buffer */
	int c, ta, c1;
	unsigned char bc;
	int ungetit = -1;

	struct utf8_sm utf8_sm;

        int *syn = 0;
        P *tmp;
        int idx=0;
        int atr = BG_COLOR(bg_text); 

	utf8_init(&utf8_sm);

	if(st.state!=-1) {
		tmp=pdup(p, USTR "lgen");
		p_goto_bol(tmp);
		parse(bw->o.syntax,tmp,st);
		syn = attr_buf;
		prm(tmp);
	}

/* Initialize bp and amnt from p */
	if (p->ofst >= p->hdr->hole) {
		bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	} else {
		bp = p->ptr + p->ofst;
		amnt = p->hdr->hole - p->ofst;
	}

	if (col == scr)
		goto loop;
      lp:			/* Display next character */
	if (amnt)
		do {
			if (ungetit== -1)
				bc = *bp++;
			else {
				bc = ungetit;
				ungetit = -1;
			}
			if(st.state!=-1) {
				atr = syn[idx++];
				if (!((atr & BG_VALUE) >> BG_SHIFT))
					atr |= BG_COLOR(bg_text);
			}
			if (p->b->o.crlf && bc == '\r') {
				++byte;
				if (!--amnt) {
				      pppl:
					if (bp == p->ptr + SEGSIZ) {
						if (pnext(p)) {
							bp = p->ptr;
							amnt = p->hdr->hole;
						} else
							goto nnnl;
					} else {
						bp = p->ptr + p->hdr->ehole;
						amnt = SEGSIZ - p->hdr->ehole;
						if (!amnt)
							goto pppl;
					}
				}
				if (*bp == '\n') {
					++bp;
					++byte;
					++amnt;
					goto eobl;
				}
			      nnnl:
				--byte;
				++amnt;
			}
			if (square)
				if (bc == '\t') {
					long tcol = col + p->b->o.tab - col % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (col >= from && col < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - col % p->b->o.tab;
				if (ta + col > scr) {
					ta -= scr - col;
					tach = ' ';
					goto dota;
				}
				if ((col += ta) == scr) {
					--amnt;
					goto loop;
				}
			} else if (bc == '\n')
				goto eobl;
			else {
				int wid = 1;
				if (p->b->o.charmap->type) {
					c = utf8_decode(&utf8_sm,bc);

					if (c>=0) /* Normal decoded character */
						wid = joe_wcwidth(1,c);
					else if(c== -1) /* Character taken */
						wid = -1;
					else if(c== -2) { /* Incomplete sequence (FIXME: do something better here) */
						wid = 1;
						ungetit = c;
						++amnt;
						--byte;
					}
					else if(c== -3) /* Control character 128-191, 254, 255 */
						wid = 1;
				} else {
					wid = 1;
				}

				if(wid>0) {
					col += wid;
					if (col == scr) {
						--amnt;
						goto loop;
					} else if (col > scr) {
						ta = col - scr;
						tach = '<';
						goto dota;
					}
				} else
					--idx;	/* Get highlighting character again.. */
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto lp;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto lp;
	}
	goto eof;

      loop:			/* Display next character */
	if (amnt)
		do {
			if (ungetit== -1)
				bc = *bp++;
			else {
				bc = ungetit;
				ungetit = -1;
			}
			if(st.state!=-1) {
				atr = syn[idx++];
				if (!(atr & BG_MASK))
					atr |= BG_COLOR(bg_text);
			}
			if (p->b->o.crlf && bc == '\r') {
				++byte;
				if (!--amnt) {
				      ppl:
					if (bp == p->ptr + SEGSIZ) {
						if (pnext(p)) {
							bp = p->ptr;
							amnt = p->hdr->hole;
						} else
							goto nnl;
					} else {
						bp = p->ptr + p->hdr->ehole;
						amnt = SEGSIZ - p->hdr->ehole;
						if (!amnt)
							goto ppl;
					}
				}
				if (*bp == '\n') {
					++bp;
					++byte;
					++amnt;
					goto eobl;
				}
			      nnl:
				--byte;
				++amnt;
			}
			if (square)
				if (bc == '\t') {
					long tcol = scr + x - ox + p->b->o.tab - (scr + x - ox) % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (scr + x - ox >= from && scr + x - ox < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - ((x - ox + scr) % p->b->o.tab);
				tach = ' ';
			      dota:
				do {
					outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, tach, c1|atr);
					if (ifhave)
						goto bye;
					if (++x == w)
						goto eosl;
				} while (--ta);
			} else if (bc == '\n')
				goto eobl;
			else {
				int wid = -1;
				int utf8_char;
				if (p->b->o.charmap->type) { /* UTF-8 */

					utf8_char = utf8_decode(&utf8_sm,bc);

					if (utf8_char >= 0) { /* Normal decoded character */
						wid = joe_wcwidth(1,utf8_char);
					} else if(utf8_char== -1) { /* Character taken */
						wid = -1;
					} else if(utf8_char== -2) { /* Incomplete sequence (FIXME: do something better here) */
						ungetit = bc;
						++amnt;
						--byte;
						utf8_char = 'X';
						wid = 1;
					} else if(utf8_char== -3) { /* Invalid UTF-8 start character 128-191, 254, 255 */
						/* Show as control character */
						wid = 1;
						utf8_char = 'X';
					}
				} else { /* Regular */
					utf8_char = bc;
					wid = 1;
				}

				if(wid>=0) {
					if (x+wid > w) {
						/* If character hits right most column, don't display it */
						while (x < w) {
							outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, '>', c1|atr);
							x++;
						}
					} else {
						outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, utf8_char, c1|atr);
						x += wid;
					}
				} else
					--idx;

				if (ifhave)
					goto bye;
				if (x >= w)
					goto eosl;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto loop;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto loop;
	}
	goto eof;

      eobl:			/* End of buffer line found.  Erase to end of screen line */
	++p->line;
      eof:
	if (x != w)
		done = eraeol(t, x, y, BG_COLOR(bg_text));
	else
		done = 0;

/* Set p to bp/amnt */
      bye:
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	return done;

      eosl:
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	pnextl(p);
	return 0;
}

/* Generate line into an array */
#ifdef junk
static int lgena(SCRN *t, int y, int *screen, int x, int w, P *p, long int scr, long int from, long int to)
        
      
            			/* Screen line address */
      				/* Window */
     				/* Buffer pointer */
         			/* Starting column to display */
              			/* Range for marked block */
{
	int ox = x;
	int done = 1;
	long col = 0;
	long byte = p->byte;
	unsigned char *bp;	/* Buffer pointer, 0 if not set */
	int amnt;		/* Amount left in this segment of the buffer */
	int c, ta, c1;
	unsigned char bc;

/* Initialize bp and amnt from p */
	if (p->ofst >= p->hdr->hole) {
		bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	} else {
		bp = p->ptr + p->ofst;
		amnt = p->hdr->hole - p->ofst;
	}

	if (col == scr)
		goto loop;
      lp:			/* Display next character */
	if (amnt)
		do {
			bc = *bp++;
			if (square)
				if (bc == '\t') {
					long tcol = col + p->b->o.tab - col % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (col >= from && col < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - col % p->b->o.tab;
				if (ta + col > scr) {
					ta -= scr - col;
					goto dota;
				}
				if ((col += ta) == scr) {
					--amnt;
					goto loop;
				}
			} else if (bc == '\n')
				goto eobl;
			else if (++col == scr) {
				--amnt;
				goto loop;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto lp;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto lp;
	}
	goto eobl;

      loop:			/* Display next character */
	if (amnt)
		do {
			bc = *bp++;
			if (square)
				if (bc == '\t') {
					long tcol = scr + x - ox + p->b->o.tab - (scr + x - ox) % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (scr + x - ox >= from && scr + x - ox < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - ((x - ox + scr) % p->b->o.tab);
			      dota:
				do {
					screen[x] = ' ' + c1;
					if (++x == w)
						goto eosl;
				} while (--ta);
			} else if (bc == '\n')
				goto eobl;
			else {
				/* xlat(&c, &bc);*/
				c ^= c1;
				screen[x] = c + bc;
				if (++x == w)
					goto eosl;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto loop;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto loop;
	}
	goto eof;
      eobl:			/* End of buffer line found.  Erase to end of screen line */
	++p->line;
      eof:
	while (x != w)
		screen[x++] = ' ';
	done = 0;

/* Set p to bp/amnt */
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	return done;

      eosl:
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	pnextl(p);
	return 0;
}
#endif

static void gennum(BW *w, int *screen, int *attr, SCRN *t, int y, int *comp)
{
	unsigned char buf[12];
	int z;
	int lin = w->top->line + y - w->y;

	if (lin <= w->b->eof->line)
		joe_snprintf_1(buf, sizeof(buf), "%9ld ", w->top->line + y - w->y + 1);
	else {
		int x;
		for (x = 0; x != LINCOLS; ++x)
			buf[x] = ' ';
		buf[x] = 0;
	}
	for (z = 0; buf[z]; ++z) {
		outatr(w->b->o.charmap, t, screen + z, attr + z, z, y, buf[z], BG_COLOR(bg_text)); 
		if (ifhave)
			return;
		comp[z] = buf[z];
	}
}

void bwgenh(BW *w)
{
	int *screen;
	int *attr;
	P *q = pdup(w->top, USTR "bwgenh");
	int bot = w->h + w->y;
	int y;
	SCRN *t = w->t->t;
	int flg = 0;
	long from;
	long to;
	int dosquare = 0;

	from = to = 0;

	if (markv(0) && markk->b == w->b)
		if (square) {
			from = markb->xcol;
			to = markk->xcol;
			dosquare = 1;
		} else {
			from = markb->byte;
			to = markk->byte;
		}
	else if (marking && w==(BW *)maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
		if (square) {
			from = long_min(w->cursor->xcol, markb->xcol);
			to = long_max(w->cursor->xcol, markb->xcol);
			dosquare = 1;
		} else {
			from = long_min(w->cursor->byte, markb->byte);
			to = long_max(w->cursor->byte, markb->byte);
		}
	}

	if (marking && w==(BW *)maint->curwin->object)
		msetI(t->updtab + w->y, 1, w->h);

	if (dosquare) {
		from = 0;
		to = 0;
	}

	y=w->y;
	attr = t->attr + y*w->t->w;
	for (screen = t->scrn + y * w->t->w; y != bot; ++y, (screen += w->t->w), (attr += w->t->w)) {
		unsigned char txt[80];
		int fmt[80];
		unsigned char bf[16];
		int x;
		memset(txt,' ',76);
		msetI(fmt,BG_COLOR(bg_text),76);
		txt[76]=0;
		if (!flg) {
#if SIZEOF_LONG_LONG && SIZEOF_LONG_LONG == SIZEOF_OFF_T
			sprintf((char *)bf,"%8llx ",q->byte);
#else
			sprintf((char *)bf,"%8lx ",q->byte);
#endif
			memcpy(txt,bf,9);
			for (x=0; x!=8; ++x) {
				int c;
				if (q->byte==w->cursor->byte && !flg) {
					fmt[10+x*3] |= INVERSE;
					fmt[10+x*3+1] |= INVERSE;
				}
				if (q->byte>=from && q->byte<to && !flg) {
					fmt[10+x*3] |= UNDERLINE;
					fmt[10+x*3+1] |= UNDERLINE;
					fmt[60+x] |= INVERSE;
				}
				c = pgetb(q);
				if (c >= 0) {
					sprintf((char *)bf,"%2.2x",c);
					txt[10+x*3] = bf[0];
					txt[10+x*3+1] = bf[1];
					if (c >= 0x20 && c <= 0x7E)
						txt[60+x] = c;
					else
						txt[60+x] = '.';
				} else
					flg = 1;
			}
			for (x=8; x!=16; ++x) {
				int c;
				if (q->byte==w->cursor->byte && !flg) {
					fmt[11+x*3] |= INVERSE;
					fmt[11+x*3+1] |= INVERSE;
				}
				if (q->byte>=from && q->byte<to && !flg) {
					fmt[11+x*3] |= UNDERLINE;
					fmt[11+x*3+1] |= UNDERLINE;
					fmt[60+x] |= INVERSE;
				}
				c = pgetb(q);
				if (c >= 0) {
					sprintf((char *)bf,"%2.2x",c);
					txt[11+x*3] = bf[0];
					txt[11+x*3+1] = bf[1];
					if (c >= 0x20 && c <= 0x7E)
						txt[60+x] = c;
					else
						txt[60+x] = '.';
				} else
					flg = 1;
			}
		}
		genfield(t, screen, attr, 0, y, w->offset, txt, 76, 0, w->w, 1, fmt);
	}
	prm(q);
}

void bwgen(BW *w, int linums)
{
	int *screen;
	int *attr;
	P *p = NULL;
	P *q;
	int bot = w->h + w->y;
	int y;
	int dosquare = 0;
	long from, to;
	long fromline, toline;
	SCRN *t = w->t->t;

	/* Set w.db to correct value */
	if (w->o.highlight && w->o.syntax && (!w->db || w->db->syn != w->o.syntax))
		w->db = find_lattr_db(w->b, w->o.syntax);

	fromline = toline = from = to = 0;

	if (w->b == errbuf) {
		P *tmp = pdup(w->cursor, USTR "bwgen");
		p_goto_bol(tmp);
		from = tmp->byte;
		pnextl(tmp);
		to = tmp->byte;
		prm(tmp);
	} else if (markv(0) && markk->b == w->b)
		if (square) {
			from = markb->xcol;
			to = markk->xcol;
			dosquare = 1;
			fromline = markb->line;
			toline = markk->line;
		} else {
			from = markb->byte;
			to = markk->byte;
		}
	else if (marking && w==(BW *)maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
		if (square) {
			from = long_min(w->cursor->xcol, markb->xcol);
			to = long_max(w->cursor->xcol, markb->xcol);
			fromline = long_min(w->cursor->line, markb->line);
			toline = long_max(w->cursor->line, markb->line);
			dosquare = 1;
		} else {
			from = long_min(w->cursor->byte, markb->byte);
			to = long_max(w->cursor->byte, markb->byte);
		}
	}

	if (marking && w==(BW *)maint->curwin->object)
		msetI(t->updtab + w->y, 1, w->h);

	q = pdup(w->cursor, USTR "bwgen");

	y = w->cursor->line - w->top->line + w->y;
	attr = t->attr + y*w->t->w;
	for (screen = t->scrn + y * w->t->w; y != bot; ++y, (screen += w->t->w), (attr += w->t->w)) {
		if (ifhave && !linums)
			break;
		if (linums)
			gennum(w, screen, attr, t, y, t->compose);
		if (t->updtab[y]) {
			int idx = w->x;
			p = getto(p, w->cursor, w->top, w->top->line + y - w->y);
/*			if (t->insdel && !w->x) {
				pset(q, p);
				if (dosquare)
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					else
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
				else
					lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				magic(t, y, screen, attr, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
			} */
			if (w->prompt && y == w->cursor->line - w->top->line + w->y) {
				genfmt(w->t->t, w->x, y, w->promptofst, w->prompt, BG_COLOR(bg_prompt), 0);
				idx += w->promptlen - w->promptofst;
			}
			if (dosquare)
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
					t->updtab[y] = lgen(t, y, screen, attr, idx, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
				else
					t->updtab[y] = lgen(t, y, screen, attr, idx, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,p,w->top->line+y-w->y),w);
			else
				t->updtab[y] = lgen(t, y, screen, attr, idx, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
		}
	}

	y = w->y;
	attr = t->attr + w->y * w->t->w;
	for (screen = t->scrn + w->y * w->t->w; y != w->y + w->cursor->line - w->top->line; ++y, (screen += w->t->w), (attr += w->t->w)) {
		if (ifhave && !linums)
			break;
		if (linums)
			gennum(w, screen, attr, t, y, t->compose);
		if (t->updtab[y]) {
			p = getto(p, w->cursor, w->top, w->top->line + y - w->y);
/*			if (t->insdel && !w->x) {
				pset(q, p);
				if (dosquare)
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					else
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
				else
					lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				magic(t, y, screen, attr, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
			} */
			if (dosquare)
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
				else
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,p,w->top->line+y-w->y),w);
			else
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
		}
	}
	prm(q);
	if (p)
		prm(p);
}

void bwmove(BW *w, int x, int y)
{
	w->x = x;
	w->y = y;
}

void bwresz(BW *w, int wi, int he)
{
	if (he > w->h && w->y != -1) {
		msetI(w->t->t->updtab + w->y + w->h, 1, he - w->h);
	}
	w->w = wi;
	w->h = he;
}

BW *bwmk(W *window, B *b, int prompt, unsigned char *ps)
{
	BW *w = (BW *) joe_malloc(sizeof(BW));

	if (ps) {
		w->prompt = zdup(ps);
		w->promptlen = fmtlen(ps);
		w->promptofst = 0;
	} else {
		w->prompt = 0;
		w->promptlen = 0;
		w->promptofst = 0;
	}

	w->parent = window;
	w->b = b;
	if (prompt || (!window->y && staen)) {
		w->y = window->y;
		w->h = window->h;
	} else {
		w->y = window->y + 1;
		w->h = window->h - 1;
	}
	if (b->oldcur) {
		w->top = b->oldtop;
		b->oldtop = NULL;
		w->top->owner = NULL;
		w->cursor = b->oldcur;
		b->oldcur = NULL;
		w->cursor->owner = NULL;
	} else {
		w->top = pdup(b->bof, USTR "bwmk");
		w->cursor = pdup(b->bof, USTR "bwmk");
	}
	w->t = window->t;
	w->object = NULL;
	w->offset = 0;
	w->o = w->b->o;
	if (w->o.linums) {
		w->x = window->x + LINCOLS;
		w->w = window->w - LINCOLS;
	} else {
		w->x = window->x;
		w->w = window->w;
	}
	if (window == window->main) {
		rmkbd(window->kbd);
		window->kbd = mkkbd(kmap_getcontext(w->o.context));
	}
	w->top->xcol = 0;
	w->cursor->xcol = 0;
	w->linums = 0;
	w->top_changed = 1;
	w->linums = 0;
	w->db = 0;
	return w;
}

/* Database of last file positions */

#define MAX_FILE_POS 20 /* Maximum number of file positions we track */

static struct file_pos {
	LINK(struct file_pos) link;
	unsigned char *name;
	long line;
} file_pos = { { &file_pos, &file_pos } };

static int file_pos_count;

struct file_pos *find_file_pos(unsigned char *name)
{
	struct file_pos *p;
	for (p = file_pos.link.next; p != &file_pos; p = p->link.next)
		if (!zcmp(p->name, name)) {
			promote(struct file_pos,link,&file_pos,p);
			return p;
		}
	p = (struct file_pos *)malloc(sizeof(struct file_pos));
	p->name = zdup(name);
	p->line = 0;
	enquef(struct file_pos,link,&file_pos,p);
	if (++file_pos_count == MAX_FILE_POS) {
		free(deque_f(struct file_pos,link,file_pos.link.prev));
		--file_pos_count;
	}
	return p;
}

int restore_file_pos;

long get_file_pos(unsigned char *name)
{
	if (name && restore_file_pos) {
		struct file_pos *p = find_file_pos(name);
		return p->line;
	} else {
		return 0;
	}
}

void set_file_pos(unsigned char *name, long pos)
{
	if (name) {
		struct file_pos *p = find_file_pos(name);
		p->line = pos;
	}
}

void save_file_pos(FILE *f)
{
	struct file_pos *p;
	for (p = file_pos.link.prev; p != &file_pos; p = p->link.prev) {
		fprintf(f,"	%ld ",p->line);
		emit_string(f,p->name,zlen(p->name));
		fprintf(f,"\n");
	}
	fprintf(f,"done\n");
}

void load_file_pos(FILE *f)
{
	unsigned char *buf = 0;
	unsigned char *name = 0;
	while (vsgets(&buf,f) && zcmp(buf,USTR "done")) {
		unsigned char *p = buf;
		long pos;
		parse_ws(&p,'#');
		if (!parse_long(&p, &pos)) {
			parse_ws(&p, '#');
			if (parse_string(&p, &name) > 0) {
				set_file_pos(name, pos);
			}
		}
	}
}

/* Save file position for all windows */

void set_file_pos_all(Screen *t)
{
	/* Step through all windows */
	W *w = t->topwin;
	do {
		if (w->watom == &watomtw) {
			BW *bw = w->object;
			set_file_pos(bw->b->name, bw->cursor->line);
		}
		w = w->link.next;
	} while(w != t->topwin);
	/* Set through orphaned buffers */
	set_file_pos_orphaned();
}

void bwrm(BW *w)
{
	if (w->b == errbuf && w->b->count == 1) {
		/* Do not lose message buffer */
		orphit(w);
	}
	set_file_pos(w->b->name,w->cursor->line);
	prm(w->top);
	prm(w->cursor);
	brm(w->b);
	if (w->prompt)
		joe_free(w->prompt);
	joe_free(w);
}

int ustat(BW *bw)
{
	int c = brch(bw->cursor);
	unsigned char *dec = vsfmt(NULL, 0, USTR "%Od", bw->cursor->byte);
	unsigned char *hex = vsfmt(NULL, 0, USTR "%Ox", bw->cursor->byte);

	if (c == NO_MORE_DATA)
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("** Line %ld  Col %ld  Offset %s(0x%s) **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, dec, hex));
	else
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("** Line %ld  Col %ld  Offset %s(0x%s)  %s %d(0%o/0x%X) Width %d **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, dec, hex, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c)));

	return 0;
}

int ucrawlr(BW *bw)
{
	int amnt = bw->w / 2;

	pcol(bw->cursor, bw->cursor->xcol + amnt);
	bw->cursor->xcol += amnt;
	bw->offset += amnt;
	updall();
	return 0;
}

int ucrawll(BW *bw)
{
	int amnt = bw->w / 2;
	int curamnt = bw->w / 2;

	if (amnt > bw->offset) {
		amnt = bw->offset;
		curamnt = bw->offset;
	}
	if (!bw->offset)
		curamnt = bw->cursor->xcol;
	if (!curamnt)
		return -1;
	pcol(bw->cursor, bw->cursor->xcol - curamnt);
	bw->cursor->xcol -= curamnt;
	bw->offset -= amnt;
	updall();
	return 0;
}

/* If we are about to call bwrm, and b->count is 1, and orphan mode
 * is set, call this. */

void orphit(BW *bw)
{
	++bw->b->count; /* Assumes bwrm() is abour to be called */
	bw->b->orphan = 1;
	pdupown(bw->cursor, &bw->b->oldcur, USTR "orphit");
	pdupown(bw->top, &bw->b->oldtop, USTR "orphit");
}
@


1.75
log
@semiautomatic variables
@
text
@d1034 1
d1047 4
d1053 1
a1053 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
d1055 1
a1055 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,p,w->top->line+y-w->y),w);
d1057 1
a1057 1
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,p,w->top->line+y-w->y),w);
d1110 1
a1110 1
BW *bwmk(W *window, B *b, int prompt)
d1114 10
d1274 2
@


1.74
log
@UC -> USTR
@
text
@d883 1
a883 1
	else if (marking && w == (BW *)maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d894 1
a894 1
	if (marking && w == (BW *)maint->curwin->object)
d1008 1
a1008 1
	else if (marking && w == (BW *)maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d1021 1
a1021 1
	if (marking && w == (BW *)maint->curwin->object)
d1217 3
a1219 2
	unsigned char buf[1024];
	while (fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,USTR "done\n")) {
a1221 1
		unsigned char name[1024];
d1225 1
a1225 1
			if (parse_string(&p, name, sizeof(name)) > 0) {
a1263 3
	static unsigned char buf[160];
	unsigned char bf1[100];
	unsigned char bf2[100];
d1265 2
a1266 8

#if SIZEOF_LONG_LONG && SIZEOF_LONG_LONG == SIZEOF_OFF_T
		joe_snprintf_1(bf1, sizeof(bf1), "%lld", bw->cursor->byte);
		joe_snprintf_1(bf2, sizeof(bf2), "%llx", bw->cursor->byte);
#else
		joe_snprintf_1(bf1, sizeof(bf1), "%ld", bw->cursor->byte);
		joe_snprintf_1(bf2, sizeof(bf2), "%lx", bw->cursor->byte);
#endif
d1269 1
a1269 1
		joe_snprintf_4(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %s(0x%s) **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bf1, bf2);
d1271 2
a1272 2
		joe_snprintf_9(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %s(0x%s)  %s %d(0%o/0x%X) Width %d **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bf1, bf2, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
	msgnw(bw->parent, buf);
@


1.73
log
@change US to UC
@
text
@d32 1
a32 1
		p = pdup(best, UC "getto");
d112 1
a112 1
		newtop = pdup(w->cursor, UC "bwfllwt");
d194 1
a194 1
		tmp = pdup(p, UC "get_highlight_state");
d230 1
a230 1
		tmp = pdup(w->top, UC "get_highlight_state");
d243 1
a243 1
	tmp = pdup(w->top, UC "get_highlight_state");
d383 1
a383 1
		tmp=pdup(p, UC "lgen");
d863 1
a863 1
	P *q = pdup(w->top, UC "bwgenh");
d991 1
a991 1
		P *tmp = pdup(w->cursor, UC "bwgen");
d1024 1
a1024 1
	q = pdup(w->cursor, UC "bwgen");
d1126 2
a1127 2
		w->top = pdup(b->bof, UC "bwmk");
		w->cursor = pdup(b->bof, UC "bwmk");
d1218 1
a1218 1
	while (fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,UC "done\n")) {
d1323 2
a1324 2
	pdupown(bw->cursor, &bw->b->oldcur, UC "orphit");
	pdupown(bw->top, &bw->b->oldtop, UC "orphit");
@


1.72
log
@fix compiler warnings
@
text
@d32 1
a32 1
		p = pdup(best, US "getto");
d112 1
a112 1
		newtop = pdup(w->cursor, US "bwfllwt");
d194 1
a194 1
		tmp = pdup(p, US "get_highlight_state");
d230 1
a230 1
		tmp = pdup(w->top, US "get_highlight_state");
d243 1
a243 1
	tmp = pdup(w->top, US "get_highlight_state");
d383 1
a383 1
		tmp=pdup(p, US "lgen");
d863 1
a863 1
	P *q = pdup(w->top, US "bwgenh");
d991 1
a991 1
		P *tmp = pdup(w->cursor, US "bwgen");
d1024 1
a1024 1
	q = pdup(w->cursor, US "bwgen");
d1126 2
a1127 2
		w->top = pdup(b->bof, US "bwmk");
		w->cursor = pdup(b->bof, US "bwmk");
d1218 1
a1218 1
	while (fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,US "done\n")) {
d1323 2
a1324 2
	pdupown(bw->cursor, &bw->b->oldcur, US "orphit");
	pdupown(bw->top, &bw->b->oldtop, US "orphit");
@


1.71
log
@fix long long warnings
@
text
@d883 1
a883 1
	else if (marking && w==maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d894 1
a894 1
	if (marking && w==maint->curwin->object)
d1008 1
a1008 1
	else if (marking && w==maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d1021 1
a1021 1
	if (marking && w==maint->curwin->object)
@


1.70
log
@Add builtins.  Fix syntax error in python.jsf.in
@
text
@d913 1
d915 3
d1269 1
a1269 1
	if (sizeof(off_t) > 4) {
d1272 1
a1272 1
	} else {
d1275 1
a1275 1
	}
@


1.69
log
@large file patch, makefile fix, tty.c fix.
@
text
@d1260 3
a1262 1
	static unsigned char buf[80];
d1265 8
d1274 1
a1274 1
		joe_snprintf_4(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %lld(0x%llx) **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d1276 1
a1276 1
		joe_snprintf_9(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %lld(0x%llx)  %s %d(0%o/0x%X) Width %d **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.68
log
@more columns for line numbers
@
text
@d913 1
a913 1
			sprintf((char *)bf,"%8lx ",q->byte);
d1142 1
d1264 1
a1264 1
		joe_snprintf_4(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %ld(0x%lx) **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d1266 1
a1266 1
		joe_snprintf_9(buf, sizeof(buf), joe_gettext(_("** Line %ld  Col %ld  Offset %ld(0x%lx)  %s %d(0%o/0x%X) Width %d **")), bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.67
log
@transpose menus
@
text
@d844 7
a850 3
		joe_snprintf_1(buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
	else
		zcpy(buf, US "      ");
@


1.66
log
@gettext()
@
text
@d1146 2
d1168 1
a1168 1
	if (++file_pos_count == 20) {
d1198 1
a1198 1
	for (p = file_pos.link.next; p != &file_pos; p = p->link.next) {
d1223 17
@


1.65
log
@e option for s&r
@
text
@d844 1
a844 1
		joe_snprintf_1((char *)buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
d1173 2
d1177 1
a1177 1
	if (name) {
d1240 1
a1240 1
		joe_snprintf_4((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d1242 1
a1242 1
		joe_snprintf_9((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  %s %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.64
log
@A option for search
Restore cursor to old position
@
text
@d1276 3
d1281 1
a1281 1
	++bw->b->count;
@


1.63
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d982 8
a989 1
	if (markv(0) && markk->b == w->b)
d1144 75
d1221 5
@


1.62
log
@New line attribute cache.
@
text
@a7 1
#include "config.h"
a9 19
#include <stdio.h>
#include <string.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif


#include "b.h"
#include "blocks.h"
#include "kbd.h"
#include "rc.h"
#include "scrn.h"
#include "ublock.h"
#include "utils.h"
#include "syntax.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"

a12 4
extern int square;
extern int staen;
extern SCREEN *maint;
extern int bg_text;
a105 1
	int x;
a176 1
	P *tmp = 0;
a177 1
	long ln;
a273 2
	int q;

a308 2
	int q;

d375 1
a375 1
        int *syn;
d473 1
a473 1
				int wid;
d679 1
a679 1

d835 1
d909 1
a909 1
			sprintf((char *)bf,"%8x ",q->byte);
a1082 1
	int x;
@


1.61
log
@expand virtual memory
fix performance problem when you did joe +300000 big.v: not recording state of last line
@
text
@a148 2
			for(x=0; x!=w->h; ++x)
				invalidate_state(w->t->t->syntab + w->y + x);
a162 2
			for(x=0; x!=w->h; ++x)
				invalidate_state(w->t->t->syntab + w->y + x);
d211 4
d231 1
d306 1
a306 1
		lattr_cut(w->db, l + 1);
a309 2
			for (q = 0; q != w->h; ++q)
				invalidate_state(w->t->t->syntab + w->y + q);
a313 2
			for (q = 0; q != size; ++q)
				invalidate_state(w->t->t->syntab + w->y + start + q);
d342 1
a342 1
		lattr_cut(w->db, l + 1);
a344 2
			for (q = 0; q != w->h; ++q)
				invalidate_state(w->t->t->syntab + w->y + q);
a348 2
			for (q = 0; q != size; ++q)
				invalidate_state(w->t->t->syntab + w->y + start + q);
d1006 4
d1116 1
a1116 3
		for(x=0;x!=he-w->h; ++x)
			invalidate_state(w->t->t->syntab + w->y + w->h + x);
		}
d1164 1
a1164 1
	w->db = mk_lattr_db();
a1169 1
	rm_lattr_db(w->db);
@


1.60
log
@add joe_debug
@
text
@d226 1
a226 1
		if (!piseof(tmp))
@


1.59
log
@Valgrind fixes.
@
text
@d56 1
a56 1
		p = pdup(best);
d137 1
a137 1
		newtop = pdup(w->cursor);
d221 1
a221 1
		tmp = pdup(p);
d228 1
d256 1
a256 1
		tmp = pdup(w->top);
d269 1
a269 1
	tmp = pdup(w->top);
d421 1
a421 1
		tmp=pdup(p);
d896 1
a896 1
	P *q = pdup(w->top);
d1042 1
a1042 1
	q = pdup(w->cursor);
d1147 2
a1148 2
		w->top = pdup(b->bof);
		w->cursor = pdup(b->bof);
d1230 2
a1231 2
	pdupown(bw->cursor, &bw->b->oldcur);
	pdupown(bw->top, &bw->b->oldtop);
@


1.58
log
@Some more highlighting cache fixes.
@
text
@d1167 1
@


1.57
log
@Fix bug in bw.c where backspace was not causing redraw.
Add utils.h to i18n.c to fix itanium.
@
text
@d218 1
a218 1
	lattr_get(w->b->db, &ln, &state);
d227 1
a227 1
			lattr_set(w->b->db, line, state);
d303 4
a306 2
		lattr_cut(w->b->db, l + 1);
		if (l <= w->top->line)
d308 9
a316 2
		else if (l < w->top->line + w->h)
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
d319 1
a319 3
	if (!n)
		return;

d325 2
a329 2
			for(q=0; q!=w->h - (int)(l - w->top->line); ++q)
				invalidate_state(w->t->t->syntab + w->y + l - w->top->line + q);
a331 2
			for(q=0; q!=n+1; ++q)
				invalidate_state(w->t->t->syntab + w->y + l - w->top->line + q);
d340 2
d344 2
a345 2
		lattr_cut(w->b->db, l + 1);
		if (l <= w->top->line)
d347 9
a355 2
		else if (l < w->top->line + w->h)
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
d358 1
a358 1
/* Update the line where the delete began */
d362 1
a362 11
/* Just a single line? */
	if (!n)
		return;

/* Update highlight for line after first one which changed */
	if ((l+1) < w->top->line + w->h && (l+1) >= w->top->line) {
		invalidate_state(w->t->t->syntab + w->y + l + 1 - w->top->line);
		w->t->t->updtab[w->y + (l+1) - w->top->line] = 1;
		}

/* Update the line where the delete ended */
d1167 1
d1173 1
@


1.56
log
@Improve highlighting performance.
@
text
@a343 3
	if (!n)
		return;

d348 4
@


1.55
log
@
Allow entry of replacement blank replacement strings when search
prompting is enabled (basically eliminate automatic replace-string
prompting).

"bufed" now works like other file name commands (it prompts for a
buffer name, and allows completion).

H-scroll jumps left ~ 10 cols (this needs more work: it should be an
option).
@
text
@d204 1
a204 1
HIGHLIGHT_STATE get_highlight_state(BW *w,int line)
d208 26
d290 1
d300 13
d335 12
d1060 1
a1060 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d1062 1
a1062 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
d1064 1
a1064 1
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d1090 1
a1090 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d1092 1
a1092 1
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
d1094 1
a1094 1
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
@


1.54
log
@fix gcc-4.0.0 warnings
@
text
@d174 8
a181 1
		w->offset = w->cursor->xcol;
d183 2
a184 1
	} else if (w->cursor->xcol >= w->offset + w->w) {
@


1.53
log
@fix mouse & hex bugs
@
text
@d11 1
a12 1
#include <stdio.h>
d817 1
a817 1
		strcpy((char *)buf, "      ");
@


1.52
log
@Background color for screen item
@
text
@d74 3
a76 1
void bwfllw(BW *w)
d78 4
a81 2
	P *newtop;
	int x;
d83 6
a88 17
	if (w->o.hex) {
		/* Top must be a muliple of 16 bytes */
		if (w->top->byte%16) {
			pbkwd(w->top,w->top->byte%16);
		}

		/* Move backward */
		if (w->cursor->byte < w->top->byte) {
			long new_top = w->cursor->byte/16;
			if (mid) {
				if (new_top >= w->h / 2)
					new_top -= w->h / 2;
				else
					new_top = 0;
			}
			if (w->top->byte/16 - new_top < w->h)
				nscrldn(w->t->t, w->y, w->y + w->h, (int) (w->top->byte/16 - new_top));
d90 1
a90 2
				msetI(w->t->t->updtab + w->y, 1, w->h);
			pgoto(w->top,new_top*16);
d92 6
d99 7
a105 14
		/* Move forward */
		if (w->cursor->byte >= w->top->byte+(w->h*16)) {
			long new_top;
			if (mid) {
				new_top = w->cursor->byte/16 - w->h / 2;
			} else {
				new_top = w->cursor->byte/16 - (w->h - 1);
			}
			if (new_top - w->top->byte/16 < w->h)
				nscrlup(w->t->t, w->y, w->y + w->h, (int) (new_top - w->top->byte/16));
			else {
				msetI(w->t->t->updtab + w->y, 1, w->h);
			}
			pgoto(w->top, new_top*16);
d107 3
a109 7

		/* Adjust scroll offset */
		if (w->cursor->byte%16+60 < w->offset) {
			w->offset = w->cursor->byte%16+60;
			msetI(w->t->t->updtab + w->y, 1, w->h);
		} else if (w->cursor->byte%16+60 >= w->offset + w->w) {
			w->offset = w->cursor->byte%16+60 - (w->w - 1);
d112 21
a132 2
		return;
	} if (!pisbol(w->top)) {
d182 10
d826 1
a826 1
void bwgenh(BW *w,long from,long to)
d835 33
a975 9
	if (w->o.hex) {
		if (dosquare) {
			from = 0;
			to = 0;
		}
		bwgenh(w,from,to);
		return;
	}

@


1.51
log
@Background color
@
text
@d36 1
a36 1
extern int bg_color;
d334 1
a334 1
        int atr = BG_COLOR(bg_color); 
d369 1
a369 1
					atr |= BG_COLOR(bg_color);
d488 1
a488 1
					atr |= BG_COLOR(bg_color);
d611 1
a611 1
		done = eraeol(t, x, y);
d803 1
a803 1
		outatr(w->b->o.charmap, t, screen + z, attr + z, z, y, buf[z], BG_COLOR(bg_color)); 
d828 1
a828 1
		msetI(fmt,BG_COLOR(bg_color),76);
@


1.50
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d36 1
d334 1
a334 1
        int atr = 0;
d366 1
a366 1
			if(st.state!=-1)
d368 3
d485 5
a489 2
			if(st.state!=-1)
				atr=syn[idx++];
d803 1
a803 1
		outatr(w->b->o.charmap, t, screen + z, attr + z, z, y, buf[z], 0);
d828 1
a828 1
		msetI(fmt,0,76);
d836 2
a837 2
					fmt[10+x*3] = INVERSE;
					fmt[10+x*3+1] = INVERSE;
d842 1
a842 1
					fmt[60+x] = INVERSE;
d859 2
a860 2
					fmt[11+x*3] = INVERSE;
					fmt[11+x*3+1] = INVERSE;
d865 1
a865 1
					fmt[60+x] = INVERSE;
@


1.49
log
@Blocks to work in hex mode.
Overtype mode for hex.
@
text
@d148 2
a149 2
		// newtop = pdup(w->top);
		// getto() creates newtop
d824 1
a824 1
			sprintf(bf,"%8x ",q->byte);
d839 1
a839 1
					sprintf(bf,"%2.2x",c);
d862 1
a862 1
					sprintf(bf,"%2.2x",c);
@


1.48
log
@minor fixes for hex mode
@
text
@d803 1
a803 1
void bwgenh(BW *w)
d817 1
d821 1
d827 11
a837 1
				int c = pgetb(q);
d850 11
a860 1
				int c = pgetb(q);
d873 1
a873 1
		genfield(t, screen, attr, 0, y, w->offset, txt, 76, 0, w->w, 1);
d883 1
a883 1
	P *q = pdup(w->cursor);
a890 5
	if (w->o.hex) {
		bwgenh(w);
		return;
	}

d920 11
@


1.47
log
@Add wheel mouse support
@
text
@d86 6
a91 3
			pset(w->top, w->cursor);
			if (w->top->byte%16) {
				pbkwd(w->top,w->top->byte%16);
d93 5
d102 12
a113 2
			pset(w->top, w->cursor);
			pbkwd(w->top, (w->top->byte % 16) + (w->h-1) * 16);
d115 2
@


1.46
log
@hex edit mode
@
text
@d97 7
d799 2
a800 2
		memset(txt,' ',75);
		txt[75]=0;
d802 1
a802 1
			sprintf(bf,"%8X ",q->byte);
d804 1
a804 1
			for (x=0; x!=16; ++x) {
d807 1
a807 1
					sprintf(bf,"%2.2X",c);
d811 14
a824 1
						txt[59+x] = c;
d826 1
a826 1
						txt[59+x] = '.';
d831 1
a831 1
		genfield(t, screen, attr, 0, y, 0, txt, 75, 0, w->w, 1);
@


1.45
log
@Fix pointer leak
@
text
@d78 24
d776 40
d829 5
@


1.44
log
@Highlighter state now includes a saved string.
This improves shell and perl highlighters.
@
text
@d97 2
a98 1
		newtop = pdup(w->top);
@


1.43
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d76 1
d91 2
a92 1
			msetI(w->t->t->syntab + w->y, -1, w->h);
d106 2
a107 1
			msetI(w->t->t->syntab + w->y, -1, w->h);
d127 1
a127 1
int get_highlight_state(BW *w,int line)
d130 1
a130 1
	int state;
d135 4
a138 2
	if(!w->o.highlight || !w->o.syntax)
		return -1;
d141 1
a141 1
	if (w->parent->t->t->syntab[y]>=0)
d146 1
a146 1
	while (y > w->y && w->parent->t->t->syntab[y] < 0) --y;
d149 1
a149 1
	if (w->parent->t->t->syntab[y]<0) {
d151 1
a151 1
		state = 0;
d195 1
d204 2
a205 1
			msetI(w->t->t->syntab + w->y + l - w->top->line, -1, w->h - (int) (l - w->top->line));
d208 2
a209 1
			msetI(w->t->t->syntab + w->y + l - w->top->line, -1, (int) n + 1);
d224 1
a224 1
		w->t->t->syntab[w->y + (l+1) - w->top->line] = -1;
d256 1
a256 1
static int lgen(SCRN *t, int y, int *screen, int *attr, int x, int w, P *p, long int scr, long int from, long int to,int st,BW *bw)
d285 1
a285 1
	if(st!=-1) {
d313 1
a313 1
			if(st!=-1)
d429 1
a429 1
			if(st!=-1)
d865 1
d868 2
a869 1
		msetI(w->t->t->syntab + w->y + w->h, -1, he - w->h);
@


1.42
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d732 1
a732 1
		snprintf((char *)buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
d924 1
a924 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d926 1
a926 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  %s %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.41
log
@Fix marking mode so only window with cursor is
effected.

Ctrl-space clears selection when cursor is in
selection, otherwise it starts a new one.
@
text
@a869 2
	w->pid = 0;
	w->out = -1;
@


1.40
log
@Print locale on startup line.
Print encoding for ^K <space>.
Change koi8-T to koi8-t.
@
text
@d35 1
d769 1
a769 1
	else if (marking && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d782 1
a782 1
	if (marking)
@


1.39
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d927 1
a927 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.38
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d27 1
d365 1
a365 1
				if (p->b->o.utf8) {
d471 1
a471 1
					outatr(bw->b->o.utf8, bw->b->o.charmap, t, screen + x, attr + x, x, y, tach, c1|atr);
d482 1
a482 1
				if (p->b->o.utf8) { /* UTF-8 */
d510 1
a510 1
							outatr(bw->b->o.utf8, bw->b->o.charmap, t, screen + x, attr + x, x, y, '>', c1|atr);
d514 1
a514 1
						outatr(bw->b->o.utf8, bw->b->o.charmap, t, screen + x, attr + x, x, y, utf8_char, c1|atr);
d735 1
a735 1
		outatr(w->b->o.utf8, w->b->o.charmap, t, screen + z, attr + z, z, y, buf[z], 0);
d927 1
a927 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, c, c, c, joe_wcwidth(bw->o.utf8,c));
@


1.37
log
@Elimiante --pedantic warnings.
@
text
@d470 1
a470 1
					outatr(bw->b->o.utf8,t, screen + x, attr + x, x, y, tach, c1|atr);
d509 1
a509 1
							outatr(bw->b->o.utf8, t, screen + x, attr + x, x, y, '>', c1|atr);
d513 1
a513 1
						outatr(bw->b->o.utf8, t, screen + x, attr + x, x, y, utf8_char, c1|atr);
d734 1
a734 1
		outatr(w->b->o.utf8, t, screen + z, attr + z, z, y, buf[z], 0);
@


1.36
log
@Fix highlighter when there are utf-8 characters in file.

No longer depend on wctype.h (working towards not depending on
iconv()).
@
text
@d732 1
a732 1
		strcpy(buf, "      ");
@


1.35
log
@Better handling of iconv() conversion errors.

Better handling of error UTF-8 sequences.
@
text
@d368 1
a368 1
						wid = mk_wcwidth(1,c);
d393 2
a394 1
				}
d486 1
a486 1
						wid = mk_wcwidth(1,utf8_char);
d516 2
a517 1
				}
d926 1
a926 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, c, c, c, mk_wcwidth(bw->o.utf8,c));
@


1.34
log
@Print <XXXX> for unicode control characters.
@
text
@d264 1
d297 6
a302 1
			bc = *bp++;
d368 1
a368 1
						wid = mk_wcwidth(c);
d371 1
a371 1
					else if(c== -2) /* Incomplete sequence (FIXME: do something better here) */
d373 4
d412 6
a417 1
			bc = *bp++;
d485 2
a486 10
						if (utf8_char<32 || utf8_char==127) { /* ASCII control character */
							bc = utf8_char;
							xlat_utf_ctrl(&c, &bc);
							utf8_char = bc;
							c1 ^= c;
							wid = 1;
						} else {
							wid = mk_wcwidth(utf8_char);
						}
					} else if(c== -1) { /* Character taken */
d488 4
a491 1
					} else if(c== -2) { /* Incomplete sequence (FIXME: do something better here) */
d494 1
a494 1
					} else if(c== -3) { /* Invalid UTF-8 start character 128-191, 254, 255 */
a495 3
						xlat_utf_ctrl(&c, &bc);
						utf8_char = bc;
						c1 ^= c;
d497 1
a499 1
					xlat(&c, &bc);
a500 1
					c1 ^= c;
d677 1
a677 1
				xlat(&c, &bc);
d924 1
a924 1
		snprintf((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, c, c, c, mk_wcwidth(c));
@


1.33
log
@Allow UTF-8 in menu entries.

Clear up genfield() and genfmt() stuff.  Now control characters in
file names are properly displayed.

When UTF-8 character decodes to 127 - 159, 0 - 31, display it
as a control character.
@
text
@d470 1
a470 1
						if (utf8_char<32 || utf8_char>126 && utf8_char<160) { /* Control character */
@


1.32
log
@Fixed bug where '-syntax' on command line had
no effect.

Now if terminal is UTF-8, the default file type
is assumed to be UTF-8.
@
text
@d472 1
a472 1
							xlat(&c, &bc);
d486 1
a486 1
						xlat(&c, &bc);
@


1.31
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d130 1
a130 1
	if(!w->o.highlight || !w->syntax)
d146 2
a147 2
		if(w->syntax->sync_lines >= 0 && tmp->line > w->syntax->sync_lines)
			pline(tmp, tmp->line-w->syntax->sync_lines);
d151 1
a151 1
			state = parse(w->syntax,tmp,state);
d162 1
a162 1
		state = parse(w->syntax,tmp,state);
d277 1
a277 1
		parse(bw->syntax,tmp,st);
a898 4
	if (w->o.syntax)
		w->syntax = load_dfa(w->o.syntax);
	else
		w->syntax = 0;
@


1.30
log
@Added way to specify no. lines back to start parsing when we don't know
the syntax highlight parsing state.
@
text
@d454 1
a454 1
					outatr(t, screen + x, attr + x, x, y, tach, c1|atr);
d502 1
a502 1
							outatr(t, screen + x, attr + x, x, y, '>', c1|atr);
d506 1
a506 1
						outatr(t, screen + x, attr + x, x, y, utf8_char, c1|atr);
d726 1
a726 1
		outatr(t, screen + z, attr + z, z, y, buf[z], 0);
@


1.29
log
@Input of UTF-8 is now working.  For example, you
can cut and paste in an xterm.

Placed UTF-8 encoder and decoder in separate file.
@
text
@d146 2
a147 2
		if(tmp->line>50)
			pline(tmp, tmp->line-50);
@


1.28
log
@If a double-wide character hits right column, display '>' instead of
the character.  If a double-wide character is one column to the left
of the screen, display '<' instead of the character.
@
text
@d26 1
d265 1
a265 2
	int utf8_state=0;		/* 0=not waiting. >0 = N more chars for single utf-8 char */
	int utf8_char;
d272 2
d357 1
a357 1
				int wid = -1;
d359 9
a367 39
					if (utf8_state) {
						if ((bc&0xC0)==0x80) {
							--utf8_state;
							utf8_char = ((utf8_char<<6)|(bc&0x3F));
							if(!utf8_state)
								wid = mk_wcwidth(utf8_char);
						} else {
							/* FIXME: Do something better here for bad UTF-8 sequence */
							/* Like print all control chars... */
							utf8_state = 0;
							utf8_char = 'X';
							wid = 1;
						}
					} else if ((bc&0xE0)==0xC0) {
						/* 192 - 223 */
						utf8_state = 1;
						utf8_char = (bc&0x1F);
					} else if ((bc&0xF0)==0xE0) {
						/* 224 - 239 */
						utf8_state = 2;
						utf8_char = (bc&0x0F);
					} else if ((bc&0xF8)==0xF0) {
						/* 240 - 247 */
						utf8_state = 3;
						utf8_char = (bc&0x07);
					} else if ((bc&0xFC)==0xF8) {
						/* 248 - 251 */
						utf8_state = 4;
						utf8_char = (bc&0x03);
					} else if ((bc&0xFE)==0xFC) {
						/* 252 - 253 */
						utf8_state = 5;
						utf8_char = (bc&0x01);
					} else {
						/* 0 - 191, 254, 255 */
						utf8_state = 0;
						xlat(&c, &bc);
						utf8_char = bc;
						c1 ^= c;
a368 1
					}
a369 3
					xlat(&c, &bc);
					utf8_char = bc;
					c1 ^= c;
d464 12
a475 7
				if (p->b->o.utf8) {
					if (utf8_state) {
						if ((bc&0xC0)==0x80) {
							--utf8_state;
							utf8_char = ((utf8_char<<6)|(bc&0x3F));
							if(!utf8_state)
								wid = mk_wcwidth(utf8_char);
d477 1
a477 5
							/* FIXME: Do something better here for bad UTF-8 sequence */
							/* Like print all control chars... */
							utf8_state = 0;
							utf8_char = 'X';
							wid = 1;
d479 7
a485 23
					} else if ((bc&0xE0)==0xC0) {
						/* 192 - 223 */
						utf8_state = 1;
						utf8_char = (bc&0x1F);
					} else if ((bc&0xF0)==0xE0) {
						/* 224 - 239 */
						utf8_state = 2;
						utf8_char = (bc&0x0F);
					} else if ((bc&0xF8)==0xF0) {
						/* 240 - 247 */
						utf8_state = 3;
						utf8_char = (bc&0x07);
					} else if ((bc&0xFC)==0xF8) {
						/* 248 - 251 */
						utf8_state = 4;
						utf8_char = (bc&0x03);
					} else if ((bc&0xFE)==0xFC) {
						/* 252 - 253 */
						utf8_state = 5;
						utf8_char = (bc&0x01);
					} else {
						/* 0 - 191, 254, 255 */
						utf8_state = 0;
d491 1
a491 1
				} else {
@


1.27
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d255 1
d345 1
d412 1
d483 1
d486 1
a486 1
					outatr(t, screen + x, attr + x, x, y, ' ', c1|atr);
d546 10
a555 2
					outatr(t, screen + x, attr + x, x, y, utf8_char, c1|atr);
					x += wid;
@


1.26
log
@Fix lockup bug in UTF-8: hit down arrow on last line.  Bug was in pcol().

Start replacement of 'char *' with 'unsigned char *'.  I want to be able to
assign characters to integers and not get -1 (this finishes the conversion
to NO_MORE_DATA from MAXINT).
@
text
@d353 43
a395 24
				if (utf8_state) {
					--utf8_state;
					utf8_char = (utf8_char<<6)|(bc&0x3F);
				} else if ((bc&0x80)==0x00) {
					utf8_state = 0;
					utf8_char = bc;
				} else if ((bc&0xC0)==0x80) {
					utf8_state = 1;
					utf8_char = (bc&0x3F);
				} else if ((bc&0xE0)==0xC0) {
					utf8_state = 2;
					utf8_char = (bc&0x1F);
				} else if ((bc&0xF0)==0xE0) {
					utf8_state = 3;
					utf8_char = (bc&0x0F);
				} else if ((bc&0xF8)==0xF0) {
					utf8_state = 4;
					utf8_char = (bc&0x07);
				} else if ((bc&0xFC)==0xF8) {
					utf8_state = 5;
					utf8_char = (bc&0x03);
				} else if ((bc&0xFE)==0xFC) {
					utf8_state = 6;
					utf8_char = (bc&0x01);
d397 1
a397 1
					utf8_state = 0;
d399 2
d402 2
a403 4
				if(!utf8_state) {
					int wid = mk_wcwidth(utf8_char);
					if(wid<=0)
						wid=1;
d405 1
a405 1
					if (col >= scr) {
d408 3
d497 2
d500 2
a501 1
							/* FIXME: Should not take character */
d503 2
a504 1
							utf8_char = 'Y';
a505 3
					} else if ((bc&0x80)==0x00) {
						utf8_state = 0;
						utf8_char = bc;
d507 1
d511 1
d515 1
d519 1
d523 1
d527 1
d529 4
a532 4
						utf8_char = 'X';
					}
					if(!utf8_state) {
						wid = mk_wcwidth(utf8_char);
d752 1
a752 1
	char buf[12];
d757 1
a757 1
		snprintf(buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
d951 1
a951 1
	static char buf[80];
d955 1
a955 1
		snprintf(buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d957 1
a957 1
		snprintf(buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, c, c, c, mk_wcwidth(c));
@


1.25
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d258 1
a258 1
	char *bp;		/* Buffer pointer, 0 if not set */
d578 1
a578 1
	char *bp;		/* Buffer pointer, 0 if not set */
@


1.24
log
@Fix screen update bug introduced with Apr 7th change.

Option settings now can be based on file contents as well as
file name.

Added syntax indicator for status line.
@
text
@d245 1
a245 1
static int lgen(SCRN *t, int y, int *screen, int x, int w, P *p, long int scr, long int from, long int to,int st,BW *bw)
d263 3
d352 39
a390 3
			else if (++col == scr) {
				--amnt;
				goto loop;
d460 1
a460 1
					outatr(t, screen + x, x, y, ' ', c1|atr);
d469 48
a516 3
				xlat(&c, &bc);
				c ^= c1;
				outatr(t, screen + x, x, y, bc, c|atr);
d519 1
a519 1
				if (++x == w)
d721 1
a721 1
static void gennum(BW *w, int *screen, SCRN *t, int y, int *comp)
d732 1
a732 1
		outatr(t, screen + z, z, y, buf[z], 0);
d742 1
d782 2
a783 1
	for (screen = t->scrn + y * w->t->w; y != bot; ++y, screen += w->t->w) {
d787 1
a787 1
			gennum(w, screen, t, y, t->compose);
d799 1
a799 1
				magic(t, y, screen, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
d803 1
a803 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d805 1
a805 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
d807 1
a807 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d812 2
a813 1
	for (screen = t->scrn + w->y * w->t->w; y != w->y + w->cursor->line - w->top->line; ++y, screen += w->t->w) {
d817 1
a817 1
			gennum(w, screen, t, y, t->compose);
d829 1
a829 1
				magic(t, y, screen, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
d833 1
a833 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d835 1
a835 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
d837 1
a837 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
d923 1
a923 1
	int c = brc(bw->cursor);
d928 1
a928 1
		snprintf(buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, 255 & c, 255 & c, 255 & c);
@


1.23
log
@Fix highlighting bug.  Assume terminal supports color if it appears to be
ansi.
@
text
@a62 1
	p_goto_bol(p);
d270 1
@


1.22
log
@Clean up meaning of default color.

Allow syntax to be specified in joerc file: "-syntax perl"

Add class definitions to syntax files.

Add perl and verilog definitions (they need work).

Change joerc to assume files with . in their name do not want word
wrap enabled (except for .txt).
@
text
@d63 1
d704 1
a704 1
			if (t->insdel && !w->x) {
d714 1
a714 1
			}
d733 1
a733 1
			if (t->insdel && !w->x) {
d743 1
a743 1
			}
@


1.21
log
@More changes for syntax highlighting.
@
text
@d129 1
a129 1
	if(!w->o.highlight)
d817 4
a820 1
	w->syntax = load_dfa("c");
@


1.20
log
@Syntax highlighting baby steps.
@
text
@d25 1
a124 1
	int syn[1024];
d145 4
a148 1
		p_goto_bof(tmp); // Fixme
d150 1
a150 1
			state = parse_c(state,syn,tmp);
d161 1
a161 1
		state = parse_c(state,syn,tmp);
d245 1
a245 1
static int lgen(SCRN *t, int y, int *screen, int x, int w, P *p, long int scr, long int from, long int to,int st)
d263 2
a264 2
        int syn[1024];	/* Temporary hack */
        P *tmp=pdup(p);
d266 1
a266 1
        int atr;
d270 2
a271 1
		parse_c(st,syn,tmp);
d273 1
a273 6
		}
	else {
		for(idx=0;idx!=1024;++idx)
			syn[idx] = 0;
		idx = 0;
		}
d290 2
a291 1
			atr = syn[idx++];
d370 2
a371 1
			atr=syn[idx++];
a664 1
	int state= w->state;
d716 1
a716 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y));
d718 1
a718 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y));
d720 1
a720 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y));
d745 1
a745 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y));
d747 1
a747 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y));
d749 1
a749 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y));
d817 1
a817 1
	w->state = 0;
@


1.19
log
@change 0 to NULL where we're talking about pointers
@
text
@d84 1
a84 1
		else
d86 2
d98 1
a98 1
		else
d100 2
d116 62
d190 1
a190 1
		if (n >= w->h - (l - w->top->line))
d192 2
a193 1
		else
d195 2
d208 6
d242 1
a242 1
static int lgen(SCRN *t, int y, int *screen, int x, int w, P *p, long int scr, long int from, long int to)
d260 16
d291 1
d370 1
d419 1
a419 1
					outatr(t, screen + x, x, y, ' ', c1);
d430 1
a430 1
				outatr(t, screen + x, x, y, bc, c);
d664 1
d716 1
a716 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
d718 1
a718 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L);
d720 1
a720 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
d745 1
a745 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
d747 1
a747 1
					t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L);
d749 1
a749 1
				t->updtab[y] = lgen(t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
d765 1
a765 1
	if (he > w->h && w->y != -1)
d767 2
d816 2
@


1.18
log
@fix segafults in isalpha()-like functions
@
text
@d563 1
a563 1
	P *p = 0;
d694 2
a695 2
		b->oldtop = 0;
		w->top->owner = 0;
d697 2
a698 2
		b->oldcur = 0;
		w->cursor->owner = 0;
@


1.17
log
@rename getcontext() to kmap_getcontext() to prevent conflict with glibc
@
text
@d734 1
a734 1
	unsigned c = brc(bw->cursor);
d736 1
a736 1
	if (c == MAXINT)
@


1.16
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d716 1
a716 1
		window->kbd = mkkbd(getcontext(w->o.context));
@


1.15
log
@kill some warnings when compiled with -Wall
@
text
@d576 3
a578 1
			from = markb->xcol, to = markk->xcol, dosquare = 1;
d581 4
a584 2
		} else
			from = markb->byte, to = markk->byte;
d587 2
a588 1
			from = long_min(w->cursor->xcol, markb->xcol), to = long_max(w->cursor->xcol, markb->xcol);
d592 4
a595 2
		} else
			from = long_min(w->cursor->byte, markb->byte), to = long_max(w->cursor->byte, markb->byte);
d685 7
a691 4
	if (prompt || (!window->y && staen))
		w->y = window->y, w->h = window->h;
	else
		w->y = window->y + 1, w->h = window->h - 1;
d693 6
a698 2
		w->top = b->oldtop, b->oldtop = 0, w->top->owner = 0;
		w->cursor = b->oldcur, b->oldcur = 0, w->cursor->owner = 0;
d707 7
a713 4
	if (w->o.linums)
		w->x = window->x + LINCOLS, w->w = window->w - LINCOLS;
	else
		w->x = window->x, w->w = window->w;
d760 4
a763 2
	if (amnt > bw->offset)
		amnt = bw->offset, curamnt = bw->offset;
@


1.14
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d37 1
a37 1
		P *best;
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@a34 3
	long dist = MAXLONG;
	long d;
	P *best;
d36 15
a50 5
	if (!p) {
		if (d = (line - cur->line >= 0 ? line - cur->line : cur->line - line), d < dist)
			dist = d, best = cur;
		if (d = (line - top->line >= 0 ? line - top->line : top->line - line), d < dist)
			dist = d, best = top;
@


1.12
log
@change xlat macro into xlat(int *, char *) function
@
text
@d665 1
a665 1
	BW *w = (BW *) malloc(sizeof(BW));
d704 1
a704 1
	free(w);
@


1.11
log
@change indentation of do {} while() cycles
@
text
@d328 1
a328 1
				xlat(c, bc);
d491 1
a491 1
				xlat(c, bc);
@


1.10
log
@include only headers which are needed
@
text
@d253 1
a253 2
		}
		while (--amnt);
d324 1
a324 2
				}
				while (--ta);
d336 1
a336 2
		}
		while (--amnt);
d445 1
a445 2
		}
		while (--amnt);
d487 1
a487 2
				}
				while (--ta);
d497 1
a497 2
		}
		while (--amnt);
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@d16 4
a19 3
#include "tty.h"
#include "vfile.h"
#include "termcap.h"
d21 1
a21 1
#include "b.h"
a22 1
#include "w.h"
d25 1
a25 2
#include "blocks.h"
#include "bw.h"
@


1.8
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d2 8
a9 5
    Edit buffer window generation
    Copyright (C) 1992 Joseph H. Allen

    This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.7
log
@version 2.9.7-pre3
@
text
@d721 1
a721 1
	msgnw(bw, buf);
@


1.6
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d32 1
a32 3
P *getto(p, cur, top, line)
P *p, *cur, *top;
long line;
d61 1
a61 2
void bwfllw(w)
BW *w;
d108 1
a108 4
void bwins(w, l, n, flg)
BW *w;
long l, n;
int flg;
d125 1
a125 4
void bwdel(w, l, n, flg)
BW *w;
long l, n;
int flg;
d159 8
a166 8
static int lgen(t, y, screen, x, w, p, scr, from, to)
SCRN *t;
int y;
int *screen;			/* Screen line address */
int w;				/* Window */
P *p;				/* Buffer pointer */
long scr;			/* Starting column to display */
long from, to;			/* Range for marked block */
d381 8
a388 8
static int lgena(t, y, screen, x, w, p, scr, from, to)
SCRN *t;
int y;
int *screen;			/* Screen line address */
int w;				/* Window */
P *p;				/* Buffer pointer */
long scr;			/* Starting column to display */
long from, to;			/* Range for marked block */
d540 1
a540 5
void gennum(w, screen, t, y, comp)
BW *w;
int *screen;
SCRN *t;
int *comp;
d558 1
a558 2
void bwgen(w, linums)
BW *w;
d654 1
a654 3
void bwmove(w, x, y)
BW *w;
int x, y;
d660 1
a660 3
void bwresz(w, wi, he)
BW *w;
int wi, he;
d668 1
a668 4
BW *bwmk(window, b, prompt)
W *window;
B *b;
int prompt;
d704 1
a704 2
void bwrm(w)
BW *w;
d712 1
a712 2
int ustat(bw)
BW *bw;
d725 1
a725 2
int ucrawlr(bw)
BW *bw;
d736 1
a736 2
int ucrawll(bw)
BW *bw;
d754 1
a754 2
void orphit(bw)
BW *bw;
@


1.5
log
@changed as of joe-2.9.6
@
text
@d8 1
d11 3
a13 1
#include "config.h"
d32 4
a35 1
P *getto (P *p, P *cur, P *top, long line) {
d41 1
a41 1
		if (d = (line - cur->line >= 0 ? line - cur->line : cur->line - line), d < dist) {
d43 1
a43 2
		}
		if (d = (line - top->line >= 0 ? line - top->line : top->line - line), d < dist) { 
d45 2
a46 3
		}
		p = pdup (best);
		p_goto_bol (p);
d48 2
a49 2
	while (line > p->line) {
		if (!pnextl (p)) {
a50 2
		}
	}
d52 3
a54 4
		while (line < p->line) {
			pprevl (p);
		}
		p_goto_bol (p);
d63 3
a65 1
void bwfllw (BW *w) {
d68 28
a95 38
	if (w->cursor->line < w->top->line)
	  {
		  newtop = pdup (w->cursor);
		  p_goto_bol (newtop);
		  if (mid)
			  if (newtop->line >= w->h / 2)
				  pline (newtop, newtop->line - w->h / 2);
			  else
				  pset (newtop, newtop->b->bof);
		  if (w->top->line - newtop->line < w->h)
			  nscrldn (w->t->t, w->y, w->y + w->h,
				   (int) (w->top->line - newtop->line));
		  else
			  msetI (w->t->t->updtab + w->y, 1, w->h);
		  pset (w->top, newtop);
		  prm (newtop);
	  }
	else if (w->cursor->line >= w->top->line + w->h)
	  {
		  newtop = pdup (w->top);
		  if (mid)
			  newtop =
				  getto (NULL, w->cursor, w->top,
					 w->cursor->line - w->h / 2);
		  else
			  newtop =
				  getto (NULL, w->cursor, w->top,
					 w->cursor->line - (w->h - 1));
		  if (newtop->line - w->top->line < w->h)
			  nscrlup (w->t->t,
				   w->y,
				   w->y + w->h,
				   (int) (newtop->line - w->top->line));
		  else
			  msetI (w->t->t->updtab + w->y, 1, w->h);
		  pset (w->top, newtop);
		  prm (newtop);
	  }
d98 7
a104 10
	if (w->cursor->xcol < w->offset)
	  {
		  w->offset = w->cursor->xcol;
		  msetI (w->t->t->updtab + w->y, 1, w->h);
	  }
	else if (w->cursor->xcol >= w->offset + w->w)
	  {
		  w->offset = w->cursor->xcol - (w->w - 1);
		  msetI (w->t->t->updtab + w->y, 1, w->h);
	  }
d111 11
a121 16
void
bwins (w, l, n, flg)
     BW *w;
     long l, n;
     int flg;
{
	if (l + flg + n < w->top->line + w->h && l + flg >= w->top->line
	    && l + flg <= w->b->eof->line)
	  {
		  if (flg)
			  w->t->t->sary[w->y + l - w->top->line] =
				  w->t->t->li;
		  nscrldn (w->t->t, (int) (w->y + l + flg - w->top->line),
			   w->y + w->h, (int) n);
	  }
	if (l < w->top->line + w->h && l >= w->top->line)
d123 1
a123 2
			msetI (w->t->t->updtab + w->y + l - w->top->line, 1,
			       w->h - (int) (l - w->top->line));
d125 2
a126 2
			msetI (w->t->t->updtab + w->y + l - w->top->line, 1,
			       (int) n + 1);
d131 4
a134 5
void
bwdel (w, l, n, flg)
     BW *w;
     long l, n;
     int flg;
d144 1
a144 4
	if (l < w->top->line + w->h &&
	    (l + n >= w->top->line + w->h ||
	     l + n == w->b->eof->line
	     && w->b->eof->line >= w->top->line + w->h))
d147 1
a147 2
			msetI (w->t->t->updtab + w->y + l - w->top->line, 1,
			       w->h - (int) (l - w->top->line));
d150 2
a151 3
			msetI (w->t->t->updtab + w->y, 1, w->h);
	else if (l < w->top->line + w->h && l + n == w->b->eof->line &&
		 w->b->eof->line < w->top->line + w->h)
d154 1
a154 2
			msetI (w->t->t->updtab + w->y + l - w->top->line, 1,
			       (int) n);
d157 2
a158 4
			msetI (w->t->t->updtab + w->y, 1,
			       (int) (w->b->eof->line - w->top->line));
	else if (l + n < w->top->line + w->h && l + n > w->top->line
		 && l + n < w->b->eof->line)
d160 1
a160 3
			nscrlup (w->t->t,
				 (int) (w->y + l + flg - w->top->line),
				 w->y + w->h, (int) n);
d162 2
a163 2
			nscrlup (w->t->t, w->y, w->y + w->h,
				 (int) (l + n - w->top->line));
d168 8
a175 9
static int
lgen (t, y, screen, x, w, p, scr, from, to)
     SCRN *t;
     int y;
     int *screen;		/* Screen line address */
     int w;			/* Window */
     P *p;			/* Buffer pointer */
     long scr;			/* Starting column to display */
     long from, to;		/* Range for marked block */
d187 7
a193 10
	if (p->ofst >= p->hdr->hole)
	  {
		  bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		  amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	  }
	else
	  {
		  bp = p->ptr + p->ofst;
		  amnt = p->hdr->hole - p->ofst;
	  }
d199 63
a261 86
		do
		  {
			  bc = *bp++;
			  if (p->b->o.crlf && bc == '\r')
			    {
				    ++byte;
				    if (!--amnt)
				      {
					    pppl:
					      if (bp == p->ptr + SEGSIZ)
						{
							if (pnext (p))
							  {
								  bp = p->ptr;
								  amnt =
									  p->
									  hdr->
									  hole;
							  }
							else
								goto nnnl;
						}
					      else
						{
							bp =
								p->ptr +
								p->hdr->ehole;
							amnt =
								SEGSIZ -
								p->hdr->ehole;
							if (!amnt)
								goto pppl;
						}
				      }
				    if (*bp == '\n')
				      {
					      ++bp;
					      ++byte;
					      ++amnt;
					      goto eobl;
				      }
				  nnnl:
				    --byte; ++amnt;
			    }
			  if (square)
				  if (bc == '\t')
				    {
					    long tcol =
						    col + p->b->o.tab -
						    col % p->b->o.tab;
					    if (tcol > from && tcol <= to)
						    c1 = INVERSE;
					    else
						    c1 = 0;
				    }
				  else if (col >= from && col < to)
					  c1 = INVERSE;
				  else
					  c1 = 0;
			  else if (byte >= from && byte < to)
				  c1 = INVERSE;
			  else
				  c1 = 0;
			  ++byte;
			  if (bc == '\t')
			    {
				    ta = p->b->o.tab - col % p->b->o.tab;
				    if (ta + col > scr)
				      {
					      ta -= scr - col;
					      goto dota;
				      }
				    if ((col += ta) == scr)
				      {
					      --amnt;
					      goto loop;
				      }
			    }
			  else if (bc == '\n')
				  goto eobl;
			  else if (++col == scr)
			    {
				    --amnt;
				    goto loop;
			    }
		  }
d263 11
a273 15
	if (bp == p->ptr + SEGSIZ)
	  {
		  if (pnext (p))
		    {
			    bp = p->ptr;
			    amnt = p->hdr->hole;
			    goto lp;
		    }
	  }
	else
	  {
		  bp = p->ptr + p->hdr->ehole;
		  amnt = SEGSIZ - p->hdr->ehole;
		  goto lp;
	  }
d278 69
a346 98
		do
		  {
			  bc = *bp++;
			  if (p->b->o.crlf && bc == '\r')
			    {
				    ++byte;
				    if (!--amnt)
				      {
					    ppl:
					      if (bp == p->ptr + SEGSIZ)
						{
							if (pnext (p))
							  {
								  bp = p->ptr;
								  amnt =
									  p->
									  hdr->
									  hole;
							  }
							else
								goto nnl;
						}
					      else
						{
							bp =
								p->ptr +
								p->hdr->ehole;
							amnt =
								SEGSIZ -
								p->hdr->ehole;
							if (!amnt)
								goto ppl;
						}
				      }
				    if (*bp == '\n')
				      {
					      ++bp;
					      ++byte;
					      ++amnt;
					      goto eobl;
				      }
				  nnl:
				    --byte; ++amnt;
			    }
			  if (square)
				  if (bc == '\t')
				    {
					    long tcol =
						    scr + x - ox +
						    p->b->o.tab - (scr + x -
								   ox) %
						    p->b->o.tab;
					    if (tcol > from && tcol <= to)
						    c1 = INVERSE;
					    else
						    c1 = 0;
				    }
				  else
					  if (scr + x - ox >= from
					      && scr + x - ox < to)
					  c1 = INVERSE;
				  else
					  c1 = 0;
			  else if (byte >= from && byte < to)
				  c1 = INVERSE;
			  else
				  c1 = 0;
			  ++byte;
			  if (bc == '\t')
			    {
				    ta =
					    p->b->o.tab -
					    ((x - ox + scr) % p->b->o.tab);
				  dota:
				    do
				      {
					      outatr (t, screen + x, x, y,
						      ' ', c1);
					      if (ifhave)
						      goto bye;
					      if (++x == w)
						      goto eosl;
				      }
				    while (--ta);
			    }
			  else if (bc == '\n')
				  goto eobl;
			  else
			    {
				    xlat (c, bc);
				    c ^= c1;
				    outatr (t, screen + x, x, y, bc, c);
				    if (ifhave)
					    goto bye;
				    if (++x == w)
					    goto eosl;
			    }
		  }
d348 11
a358 15
	if (bp == p->ptr + SEGSIZ)
	  {
		  if (pnext (p))
		    {
			    bp = p->ptr;
			    amnt = p->hdr->hole;
			    goto loop;
		    }
	  }
	else
	  {
		  bp = p->ptr + p->hdr->ehole;
		  amnt = SEGSIZ - p->hdr->ehole;
		  goto loop;
	  }
d365 1
a365 1
		done = eraeol (t, x, y);
d384 1
a384 1
	pnextl (p);
d390 8
a397 9
static int
lgena (t, y, screen, x, w, p, scr, from, to)
     SCRN *t;
     int y;
     int *screen;		/* Screen line address */
     int w;			/* Window */
     P *p;			/* Buffer pointer */
     long scr;			/* Starting column to display */
     long from, to;		/* Range for marked block */
d409 7
a415 10
	if (p->ofst >= p->hdr->hole)
	  {
		  bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		  amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	  }
	else
	  {
		  bp = p->ptr + p->ofst;
		  amnt = p->hdr->hole - p->ofst;
	  }
d421 36
a456 45
		do
		  {
			  bc = *bp++;
			  if (square)
				  if (bc == '\t')
				    {
					    long tcol =
						    col + p->b->o.tab -
						    col % p->b->o.tab;
					    if (tcol > from && tcol <= to)
						    c1 = INVERSE;
					    else
						    c1 = 0;
				    }
				  else if (col >= from && col < to)
					  c1 = INVERSE;
				  else
					  c1 = 0;
			  else if (byte >= from && byte < to)
				  c1 = INVERSE;
			  else
				  c1 = 0;
			  ++byte;
			  if (bc == '\t')
			    {
				    ta = p->b->o.tab - col % p->b->o.tab;
				    if (ta + col > scr)
				      {
					      ta -= scr - col;
					      goto dota;
				      }
				    if ((col += ta) == scr)
				      {
					      --amnt;
					      goto loop;
				      }
			    }
			  else if (bc == '\n')
				  goto eobl;
			  else if (++col == scr)
			    {
				    --amnt;
				    goto loop;
			    }
		  }
d458 11
a468 15
	if (bp == p->ptr + SEGSIZ)
	  {
		  if (pnext (p))
		    {
			    bp = p->ptr;
			    amnt = p->hdr->hole;
			    goto lp;
		    }
	  }
	else
	  {
		  bp = p->ptr + p->hdr->ehole;
		  amnt = SEGSIZ - p->hdr->ehole;
		  goto lp;
	  }
d473 38
a510 52
		do
		  {
			  bc = *bp++;
			  if (square)
				  if (bc == '\t')
				    {
					    long tcol =
						    scr + x - ox +
						    p->b->o.tab - (scr + x -
								   ox) %
						    p->b->o.tab;
					    if (tcol > from && tcol <= to)
						    c1 = INVERSE;
					    else
						    c1 = 0;
				    }
				  else
					  if (scr + x - ox >= from
					      && scr + x - ox < to)
					  c1 = INVERSE;
				  else
					  c1 = 0;
			  else if (byte >= from && byte < to)
				  c1 = INVERSE;
			  else
				  c1 = 0;
			  ++byte;
			  if (bc == '\t')
			    {
				    ta =
					    p->b->o.tab -
					    ((x - ox + scr) % p->b->o.tab);
				  dota:
				    do
				      {
					      screen[x] = ' ' + c1;
					      if (++x == w)
						      goto eosl;
				      }
				    while (--ta);
			    }
			  else if (bc == '\n')
				  goto eobl;
			  else
			    {
				    xlat (c, bc);
				    c ^= c1;
				    screen[x] = c + bc;
				    if (++x == w)
					    goto eosl;
			    }
		  }
d512 11
a522 15
	if (bp == p->ptr + SEGSIZ)
	  {
		  if (pnext (p))
		    {
			    bp = p->ptr;
			    amnt = p->hdr->hole;
			    goto loop;
		    }
	  }
	else
	  {
		  bp = p->ptr + p->hdr->ehole;
		  amnt = SEGSIZ - p->hdr->ehole;
		  goto loop;
	  }
a531 1
      bye:
d545 1
a545 1
	pnextl (p);
d549 6
a554 1
void gennum (BW *w, int *screen, SCRN *t, int y, int *comp) {
d559 4
a562 5
	if (lin <= w->b->eof->line) {
		snprintf (buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
	} else {
		strcpy (buf, "      ");
	}
d564 2
a565 2
		outatr (t, screen + z, z, y, buf[z], 0);
		if (ifhave) {
a566 1
		}
d571 3
a573 1
void bwgen (BW *w, int linums) {
d576 1
a576 1
	P *q = pdup (w->cursor);
d585 2
a586 1
	if (markv (0) && markk->b == w->b) {
d591 1
a591 1
		} else {
d593 1
a593 2
		}
	} else if (marking && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d595 3
a597 3
			from = long_min (w->cursor->xcol, markb->xcol), to = long_max (w->cursor->xcol, markb->xcol);
			fromline = long_min (w->cursor->line, markb->line);
			toline = long_max (w->cursor->line, markb->line);
d599 2
a600 3
		} else {
			from = long_min (w->cursor->byte, markb->byte),	to = long_max (w->cursor->byte, markb->byte);
		}
d603 2
a604 3
	if (marking) {
		msetI (t->updtab + w->y, 1, w->h);
	}
d608 1
a608 1
		if (ifhave && !linums) {
d610 2
a611 4
		}
		if (linums) {
			gennum (w, screen, t, y, t->compose);
		}
d613 1
a613 1
			p = getto (p, w->cursor, w->top, w->top->line + y - w->y);
d615 9
a623 20
				pset (q, p);
				if (dosquare) {
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline) {
						lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					} else {
						lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
					}
				} else {
					lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				}
				magic (t, y, screen, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
			}
			if (dosquare) {
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline) {
					    t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
				} else {
					t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L);
				}
			} else {
				t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
d625 7
d637 1
a637 1
		if (ifhave && !linums) {
d639 2
a640 4
		}
		if (linums) {
			gennum (w, screen, t, y, t->compose);
		}
d642 1
a642 1
			p = getto (p, w->cursor, w->top, w->top->line + y - w->y);
d644 9
a652 11
				pset (q, p);
				if (dosquare) {
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline) {
						lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					} else {
						lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
					}
				} else {
					lgena (t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				}
				magic (t, y, screen, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
d654 18
a671 18
			if (dosquare) {
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline) {
					t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset, from, to);
				} else {
					t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset, 0L, 0L);
				}
			} else {
				t->updtab[y] = lgen (t, y, screen, w->x, w->x + w->w, p, w->offset,	from, to);
			}
		}
	}
	prm (q);
	if (p) {
		prm (p);
	}
}

void bwmove (BW *w, int x, int y) {
d676 6
a681 4
void bwresz (BW *w, int wi, int he) {
	if (he > w->h && w->y != -1) {
		msetI (w->t->t->updtab + w->y + w->h, 1, he - w->h);
	}
d686 6
a691 2
BW *bwmk (W *window, B *b, int prompt) {
	BW *w = (BW *) malloc (sizeof (BW));
d697 1
a697 1
	if (prompt || (!window->y && staen)) {
d699 1
a699 1
	} else {
a700 1
	}
d705 2
a706 2
		w->top = pdup (b->bof);
		w->cursor = pdup (b->bof);
d712 1
a712 1
	if (w->o.linums) {
d714 1
a714 1
	} else {
a715 1
	}
d717 2
a718 2
		rmkbd (window->kbd);
		window->kbd = mkkbd (getcontext (w->o.context));
d725 7
a731 5
void bwrm (BW *bw) {
	prm (bw->top);
	prm (bw->cursor);
	brm (bw->b);
	free (bw);
d734 3
a736 1
int ustat (BW *bw) {
d738 1
a738 1
	unsigned c = brc (bw->cursor);
d740 5
a744 12
	if (c == MAXINT) {
		snprintf (buf,sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx) **",
			 bw->cursor->line + 1, piscol (bw->cursor) + 1,
			 bw->cursor->byte, bw->cursor->byte);
	} else {
		snprintf (buf, sizeof(buf),
			 "** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) **",
			 bw->cursor->line + 1, piscol (bw->cursor) + 1,
			 bw->cursor->byte, bw->cursor->byte, 255 & c, 255 & c,
			 255 & c);
	}
	msgnw (bw, buf);
d748 3
a750 1
int ucrawlr (BW *bw) {
d753 1
a753 1
	pcol (bw->cursor, bw->cursor->xcol + amnt);
d756 1
a756 1
	updall ();
d760 3
a762 1
int ucrawll (BW *bw) {
d766 1
a766 1
	if (amnt > bw->offset) {
d768 1
a768 2
	}
	if (!bw->offset) {
d770 1
a770 2
	}
	if (!curamnt) {
d772 1
a772 2
	}
	pcol (bw->cursor, bw->cursor->xcol - curamnt);
d775 1
a775 1
	updall ();
d779 3
a781 1
void orphit (BW *bw) {
d784 2
a785 2
	pdupown (bw->cursor, &bw->b->oldcur);
	pdupown (bw->top, &bw->b->oldtop);
@


1.4
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Edit buffer window generation
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d9 1
d24 2
a25 2
int dspasis=0;
int marking=0;
d29 27
a55 23
P *getto(p,cur,top,line)
P *p,*cur,*top;
long line;
{
long dist=MAXLONG;
long d;
P *best;
if(!p)
 {
 if(d=(line-cur->line>=0?line-cur->line:cur->line-line), d<dist)
  dist=d, best=cur;
 if(d=(line-top->line>=0?line-top->line:top->line-line), d<dist)
  dist=d, best=top;
 p=pdup(best);
 pbol(p);
 }
while(line>p->line) if(!pnextl(p)) break;
if(line<p->line)
 {
 while(line<p->line) pprevl(p);
 pbol(p);
 }
return p;
d60 4
a63 1
int mid=0;
d65 38
a102 31
void bwfllw(w)
BW *w;
{
P *newtop;
if(w->cursor->line<w->top->line)
 {
 newtop=pdup(w->cursor);
 pbol(newtop);
 if(mid)
  if(newtop->line>=w->h/2) pline(newtop,newtop->line-w->h/2);
  else pset(newtop,newtop->b->bof);
 if(w->top->line-newtop->line<w->h)
  nscrldn(w->t->t,w->y,w->y+w->h,(int)(w->top->line-newtop->line));
 else msetI(w->t->t->updtab+w->y,1,w->h);
 pset(w->top,newtop);
 prm(newtop);
 }
else if(w->cursor->line>=w->top->line+w->h)
 {
 newtop=pdup(w->top);
 if(mid) newtop=getto(NULL,w->cursor,w->top,w->cursor->line-w->h/2);
 else newtop=getto(NULL,w->cursor,w->top,w->cursor->line-(w->h-1));
 if(newtop->line-w->top->line<w->h)
  nscrlup(w->t->t,
            w->y,
            w->y+w->h,
            (int)(newtop->line-w->top->line));
 else msetI(w->t->t->updtab+w->y,1,w->h);
 pset(w->top,newtop);
 prm(newtop);
 }
d105 10
a114 10
if(w->cursor->xcol<w->offset)
 {
 w->offset=w->cursor->xcol;
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
else if(w->cursor->xcol>=w->offset+w->w)
 {
 w->offset=w->cursor->xcol-(w->w-1);
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
d121 22
a142 15
void bwins(w,l,n,flg)
BW *w;
long l,n;
int flg;
{
if(l+flg+n<w->top->line+w->h && l+flg>=w->top->line && l+flg<=w->b->eof->line)
 {
 if(flg) w->t->t->sary[w->y+l-w->top->line]=w->t->t->li;
 nscrldn(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
 }
if(l<w->top->line+w->h && l>=w->top->line)
 if(n>=w->h-(l-w->top->line))
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,w->h-(int)(l-w->top->line));
 else
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,(int)n+1);
d147 5
a151 4
void bwdel(w,l,n,flg)
BW *w;
long l,n;
int flg;
d154 2
a155 2
if(l<w->top->line+w->h && l>=w->top->line)
 w->t->t->updtab[w->y+l-w->top->line]=1;
d158 2
a159 2
if(l+n<w->top->line+w->h && l+n>=w->top->line)
 w->t->t->updtab[w->y+l+n-w->top->line]=1;
d161 30
a190 24
if(l<w->top->line+w->h &&
   (l+n>=w->top->line+w->h ||
    l+n==w->b->eof->line && w->b->eof->line>=w->top->line+w->h))
 if(l>=w->top->line)
  /* Update window from l to end */
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,w->h-(int)(l-w->top->line));
 else
  /* Update entire window */
  msetI(w->t->t->updtab+w->y,1,w->h);
else if(l<w->top->line+w->h && l+n==w->b->eof->line &&
        w->b->eof->line<w->top->line+w->h)
 if(l>=w->top->line)
  /* Update window from l to end of file */
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,(int)n);
 else
  /* Update from beginning of window to end of file */
  msetI(w->t->t->updtab+w->y,1,(int)(w->b->eof->line-w->top->line));
else if(l+n<w->top->line+w->h &&
        l+n>w->top->line &&
        l+n<w->b->eof->line)
 if(l+flg>=w->top->line)
  nscrlup(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
 else
  nscrlup(w->t->t,w->y,w->y+w->h,(int)(l+n-w->top->line));
d195 18
a212 17
static int lgen(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int ox=x;
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta, c1;
unsigned char bc;
d215 244
a458 186
if(p->ofst>=p->hdr->hole)
 {
 bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
 amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
 }
else
 {
 bp=p->ptr+p->ofst;
 amnt=p->hdr->hole-p->ofst;
 }

if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(p->b->o.crlf && bc=='\r')
  {
  ++byte;
  if(!--amnt)
   {
   pppl:
   if(bp==p->ptr+SEGSIZ)
    {
    if(pnext(p))
     {
     bp=p->ptr;
     amnt=p->hdr->hole;
     }
    else goto nnnl;
    }
   else
    {
    bp=p->ptr+p->hdr->ehole;
    amnt=SEGSIZ-p->hdr->ehole;
    if(!amnt) goto pppl;
    }
   }
  if(*bp=='\n')
   {
   ++bp;
   ++byte;
   ++amnt;
   goto eobl;
   }
  nnnl: --byte; ++amnt;
  }
 if(square)
  if(bc=='\t')
   {
   long tcol=col+p->b->o.tab-col%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(col>=from && col<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-col%p->b->o.tab;
  if(ta+col>scr)
   {
   ta-=scr-col;
   goto dota;
   }
  if((col+=ta)==scr) { --amnt; goto loop; }
  }
 else if(bc=='\n') goto eobl;
 else if(++col==scr) { --amnt; goto loop; }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto lp;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto lp;
 }
goto eof;

loop:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(p->b->o.crlf && bc=='\r')
  {
  ++byte;
  if(!--amnt)
   {
   ppl:
   if(bp==p->ptr+SEGSIZ)
    {
    if(pnext(p))
     {
     bp=p->ptr;
     amnt=p->hdr->hole;
     }
    else goto nnl;
    }
   else
    {
    bp=p->ptr+p->hdr->ehole;
    amnt=SEGSIZ-p->hdr->ehole;
    if(!amnt) goto ppl;
    }
   }
  if(*bp=='\n')
   {
   ++bp;
   ++byte;
   ++amnt;
   goto eobl;
   }
  nnl: --byte; ++amnt;
  }
 if(square)
  if(bc=='\t')
   {
   long tcol=scr+x-ox+p->b->o.tab-(scr+x-ox)%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(scr+x-ox>=from && scr+x-ox<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-((x-ox+scr)%p->b->o.tab);
  dota:
  do
   {
   outatr(t,screen+x,x,y,' ',c1);
   if(ifhave) goto bye;
   if(++x==w) goto eosl;
   }
   while(--ta);
  }
 else if(bc=='\n') goto eobl;
 else
  {
  xlat(c,bc);
  c^=c1;
  outatr(t,screen+x,x,y,bc,c);
  if(ifhave) goto bye;
  if(++x==w) goto eosl;
  }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto loop;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto loop;
 }
goto eof;

eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
if(x!=w) done=eraeol(t,x,y);
else done=0;
d461 16
a476 12
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;

eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
d481 18
a498 17
static int lgena(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int ox=x;
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta, c1;
unsigned char bc;
d501 155
a655 121
if(p->ofst>=p->hdr->hole)
 {
 bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
 amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
 }
else
 {
 bp=p->ptr+p->ofst;
 amnt=p->hdr->hole-p->ofst;
 }

if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(square)
  if(bc=='\t')
   {
   long tcol=col+p->b->o.tab-col%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(col>=from && col<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-col%p->b->o.tab;
  if(ta+col>scr)
   {
   ta-=scr-col;
   goto dota;
   }
  if((col+=ta)==scr) { --amnt; goto loop; }
  }
 else if(bc=='\n') goto eobl;
 else if(++col==scr) { --amnt; goto loop; }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto lp;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto lp;
 }
goto eobl;

loop:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(square)
  if(bc=='\t')
   {
   long tcol=scr+x-ox+p->b->o.tab-(scr+x-ox)%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(scr+x-ox>=from && scr+x-ox<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-((x-ox+scr)%p->b->o.tab);
  dota:
  do
   {
   screen[x]=' '+c1;
   if(++x==w) goto eosl;
   }
   while(--ta);
  }
 else if(bc=='\n') goto eobl;
 else
  {
  xlat(c,bc);
  c^=c1;
  screen[x]=c+bc;
  if(++x==w) goto eosl;
  }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto loop;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto loop;
 }
goto eof;
eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
while(x!=w) screen[x++]=' ';
done=0;
d658 258
a915 152
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;

eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
}

void gennum(w,screen,t,y,comp)
BW *w;
int *screen;
SCRN *t;
int *comp;
 {
 char buf[12];
 int z;
 int lin=w->top->line+y-w->y;
 if(lin<=w->b->eof->line) sprintf(buf,"%5ld ",w->top->line+y-w->y+1);
 else strcpy(buf,"      ");
 for(z=0;buf[z];++z)
  {
  outatr(t,screen+z,z,y,buf[z],0);
  if(ifhave) return;
  comp[z]=buf[z];
  }
 }

void bwgen(w,linums)
BW *w;
{
int *screen;
P *p=0;
P *q=pdup(w->cursor);
int bot=w->h+w->y;
int y;
int dosquare=0;
long from,to;
long fromline,toline;
SCRN *t=w->t->t;
fromline=toline=from=to=0;

if(markv(0) && markk->b==w->b)
 if(square)
  {
  from=markb->xcol, to=markk->xcol, dosquare=1;
  fromline=markb->line;
  toline=markk->line;
  }
 else from=markb->byte, to=markk->byte;
else if(marking && markb && markb->b==w->b &&
        w->cursor->byte!= markb->byte && !from)
 if(square)
  {
  from=long_min(w->cursor->xcol,markb->xcol),
    to=long_max(w->cursor->xcol,markb->xcol);
  fromline=long_min(w->cursor->line,markb->line);
  toline=long_max(w->cursor->line,markb->line);
  dosquare=1;
  }
 else from=long_min(w->cursor->byte,markb->byte),
        to=long_max(w->cursor->byte,markb->byte);

if(marking) msetI(t->updtab+w->y,1,w->h);

y=w->cursor->line-w->top->line+w->y;
for(screen=t->scrn+y*w->t->w;y!=bot; ++y, screen+=w->t->w)
 {
 if(ifhave && !linums) break;
 if(linums) gennum(w,screen,t,y,t->compose);
 if(t->updtab[y])
  {
  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
  if(t->insdel && !w->x)
   {
   pset(q,p);
   if(dosquare)
    if(w->top->line+y-w->y>=fromline &&
       w->top->line+y-w->y<=toline)
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
    else
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
   else
    lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
   magic(t,y,screen,t->compose,
         (int)(w->cursor->xcol-w->offset+w->x));
   }
  if(dosquare)
   if(w->top->line+y-w->y>=fromline &&
      w->top->line+y-w->y<=toline)
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            from,to);
   else
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            0L,0L);
  else
   t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                           from,to);
  }
 }
 
y=w->y;
for(screen=t->scrn+w->y*w->t->w; y!=w->y+w->cursor->line-w->top->line;
    ++y, screen+=w->t->w)
 {
 if(ifhave && !linums) break;
 if(linums) gennum(w,screen,t,y,t->compose);
 if(t->updtab[y])
  {
  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
  if(t->insdel && !w->x)
   {
   pset(q,p);
   if(dosquare)
    if(w->top->line+y-w->y>=fromline &&
       w->top->line+y-w->y<=toline)
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
    else
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
   else
    lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
   magic(t,y,screen,t->compose,
         (int)(w->cursor->xcol-w->offset+w->x));
   }
  if(dosquare)
   if(w->top->line+y-w->y>=fromline &&
      w->top->line+y-w->y<=toline)
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            from,to);
   else
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            0L,0L);
  else
   t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                           from,to);
  }
 }
prm(q);
if(p) prm(p);
}

void bwmove(w,x,y)
BW *w;
int x,y;
{
w->x=x;
w->y=y;
a916 109

void bwresz(w,wi,he)
BW *w;
int wi, he;
{
if(he>w->h && w->y!= -1) msetI(w->t->t->updtab+w->y+w->h,1,he-w->h);
w->w=wi;
w->h=he;
}

BW *bwmk(window,b,prompt)
W *window;
B *b;
int prompt;
{
BW *w=(BW *)malloc(sizeof(BW));
w->parent=window;
w->pid=0;
w->out= -1;
w->b=b;
if(prompt || !window->y && staen)
 w->y=window->y, w->h=window->h;
else
 w->y=window->y+1, w->h=window->h-1;
if(b->oldcur)
 {
 w->top=b->oldtop, b->oldtop=0, w->top->owner=0;
 w->cursor=b->oldcur, b->oldcur=0, w->cursor->owner=0;
 }
else
 {
 w->top=pdup(b->bof);
 w->cursor=pdup(b->bof);
 }
w->t=window->t;
w->object=NULL;
w->offset=0;
w->o=w->b->o;
if(w->o.linums) w->x=window->x+LINCOLS, w->w=window->w-LINCOLS;
else w->x=window->x, w->w=window->w;
if(window==window->main)
 {
 rmkbd(window->kbd);
 window->kbd=mkkbd(getcontext(w->o.context));
 } 
w->top->xcol=0; w->cursor->xcol=0;
return w;
}

void bwrm(w)
BW *w;
{
prm(w->top);
prm(w->cursor);
brm(w->b);
free(w);
}

int ustat(bw)
BW *bw;
{
static char buf[80];
unsigned c=brc(bw->cursor);
if(c==MAXINT)
 sprintf(buf,"** Line %ld  Col %ld  Offset %ld(0x%lx) **",
         bw->cursor->line+1,piscol(bw->cursor)+1,bw->cursor->byte,
         bw->cursor->byte);
else
 sprintf(buf,"** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) **",
         bw->cursor->line+1,piscol(bw->cursor)+1,bw->cursor->byte,
         bw->cursor->byte,255&c,255&c,255&c);
msgnw(bw,buf);
return 0;
}

int ucrawlr(bw)
BW *bw;
 {
 int amnt=bw->w/2;
 pcol(bw->cursor,bw->cursor->xcol+amnt);
 bw->cursor->xcol+=amnt;
 bw->offset+=amnt;
 updall();
 return 0;
 }

int ucrawll(bw)
BW *bw;
 {
 int amnt=bw->w/2;
 int curamnt=bw->w/2;
 if(amnt>bw->offset) amnt=bw->offset, curamnt=bw->offset;
 if(!bw->offset) curamnt=bw->cursor->xcol;
 if(!curamnt) return -1;
 pcol(bw->cursor,bw->cursor->xcol-curamnt);
 bw->cursor->xcol-=curamnt;
 bw->offset-=amnt;
 updall();
 return 0;
 }

void orphit(bw)
BW *bw;
 {
 ++bw->b->count;
 bw->b->orphan=1;
 pdupown(bw->cursor,&bw->b->oldcur);
 pdupown(bw->top,&bw->b->oldtop);
 }
@


1.3
log
@changed as of joe-2.9.4
@
text
@d29 1
a29 1
#include "zstr.h"
@


1.2
log
@changed as of joe-2.9.2
@
text
@d601 4
a604 4
  from=Lmin(w->cursor->xcol,markb->xcol),
    to=Lmax(w->cursor->xcol,markb->xcol);
  fromline=Lmin(w->cursor->line,markb->line);
  toline=Lmax(w->cursor->line,markb->line);
d607 2
a608 2
 else from=Lmin(w->cursor->byte,markb->byte),
        to=Lmax(w->cursor->byte,markb->byte);
@


1.1
log
@Initial revision
@
text
@d19 1
d566 1
a566 1
 else zcpy(buf,"      ");
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
