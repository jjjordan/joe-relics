head	1.46;
access;
symbols
	joe_3_5:1.37
	joe-3_4:1.35
	help:1.35
	joe_3_1:1.22
	joe_3_0:1.17
	joe_2_9_8:1.10
	joe_2_9_8_pre1:1.7
	joe_2_9_7:1.5
	joe_2_9_7_pre3:1.5
	joe_2_9_7_pre2:1.4
	joe_2_9_6:1.3
	joe_2_9_5:1.2
	joe_2_9_4:1.2
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2008.11.01.02.10.39;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.30.22.30.03;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.29.02.06.05;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.28.22.55.41;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.25.04.08.47;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.25.01.44.44;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.25.01.02.36;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.01.17.44.40;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.24.16.04.14;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.21.18.03.34;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.21.16.29.49;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.20.00.58.25;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.19.01.22.49;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.16.00.00.54;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.14.00.23.08;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.14.00.07.49;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.13.00.23.45;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.12.02.06.37;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.11.20.02.50;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.10.16.06.35;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.22.03.40.21;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.22.00.57.11;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.12.20.11.16;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.09.22.01.06;	author jhallen;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.20.07.18.18;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.13.15.29.05;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.29.14.43.33;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.32;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.32;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Missed one for quoting
@
text
@ /*
 *	Editor engine
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_B_H
#define _JOE_B_H 1

/* A buffer is made up of a doubly-linked list of gap buffer.  These are the
 * buffer headers.  The buffers themselves can be swapped out.  A buffer with
 * point referring to it is guaranteed to be swapped in.
 */

struct header {
	LINK(H)	link;		/* Doubly-linked list of gap buffer headers */
	long	seg;		/* Swap file offset to gap buffer */
	int	hole;		/* Offset to gap */
	int	ehole;		/* Offset to after gap */
	int	nlines;		/* No. '\n's in this buffer */
};

/* A pointer to some location within a buffer.  After an insert or delete,
 * all of the pointers following the insertion or deletion point are
 * adjusted so that they keep pointing to the same character. */

struct point {
	LINK(P)	link;		/* Doubly-linked list of pointers for a particular buffer */

	B	*b;		/* Buffer */
	int	ofst;		/* Gap buffer offset */
	unsigned char	*ptr;	/* Gap buffer address */
	H	*hdr;		/* Gap buffer header */

	off_t	byte;		/* Buffer byte offset */
	long	line;		/* Line number */
	long	col;		/* current column */
	long	xcol;		/* cursor column (can be different from actual column) */
	int	valcol;		/* bool: is col valid? */
	int	end;		/* set if this is end of file pointer */

	P	**owner;	/* owner of this pointer.  owner gets cleared if pointer is deleted. */
	unsigned char *tracker;	/* Name of function who pdup()ed me */
};

/* Options: both BWs and Bs have one of these */

struct options {
	OPTIONS	*next;
	unsigned char	*name_regex;
	unsigned char	*contents_regex;
	int	overtype;
	int	lmargin;
	int	rmargin;
	int	autoindent;
	int	wordwrap;
	int	nobackup;
	int	tab;
	int	indentc;
	int	istep;
	unsigned char	*context;
	unsigned char	*lmsg;
	unsigned char	*rmsg;
	int	linums;
	int	readonly;
	int	french;
	int	flowed;
	int	spaces;
	int	crlf;
	int	highlight;	/* Set to enable highlighting */
	unsigned char *syntax_name;	/* Name of syntax to use */
	struct high_syntax *syntax;	/* Syntax for highlighting (load_syntax() from syntax_name happens in setopt()) */
	unsigned char *map_name;	/* Name of character set */
	struct charmap *charmap;	/* Character set */
	unsigned char *language;	/* Language of this buffer (for spell) */
	int	smarthome;	/* Set for smart home key */
	int	indentfirst;	/* Smart home goes to indentation point first */
	int	smartbacks;	/* Set for smart backspace key */
	int	purify;		/* Purify indentation */
	int	picture;	/* Picture mode */
	int	single_quoted;	/* Ignore '  ' for ^G */
	int	no_double_quoted; /* Don't ignore " " for ^G */
	int	c_comment;	/* Ignore text in C comments */
	int	cpp_comment;	/* Ignore text after // comments */
	int	pound_comment;	/* Ignore text after # comments */
	int	vhdl_comment;	/* Ignore text after -- comments */
	int	semi_comment;	/* Ignore text after ; comments */
	int	tex_comment;	/* Ignore text after % comments */
	int	hex;		/* Hex edit mode */
	unsigned char *text_delimiters;	/* Define word delimiters */
	unsigned char *cpara;	/* Characters which can indent paragraphcs */
	MACRO	*mnew;		/* Macro to execute for new files */
	MACRO	*mold;		/* Macro to execute for existing files */
	MACRO	*msnew;		/* Macro to execute before saving new files */
	MACRO	*msold;		/* Macro to execute before saving existing files */
	MACRO	*mfirst;	/* Macro to execute on first change */
};

/* A buffer */

struct buffer {
	LINK(B)	link;		/* Doubly-linked list of all buffers */
	P	*bof;		/* Beginning of file pointer */
	P	*eof;		/* End of file pointer */
	unsigned char	*name;	/* File name */
	int locked;		/* Set if we created a lock for this file */
	int ignored_lock;	/* Set if we didn't create a lock and we don't care (locked set in this case) */
	int didfirst;		/* Set after user attempted first change */
	long    mod_time;	/* Last modification time for file */
	long	check_time;	/* Last time we checked the file on disk */
	int	gave_notice;	/* Set if we already gave file changed notice for this file */
	int	orphan;		/* Set if buffer is orphaned: refcount is bumped up by one in this case */
	int	count;		/* Reference count.  Buffer is deleted if brm decrements count to 0 */
	int	changed;
	int	backup;
	void	*undo;
	P	*marks[11];	/* Bookmarks */
	OPTIONS	o;		/* Options */
	P	*oldcur;	/* Last cursor position before orphaning */
	P	*oldtop;	/* Last top screen position before orphaning */
	int	rdonly;		/* Set for read-only */
	int	internal;	/* Set for internal buffers */
	int	scratch;	/* Set for scratch buffers */
	int	er;		/* Error code when file was loaded */
	pid_t	pid;		/* Process id */
	int	out;		/* fd to write to process */
	struct lattr_db *db;	/* Linked list of line attribute databases */
	void (*parseone)(struct charmap *map,unsigned char *s,unsigned char **rtn_name,
	                 long *rtn_line);
	                        /* Error parser for this buffer */
};

extern B bufs;

extern int force;		/* Set to have final '\n' added to file */
extern int tabwidth;		/* Default tab width */

extern VFILE *vmem;		/* Virtual memory file used for buffer system */

extern unsigned char *msgs[];	/* File access status messages */

B *bmk PARAMS((B *prop));
void brm PARAMS((B *b));
void brmall();

B *bfind PARAMS((unsigned char *s));
B *bfind_scratch PARAMS((unsigned char *s));
B *bcheck_loaded PARAMS((unsigned char *s));
B *bfind_reload PARAMS((unsigned char *s));

P *pdup PARAMS((P *p, unsigned char *tr));
P *pdupown PARAMS((P *p, P **o, unsigned char *tr));
P *poffline PARAMS((P *p));
P *ponline PARAMS((P *p));
B *bonline PARAMS((B *b));
B *boffline PARAMS((B *b));

void prm PARAMS((P *p));
P *pset PARAMS((P *n, P *p));

P *p_goto_bof PARAMS((P *p));		/* move cursor to begging of file */
P *p_goto_eof PARAMS((P *p));		/* move cursor to end of file */
P *p_goto_bol PARAMS((P *p));		/* move cursor to begging of line */
P *p_goto_eol PARAMS((P *p));		/* move cursor to end of line */

P *p_goto_indent PARAMS((P *p,int c));	/* move cursor to indentation point */

int pisbof PARAMS((P *p));
int piseof PARAMS((P *p));
int piseol PARAMS((P *p));
int pisbol PARAMS((P *p));
int pisbow PARAMS((P *p));
int piseow PARAMS((P *p));

#define piscol(p) ((p)->valcol ? (p)->col : (pfcol(p), (p)->col))

int pisblank PARAMS((P *p));
int piseolblank PARAMS((P *p));

long pisindent PARAMS((P *p));
int pispure PARAMS((P *p,int c));

int pnext PARAMS((P *p));
int pprev PARAMS((P *p));

int pgetb PARAMS((P *p));
int prgetb PARAMS((P *p));

int pgetc PARAMS((P *p));
int prgetc PARAMS((P *p));

P *pgoto PARAMS((P *p, long int loc));
P *pfwrd PARAMS((P *p, long int n));
P *pbkwd PARAMS((P *p, long int n));

P *pfcol PARAMS((P *p));

P *pnextl PARAMS((P *p));
P *pprevl PARAMS((P *p));

P *pline PARAMS((P *p, long int line));

P *pcolwse PARAMS((P *p, long int goalcol));
P *pcol PARAMS((P *p, long int goalcol));
P *pcoli PARAMS((P *p, long int goalcol));
void pbackws PARAMS((P *p));
void pfill PARAMS((P *p, long int to, int usetabs));

P *pfind PARAMS((P *p, unsigned char *s, int len));
P *pifind PARAMS((P *p, unsigned char *s, int len));
P *prfind PARAMS((P *p, unsigned char *s, int len));
P *prifind PARAMS((P *p, unsigned char *s, int len));

/* copy text between 'from' and 'to' into new buffer */
B *bcpy PARAMS((P *from, P *to));	

void pcoalesce PARAMS((P *p));

void bdel PARAMS((P *from, P *to));

/* insert buffer 'b' into another at 'p' */
P *binsb PARAMS((P *p, B *b));
/* insert a block 'blk' of size 'amnt' into buffer at 'p' */
P *binsm PARAMS((P *p, unsigned char *blk, int amnt)); 

/* insert character 'c' into buffer at 'p' */
P *binsc PARAMS((P *p, int c));

/* insert byte 'c' into buffer at at 'p' */
P *binsbyte PARAMS((P *p, unsigned char c));

/* insert zero term. string 's' into buffer at 'p' */
P *binss PARAMS((P *p, unsigned char *s));

/* B *bload(char *s);
 * Load a file into a new buffer
 *
 * Returns with errno set to 0 for success,
 * -1 for new file (file doesn't exist)
 * -2 for read error
 * -3 for seek error
 * -4 for open error
 */
B *bload PARAMS((unsigned char *s));
B *bread PARAMS((int fi, long int max));
B *bfind PARAMS((unsigned char *s));
B *borphan PARAMS((void));

/* Save 'size' bytes beginning at 'p' into file with name in 's' */
int bsave PARAMS((P *p, unsigned char *s, off_t size,int flag));
int bsavefd PARAMS((P *p, int fd, off_t size));

unsigned char *parsens PARAMS((unsigned char *s, off_t *skip, off_t *amnt));
unsigned char *canonical PARAMS((unsigned char *s));

/* Get byte at pointer or return NO_MORE_DATA if pointer is at end of buffer */
int brc PARAMS((P *p));

/* Get character at pointer or return NO_MORE_DATA if pointer is at end of buffer */
int brch PARAMS((P *p));

/* Copy 'size' bytes from a buffer beginning at p into block 'blk' */
unsigned char *brmem PARAMS((P *p, unsigned char *blk, int size));

/* Copy 'size' bytes from a buffer beginning at p into a zero-terminated
 * C-string in an malloc block.
 */
unsigned char *brs PARAMS((P *p, int size));

/* Copy 'size' bytes from a buffer beginning at p into a variable length string. */
unsigned char *brvs PARAMS((unsigned char *s, P *p, int size));

/* Copy line into variable length string buf. */
unsigned char *brlinevs PARAMS((unsigned char *buf, P *p));

B *bnext PARAMS((void));
B *bafter PARAMS((B *b));
B *bprev PARAMS((void));

extern int berror;	/* bload error status code (use msgs[-berror] to get message) */

unsigned char **getbufs PARAMS((void));

int lock_it PARAMS((unsigned char *path,unsigned char *buf));
void unlock_it PARAMS((unsigned char *path));
int plain_file PARAMS((B *b));
int check_mod PARAMS((B *b));
int file_exists PARAMS((unsigned char *path));

int udebug_joe PARAMS((BW *bw));

extern int guesscrlf; /* Try to guess line ending when set */
extern int guessindent; /* Try to guess indent character and step when set */
extern int break_links; /* Break hard links on write */
extern int break_symlinks; /* Break symbolic links on write */

void set_file_pos_orphaned();

void breplace(B *b, B *n);

unsigned char *dequote(unsigned char *s);

#endif
@


1.45
log
@Syntax highlighter stack
@
text
@d302 2
@


1.44
log
@Add reloadall command.
@
text
@d73 1
a73 1
	struct high_syntax *syntax;	/* Syntax for highlighting (load_dfa() from syntax_name happens in setopt()) */
@


1.43
log
@Add reload command
@
text
@d134 2
@


1.42
log
@Add -flowed option.
@
text
@d298 2
@


1.41
log
@Add -no_double_quoted and -tex_comment
@
text
@d68 1
@


1.40
log
@Change break_links to not break symbolic links.
Add break_symlinks.
@
text
@d82 1
d88 1
@


1.39
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d291 1
@


1.38
log
@semiautomatic variables
@
text
@d58 1
@


1.37
log
@large file patch, makefile fix, tty.c fix.
@
text
@d1 1
a1 1
/*
a129 3
/* 31744 */
extern unsigned char stdbuf[stdsiz];	/* Convenient global buffer */

d266 1
a266 1
unsigned char *brvs PARAMS((P *p, int size));
d268 2
a269 3
/* Copy line into buffer.  Maximum of size bytes will be copied.  Buffer needs
   to be one bigger for NIL */
unsigned char *brzs PARAMS((P *p, unsigned char *buf, int size));
@


1.36
log
@aspell localized
@
text
@d36 1
a36 1
	long	byte;		/* Buffer byte offset */
d248 2
a249 2
int bsave PARAMS((P *p, unsigned char *s, long int size,int flag));
int bsavefd PARAMS((P *p, int fd, long int size));
d251 1
a251 1
unsigned char *parsens PARAMS((unsigned char *s, long int *skip, long int *amnt));
@


1.35
log
@transpose menus
@
text
@d74 1
@


1.34
log
@Less annoying lock messages.
@
text
@d294 2
@


1.33
log
@Better grep-find
@
text
@d107 1
@


1.32
log
@e option for s&r
@
text
@d123 3
@


1.31
log
@A option for search
Restore cursor to old position
@
text
@d107 2
a108 2
	int	orphan;
	int	count;
@


1.30
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d271 1
@


1.29
log
@add joe_debug
@
text
@d11 113
a123 2
#include "config.h"
#include "types.h"
d126 1
a126 1
extern unsigned char stdbuf[stdsiz];
d133 1
a133 1
extern unsigned char *msgs[];
d273 1
a273 2
#define error berror
extern int berror;
d277 11
a287 5
int lock_it(unsigned char *path,unsigned char *buf);
void unlock_it(unsigned char *path);
int plain_file(B *b);
int check_mod(B *b);
int file_exists(unsigned char *path);
@


1.28
log
@fix locks bug, jmacs improvements
@
text
@d33 2
a34 2
P *pdup PARAMS((P *p));
P *pdupown PARAMS((P *p, P **o));
@


1.27
log
@prefer bash over sh for cygwin
@
text
@d26 1
@


1.26
log
@Fix ~ expansion insanity
@
text
@d170 1
@


1.25
log
@File changed check.
@
text
@d135 1
@


1.24
log
@make locking optional
@
text
@d168 1
@


1.23
log
@file locking.
@
text
@d167 1
@


1.22
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d165 3
@


1.21
log
@Added "upper" and "lower" functions (no longer depend on "tr" command).
Fix jmacs transpose word command.
@
text
@d28 1
@


1.20
log
@^K E prompts to load original file from disk.
@
text
@d28 1
a28 1
B *bfind_check PARAMS((unsigned char *s));
@


1.19
log
@Warn if file changed on save.
@
text
@d28 2
@


1.18
log
@New status line escape sequence: %x shows current context (function
cursor is in).

More globs in *rc.in files.

csh.jsf lisp.jsf
@
text
@d128 1
a128 1
int bsave PARAMS((P *p, unsigned char *s, long int size));
@


1.17
log
@Added -purify option.
@
text
@d150 4
@


1.16
log
@*** empty log message ***
@
text
@d44 2
@


1.15
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d57 1
@


1.14
log
@Input of UTF-8 is now working.  For example, you
can cut and paste in an xterm.

Placed UTF-8 encoder and decoder in separate file.
@
text
@d54 1
d101 2
a102 2
/* insert byte 'c' into buffer at 'p' */
P *binsc PARAMS((P *p, unsigned char c));
d104 2
a105 2
/* UTF-8 encode 'c' and insert is at 'p' */
P *bins_utf8 PARAMS((P *p, int c));
@


1.13
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d99 2
a100 1
/* insert character 'c' into buffer at 'p' */
d102 4
@


1.12
log
@Fix lockup bug in UTF-8: hit down arrow on last line.  Bug was in pcol().

Start replacement of 'char *' with 'unsigned char *'.  I want to be able to
assign characters to integers and not get -1 (this finishes the conversion
to NO_MORE_DATA from MAXINT).
@
text
@d15 1
a15 1
extern char stdbuf[stdsiz];
d22 1
a22 1
extern char *msgs[];
d27 1
a27 1
B *bfind PARAMS((char *s));
d113 1
a113 1
B *bload PARAMS((char *s));
d115 1
a115 1
B *bfind PARAMS((char *s));
d119 1
a119 1
int bsave PARAMS((P *p, char *s, long int size));
d122 1
a122 1
char *parsens PARAMS((char *s, long int *skip, long int *amnt));
d139 1
a139 1
char *brvs PARAMS((P *p, int size));
d147 1
a147 1
char **getbufs PARAMS((void));
@


1.11
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d98 1
a98 1
P *binsm PARAMS((P *p, char *blk, int amnt)); 
d100 1
a100 1
P *binsc PARAMS((P *p, char c));
d102 1
a102 1
P *binss PARAMS((P *p, char *s));
d131 1
a131 1
char *brmem PARAMS((P *p, char *blk, int size));
d136 1
a136 1
char *brs PARAMS((P *p, int size));
@


1.10
log
@change type of variables holding string to unsigned char *
@
text
@d60 3
d124 3
d128 1
a128 1
int brc PARAMS((P *p));
@


1.9
log
@fix segafults in isalpha()-like functions
@
text
@d80 4
a83 4
P *pfind PARAMS((P *p, char *s, int len));
P *pifind PARAMS((P *p, char *s, int len));
P *prfind PARAMS((P *p, char *s, int len));
P *prifind PARAMS((P *p, char *s, int len));
@


1.8
log
@add comments - explain what is the function doing
@
text
@d121 1
a121 1
/* Get character at pointer or return MAXINT if pointer is at end of buffer */
@


1.7
log
@include only headers which are needed
@
text
@d51 1
a51 1
#define piscol(p) ((p)->valcol?(p)->col:(pfcol(p),(p)->col))
d61 1
d63 1
a64 3

int prgetc PARAMS((P *p));

a65 1
P *pgoto PARAMS((P *p, long int loc));
a68 1

a69 1

d85 2
a86 4
/* B *bcpy(P *from,P *to);
 * Copy text between from and to into a new buffer
 */
B *bcpy PARAMS((P *from, P *to));
d92 1
a92 3
/* P *binsb(P *p,B *b);
 * Insert an entire buffer 'b' into another buffer at 'p'
 */
d94 3
a96 9

/* P *binsm(P *p,char *blk,int amnt);
 * Insert a block 'blk' of size 'amnt' into buffer at 'p'
 */
P *binsm PARAMS((P *p, char *blk, int amnt));

/* P *binsc(P *p,char c);
 * Insert character into buffer at P
 */
d98 1
a98 4

/* P *binss(P *p,char *s);
 * Insert zero terminated string into buffer at P
 */
d110 1
a111 1
B *bload PARAMS((char *s));
d115 2
a116 3
/* int bsave(P *p,char *s,long size);
 * Save 'size' bytes beginning at 'p' into file with name in 's'
 */
a117 1
int bsave PARAMS((P *p, char *s, long int size));
d121 1
a121 3
/* int brc(P *p);
 * Get character at pointer or return MAXINT if pointer is at end of buffer
 */
d124 1
a124 3
/* char *brmem(P *p,char *blk,int size);
 * Copy 'size' bytes from a buffer beginning at p into block 'blk'
 */
d127 1
a127 2
/* char *brs(P *p,int size);
 * Copy 'size' bytes from a buffer beginning at p into a zero-terminated
d132 1
a132 4
/* char *brvs(P *p,int size);
 * Copy 'size' bytes from a buffer beginning at p into a variable length
 * string.
 */
@


1.6
log
@put struct definitions and other goodies into types.h
@
text
@a13 4
#include "queue.h"
#include "rc.h"
#include "vfile.h"

@


1.5
log
@version 2.9.7-pre3
@
text
@d1 9
a9 2
#ifndef _Ib
#define _Ib 1
d12 2
a17 1
#define stdsiz 8192
a19 49

typedef struct buffer B;
typedef struct point P;
typedef struct header H;

struct header {
	LINK(H) link;		/* LINK ??? */
	long seg;		/* ??? */
	int hole;		/* ??? */
	int ehole;		/* ??? */
	int nlines;		/* ??? */
};

struct point {
	LINK(P) link;		/* ?LINK ??? */

	B *b;			/* ?B ??? */
	int ofst;		/* ??? */
	char *ptr;		/* ??? */
	H *hdr;			/* ?H ??? */

	long byte;		/* ??? */
	long line;		/* ??? */
	long col;		/* ??? */
	long xcol;		/* ??? */
	int valcol;		/* ??? */
	int end;		/* ??? */

	P **owner;		/* ??? */
};

struct buffer {
	LINK(B) link;
	P *bof;
	P *eof;
	char *name;
	int orphan;
	int count;
	int changed;
	int backup;
	void *undo;
	P *marks[10];		/* Bookmarks */
	OPTIONS o;		/* Options */
	P *oldcur;		/* Last cursor position before orphaning */
	P *oldtop;		/* Last top screen position before orphaning */
	int rdonly;		/* Set for read-only */
	int internal;		/* Set for internal buffers */
	int er;			/* Error code when file was loaded */
};
@


1.4
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d69 2
a70 2
B *bmk();
void brm();
d72 1
a72 1
B *bfind();
d74 21
a94 21
P *pdup();
P *pdupown();
P *poffline();
P *ponline();
B *bonline();
B *boffline();

void prm();
P *pset();

P *p_goto_bof(P * p);		/* move cursor to begging of file */
P *p_goto_eof(P * p);		/* move cursor to end of file */
P *p_goto_bol(P * p);		/* move cursor to begging of line */
P *p_goto_eol(P * p);		/* move cursor to end of line */

int pisbof();
int piseof();
int piseol();
int pisbol();
int pisbow();
int piseow();
d98 1
a98 1
int pisblank();
d100 1
a100 1
long pisindent();
d102 2
a103 2
int pnext();
int pprev();
d105 1
a105 1
int pgetc();
d107 1
a107 1
P *pfwrd();
d109 1
a109 1
int prgetc();
d111 2
a112 2
P *pbkwd();
P *pgoto();
d114 1
a114 1
P *pfcol();
d117 1
a117 1
P *pnextl();
d119 1
a119 1
P *pprevl();
d121 1
a121 1
P *pline();
d123 5
a127 5
P *pcolwse();
P *pcol();
P *pcoli();
void pbackws();
void pfill();
d129 4
a132 4
P *pfind();
P *pifind();
P *prfind();
P *prifind();
d137 1
a137 1
B *bcpy();
d139 1
a139 1
void pcoalesce();
d141 1
a141 1
void bdel();
d146 1
a146 1
P *binsb();
d151 1
a151 1
P *binsm();
d156 1
a156 1
P *binsc();
d161 1
a161 1
P *binss();
d172 4
a175 4
B *bread();
B *bload();
B *bfind();
B *borphan();
d180 2
a181 2
int bsavefd();
int bsave();
d183 1
a183 1
char *parsens();
d188 1
a188 1
int brc();
d193 1
a193 1
char *brmem();
d199 1
a199 1
char *brs();
d205 1
a205 1
char *brvs();
d207 2
a208 2
B *bnext();
B *bprev();
d213 1
a213 1
char **getbufs();
@


1.3
log
@changed as of joe-2.9.6
@
text
@d18 5
a22 5
	LINK (H) link;			/* ??? */
	long seg;			/* ??? */
	int hole;			/* ??? */
	int ehole;			/* ??? */
	int nlines;			/* ??? */
d26 1
a26 13
	LINK (P) link;			/* ??? */
		
	B *b;				/* ??? */
	int ofst;			/* ??? */
	char *ptr;			/* ??? */
	H *hdr;				/* ??? */

	long byte;			/* ??? */
	long line;			/* ??? */
	long col;			/* ??? */
	long xcol;			/* ??? */
	int valcol;			/* ??? */
	int end;			/* ??? */
d28 13
a40 1
	P **owner;			/* ??? */
d44 1
a44 1
	LINK (B) link;
d69 2
a70 2
B *bmk ();
void brm ();
d72 1
a72 1
B *bfind ();
d74 21
a94 21
P *pdup ();
P *pdupown ();
P *poffline ();
P *ponline ();
B *bonline ();
B *boffline ();

void prm ();
P *pset ();

P *p_goto_bof (P *p);		/* move cursor to begging of file */
P *p_goto_eof (P *p);		/* move cursor to end of file */
P *p_goto_bol (P *p);		/* move cursor to begging of line */
P *p_goto_eol (P *p);		/* move cursor to end of line */

int pisbof ();
int piseof ();
int piseol ();
int pisbol ();
int pisbow ();
int piseow ();
d98 1
a98 1
int pisblank ();
d100 1
a100 1
long pisindent ();
d102 2
a103 2
int pnext ();
int pprev ();
d105 1
a105 1
int pgetc ();
d107 1
a107 1
P *pfwrd ();
d109 1
a109 1
int prgetc ();
d111 2
a112 2
P *pbkwd ();
P *pgoto ();
d114 1
a114 1
P *pfcol ();
d117 1
a117 1
P *pnextl ();
d119 1
a119 1
P *pprevl ();
d121 1
a121 1
P *pline ();
d123 5
a127 5
P *pcolwse ();
P *pcol ();
P *pcoli ();
void pbackws ();
void pfill ();
d129 4
a132 4
P *pfind ();
P *pifind ();
P *prfind ();
P *prifind ();
d137 1
a137 1
B *bcpy ();
d139 1
a139 1
void pcoalesce ();
d141 1
a141 1
void bdel ();
d146 1
a146 1
P *binsb ();
d151 1
a151 1
P *binsm ();
d156 1
a156 1
P *binsc ();
d161 1
a161 1
P *binss ();
d172 4
a175 4
B *bread ();
B *bload ();
B *bfind ();
B *borphan ();
d180 2
a181 2
int bsavefd ();
int bsave ();
d183 1
a183 1
char *parsens ();
d188 1
a188 1
int brc ();
d193 1
a193 1
char *brmem ();
d199 1
a199 1
char *brs ();
d205 1
a205 1
char *brvs ();
d207 2
a208 2
B *bnext ();
B *bprev ();
d213 1
a213 1
char **getbufs ();
@


1.2
log
@changed as of joe-2.9.4
@
text
@d17 6
a22 7
struct header
{
  LINK (H) link;
  long seg;
  int hole;
  int ehole;
  int nlines;
d25 14
a38 15
struct point
{
  LINK (P) link;

  B *b;
  int ofst;
  char *ptr;
  H *hdr;

  long byte;
  long line;
  long col;
  long xcol;
  int valcol;
  int end;
d40 1
a40 1
  P **owner;
d43 17
a59 18
struct buffer
{
  LINK (B) link;
  P *bof;
  P *eof;
  char *name;
  int orphan;
  int count;
  int changed;
  int backup;
  void *undo;
  P *marks[10];			/* Bookmarks */
  OPTIONS o;			/* Options */
  P *oldcur;			/* Last cursor position before orphaning */
  P *oldtop;			/* Last top screen position before orphaning */
  int rdonly;			/* Set for read-only */
  int internal;			/* Set for internal buffers */
  int er;			/* Error code when file was loaded */
d84 4
a87 2
P *pbof ();
P *peof ();
a115 3
P *pbol ();

P *peol ();
d210 2
a211 1
extern int error;
@


1.1
log
@Initial revision
@
text
@d18 7
a24 7
 {
 LINK(H) link;
 long seg;
 int hole;
 int ehole;
 int nlines;
 };
d27 17
a43 17
 {
 LINK(P) link;
 
 B *b;
 int ofst;
 char *ptr;
 H *hdr;
 
 long byte;
 long line;
 long col;
 long xcol;
 int valcol;
 int end;
 
 P **owner;
 };
d46 18
a63 18
 {
 LINK(B) link;
 P *bof;
 P *eof;
 char *name;
 int orphan;
 int count;
 int changed;
 int backup;
 void *undo;
 P *marks[10];			/* Bookmarks */
 OPTIONS o;			/* Options */
 P *oldcur;			/* Last cursor position before orphaning */
 P *oldtop;			/* Last top screen position before orphaning */
 int rdonly;			/* Set for read-only */
 int internal;			/* Set for internal buffers */
 int er;			/* Error code when file was loaded */
 };
d65 2
a66 2
extern int force;	/* Set to have final '\n' added to file */
extern int tabwidth;	/* Default tab width */
d68 1
a68 1
extern VFILE *vmem;	/* Virtual memory file used for buffer system */
d72 2
a73 2
B *bmk();
void brm();
d75 1
a75 1
B *bfind();
d77 19
a95 19
P *pdup();
P *pdupown();
P *poffline();
P *ponline();
B *bonline();
B *boffline();

void prm();
P *pset();

P *pbof();
P *peof();

int pisbof();
int piseof();
int piseol();
int pisbol();
int pisbow();
int piseow();
d99 1
a99 1
int pisblank();
d101 1
a101 1
long pisindent();
d103 2
a104 2
int pnext();
int pprev();
d106 1
a106 1
int pgetc();
d108 1
a108 1
P *pfwrd();
d110 1
a110 1
int prgetc();
d112 2
a113 2
P *pbkwd();
P *pgoto();
d115 1
a115 1
P *pfcol();
d117 1
a117 1
P *pbol();
d119 1
a119 1
P *peol();
d121 1
a121 1
P *pnextl();
d123 1
a123 1
P *pprevl();
d125 1
a125 1
P *pline();
d127 5
a131 5
P *pcolwse();
P *pcol();
P *pcoli();
void pbackws();
void pfill();
d133 4
a136 4
P *pfind();
P *pifind();
P *prfind();
P *prifind();
d141 1
a141 1
B *bcpy();
d143 1
a143 1
void pcoalesce();
d145 1
a145 1
void bdel();
d150 1
a150 1
P *binsb();
d155 1
a155 1
P *binsm();
d160 1
a160 1
P *binsc();
d165 1
a165 1
P *binss();
d176 4
a179 4
B *bread();
B *bload();
B *bfind();
B *borphan();
d184 2
a185 2
int bsavefd();
int bsave();
d187 1
a187 1
char *parsens();
d192 1
a192 1
int brc();
d197 1
a197 1
char *brmem();
d203 1
a203 1
char *brs();
d209 1
a209 1
char *brvs();
d211 2
a212 2
B *bnext();
B *bprev();
d216 1
a216 1
char **getbufs();
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
