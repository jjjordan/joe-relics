head	1.61;
access;
symbols
	joe_3_5:1.57
	joe-3_4:1.55
	help:1.55
	joe_3_1:1.38
	joe_3_0:1.30
	joe_2_9_8:1.19
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.2
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2008.11.01.02.07.46;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.24.16.24.40;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.23.05.27.50;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.20.04.27.10;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.03.21.01.30;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.06.04.27.31;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.05.02.06.40;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.28.19.42.05;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.28.15.26.30;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.28.15.13.15;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.28.06.17.08;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.28.05.05.36;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.26.05.47.32;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.21.04.46.59;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.27.05.29.32;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.07.19.59.49;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.25.02.32.27;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.13.03.51.53;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.03.22.55.51;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.03.12.28.48;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.03.12.17.02;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.25.15.52.36;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.25.00.53.41;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.18.02.26.36;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.15.19.40.04;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.15.14.29.08;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.13.19.35.05;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.12.20.11.16;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.08.00.34.58;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.07.00.19.20;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.01.19.49.36;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.04.17.39.13;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.10.12.09.39;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.08.12;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.12.19.16;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.21.11.23.05;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.13.57.21;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.35.52;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.48.08;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.05;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.05;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.61
log
@quoting fixes
@
text
@/*
 *	Device independant TTY interface for JOE
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int bg_text = 0; /* Background color for text */
int skiptop = 0;
int lines = 0;
int columns = 0;
int notite = 0;
int usetabs = 0;
int assume_color = 0;
int assume_256color = 0;

/* How to display characters (especially the control ones) */
/* here are characters ... */
unsigned char xlatc[256] = {
	 64,  65,  66,  67,  68,  69,  70,  71,			/*   8 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/*  16 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/*  24 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/*  32 */
	 32,  33,  34,  35,  36,  37,  38,  39,			/*  40 */
	 40,  41,  42,  43,  44,  45,  46,  47,			/*  48 */
	 48,  49,  50,  51,  52,  53,  54,  55,			/*  56 */
	 56,  57,  58,  59,  60,  61,  62,  63,			/*  64 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/*  72 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/*  80 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/*  88 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/*  96 */
	 96,  97,  98,  99, 100, 101, 102, 103,			/* 104 */
	104, 105, 106, 107, 108, 109, 110, 111,			/* 112 */
	112, 113, 114, 115, 116, 117, 118, 119,			/* 120 */
	120, 121, 122, 123, 124, 125, 126,  63,			/* 128 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/* 136 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/* 144 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/* 152 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/* 160 */
	 32,  33,  34,  35,  36,  37,  38,  39,			/* 168 */
	 40,  41,  42,  43,  44,  45,  46,  47,			/* 176 */
	 48,  49,  50,  51,  52,  53,  54,  55,			/* 184 */
	 56,  57,  58,  59,  60,  61,  62,  63,			/* 192 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/* 200 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/* 208 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/* 216 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/* 224 */
	 96,  97,  98,  99, 100, 101, 102, 103,			/* 232 */
	104, 105, 106, 107, 108, 109, 110, 111,			/* 240 */
	112, 113, 114, 115, 116, 117, 118, 119,			/* 248 */
	120, 121, 122, 123, 124, 125, 126,  63			/* 256 */
};
/* ... and here their attributes */ 
unsigned xlata[256] = {
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*   4 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*   8 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  12 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  16 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  20 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  24 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  28 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  32 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  48 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  64 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  80 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  96 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 112 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNDERLINE,	/* 128 */

	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 130 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 132 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 134 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 136 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 138 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 140 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 142 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 144 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 146 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 148 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 150 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 152 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 154 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 156 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 158 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 160 */

	INVERSE, INVERSE, INVERSE, INVERSE,			/* 164 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 168 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 172 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 176 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 180 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 184 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 188 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 192 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 196 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 200 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 204 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 208 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 212 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 216 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 220 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 224 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 228 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 232 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 236 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 240 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 244 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 248 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 252 */
	INVERSE, INVERSE, INVERSE, INVERSE + UNDERLINE		/* 256 */
};

/* Set attributes */

int set_attr(SCRN *t, int c)
{
	int e;

	c &= ~255;

	/* Attributes which have gone off */
	e = ((AT_MASK|FG_NOT_DEFAULT|BG_NOT_DEFAULT)&t->attrib & ~c);

	if (e) {	/* If any attribute go off, switch them all off: fixes bug on PCs */
		if (t->me)
			texec(t->cap, t->me, 1, 0, 0, 0, 0);
		else {
			if (t->ue)
				texec(t->cap, t->ue, 1, 0, 0, 0, 0);
			if (t->se)
				texec(t->cap, t->se, 1, 0, 0, 0, 0);
		}
		t->attrib = 0;
	}

	/* Attributes which have turned on */
	e = (c & ~t->attrib);

	if (e & INVERSE) {
		if (t->mr)
			texec(t->cap, t->mr, 1, 0, 0, 0, 0);
		else if (t->so)
			texec(t->cap, t->so, 1, 0, 0, 0, 0);
	}

	if (e & UNDERLINE)
		if (t->us)
			texec(t->cap, t->us, 1, 0, 0, 0, 0);
	if (e & BLINK)
		if (t->mb)
			texec(t->cap, t->mb, 1, 0, 0, 0, 0);
	if (e & BOLD)
		if (t->md)
			texec(t->cap, t->md, 1, 0, 0, 0, 0);
	if (e & DIM)
		if (t->mh)
			texec(t->cap, t->mh, 1, 0, 0, 0, 0);

	if ((t->attrib & FG_MASK) != (c & FG_MASK)) {
		if (t->Sf) {
			int color = ((c & FG_VALUE) >> FG_SHIFT);
			if (t->assume_256 && color >= t->Co) {
				unsigned char bf[32];
				joe_snprintf_1(bf,sizeof(bf),"\033[38;5;%dm",color);
				ttputs(bf);
			} else {
				if (t->Co & (t->Co - 1))
					texec(t->cap, t->Sf, 1, color % t->Co, 0, 0, 0);
				else
					texec(t->cap, t->Sf, 1, color & (t->Co - 1), 0, 0, 0);
			}
		}
	}

	if ((t->attrib & BG_MASK) != (c & BG_MASK)) {
		if (t->Sb) {
			int color = ((c & BG_VALUE) >> BG_SHIFT);
			if (t->assume_256 && color >= t->Co) {
				unsigned char bf[32];
				joe_snprintf_1(bf,sizeof(bf),"\033[48;5;%dm",color);
				ttputs(bf);
			} else {
				if (t->Co & (t->Co - 1))
					texec(t->cap, t->Sb, 1, color % t->Co, 0, 0, 0);
				else
					texec(t->cap, t->Sb, 1, color & (t->Co - 1), 0, 0, 0);
			}
		}
	}

	t->attrib = c;

	return 0;
}

/* Output character with attributes */

void outatr(struct charmap *map,SCRN *t,int *scrn,int *attrf,int xx,int yy,int c,int a)
{
	if(map->type)
		if(locale_map->type) {
			/* UTF-8 char to UTF-8 terminal */
			int wid;
			int uni_ctrl = 0;
			unsigned char buf[16];

			/* Deal with control characters */
			if (c<32) {
				c = c + '@@';
				a ^= UNDERLINE;
			} else if (c==127) {
				c = '?';
				a ^= UNDERLINE;
			} else if (unictrl(c)) {
				a ^= UNDERLINE;
				uni_ctrl = 1;
			}

			if(*scrn==c && *attrf==a)
				return;

			wid = joe_wcwidth(1,c);

			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t, xx, yy);
			if(t->attrib != a)
				set_attr(t, a);
			if (uni_ctrl) {
				sprintf((char *)buf,"<%X>",c);
				ttputs(buf);
			} else {
				utf8_encode(buf,c);
				ttputs(buf);
			}
			t->x+=wid;
			while (wid>1) {
				*++scrn= -1;
				*++attrf= 0;
				--wid;
			}
		} else {
			/* UTF-8 char to non-UTF-8 terminal */
			/* Don't convert control chars below 256 */
			if ((c>=32 && c<=126) || c>=160) {
				if (unictrl(c))
					a ^= UNDERLINE;
				c = from_uni(locale_map,c);
				if (c==-1)
					c = '?';
			}

			/* Deal with control characters */
			if (!joe_isprint(locale_map,c) && !(dspasis && c>=128)) {
				a ^= xlata[c];
				c = xlatc[c];
			}

			if(*scrn==c && *attrf==a)
				return;

			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t,xx,yy);
			if(t->attrib != a)
				set_attr(t,a);
			ttputc(c);
			t->x++;
		}
	else
		if (!locale_map->type) {
			/* Non UTF-8 char to non UTF-8 terminal */
			/* Byte-byte Translate? */

			/* Deal with control characters */
			if (!joe_isprint(locale_map,c) && !(dspasis && c>=128)) {
				a ^= xlata[c];
				c = xlatc[c];
			}

			if (*scrn==c && *attrf==a)
				return;

			*scrn = c;
			*attrf = a;

			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t,xx,yy);
			if(t->attrib != a)
				set_attr(t,a);
			ttputc(c);
			t->x++;
		} else {
			/* Non UTF-8 char to UTF-8 terminal */
			unsigned char buf[16];
			int wid;

			/* Deal with control characters */
			if (!(dspasis && c>=128) && !joe_isprint(map,c)) {
				a ^= xlata[c];
				c = xlatc[c];
			}

			c = to_uni(map,c);
			if (c == -1)
				c = '?';
			utf8_encode(buf,c);

			if (*scrn == c && *attrf == a)
				return;

			wid = joe_wcwidth(0,c);
			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t, xx, yy);
			if(t->attrib != a)
				set_attr(t, a);
			ttputs(buf);
			t->x+=wid;
			while(wid>1) {
				*++scrn= -1;
				*++attrf= 0;
				--wid;
			}
		}
}

/* Set scrolling region */

static void setregn(SCRN *t, int top, int bot)
{
	if (!t->cs) {
		t->top = top;
		t->bot = bot;
		return;
	}
	if (t->top != top || t->bot != bot) {
		t->top = top;
		t->bot = bot;
		texec(t->cap, t->cs, 1, top, bot - 1, 0, 0);
		t->x = -1;
		t->y = -1;
	}
}

/* Enter insert mode */

static void setins(SCRN *t, int x)
{
	if (t->ins != 1 && t->im) {
		t->ins = 1;
		texec(t->cap, t->im, 1, x, 0, 0, 0);
	}
}

/* Exit insert mode */

int clrins(SCRN *t)
{
	if (t->ins != 0) {
		texec(t->cap, t->ei, 1, 0, 0, 0, 0);
		t->ins = 0;
	}
	return 0;
}

/* Erase from given screen coordinate to end of line */

int eraeol(SCRN *t, int x, int y, int atr)
{
	int *s, *ss, *a, *aa;
	int w = t->co - x - 1;	/* Don't worry about last column */

	if (w <= 0)
		return 0;
	s = t->scrn + y * t->co + x;
	a = t->attr + y * t->co + x;
	ss = s + w;
	aa = a + w;
	do {
		if (*--ss != ' ') {
			++ss;
			break;
		} else if (*--aa != atr) {
			++ss;
			++aa;
			break;
		}
	} while (ss != s);
	if ((ss - s > 3 || s[w] != ' ' || a[w] != atr) && t->ce) {
		cpos(t, x, y);
		if(t->attrib != atr)
			set_attr(t, atr); 
		texec(t->cap, t->ce, 1, 0, 0, 0, 0);
		msetI(s, ' ', w);
		msetI(a, atr, w);
	} else if (s != ss) {
		if (t->ins)
			clrins(t);
		if (t->x != x || t->y != y)
			cpos(t, x, y);
		if (t->attrib != atr)
			set_attr(t, atr); 
		while (s != ss) {
			*s = ' ';
			*a = atr;
			ttputc(' ');
			++t->x;
			++s;
			++a;
		}
	}
	return 0;
}

/* As above but useable in insert mode */
/* The cursor position must already be correct */

static void outatri(SCRN *t, int x, int y, int c, int a)
{
/*
	if (c == -1)
		c = ' ';
	if (a != t->attrib)
		set_attr(t, a);
	if (t->haz && c == '~')
		c = '\\';
	utf8_putc(c);
	t->x+=joe_wcwidth(1,c);
*/
	/* ++t->x; */
}

static void out(unsigned char *t, unsigned char c)
{
	ttputc(c);
}

SCRN *nopen(CAP *cap)
{
	SCRN *t = (SCRN *) joe_malloc(sizeof(SCRN));
	int x, y;

	ttopen();

	t->cap = cap;
	setcap(cap, baud, out, NULL);

	t->li = getnum(t->cap,USTR "li");
	if (t->li < 1)
		t->li = 24;
	t->co = getnum(t->cap,USTR "co");
	if (t->co < 2)
		t->co = 80;
	x = y = 0;
	ttgtsz(&x, &y);
	if (x > 7 && y > 3) {
		t->li = y;
		t->co = x;
	}

	t->haz = getflag(t->cap,USTR "hz");
	t->os = getflag(t->cap,USTR "os");
	t->eo = getflag(t->cap,USTR "eo");
	if (getflag(t->cap,USTR "hc"))
		t->os = 1;
	if (t->os || getflag(t->cap,USTR "ul"))
		t->ul = 1;
	else
		t->ul = 0;

	t->xn = getflag(t->cap,USTR "xn");
	t->am = getflag(t->cap,USTR "am");

	if (notite)
		t->ti = 0;
	else
		t->ti = jgetstr(t->cap,USTR "ti");
	t->cl = jgetstr(t->cap,USTR "cl");
	t->cd = jgetstr(t->cap,USTR "cd");

	if (notite)
		t->te = 0;
	else
		t->te = jgetstr(t->cap,USTR "te");

	t->ut = getflag(t->cap,USTR "ut");
	t->Sb = jgetstr(t->cap,USTR "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap,USTR "Sb");
	t->Sf = jgetstr(t->cap,USTR "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap,USTR "Sf");
	t->Co = getnum(t->cap,USTR "Co");
	if (t->Co == -1)
		t->Co = 8;

	t->mb = NULL;
	t->md = NULL;
	t->mh = NULL;
	t->mr = NULL;
	t->avattr = 0;
	if (!(t->me = jgetstr(t->cap,USTR "me")))
		goto oops;
	if ((t->mb = jgetstr(t->cap,USTR "mb")))
		t->avattr |= BLINK;
	if ((t->md = jgetstr(t->cap,USTR "md")))
		t->avattr |= BOLD;
	if ((t->mh = jgetstr(t->cap,USTR "mh")))
		t->avattr |= DIM;
	if ((t->mr = jgetstr(t->cap,USTR "mr")))
		t->avattr |= INVERSE;
      oops:


	if (assume_color || assume_256color) {
		/* Install 8 color support if it looks like an ansi terminal (it has bold which begins with ESC [) */
#ifndef TERMINFO
		if (!t->Sf && t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') { 
			t->ut = 1;
			t->Sf = USTR "\\E[3%dm";
			t->Sb = USTR "\\E[4%dm";
			t->Co = 8;
		}
#else
		if (!t->Sf && t->md && t->md[0]=='\033' && t->md[1]=='[') { 
			t->ut = 1;
			t->Sf = USTR "\033[3%p1%dm";
			t->Sb = USTR "\033[4%p1%dm";
		}
#endif
	}

	t->assume_256 = 0;
      	if (assume_256color && t->Co < 256) {
		/* Force 256 color support */
#ifndef TERMINFO
		if (t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') { 
			t->assume_256 = 1;
#ifdef junk
			t->ut = 1;
			t->Sf = USTR "\\E[38;5;%dm";
			t->Sb = USTR "\\E[48;5;%dm";
#endif
		}
#else
		if (t->md && t->md[0]=='\033' && t->md[1]=='[') { 
			t->assume_256 = 1;
#ifdef junk
			t->ut = 1;
			t->Sf = USTR "\033[38;5;%p1%dm";
			t->Sb = USTR "\033[48;5;%p1%dm";
#endif
		}
#endif
	}

	t->so = NULL;
	t->se = NULL;
	if (getnum(t->cap,USTR "sg") <= 0 && !t->mr && jgetstr(t->cap,USTR "se")) {
		if ((t->so = jgetstr(t->cap,USTR "so")) != NULL)
			t->avattr |= INVERSE;
		t->se = jgetstr(t->cap,USTR "se");
	}
	if (getflag(t->cap,USTR "xs") || getflag(t->cap,USTR "xt"))
		t->so = NULL;

	t->us = NULL;
	t->ue = NULL;
	if (getnum(t->cap,USTR "ug") <= 0 && jgetstr(t->cap,USTR "ue")) {
		if ((t->us = jgetstr(t->cap,USTR "us")) != NULL)
			t->avattr |= UNDERLINE;
		t->ue = jgetstr(t->cap,USTR "ue");
	}

	if (!(t->uc = jgetstr(t->cap,USTR "uc")))
		if (t->ul)
			t->uc =USTR "_";
	if (t->uc)
		t->avattr |= UNDERLINE;

	t->ms = getflag(t->cap,USTR "ms");

	t->da = getflag(t->cap,USTR "da");
	t->db = getflag(t->cap,USTR "db");
	t->cs = jgetstr(t->cap,USTR "cs");
	t->rr = getflag(t->cap,USTR "rr");
	t->sf = jgetstr(t->cap,USTR "sf");
	t->sr = jgetstr(t->cap,USTR "sr");
	t->SF = jgetstr(t->cap,USTR "SF");
	t->SR = jgetstr(t->cap,USTR "SR");
	t->al = jgetstr(t->cap,USTR "al");
	t->dl = jgetstr(t->cap,USTR "dl");
	t->AL = jgetstr(t->cap,USTR "AL");
	t->DL = jgetstr(t->cap,USTR "DL");
	if (!getflag(t->cap,USTR "ns") && !t->sf)
		t->sf =USTR "\12";

	if (!getflag(t->cap,USTR "in") && baud < 38400) {
		t->dc = jgetstr(t->cap,USTR "dc");
		t->DC = jgetstr(t->cap,USTR "DC");
		t->dm = jgetstr(t->cap,USTR "dm");
		t->ed = jgetstr(t->cap,USTR "ed");

		t->im = jgetstr(t->cap,USTR "im");
		t->ei = jgetstr(t->cap,USTR "ei");
		t->ic = jgetstr(t->cap,USTR "ic");
		t->IC = jgetstr(t->cap,USTR "IC");
		t->ip = jgetstr(t->cap,USTR "ip");
		t->mi = getflag(t->cap,USTR "mi");
	} else {
		t->dm = NULL;
		t->dc = NULL;
		t->DC = NULL;
		t->ed = NULL;
		t->im = NULL;
		t->ic = NULL;
		t->IC = NULL;
		t->ip = NULL;
		t->ei = NULL;
		t->mi = 1;
	}

	t->bs = NULL;
	if (jgetstr(t->cap,USTR "bc"))
		t->bs = jgetstr(t->cap,USTR "bc");
	else if (jgetstr(t->cap,USTR "le"))
		t->bs = jgetstr(t->cap,USTR "le");
	if (getflag(t->cap,USTR "bs"))
		t->bs =USTR "\10";

	t->cbs = tcost(t->cap, t->bs, 1, 2, 2, 0, 0);

	t->lf =USTR "\12";
	if (jgetstr(t->cap,USTR "do"))
		t->lf = jgetstr(t->cap,USTR "do");
	t->clf = tcost(t->cap, t->lf, 1, 2, 2, 0, 0);

	t->up = jgetstr(t->cap,USTR "up");
	t->cup = tcost(t->cap, t->up, 1, 2, 2, 0, 0);

	t->nd = jgetstr(t->cap,USTR "nd");

	t->tw = 8;
	if (getnum(t->cap,USTR "it") > 0)
		t->tw = getnum(t->cap,USTR "it");
	else if (getnum(t->cap,USTR "tw") > 0)
		t->tw = getnum(t->cap,USTR "tw");

	if (!(t->ta = jgetstr(t->cap,USTR "ta")))
		if (getflag(t->cap,USTR "pt"))
			t->ta =USTR "\11";
	t->bt = jgetstr(t->cap,USTR "bt");
	if (getflag(t->cap,USTR "xt")) {
		t->ta = NULL;
		t->bt = NULL;
	}

	if (!usetabs) {
		t->ta = NULL;
		t->bt = NULL;
	}

	t->cta = tcost(t->cap, t->ta, 1, 2, 2, 0, 0);
	t->cbt = tcost(t->cap, t->bt, 1, 2, 2, 0, 0);

	t->ho = jgetstr(t->cap,USTR "ho");
	t->cho = tcost(t->cap, t->ho, 1, 2, 2, 0, 0);
	t->ll = jgetstr(t->cap,USTR "ll");
	t->cll = tcost(t->cap, t->ll, 1, 2, 2, 0, 0);

	t->cr =USTR "\15";
	if (jgetstr(t->cap,USTR "cr"))
		t->cr = jgetstr(t->cap,USTR "cr");
	if (getflag(t->cap,USTR "nc") || getflag(t->cap,USTR "xr"))
		t->cr = NULL;
	t->ccr = tcost(t->cap, t->cr, 1, 2, 2, 0, 0);

	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap,USTR "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap,USTR "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap,USTR "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap,USTR "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap,USTR "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap,USTR "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap,USTR "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap,USTR "cm"), 1, 2, 2, 0, 0);

	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap,USTR "ce"), 1, 2, 2, 0, 0);

/* Make sure terminal can do absolute positioning */
	if (t->cm)
		goto ok;
	if (t->ch && t->cv)
		goto ok;
	if (t->ho && (t->lf || t->DO || t->cv))
		goto ok;
	if (t->ll && (t->up || t->UP || t->cv))
		goto ok;
	if (t->cr && t->cv)
		goto ok;
	leave = 1;
	ttclose();
	signrm();
        fprintf(stderr,"cm=%p ch=%p cv=%p ho=%p lf=%p DO=%p ll=%p up=%p UP=%p cr=%p\n",
                       t->cm, t->ch, t->cv, t->ho, t->lf, t->DO, t->ll, t->up, t->UP, t->cr);
	fprintf(stderr,(char *)joe_gettext(_("Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n")));
	return NULL;
      ok:

/* Determine if we can scroll */
	if (((t->sr || t->SR) && (t->sf || t->SF) && t->cs) || ((t->al || t->AL) && (t->dl || t->DL)))
		t->scroll = 1;
	else {
		t->scroll = 0;
		if (baud < 38400)
			mid = 1;
	}

/* Determine if we can ins/del within lines */
	if ((t->im || t->ic || t->IC) && (t->dc || t->DC))
		t->insdel = 1;
	else
		t->insdel = 0;

/* Adjust for high baud rates */
	if (baud >= 38400) {
		t->scroll = 0;
		t->insdel = 0;
	}

/* Send out terminal initialization string */
	if (t->ti)
		texec(t->cap, t->ti, 1, 0, 0, 0, 0);
	if (!skiptop && t->cl)
		texec(t->cap, t->cl, 1, 0, 0, 0, 0);

/* Initialize variable screen size dependant vars */
	t->scrn = NULL;
	t->attr = NULL;
	t->sary = NULL;
	t->updtab = NULL;
	t->compose = NULL;
	t->ofst = NULL;
	t->ary = NULL;
	t->htab = (struct hentry *) joe_malloc(256 * sizeof(struct hentry));

	nresize(t, t->co, t->li);

/* Initialize mouse */
	mouseopen();

	return t;
}

/* Change size of screen */

void nresize(SCRN *t, int w, int h)
{
	if (h < 4)
		h = 4;
	if (w < 8)
		w = 8;
	t->li = h;
	t->co = w;
	if (t->sary)
		joe_free(t->sary);
	if (t->updtab)
		joe_free(t->updtab);
	if (t->scrn)
		joe_free(t->scrn);
	if (t->attr)
		joe_free(t->attr);
	if (t->compose)
		joe_free(t->compose);
	if (t->ofst)
		joe_free(t->ofst);
	if (t->ary)
		joe_free(t->ary);
	t->scrn = (int *) joe_malloc(t->li * t->co * sizeof(int));
	t->attr = (int *) joe_malloc(t->li * t->co * sizeof(int));
	t->sary = (int *) joe_calloc(t->li, sizeof(int));
	t->updtab = (int *) joe_malloc(t->li * sizeof(int));
	t->compose = (int *) joe_malloc(t->co * sizeof(int));
	t->ofst = (int *) joe_malloc(t->co * sizeof(int));
	t->ary = (struct hentry *) joe_malloc(t->co * sizeof(struct hentry));

	nredraw(t);
}

/* Calculate cost of positioning the cursor using only relative cursor
 * positioning functions: t->(lf, DO, up, UP, bs, LE, RI, ta, bt) and rewriting
 * characters (to move right)
 *
 * This doesn't use the am and bw capabilities although it probably could.
 */

static int relcost(register SCRN *t, register int x, register int y, register int ox, register int oy)
{
	int cost = 0;

/* If we don't know the cursor position, force use of absolute positioning */
	if (oy == -1 || ox == -1)
		return 10000;

/* First adjust row */
	if (y > oy) {
		int dist = y - oy;

		/* Have to go down */
		if (t->lf) {
			int mult = dist * t->clf;

			if (dist < 10 && t->cDO < mult)
				cost += t->cDO;
			else if (dist >= 10 && t->cDO + 1 < mult)
				cost += t->cDO + 1;
			else
				cost += mult;
		} else if (t->DO)
			if (dist < 10)
				cost += t->cDO;
			else
				cost += t->cDO + 1;
		else
			return 10000;
	} else if (y < oy) {
		int dist = oy - y;

		/* Have to go up */
		if (t->up) {
			int mult = dist * t->cup;

			if (dist < 10 && t->cUP < mult)
				cost += t->cUP;
			else if (dist >= 10 && t->cUP < mult)
				cost += t->cUP + 1;
			else
				cost += mult;
		} else if (t->UP)
			if (dist < 10)
				cost += t->cUP;
			else
				cost += t->cUP + 1;
		else
			return 10000;
	}

/* Now adjust column */

/* Use tabs */
	if (x > ox && t->ta) {
		int dist = x - ox;
		int ntabs = (dist + ox % t->tw) / t->tw;
		int cstunder = x % t->tw + t->cta * ntabs;
		int cstover;

		if (x + t->tw < t->co && t->bs)
			cstover = t->cbs * (t->tw - x % t->tw) + t->cta * (ntabs + 1);
		else
			cstover = 10000;
		if (dist < 10 && cstunder < t->cRI && cstunder < x - ox && cstover > cstunder)
			return cost + cstunder;
		else if (cstunder < t->cRI + 1 && cstunder < x - ox && cstover > cstunder)
			return cost + cstunder;
		else if (dist < 10 && cstover < t->cRI && cstover < x - ox)
			return cost + cstover;
		else if (cstover < t->cRI + 1 && cstover < x - ox)
			return cost + cstover;
	} else if (x < ox && t->bt) {
		int dist = ox - x;
		int ntabs = (dist + t->tw - ox % t->tw) / t->tw;
		int cstunder, cstover;

		if (t->bs)
			cstunder = t->cbt * ntabs + t->cbs * (t->tw - x % t->tw);
		else
			cstunder = 10000;
		if (x - t->tw >= 0)
			cstover = t->cbt * (ntabs + 1) + x % t->tw;
		else
			cstover = 10000;
		if (dist < 10 && cstunder < t->cLE && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		    && cstover > cstunder)
			return cost + cstunder;
		if (cstunder < t->cLE + 1 && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		    && cstover > cstunder)
			return cost + cstunder;
		else if (dist < 10 && cstover < t->cRI && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			return cost + cstover;
		else if (cstover < t->cRI + 1 && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			return cost + cstover;
	}

/* Use simple motions */
	if (x < ox) {
		int dist = ox - x;

		/* Have to go left */
		if (t->bs) {
			int mult = dist * t->cbs;

			if (t->cLE < mult && dist < 10)
				cost += t->cLE;
			else if (t->cLE + 1 < mult)
				cost += t->cLE + 1;
			else
				cost += mult;
		} else if (t->LE)
			cost += t->cLE;
		else
			return 10000;
	} else if (x > ox) {
		int dist = x - ox;

		/* Have to go right */
		/* Hmm.. this should take into account possible attribute changes */
		if (t->cRI < dist && dist < 10)
			cost += t->cRI;
		else if (t->cRI + 1 < dist)
			cost += t->cRI + 1;
		else
			cost += dist;
	}

	return cost;
}

/* Find optimal set of cursor positioning commands to move from the current
 * cursor row and column (either or both of which might be unknown) to the
 * given new row and column and execute them.
 */

static void cposs(register SCRN *t, register int x, register int y)
{
	register int bestcost, cost;
	int bestway;
	int hy;
	int hl;

/* Home y position is usually 0, but it is 'top' if we have scrolling region
 * relative addressing
 */
	if (t->rr) {
		hy = t->top;
		hl = t->bot - 1;
	} else {
		hy = 0;
		hl = t->li - 1;
	}

/* Assume best way is with only using relative cursor positioning */

	bestcost = relcost(t, x, y, t->x, t->y);
	bestway = 0;

/* Now check if combinations of absolute cursor positioning functions are
 * better (or necessary in case one or both cursor positions are unknown)
 */

	if (t->ccm < bestcost) {
		cost = tcost(t->cap, t->cm, 1, y, x, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 6;
		}
	}
	if (t->ccr < bestcost) {
		cost = relcost(t, x, y, 0, t->y) + t->ccr;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 1;
		}
	}
	if (t->cho < bestcost) {
		cost = relcost(t, x, y, 0, hy) + t->cho;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 2;
		}
	}
	if (t->cll < bestcost) {
		cost = relcost(t, x, y, 0, hl) + t->cll;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 3;
		}
	}
	if (t->cch < bestcost && x != t->x) {
		cost = relcost(t, x, y, x, t->y) + tcost(t->cap, t->ch, 1, x, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 4;
		}
	}
	if (t->ccv < bestcost && y != t->y) {
		cost = relcost(t, x, y, t->x, y) + tcost(t->cap, t->cv, 1, y, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 5;
		}
	}
	if (t->ccV < bestcost) {
		cost = relcost(t, x, y, 0, y) + tcost(t->cap, t->cV, 1, y, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 13;
		}
	}
	if (t->cch + t->ccv < bestcost && x != t->x && y != t->y) {
		cost = tcost(t->cap, t->cv, 1, y - hy, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 7;
		}
	}
	if (t->ccv + t->ccr < bestcost && y != t->y) {
		cost = tcost(t->cap, t->cv, 1, y, 0, 0, 0) + tcost(t->cap, t->cr, 1, 0, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 8;
		}
	}
	if (t->cll + t->cch < bestcost) {
		cost = tcost(t->cap, t->ll, 1, 0, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0) + relcost(t, x, y, x, hl);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 9;
		}
	}
	if (t->cll + t->ccv < bestcost) {
		cost = tcost(t->cap, t->ll, 1, 0, 0, 0, 0) + tcost(t->cap, t->cv, 1, y, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 10;
		}
	}
	if (t->cho + t->cch < bestcost) {
		cost = tcost(t->cap, t->ho, 1, 0, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0) + relcost(t, x, y, x, hy);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 11;
		}
	}
	if (t->cho + t->ccv < bestcost) {
		cost = tcost(t->cap, t->ho, 1, 0, 0, 0, 0) + tcost(t->cap, t->cv, 1, y, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 12;
		}
	}

/* Do absolute cursor positioning if we don't know the cursor position or
 * if it is faster than doing only relative cursor positioning
 */

	switch (bestway) {
	case 1:
		texec(t->cap, t->cr, 1, 0, 0, 0, 0);
		t->x = 0;
		break;
	case 2:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
		break;
	case 3:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		break;
	case 9:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		goto doch;
	case 11:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
doch:
	case 4:
		texec(t->cap, t->ch, 1, x, 0, 0, 0);
		t->x = x;
		break;
	case 10:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		goto docv;
	case 12:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
		goto docv;
	case 8:
		texec(t->cap, t->cr, 1, 0, 0, 0, 0);
		t->x = 0;
docv:
	case 5:
		texec(t->cap, t->cv, 1, y, 0, 0, 0);
		t->y = y;
		break;
	case 6:
		texec(t->cap, t->cm, 1, y, x, 0, 0);
		t->y = y;
		t->x = x;
		break;
	case 7:
		texec(t->cap, t->cv, 1, y, 0, 0, 0);
		t->y = y;
		texec(t->cap, t->ch, 1, x, 0, 0, 0);
		t->x = x;
		break;
	case 13:
		texec(t->cap, t->cV, 1, y, 0, 0, 0);
		t->y = y;
		t->x = 0;
		break;
	}

/* Use relative cursor position functions if we're not there yet */

/* First adjust row */
	if (y > t->y) {
		/* Have to go down */
		if (!t->lf || t->cDO < (y - t->y) * t->clf) {
			texec(t->cap, t->DO, 1, y - t->y, 0, 0, 0);
			t->y = y;
		} else
			while (y > t->y) {
				texec(t->cap, t->lf, 1, 0, 0, 0, 0);
				++t->y;
			}
	} else if (y < t->y) {
		/* Have to go up */
		if (!t->up || t->cUP < (t->y - y) * t->cup) {
			texec(t->cap, t->UP, 1, t->y - y, 0, 0, 0);
			t->y = y;
		} else
			while (y < t->y) {
				texec(t->cap, t->up, 1, 0, 0, 0, 0);
				--t->y;
			}
	}

/* Use tabs */
	if (x > t->x && t->ta) {
		int ntabs = (x - t->x + t->x % t->tw) / t->tw;
		int cstunder = x % t->tw + t->cta * ntabs;
		int cstover;

		if (x + t->tw < t->co && t->bs)
			cstover = t->cbs * (t->tw - x % t->tw) + t->cta * (ntabs + 1);
		else
			cstover = 10000;
		if (cstunder < t->cRI && cstunder < x - t->x && cstover > cstunder) {
			if (ntabs) {
				t->x = x - x % t->tw;
				do {
					texec(t->cap, t->ta, 1, 0, 0, 0, 0);
				} while (--ntabs);
			}
		} else if (cstover < t->cRI && cstover < x - t->x) {
			t->x = t->tw + x - x % t->tw;
			++ntabs;
			do {
				texec(t->cap, t->ta, 1, 0, 0, 0, 0);
			} while (--ntabs);
		}
	} else if (x < t->x && t->bt) {
		int ntabs = ((t->x + t->tw - 1) - (t->x + t->tw - 1) % t->tw - ((x + t->tw - 1) - (x + t->tw - 1) % t->tw)) / t->tw;
		int cstunder, cstover;

		if (t->bs)
			cstunder = t->cbt * ntabs + t->cbs * (t->tw - x % t->tw);
		else
			cstunder = 10000;
		if (x - t->tw >= 0)
			cstover = t->cbt * (ntabs + 1) + x % t->tw;
		else
			cstover = 10000;
		if (cstunder < t->cLE && (t->bs ? cstunder < (t->x - x) * t->cbs : 1)
		    && cstover > cstunder) {
			if (ntabs) {
				do {
					texec(t->cap, t->bt, 1, 0, 0, 0, 0);
				} while (--ntabs);
				t->x = x + t->tw - x % t->tw;
			}
		} else if (cstover < t->cRI && (t->bs ? cstover < (t->x - x) * t->cbs : 1)) {
			t->x = x - x % t->tw;
			++ntabs;
			do {
				texec(t->cap, t->bt, 1, 0, 0, 0, 0);
			} while (--ntabs);
		}
	}

/* Now adjust column */
	if (x < t->x) {
		/* Have to go left */
		if (!t->bs || t->cLE < (t->x - x) * t->cbs) {
			texec(t->cap, t->LE, 1, t->x - x, 0, 0, 0);
			t->x = x;
		} else
			while (x < t->x) {
				texec(t->cap, t->bs, 1, 0, 0, 0, 0);
				--t->x;
			}
	} else if (x > t->x) {
		/* Have to go right */
		/* Hmm.. this should take into account possible attribute changes */
		if (x-t->x>1 && t->RI) {
			texec(t->cap, t->RI, 1, x - t->x, 0, 0, 0);
			t->x = x;
		} else {
			while(x>t->x) {
				texec(t->cap, t->nd, 1, 0, 0, 0, 0);
				++t->x;
			}
		}

		/* if (t->cRI < x - t->x) { */
/*		} else {
			int *s = t->scrn + t->x + t->y * t->co;
			int *a = t->attr + t->x + t->y * t->co;

			if (t->ins)
				clrins(t);
			while (x > t->x) {
				int atr, c;
				if(*s==-1) c=' ', atr=0;
				else c= *s, atr= *a;

				if (atr != t->attrib)
					set_attr(t, atr);
				utf8_putc(c);
				++s;
				++a;
				++t->x;
			}
		}
*/
	}
}

int cpos(register SCRN *t, register int x, register int y)
{
	/* Move cursor quickly if we can */
	if (y == t->y) {
		if (x > t->x && x - t->x < 4 && !t->ins) {
			int *cs = t->scrn + t->x + t->co * t->y;
			int *as = t->attr + t->x + t->co * t->y;
			do {
				/* We used to space over unknown chars, but they now could be
				   the right half of a UTF-8 two column character, so we can't.
				   Also do not try to emit utf-8 sequences here. */
				if(*cs<32 || *cs>=127)
					break;

				if (*as != t->attrib)
					set_attr(t, *as);

				ttputc(*cs);

				++cs;
				++as;
				++t->x;

			} while (x != t->x);
		}
		if (x == t->x)
			return 0;
	}
	if ((!t->ms && t->attrib & (INVERSE | UNDERLINE | BG_NOT_DEFAULT)) ||
	    (t->ut && (t->attrib & BG_NOT_DEFAULT)))
		set_attr(t, t->attrib & ~(INVERSE | UNDERLINE | BG_MASK));

	/* Should be in cposs */
	if (y < t->top || y >= t->bot)
		setregn(t, 0, t->li);

	cposs(t, x, y);
	return 0;
}

static void doinschr(SCRN *t, int x, int y, int *s, int *as, int n)
{
	int a;

	if (x < 0) {
		s -= x;
		as -= x;
		x = 0;
	}
	if (x >= t->co - 1 || n <= 0)
		return;
	if (t->im || t->ic || t->IC) {
		cpos(t, x, y);
		if ((n == 1 && t->ic) || !t->IC) {
			if (!t->ic)
				setins(t, x);
			for (a = 0; a != n; ++a) {
				texec(t->cap, t->ic, 1, x, 0, 0, 0);
				outatri(t, x + a, y, s[a], as[a]);
				texec(t->cap, t->ip, 1, x, 0, 0, 0);
			}
			if (!t->mi)
				clrins(t);
		} else {
			texec(t->cap, t->IC, 1, n, 0, 0, 0);
			for (a = 0; a != n; ++a)
				outatri(t, x + a, y, s[a], as[a]);
		}
	}
	mmove(t->scrn + x + t->co * y + n, t->scrn + x + t->co * y, (t->co - (x + n)) * sizeof(int));
	mmove(t->attr + x + t->co * y + n, t->attr + x + t->co * y, (t->co - (x + n)) * sizeof(int));
	mmove(t->scrn + x + t->co * y, s, n * sizeof(int));
	mmove(t->attr + x + t->co * y, s, n * sizeof(int));
}

static void dodelchr(SCRN *t, int x, int y, int n)
{
	int a;

	if (x < 0)
		x = 0;
	if (!n || x >= t->co - 1)
		return;
	if (t->dc || t->DC) {
		cpos(t, x, y);
		texec(t->cap, t->dm, 1, x, 0, 0, 0);	/* Enter delete mode */
		if ((n == 1 && t->dc) || !t->DC)
			for (a = n; a; --a)
				texec(t->cap, t->dc, 1, x, 0, 0, 0);
		else
			texec(t->cap, t->DC, 1, n, 0, 0, 0);
		texec(t->cap, t->ed, 1, x, 0, 0, 0);	/* Exit delete mode */
	}
	mmove(t->scrn + t->co * y + x, t->scrn + t->co * y + x + n, (t->co - (x + n)) * sizeof(int));
	mmove(t->attr + t->co * y + x, t->attr + t->co * y + x + n, (t->co - (x + n)) * sizeof(int));
	msetI(t->scrn + t->co * y + t->co - n, ' ', n);
	msetI(t->attr + t->co * y + t->co - n, (t->attrib & FG_MASK), n);
}

/* Insert/Delete within line */
/* FIXME: doesn't know about attr */

void magic(SCRN *t, int y, int *cs, int *ca,int *s, int *a, int placex)
{
	struct hentry *htab = t->htab;
	int *ofst = t->ofst;
	int aryx = 1;
	int x;

	if (!(t->im || t->ic || t->IC) || !(t->dc || t->DC))
		return;
	mset(htab, 0, 256 * sizeof(struct hentry));

	msetI(ofst, 0, t->co);

/* Build hash table */
	for (x = 0; x != t->co - 1; ++x) {
		t->ary[aryx].next = htab[cs[x] & 255].next;
		t->ary[aryx].loc = x;
		++htab[cs[x] & 255].loc;
		htab[cs[x] & 255].next = aryx++;
	}

/* Build offset table */
	for (x = 0; x < t->co - 1;)
		if (htab[s[x] & 255].loc >= 15)
			ofst[x++] = t->co - 1;
		else {
			int aryy;
			int maxaryy = 0;
			int maxlen = 0;
			int best = 0;
			int bestback = 0;
			int z;

			for (aryy = htab[s[x] & 255].next; aryy; aryy = t->ary[aryy].next) {
				int amnt, back;
				int tsfo = t->ary[aryy].loc - x;
				int cst = -abs(tsfo);
				int pre = 32;

				for (amnt = 0; x + amnt < t->co - 1 && x + tsfo + amnt < t->co - 1; ++amnt) {
					if (cs[x + tsfo + amnt] != s[x + amnt])
						break;
					else if ((s[x + amnt] & 255) != 32 || pre != 32)
						++cst;
					pre = s[x + amnt] & 255;
				}
				pre = 32;
				for (back = 0; back + x > 0 && back + tsfo + x > 0; --back) {
					if (cs[x + tsfo + back - 1] != s[x + back - 1])
						break;
					else if ((s[x + back - 1] & 255) != 32 || pre != 32)
						++cst;
					pre = s[x + back - 1] & 255;
				}
				if (cst > best) {
					maxaryy = aryy;
					maxlen = amnt;
					best = cst;
					bestback = back;
				}
			}
			if (!maxlen) {
				ofst[x] = t->co - 1;
				maxlen = 1;
			} else if (best < 2)
				for (z = 0; z != maxlen; ++z)
					ofst[x + z] = t->co - 1;
			else
				for (z = 0; z != maxlen - bestback; ++z)
					ofst[x + z + bestback] = t->ary[maxaryy].loc - x;
			x += maxlen;
		}

/* Apply scrolling commands */

	for (x = 0; x != t->co - 1; ++x) {
		int q = ofst[x];

		if (q && q != t->co - 1) {
			if (q > 0) {
				int z, fu;

				for (z = x; z != t->co - 1 && ofst[z] == q; ++z) ;
				while (s[x] == cs[x] && x < placex)
					++x;
				dodelchr(t, x, y, q);
				for (fu = x; fu != t->co - 1; ++fu)
					if (ofst[fu] != t->co - 1)
						ofst[fu] -= q;
				x = z - 1;
			} else {
				int z, fu;

				for (z = x; z != t->co - 1 && ofst[z] == q; ++z) ;
				while (s[x + q] == cs[x + q] && x - q < placex)
					++x;
				doinschr(t, x + q, y, s + x + q, a + x + q, -q);
				for (fu = x; fu != t->co - 1; ++fu)
					if (ofst[fu] != t->co - 1)
						ofst[fu] -= q;
				x = z - 1;
			}
		}
	}
}

static void doupscrl(SCRN *t, int top, int bot, int amnt, int atr)
{
	int a = amnt;

	if (!amnt)
		return;
	set_attr(t, atr);
	if (top == 0 && bot == t->li && (t->sf || t->SF)) {
		setregn(t, 0, t->li);
		cpos(t, 0, t->li - 1);
		if ((amnt == 1 && t->sf) || !t->SF)
			while (a--)
				texec(t->cap, t->sf, 1, t->li - 1, 0, 0, 0);
		else
			texec(t->cap, t->SF, a, a, 0, 0, 0);
		goto done;
	}
	if (bot == t->li && (t->dl || t->DL)) {
		setregn(t, 0, t->li);
		cpos(t, 0, top);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		goto done;
	}
	if (t->cs && (t->sf || t->SF)) {
		setregn(t, top, bot);
		cpos(t, 0, bot - 1);
		if ((amnt == 1 && t->sf) || !t->SF)
			while (a--)
				texec(t->cap, t->sf, 1, bot - 1, 0, 0, 0);
		else
			texec(t->cap, t->SF, a, a, 0, 0, 0);
		goto done;
	}
	if ((t->dl || t->DL) && (t->al || t->AL)) {
		cpos(t, 0, top);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		a = amnt;
		cpos(t, 0, bot - amnt);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, bot - amnt, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	msetI(t->updtab + top, 1, bot - top);
	return;

      done:
	mmove(t->scrn + top * t->co, t->scrn + (top + amnt) * t->co, (bot - top - amnt) * t->co * sizeof(int));
	mmove(t->attr + top * t->co, t->attr + (top + amnt) * t->co, (bot - top - amnt) * t->co * sizeof(int));

	if (bot == t->li && t->db) {
		msetI(t->scrn + (t->li - amnt) * t->co, -1, amnt * t->co);
		msetI(t->attr + (t->li - amnt) * t->co, 0, amnt * t->co);
		msetI(t->updtab + t->li - amnt, 1, amnt);
	} else {
		msetI(t->scrn + (bot - amnt) * t->co, ' ', amnt * t->co);
		msetI(t->attr + (bot - amnt) * t->co, 0, amnt * t->co); 
	}
}

static void dodnscrl(SCRN *t, int top, int bot, int amnt, int atr)
{
	int a = amnt;

	if (!amnt)
		return;
	set_attr(t, atr); 
	if (top == 0 && bot == t->li && (t->sr || t->SR)) {
		setregn(t, 0, t->li);
		cpos(t, 0, 0);
		if ((amnt == 1 && t->sr) || !t->SR)
			while (a--)
				texec(t->cap, t->sr, 1, 0, 0, 0, 0);
		else
			texec(t->cap, t->SR, a, a, 0, 0, 0);
		goto done;
	}
	if (bot == t->li && (t->al || t->AL)) {
		setregn(t, 0, t->li);
		cpos(t, 0, top);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	if (t->cs && (t->sr || t->SR)) {
		setregn(t, top, bot);
		cpos(t, 0, top);
		if ((amnt == 1 && t->sr) || !t->SR)
			while (a--)
				texec(t->cap, t->sr, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->SR, a, a, 0, 0, 0);
		goto done;
	}
	if ((t->dl || t->DL) && (t->al || t->AL)) {
		cpos(t, 0, bot - amnt);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, bot - amnt, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		a = amnt;
		cpos(t, 0, top);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	msetI(t->updtab + top, 1, bot - top);
	return;
      done:
	mmove(t->scrn + (top + amnt) * t->co, t->scrn + top * t->co, (bot - top - amnt) * t->co * sizeof(int));
	mmove(t->attr + (top + amnt) * t->co, t->attr + top * t->co, (bot - top - amnt) * t->co * sizeof(int));

	if (!top && t->da) {
		msetI(t->scrn, -1, amnt * t->co);
		msetI(t->attr, 0, amnt * t->co);
		msetI(t->updtab, 1, amnt);
	} else {
		msetI(t->scrn + t->co * top, ' ', amnt * t->co);
		msetI(t->attr + t->co * top, 0, amnt * t->co); 
	}
}

void nscroll(SCRN *t,int atr)
{
	int y, z, q, r, p;

	for (y = 0; y != t->li; ++y) {
		q = t->sary[y];
		if (ifhave)
			return;
		if (q && q != t->li) {
			if (q > 0) {
				for (z = y; z != t->li && t->sary[z] == q; ++z)
					t->sary[z] = 0;
				doupscrl(t, y, z + q, q, atr);
				y = z - 1;
			} else {
				for (r = y; r != t->li && (t->sary[r] < 0 || t->sary[r] == t->li); ++r) ;
				p = r - 1;
				do {
					q = t->sary[p];
					if (q && q != t->li) {
						for (z = p; t->sary[z] = 0, (z && t->sary[z - 1] == q); --z) ;
						dodnscrl(t, z + q, p + 1, -q, atr);
						p = z + 1;
					}
				} while (p-- != y);
				y = r - 1;
			}
		}
	}
	msetI(t->sary, 0, t->li);
}

void npartial(SCRN *t)
{
	set_attr(t, BG_COLOR(bg_text)); 
	clrins(t);
	setregn(t, 0, t->li);
}

void nescape(SCRN *t)
{
	mouseclose();
	npartial(t);
	cpos(t, 0, t->li - 1);
	eraeol(t, 0, t->li - 1, 0);
	if (t->te)
		texec(t->cap, t->te, 1, 0, 0, 0, 0);
}

void nreturn(SCRN *t)
{
	mouseopen();
	if (t->ti)
		texec(t->cap, t->ti, 1, 0, 0, 0, 0);
	if (!skiptop && t->cl)
		texec(t->cap, t->cl, 1, 0, 0, 0, 0);
	nredraw(t);
}

void nclose(SCRN *t)
{
	mouseclose();
	leave = 1;
	set_attr(t, 0);
	clrins(t);
	setregn(t, 0, t->li);
	cpos(t, 0, t->li - 1);
	if (t->te)
		texec(t->cap, t->te, 1, 0, 0, 0, 0);
	ttclose();
	rmcap(t->cap);
	joe_free(t->scrn);
	joe_free(t->attr);
	joe_free(t->sary);
	joe_free(t->ofst);
	joe_free(t->htab);
	joe_free(t->ary);
	joe_free(t);
}

void nscrldn(SCRN *t, int top, int bot, int amnt)
{
	int x;

	if (!amnt || top >= bot || bot > t->li)
		return;
	if ((amnt < bot - top && bot - top - amnt < amnt / 2) || !t->scroll)
		amnt = bot - top;
	if (amnt < bot - top) {
		for (x = bot; x != top + amnt; --x) {
			t->sary[x - 1] = (t->sary[x - amnt - 1] == t->li ? t->li : t->sary[x - amnt - 1] - amnt);
			t->updtab[x - 1] = t->updtab[x - amnt - 1];
		}
		for (x = top; x != top + amnt; ++x) {
			t->updtab[x] = 1;
		}
	}
	if (amnt > bot - top)
		amnt = bot - top;
	msetI(t->sary + top, t->li, amnt);
	if (amnt == bot - top) {
		msetI(t->updtab + top, 1, amnt);
	}
}

void nscrlup(SCRN *t, int top, int bot, int amnt)
{
	int x;

	if (!amnt || top >= bot || bot > t->li)
		return;
	if ((amnt < bot - top && bot - top - amnt < amnt / 2) || !t->scroll)
		amnt = bot - top;
	if (amnt < bot - top) {
		for (x = top + amnt; x != bot; ++x) {
			t->sary[x - amnt] = (t->sary[x] == t->li ? t->li : t->sary[x] + amnt);
			t->updtab[x - amnt] = t->updtab[x];
		}
		for (x = bot - amnt; x != bot; ++x) {
			t->updtab[x] = 1;
		}
	}
	if (amnt > bot - top)
		amnt = bot - top;
	msetI(t->sary + bot - amnt, t->li, amnt);
	if (amnt == bot - top) {
		msetI(t->updtab + bot - amnt, 1, amnt);
		}
}

void nredraw(SCRN *t)
{
	dostaupd = 1;
	msetI(t->scrn, ' ', t->co * skiptop);
	msetI(t->attr, BG_COLOR(bg_text), t->co * skiptop);  
	msetI(t->scrn + skiptop * t->co, -1, (t->li - skiptop) * t->co);
	msetI(t->attr + skiptop * t->co, BG_COLOR(bg_text), (t->li - skiptop) * t->co); 
	msetI(t->sary, 0, t->li);
	msetI(t->updtab + skiptop, -1, t->li - skiptop);
	t->x = -1;
	t->y = -1;
	t->top = t->li;
	t->bot = 0;
	t->attrib = -1;
	t->ins = -1;
	set_attr(t, BG_COLOR(bg_text)); 
	clrins(t);
	setregn(t, 0, t->li);

	if (!skiptop) {
		if (t->cl) {
			texec(t->cap, t->cl, 1, 0, 0, 0, 0);
			t->x = 0;
			t->y = 0;
			msetI(t->scrn, ' ', t->li * t->co);
			msetI(t->attr, BG_COLOR(bg_text), t->li * t->co); 
		} else if (t->cd) {
			cpos(t, 0, 0);
			texec(t->cap, t->cd, 1, 0, 0, 0, 0);
			msetI(t->scrn, ' ', t->li * t->co);
			msetI(t->attr, BG_COLOR(bg_text), t->li * t->co); 
		}
	}
}

/* Convert color/attribute name into internal code */

int meta_color_single(unsigned char *s)
{
	if(!zcmp(s,USTR "inverse"))
		return INVERSE;
	else if(!zcmp(s,USTR "underline"))
		return UNDERLINE;
	else if(!zcmp(s,USTR "bold"))
		return BOLD;
	else if(!zcmp(s,USTR "blink"))
		return BLINK;
	else if(!zcmp(s,USTR "dim"))
		return DIM;

	/* ISO colors */
	else if(!zcmp(s,USTR "white"))
		return FG_WHITE;
	else if(!zcmp(s,USTR "cyan"))
		return FG_CYAN;
	else if(!zcmp(s,USTR "magenta"))
		return FG_MAGENTA;
	else if(!zcmp(s,USTR "blue"))
		return FG_BLUE;
	else if(!zcmp(s,USTR "yellow"))
		return FG_YELLOW;
	else if(!zcmp(s,USTR "green"))
		return FG_GREEN;
	else if(!zcmp(s,USTR "red"))
		return FG_RED;
	else if(!zcmp(s,USTR "black"))
		return FG_BLACK;
	else if(!zcmp(s,USTR "bg_white"))
		return BG_WHITE;
	else if(!zcmp(s,USTR "bg_cyan"))
		return BG_CYAN;
	else if(!zcmp(s,USTR "bg_magenta"))
		return BG_MAGENTA;
	else if(!zcmp(s,USTR "bg_blue"))
		return BG_BLUE;
	else if(!zcmp(s,USTR "bg_yellow"))
		return BG_YELLOW;
	else if(!zcmp(s,USTR "bg_green"))
		return BG_GREEN;
	else if(!zcmp(s,USTR "bg_red"))
		return BG_RED;
	else if(!zcmp(s,USTR "bg_black"))
		return BG_BLACK;

	/* 16 color xterm support: codes 8 - 15 are brighter versions of above */
	else if(!zcmp(s,USTR "WHITE"))
		return FG_BWHITE;
	else if(!zcmp(s,USTR "CYAN"))
		return FG_BCYAN;
	else if(!zcmp(s,USTR "MAGENTA"))
		return FG_BMAGENTA;
	else if(!zcmp(s,USTR "BLUE"))
		return FG_BBLUE;
	else if(!zcmp(s,USTR "YELLOW"))
		return FG_BYELLOW;
	else if(!zcmp(s,USTR "GREEN"))
		return FG_BGREEN;
	else if(!zcmp(s,USTR "RED"))
		return FG_BRED;
	else if(!zcmp(s,USTR "BLACK"))
		return FG_BBLACK;
	else if(!zcmp(s,USTR "bg_WHITE"))
		return BG_BWHITE;
	else if(!zcmp(s,USTR "bg_CYAN"))
		return BG_BCYAN;
	else if(!zcmp(s,USTR "bg_MAGENTA"))
		return BG_BMAGENTA;
	else if(!zcmp(s,USTR "bg_BLUE"))
		return BG_BBLUE;
	else if(!zcmp(s,USTR "bg_YELLOW"))
		return BG_BYELLOW;
	else if(!zcmp(s,USTR "bg_GREEN"))
		return BG_BGREEN;
	else if(!zcmp(s,USTR "bg_RED"))
		return BG_BRED;
	else if(!zcmp(s,USTR "bg_BLACK"))
		return BG_BBLACK;

	/* Look at the "256colres.pl" PERL script in the xterm source
	   distribution to see how these work. */

	/* 256 color xterm support: bg_RGB and fg_RGB, where R, G, and B range from 0 - 5 */
	/* Codes 16 - 231 are a 6x6x6 color cube */
	else if(s[0]=='f' && s[1]=='g' && s[2]=='_' &&
		s[3]>='0' && s[3]<='5' &&
		s[4]>='0' && s[4]<='5' &&
		s[5]>='0' && s[5]<='5' && !s[6])
	        return FG_NOT_DEFAULT | ((16 + (s[3]-'0')*6*6 + (s[4]-'0')*6 + (s[5]-'0')) << FG_SHIFT);

	else if(s[0]=='b' && s[1]=='g' && s[2]=='_' &&
		  s[3]>='0' && s[3]<='5' &&
		  s[4]>='0' && s[4]<='5' &&
		  s[5]>='0' && s[5]<='5' && !s[6])
	        return BG_NOT_DEFAULT | ((16 + (s[3]-'0')*6*6 + (s[4]-'0')*6 + (s[5]-'0')) << BG_SHIFT);

	/* 256 color xterm support: shades of grey */
	/* Codes 232 - 255 are shades of grey */
	else if(s[0]=='f' && s[1]=='g' && s[2]=='_' && atoi((char *)(s+3)) >= 0 && atoi((char *)(s+3)) <= 23)
		return FG_NOT_DEFAULT | (232 + (atoi((char *)(s+3)) << FG_SHIFT));

	else if(s[0]=='b' && s[1]=='g' && s[2]=='_' && atoi((char *)(s+3)) >= 0 && atoi((char *)(s+3)) <= 23)
		return BG_NOT_DEFAULT | (232 + (atoi((char *)(s+3)) << BG_SHIFT));

	else
		return 0;
}

int meta_color(unsigned char *s)
{
	int code = 0;
	while (*s) {
		unsigned char buf[32];
		int x = 0;
		while (*s)
			if (*s && *s != '+') {
				if (x != sizeof(buf) - 1)
					buf[x++] = *s;
				++s;
			} else
				break;
		if (*s == '+')
			++s;
		buf[x] = 0;
		code |= meta_color_single(buf);
	}
	return code;
}

/* Calculate number of lines needed for a given prompt string and a given window width.
   Also this finds the nth line and returns the position of the substring which is
   that line. Set n to -1 if you just want the height. */

int break_height(struct charmap *map,unsigned char **src,int *src_len,int wid,int n)
{
	unsigned char *s = *src;
	int len = *src_len;
	int h = 1; /* Number of lines */
	int col = 0; /* Current column */
	int x = 0; /* Offset into string */
	int start_of_line = 0; /* Start of most recent line */
	while (x != len) {
		int space = 0;
		int word = 0;
		int start = x;
		int start_word;
		while (x != len && s[x] == ' ') {
			++space;
			++x;
		}
		start_word = x;
		while (x != len && s[x] != ' ') {
			++x;
		}
		word = txtwidth(map, s + start_word, x - start_word);
		if (col + space + word < wid || !col) {
			/* Leading space and word fit on current line */
			col += space + word;
		} else {
			/* They don't fit, start a new line */
			if (!n--) {
				x = start;
				break;
			}
			++h;
			col = word;
			start_of_line = start_word;
		}
	}
	*src = s + start_of_line;
	*src_len = x - start_of_line;
	return h;
}

/* Generate a field
 *
 * 't' is SCRN to write to.
 * 'scrn' is address of field in character buffer
 * 'attr' is address of field in attribute buffer
 * 'x', 'y' are starting column and line numbers of field
 * 'ofst' is first column within string to display
 * 's', 'len' is string to generate in field
 * 'atr' is screeen attributes (and color) which should be used
 * 'width' is column width of field
 * 'flg' if set, erases to end of line
 * 'fmt' is array of attributes, one for each byte.  OK if NULL.
 */

void genfield(SCRN *t,int *scrn,int *attr,int x,int y,int ofst,unsigned char *s,int len,int atr,int width,int flg,int *fmt)
{
	int col;
	struct utf8_sm sm;
	int last_col = x + width;

	utf8_init(&sm);

	for (col = 0;len != 0 && x < last_col; len--) {
		int c = *s++;
		int wid = -1;
		int my_atr = atr;
		if (fmt) my_atr |= *fmt++;
		if (locale_map->type) {
			/* UTF-8 mode: decode character and determine its width */
			c = utf8_decode(&sm,c);
			if (c >= 0)
				wid = joe_wcwidth(1,c);
		} else {
			/* Byte mode: character is one column wide */
			wid = 1 ;
		}
		if (wid>=0) {
			if (col >= ofst) {
				if (x + wid > last_col) {
					/* Character crosses end of field, so fill balance of field with '>' characters instead */
					while (x < last_col) {
						outatr(locale_map, t, scrn, attr, x, y, '>', my_atr);
						++scrn;
						++attr;
						++x;
					}
				} else if(wid) {
					/* Emit character */
					outatr(locale_map, t, scrn, attr, x, y, c, my_atr);
					x += wid;
					scrn += wid;
					attr += wid;
				}
			} else if ((col + wid) > ofst) {
				/* Wide character crosses left side of field */
				wid -= ofst - col;
				col = ofst;
				while (wid) {
					outatr(locale_map, t, scrn, attr, x, y, '<', my_atr);
					++scrn;
					++attr;
					++x;
					++col;
					--wid;
				}
			} else
				col += wid;
		}
	}
	/* Fill balance of field with spaces */
	while (x < last_col) {
		outatr(locale_map, t, scrn, attr, x, y, ' ', atr);
		++x;
		++scrn;
		++attr;
	}
	/* Erase to end of line */
	if (flg)
		eraeol(t, x, y, atr);
}

/* Width function for above */

int txtwidth(struct charmap *map,unsigned char *s,int len)
{
	if (map->type) {
		int col=0;
		struct utf8_sm sm;
		utf8_init(&sm);

		while(len--) {
			int d = utf8_decode(&sm,*s++);
			if (d >= 0)
				col += joe_wcwidth(1,d);
		}

		return col;
	} else
		return len;
}

int txtwidth1(struct charmap *map,int tabwidth,unsigned char *s,int len)
{
	if (map->type) {
		int col=0;
		struct utf8_sm sm;
		utf8_init(&sm);

		while(len--) {
			int d = utf8_decode(&sm,*s++);
			if (d == '\t') {
				++col;
				col += tabwidth - (col % tabwidth);
			} else if (d >= 0)
				col += joe_wcwidth(1,d);
		}

		return col;
	} else {
		int col = 0;
		while (len--) {
			if (*s++ == '\t') {
				++col;
				col += tabwidth - (col % tabwidth);
			} else
				++col;
		}
		return col;
	}
}

/* Unescape for text going to genfmt */

void unesc_genfmt(unsigned char *d, unsigned char *s, int len, int max)
{
	while (max > 0 && len) {
		if (!*s) {
			*d++ = '\\';
			*d++ = '@@';
			++s;
		} else {
			if (*s == '\\') {
				*d++ = '\\';
				--max;
			}
			*d++ = *s++;
		}
		--len;
		--max;
	}
	if (len)
		*d++ = '$';
	*d = 0;
}

/* Generate text with formatting escape sequences */

void genfmt(SCRN *t, int x, int y, int ofst, unsigned char *s, int atr, int flg)
{
	int *scrn = t->scrn + y * t->co + x;
	int *attr = t->attr + y * t->co + x;
	int col = 0;
	int c;
	struct utf8_sm sm;

	utf8_init(&sm);

	while ((c = *s++) != '\0')
		if (c == '\\') {
			switch (c = *s++) {
			case 'u':
			case 'U':
				atr ^= UNDERLINE;
				break;
			case 'i':
			case 'I':
				atr ^= INVERSE;
				break;
			case 'b':
			case 'B':
				atr ^= BOLD;
				break;
			case 'd':
			case 'D':
				atr ^= DIM;
				break;
			case 'f':
			case 'F':
				atr ^= BLINK;
				break;
			case 0:
				--s;
				break;
			case '@@':
				c = 0;
			default: {
				if (col++ >= ofst) {
					outatr(locale_map, t, scrn, attr, x, y, (c&0x7F), atr);
					++scrn;
					++attr;
					++x;
					}
				break;
				}
			}
		} else {
			int wid = -1;
			if (locale_map->type) {
				/* UTF-8 mode: decode character and determine its width */
				c = utf8_decode(&sm,c);
				if (c >= 0) {
						wid = joe_wcwidth(1,c);
				}
			} else {
				/* Byte mode: character is one column wide */
				wid = 1 ;
			}

			if (wid>=0) {
				if (col >= ofst) {
					outatr(locale_map, t, scrn, attr, x, y, c, atr);
					scrn += wid;
					attr += wid;
					x += wid;
					col += wid;
				} else if (col+wid>ofst) {
					while (col<ofst) {
						++col;
						--wid;
					}
					while (wid) {
						outatr(locale_map, t, scrn, attr, x, y, '<', atr);
						++scrn;
						++attr;
						++x;
						++col;
						--wid;
					}
				} else
					col += wid;
			}
		}
	if (flg)
		eraeol(t, x, y, atr);
}

/* Determine column width of string with format codes */

int fmtlen(unsigned char *s)
{
	int col = 0;
	struct utf8_sm sm;
	int c;

	utf8_init(&sm);

	while ((c= *s++)) {
		if (c == '\\') {
			switch (*s++) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				continue;
			case 0:
				return col;
			default:
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(locale_map->type) {
				c = utf8_decode(&sm,c);
				if (c>=0)
					wid = joe_wcwidth(1,c);
			} else {
				wid = 1;
			}
			col += wid;
		}
	}
	return col;
}

/* Return offset within format string which corresponds to a particular
   column */

/* FIXME: this is not valid if we land in the middle of a double-wide character */

int fmtpos(unsigned char *s, int goal)
{
	unsigned char *org = s;
	int col = 0;
	int c;
	struct utf8_sm sm;

	utf8_init(&sm);

	while ((c= *s) && col<goal) {
		s++;
		if (c == '\\') {
			switch (*s++) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				continue;
			case 0:
				--s;
				break;
			default:
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(locale_map->type) {
				c = utf8_decode(&sm,c);
				if (c>=0)
					wid = joe_wcwidth(1,c);
			} else {
				wid = 1;
			}
			col += wid;
		}
	}

	return s - org + goal - col;
}
@


1.60
log
@Do not indent single line paragraphs with autoindent is off.  Better dealing
with bullets.
@
text
@d2084 1
a2084 1
void unesc_genfmt(unsigned char *d, unsigned char *s, int max)
d2086 2
a2087 2
	while (max && *s) {
		if (*s == '\\')
d2089 10
a2098 1
		*d++ = *s++;
d2101 1
a2101 1
	if (*s)
d2144 2
@


1.59
log
@More work on coroutine refactoring.
@
text
@d2052 30
@


1.58
log
@more wmkpw elimination
@
text
@d1906 45
d2034 1
a2034 1
int txtwidth(unsigned char *s,int len)
d2036 1
a2036 1
	if (locale_map->type) {
@


1.57
log
@UC -> USTR
@
text
@d2007 15
@


1.56
log
@change US to UC
@
text
@d465 1
a465 1
	t->li = getnum(t->cap,UC "li");
d468 1
a468 1
	t->co = getnum(t->cap,UC "co");
d478 4
a481 4
	t->haz = getflag(t->cap,UC "hz");
	t->os = getflag(t->cap,UC "os");
	t->eo = getflag(t->cap,UC "eo");
	if (getflag(t->cap,UC "hc"))
d483 1
a483 1
	if (t->os || getflag(t->cap,UC "ul"))
d488 2
a489 2
	t->xn = getflag(t->cap,UC "xn");
	t->am = getflag(t->cap,UC "am");
d494 3
a496 3
		t->ti = jgetstr(t->cap,UC "ti");
	t->cl = jgetstr(t->cap,UC "cl");
	t->cd = jgetstr(t->cap,UC "cd");
d501 1
a501 1
		t->te = jgetstr(t->cap,UC "te");
d503 6
a508 6
	t->ut = getflag(t->cap,UC "ut");
	t->Sb = jgetstr(t->cap,UC "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap,UC "Sb");
	t->Sf = jgetstr(t->cap,UC "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap,UC "Sf");
	t->Co = getnum(t->cap,UC "Co");
d517 1
a517 1
	if (!(t->me = jgetstr(t->cap,UC "me")))
d519 1
a519 1
	if ((t->mb = jgetstr(t->cap,UC "mb")))
d521 1
a521 1
	if ((t->md = jgetstr(t->cap,UC "md")))
d523 1
a523 1
	if ((t->mh = jgetstr(t->cap,UC "mh")))
d525 1
a525 1
	if ((t->mr = jgetstr(t->cap,UC "mr")))
d535 2
a536 2
			t->Sf = UC "\\E[3%dm";
			t->Sb = UC "\\E[4%dm";
d542 2
a543 2
			t->Sf = UC "\033[3%p1%dm";
			t->Sb = UC "\033[4%p1%dm";
d556 2
a557 2
			t->Sf = UC "\\E[38;5;%dm";
			t->Sb = UC "\\E[48;5;%dm";
d565 2
a566 2
			t->Sf = UC "\033[38;5;%p1%dm";
			t->Sb = UC "\033[48;5;%p1%dm";
d574 2
a575 2
	if (getnum(t->cap,UC "sg") <= 0 && !t->mr && jgetstr(t->cap,UC "se")) {
		if ((t->so = jgetstr(t->cap,UC "so")) != NULL)
d577 1
a577 1
		t->se = jgetstr(t->cap,UC "se");
d579 1
a579 1
	if (getflag(t->cap,UC "xs") || getflag(t->cap,UC "xt"))
d584 2
a585 2
	if (getnum(t->cap,UC "ug") <= 0 && jgetstr(t->cap,UC "ue")) {
		if ((t->us = jgetstr(t->cap,UC "us")) != NULL)
d587 1
a587 1
		t->ue = jgetstr(t->cap,UC "ue");
d590 1
a590 1
	if (!(t->uc = jgetstr(t->cap,UC "uc")))
d592 1
a592 1
			t->uc =UC "_";
d596 1
a596 1
	t->ms = getflag(t->cap,UC "ms");
d598 27
a624 27
	t->da = getflag(t->cap,UC "da");
	t->db = getflag(t->cap,UC "db");
	t->cs = jgetstr(t->cap,UC "cs");
	t->rr = getflag(t->cap,UC "rr");
	t->sf = jgetstr(t->cap,UC "sf");
	t->sr = jgetstr(t->cap,UC "sr");
	t->SF = jgetstr(t->cap,UC "SF");
	t->SR = jgetstr(t->cap,UC "SR");
	t->al = jgetstr(t->cap,UC "al");
	t->dl = jgetstr(t->cap,UC "dl");
	t->AL = jgetstr(t->cap,UC "AL");
	t->DL = jgetstr(t->cap,UC "DL");
	if (!getflag(t->cap,UC "ns") && !t->sf)
		t->sf =UC "\12";

	if (!getflag(t->cap,UC "in") && baud < 38400) {
		t->dc = jgetstr(t->cap,UC "dc");
		t->DC = jgetstr(t->cap,UC "DC");
		t->dm = jgetstr(t->cap,UC "dm");
		t->ed = jgetstr(t->cap,UC "ed");

		t->im = jgetstr(t->cap,UC "im");
		t->ei = jgetstr(t->cap,UC "ei");
		t->ic = jgetstr(t->cap,UC "ic");
		t->IC = jgetstr(t->cap,UC "IC");
		t->ip = jgetstr(t->cap,UC "ip");
		t->mi = getflag(t->cap,UC "mi");
d639 6
a644 6
	if (jgetstr(t->cap,UC "bc"))
		t->bs = jgetstr(t->cap,UC "bc");
	else if (jgetstr(t->cap,UC "le"))
		t->bs = jgetstr(t->cap,UC "le");
	if (getflag(t->cap,UC "bs"))
		t->bs =UC "\10";
d648 3
a650 3
	t->lf =UC "\12";
	if (jgetstr(t->cap,UC "do"))
		t->lf = jgetstr(t->cap,UC "do");
d653 1
a653 1
	t->up = jgetstr(t->cap,UC "up");
d656 1
a656 1
	t->nd = jgetstr(t->cap,UC "nd");
d659 10
a668 10
	if (getnum(t->cap,UC "it") > 0)
		t->tw = getnum(t->cap,UC "it");
	else if (getnum(t->cap,UC "tw") > 0)
		t->tw = getnum(t->cap,UC "tw");

	if (!(t->ta = jgetstr(t->cap,UC "ta")))
		if (getflag(t->cap,UC "pt"))
			t->ta =UC "\11";
	t->bt = jgetstr(t->cap,UC "bt");
	if (getflag(t->cap,UC "xt")) {
d681 1
a681 1
	t->ho = jgetstr(t->cap,UC "ho");
d683 1
a683 1
	t->ll = jgetstr(t->cap,UC "ll");
d686 4
a689 4
	t->cr =UC "\15";
	if (jgetstr(t->cap,UC "cr"))
		t->cr = jgetstr(t->cap,UC "cr");
	if (getflag(t->cap,UC "nc") || getflag(t->cap,UC "xr"))
d693 8
a700 8
	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap,UC "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap,UC "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap,UC "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap,UC "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap,UC "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap,UC "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap,UC "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap,UC "cm"), 1, 2, 2, 0, 0);
d702 1
a702 1
	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap,UC "ce"), 1, 2, 2, 0, 0);
d1777 1
a1777 1
	if(!zcmp(s,UC "inverse"))
d1779 1
a1779 1
	else if(!zcmp(s,UC "underline"))
d1781 1
a1781 1
	else if(!zcmp(s,UC "bold"))
d1783 1
a1783 1
	else if(!zcmp(s,UC "blink"))
d1785 1
a1785 1
	else if(!zcmp(s,UC "dim"))
d1789 1
a1789 1
	else if(!zcmp(s,UC "white"))
d1791 1
a1791 1
	else if(!zcmp(s,UC "cyan"))
d1793 1
a1793 1
	else if(!zcmp(s,UC "magenta"))
d1795 1
a1795 1
	else if(!zcmp(s,UC "blue"))
d1797 1
a1797 1
	else if(!zcmp(s,UC "yellow"))
d1799 1
a1799 1
	else if(!zcmp(s,UC "green"))
d1801 1
a1801 1
	else if(!zcmp(s,UC "red"))
d1803 1
a1803 1
	else if(!zcmp(s,UC "black"))
d1805 1
a1805 1
	else if(!zcmp(s,UC "bg_white"))
d1807 1
a1807 1
	else if(!zcmp(s,UC "bg_cyan"))
d1809 1
a1809 1
	else if(!zcmp(s,UC "bg_magenta"))
d1811 1
a1811 1
	else if(!zcmp(s,UC "bg_blue"))
d1813 1
a1813 1
	else if(!zcmp(s,UC "bg_yellow"))
d1815 1
a1815 1
	else if(!zcmp(s,UC "bg_green"))
d1817 1
a1817 1
	else if(!zcmp(s,UC "bg_red"))
d1819 1
a1819 1
	else if(!zcmp(s,UC "bg_black"))
d1823 1
a1823 1
	else if(!zcmp(s,UC "WHITE"))
d1825 1
a1825 1
	else if(!zcmp(s,UC "CYAN"))
d1827 1
a1827 1
	else if(!zcmp(s,UC "MAGENTA"))
d1829 1
a1829 1
	else if(!zcmp(s,UC "BLUE"))
d1831 1
a1831 1
	else if(!zcmp(s,UC "YELLOW"))
d1833 1
a1833 1
	else if(!zcmp(s,UC "GREEN"))
d1835 1
a1835 1
	else if(!zcmp(s,UC "RED"))
d1837 1
a1837 1
	else if(!zcmp(s,UC "BLACK"))
d1839 1
a1839 1
	else if(!zcmp(s,UC "bg_WHITE"))
d1841 1
a1841 1
	else if(!zcmp(s,UC "bg_CYAN"))
d1843 1
a1843 1
	else if(!zcmp(s,UC "bg_MAGENTA"))
d1845 1
a1845 1
	else if(!zcmp(s,UC "bg_BLUE"))
d1847 1
a1847 1
	else if(!zcmp(s,UC "bg_YELLOW"))
d1849 1
a1849 1
	else if(!zcmp(s,UC "bg_GREEN"))
d1851 1
a1851 1
	else if(!zcmp(s,UC "bg_RED"))
d1853 1
a1853 1
	else if(!zcmp(s,UC "bg_BLACK"))
@


1.55
log
@gettext()
@
text
@d465 1
a465 1
	t->li = getnum(t->cap,US "li");
d468 1
a468 1
	t->co = getnum(t->cap,US "co");
d478 4
a481 4
	t->haz = getflag(t->cap,US "hz");
	t->os = getflag(t->cap,US "os");
	t->eo = getflag(t->cap,US "eo");
	if (getflag(t->cap,US "hc"))
d483 1
a483 1
	if (t->os || getflag(t->cap,US "ul"))
d488 2
a489 2
	t->xn = getflag(t->cap,US "xn");
	t->am = getflag(t->cap,US "am");
d494 3
a496 3
		t->ti = jgetstr(t->cap,US "ti");
	t->cl = jgetstr(t->cap,US "cl");
	t->cd = jgetstr(t->cap,US "cd");
d501 1
a501 1
		t->te = jgetstr(t->cap,US "te");
d503 6
a508 6
	t->ut = getflag(t->cap,US "ut");
	t->Sb = jgetstr(t->cap,US "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap,US "Sb");
	t->Sf = jgetstr(t->cap,US "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap,US "Sf");
	t->Co = getnum(t->cap,US "Co");
d517 1
a517 1
	if (!(t->me = jgetstr(t->cap,US "me")))
d519 1
a519 1
	if ((t->mb = jgetstr(t->cap,US "mb")))
d521 1
a521 1
	if ((t->md = jgetstr(t->cap,US "md")))
d523 1
a523 1
	if ((t->mh = jgetstr(t->cap,US "mh")))
d525 1
a525 1
	if ((t->mr = jgetstr(t->cap,US "mr")))
d535 2
a536 2
			t->Sf = US "\\E[3%dm";
			t->Sb = US "\\E[4%dm";
d542 2
a543 2
			t->Sf = US "\033[3%p1%dm";
			t->Sb = US "\033[4%p1%dm";
d556 2
a557 2
			t->Sf = US "\\E[38;5;%dm";
			t->Sb = US "\\E[48;5;%dm";
d565 2
a566 2
			t->Sf = US "\033[38;5;%p1%dm";
			t->Sb = US "\033[48;5;%p1%dm";
d574 2
a575 2
	if (getnum(t->cap,US "sg") <= 0 && !t->mr && jgetstr(t->cap,US "se")) {
		if ((t->so = jgetstr(t->cap,US "so")) != NULL)
d577 1
a577 1
		t->se = jgetstr(t->cap,US "se");
d579 1
a579 1
	if (getflag(t->cap,US "xs") || getflag(t->cap,US "xt"))
d584 2
a585 2
	if (getnum(t->cap,US "ug") <= 0 && jgetstr(t->cap,US "ue")) {
		if ((t->us = jgetstr(t->cap,US "us")) != NULL)
d587 1
a587 1
		t->ue = jgetstr(t->cap,US "ue");
d590 1
a590 1
	if (!(t->uc = jgetstr(t->cap,US "uc")))
d592 1
a592 1
			t->uc =US "_";
d596 1
a596 1
	t->ms = getflag(t->cap,US "ms");
d598 27
a624 27
	t->da = getflag(t->cap,US "da");
	t->db = getflag(t->cap,US "db");
	t->cs = jgetstr(t->cap,US "cs");
	t->rr = getflag(t->cap,US "rr");
	t->sf = jgetstr(t->cap,US "sf");
	t->sr = jgetstr(t->cap,US "sr");
	t->SF = jgetstr(t->cap,US "SF");
	t->SR = jgetstr(t->cap,US "SR");
	t->al = jgetstr(t->cap,US "al");
	t->dl = jgetstr(t->cap,US "dl");
	t->AL = jgetstr(t->cap,US "AL");
	t->DL = jgetstr(t->cap,US "DL");
	if (!getflag(t->cap,US "ns") && !t->sf)
		t->sf =US "\12";

	if (!getflag(t->cap,US "in") && baud < 38400) {
		t->dc = jgetstr(t->cap,US "dc");
		t->DC = jgetstr(t->cap,US "DC");
		t->dm = jgetstr(t->cap,US "dm");
		t->ed = jgetstr(t->cap,US "ed");

		t->im = jgetstr(t->cap,US "im");
		t->ei = jgetstr(t->cap,US "ei");
		t->ic = jgetstr(t->cap,US "ic");
		t->IC = jgetstr(t->cap,US "IC");
		t->ip = jgetstr(t->cap,US "ip");
		t->mi = getflag(t->cap,US "mi");
d639 6
a644 6
	if (jgetstr(t->cap,US "bc"))
		t->bs = jgetstr(t->cap,US "bc");
	else if (jgetstr(t->cap,US "le"))
		t->bs = jgetstr(t->cap,US "le");
	if (getflag(t->cap,US "bs"))
		t->bs =US "\10";
d648 3
a650 3
	t->lf =US "\12";
	if (jgetstr(t->cap,US "do"))
		t->lf = jgetstr(t->cap,US "do");
d653 1
a653 1
	t->up = jgetstr(t->cap,US "up");
d656 1
a656 1
	t->nd = jgetstr(t->cap,US "nd");
d659 10
a668 10
	if (getnum(t->cap,US "it") > 0)
		t->tw = getnum(t->cap,US "it");
	else if (getnum(t->cap,US "tw") > 0)
		t->tw = getnum(t->cap,US "tw");

	if (!(t->ta = jgetstr(t->cap,US "ta")))
		if (getflag(t->cap,US "pt"))
			t->ta =US "\11";
	t->bt = jgetstr(t->cap,US "bt");
	if (getflag(t->cap,US "xt")) {
d681 1
a681 1
	t->ho = jgetstr(t->cap,US "ho");
d683 1
a683 1
	t->ll = jgetstr(t->cap,US "ll");
d686 4
a689 4
	t->cr =US "\15";
	if (jgetstr(t->cap,US "cr"))
		t->cr = jgetstr(t->cap,US "cr");
	if (getflag(t->cap,US "nc") || getflag(t->cap,US "xr"))
d693 8
a700 8
	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap,US "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap,US "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap,US "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap,US "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap,US "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap,US "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap,US "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap,US "cm"), 1, 2, 2, 0, 0);
d702 1
a702 1
	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap,US "ce"), 1, 2, 2, 0, 0);
d1777 1
a1777 1
	if(!zcmp(s,US "inverse"))
d1779 1
a1779 1
	else if(!zcmp(s,US "underline"))
d1781 1
a1781 1
	else if(!zcmp(s,US "bold"))
d1783 1
a1783 1
	else if(!zcmp(s,US "blink"))
d1785 1
a1785 1
	else if(!zcmp(s,US "dim"))
d1789 1
a1789 1
	else if(!zcmp(s,US "white"))
d1791 1
a1791 1
	else if(!zcmp(s,US "cyan"))
d1793 1
a1793 1
	else if(!zcmp(s,US "magenta"))
d1795 1
a1795 1
	else if(!zcmp(s,US "blue"))
d1797 1
a1797 1
	else if(!zcmp(s,US "yellow"))
d1799 1
a1799 1
	else if(!zcmp(s,US "green"))
d1801 1
a1801 1
	else if(!zcmp(s,US "red"))
d1803 1
a1803 1
	else if(!zcmp(s,US "black"))
d1805 1
a1805 1
	else if(!zcmp(s,US "bg_white"))
d1807 1
a1807 1
	else if(!zcmp(s,US "bg_cyan"))
d1809 1
a1809 1
	else if(!zcmp(s,US "bg_magenta"))
d1811 1
a1811 1
	else if(!zcmp(s,US "bg_blue"))
d1813 1
a1813 1
	else if(!zcmp(s,US "bg_yellow"))
d1815 1
a1815 1
	else if(!zcmp(s,US "bg_green"))
d1817 1
a1817 1
	else if(!zcmp(s,US "bg_red"))
d1819 1
a1819 1
	else if(!zcmp(s,US "bg_black"))
d1823 1
a1823 1
	else if(!zcmp(s,US "WHITE"))
d1825 1
a1825 1
	else if(!zcmp(s,US "CYAN"))
d1827 1
a1827 1
	else if(!zcmp(s,US "MAGENTA"))
d1829 1
a1829 1
	else if(!zcmp(s,US "BLUE"))
d1831 1
a1831 1
	else if(!zcmp(s,US "YELLOW"))
d1833 1
a1833 1
	else if(!zcmp(s,US "GREEN"))
d1835 1
a1835 1
	else if(!zcmp(s,US "RED"))
d1837 1
a1837 1
	else if(!zcmp(s,US "BLACK"))
d1839 1
a1839 1
	else if(!zcmp(s,US "bg_WHITE"))
d1841 1
a1841 1
	else if(!zcmp(s,US "bg_CYAN"))
d1843 1
a1843 1
	else if(!zcmp(s,US "bg_MAGENTA"))
d1845 1
a1845 1
	else if(!zcmp(s,US "bg_BLUE"))
d1847 1
a1847 1
	else if(!zcmp(s,US "bg_YELLOW"))
d1849 1
a1849 1
	else if(!zcmp(s,US "bg_GREEN"))
d1851 1
a1851 1
	else if(!zcmp(s,US "bg_RED"))
d1853 1
a1853 1
	else if(!zcmp(s,US "bg_BLACK"))
@


1.54
log
@fix assume_256.  get rid of ^#
@
text
@d169 1
a169 1
				joe_snprintf_1((char *)bf,sizeof(bf),"\033[38;5;%dm",color);
d185 1
a185 1
				joe_snprintf_1((char *)bf,sizeof(bf),"\033[48;5;%dm",color);
d720 1
a720 1
	fprintf(stderr,"Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
@


1.53
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d166 11
a176 4
			if (t->Co & (t->Co - 1))
				texec(t->cap, t->Sf, 1, ((c & FG_VALUE) >> FG_SHIFT) % t->Co, 0, 0, 0);
			else
				texec(t->cap, t->Sf, 1, ((c & FG_VALUE) >> FG_SHIFT) & (t->Co - 1), 0, 0, 0);
d182 11
a192 4
			if (t->Co & (t->Co - 1))
				texec(t->cap, t->Sb, 1, ((c & BG_VALUE) >> BG_SHIFT) % t->Co, 0, 0, 0);
			else
				texec(t->cap, t->Sb, 1, ((c & BG_VALUE) >> BG_SHIFT) & (t->Co - 1), 0, 0, 0);
d530 1
a530 1
	if (assume_color) {
d548 1
a549 1
      		t->Co = 256;
d553 2
d558 1
d562 2
d567 1
@


1.52
log
@New line attribute cache.
@
text
@a7 1
#include "config.h"
a9 15
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "bw.h"
#include "blocks.h"
#include "scrn.h"
#include "termcap.h"
#include "charmap.h"
#include "utf8.h"
#include "syntax.h"
#include "utils.h"
#include "mouse.h"

a18 2
extern int mid;

d164 2
a165 2
	if ((t->attrib & FG_MASK) != (c & FG_MASK))
		if (t->Sf)
d170 2
d173 2
a174 2
	if ((t->attrib & BG_MASK) != (c & BG_MASK))
		if (t->Sb)
d179 2
d239 1
a239 1
			if (c>=32 && c<=126 || c>=160) {
d698 1
a698 1
        fprintf(stderr,"cm=%d ch=%d cv=%d ho=%d lf=%d DO=%d ll=%d up=%d UP=%d cr=%d\n",
d1370 1
a1370 1
			int maxaryy;
a1451 1
	int q;
a1521 1
	int q;
a1717 2
extern volatile int dostaupd;

a1719 1
	int x;
d1922 1
a1922 1
		if (wid>=0)
d1953 1
d2048 1
a2048 1
			if (wid>=0)
d2070 1
d2086 1
a2086 1
	while (c= *s++) {
@


1.51
log
@Allow setting foreground and background colors.  Added new status line color.
@
text
@a749 1
	t->syntab = NULL;
a776 2
	if (t->syntab)
		joe_free(t->syntab);
a790 1
	t->syntab = (HIGHLIGHT_STATE *) joe_malloc(t->li * sizeof(HIGHLIGHT_STATE));
a1517 2
	for(q=0; q!=bot-top; ++q)
		invalidate_state(t->syntab + top + q);
a1527 2
		for(q=0; q!=amnt; ++q)
			invalidate_state(t->syntab + t->li - amnt + q);
a1588 2
	for(q=0; q!=bot-top; ++q)
		invalidate_state(t->syntab + top + q);
a1597 2
		for(q=0;q!=amnt; ++q)
			invalidate_state(t->syntab + q);
a1695 1
			move_state(t->syntab + x - 1, t->syntab + x - amnt - 1);
d1699 1
a1699 2
			invalidate_state(t->syntab + x);
			}
d1706 1
a1706 3
		for(x=0; x!=amnt; ++x)
			invalidate_state(t->syntab + top + x);
		}
a1720 1
			move_state(t->syntab + x - amnt, t->syntab + x);
d1724 1
a1724 2
			invalidate_state(t->syntab + x);
			}
a1730 2
		for(x=0; x!=amnt; ++x)
			invalidate_state(t->syntab + bot - amnt + x);
a1745 2
	for(x=0; x!=t->li - skiptop; ++x)
		invalidate_state(t->syntab + skiptop + x);
@


1.50
log
@fix -assume_256color bug
@
text
@d1796 1
a1796 1
int meta_color(unsigned char *s)
d1906 21
@


1.49
log
@fix gcc-4.0.0 warnings
@
text
@d552 1
a552 1
		if (!t->Sf && t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') { 
d558 1
a558 1
		if (!t->Sf && t->md && t->md[0]=='\033' && t->md[1]=='[') { 
d560 2
a561 2
			t->Sf = US "\033[38;5%p1%dm";
			t->Sb = US "\033[48;5%p1%dm";
@


1.48
log
@Minor fix with bg_color
@
text
@d1798 1
a1798 1
	if(!strcmp((char *)s,"inverse"))
d1800 1
a1800 1
	else if(!strcmp((char *)s,"underline"))
d1802 1
a1802 1
	else if(!strcmp((char *)s,"bold"))
d1804 1
a1804 1
	else if(!strcmp((char *)s,"blink"))
d1806 1
a1806 1
	else if(!strcmp((char *)s,"dim"))
d1810 1
a1810 1
	else if(!strcmp((char *)s,"white"))
d1812 1
a1812 1
	else if(!strcmp((char *)s,"cyan"))
d1814 1
a1814 1
	else if(!strcmp((char *)s,"magenta"))
d1816 1
a1816 1
	else if(!strcmp((char *)s,"blue"))
d1818 1
a1818 1
	else if(!strcmp((char *)s,"yellow"))
d1820 1
a1820 1
	else if(!strcmp((char *)s,"green"))
d1822 1
a1822 1
	else if(!strcmp((char *)s,"red"))
d1824 1
a1824 1
	else if(!strcmp((char *)s,"black"))
d1826 1
a1826 1
	else if(!strcmp((char *)s,"bg_white"))
d1828 1
a1828 1
	else if(!strcmp((char *)s,"bg_cyan"))
d1830 1
a1830 1
	else if(!strcmp((char *)s,"bg_magenta"))
d1832 1
a1832 1
	else if(!strcmp((char *)s,"bg_blue"))
d1834 1
a1834 1
	else if(!strcmp((char *)s,"bg_yellow"))
d1836 1
a1836 1
	else if(!strcmp((char *)s,"bg_green"))
d1838 1
a1838 1
	else if(!strcmp((char *)s,"bg_red"))
d1840 1
a1840 1
	else if(!strcmp((char *)s,"bg_black"))
d1844 1
a1844 1
	else if(!strcmp((char *)s,"WHITE"))
d1846 1
a1846 1
	else if(!strcmp((char *)s,"CYAN"))
d1848 1
a1848 1
	else if(!strcmp((char *)s,"MAGENTA"))
d1850 1
a1850 1
	else if(!strcmp((char *)s,"BLUE"))
d1852 1
a1852 1
	else if(!strcmp((char *)s,"YELLOW"))
d1854 1
a1854 1
	else if(!strcmp((char *)s,"GREEN"))
d1856 1
a1856 1
	else if(!strcmp((char *)s,"RED"))
d1858 1
a1858 1
	else if(!strcmp((char *)s,"BLACK"))
d1860 1
a1860 1
	else if(!strcmp((char *)s,"bg_WHITE"))
d1862 1
a1862 1
	else if(!strcmp((char *)s,"bg_CYAN"))
d1864 1
a1864 1
	else if(!strcmp((char *)s,"bg_MAGENTA"))
d1866 1
a1866 1
	else if(!strcmp((char *)s,"bg_BLUE"))
d1868 1
a1868 1
	else if(!strcmp((char *)s,"bg_YELLOW"))
d1870 1
a1870 1
	else if(!strcmp((char *)s,"bg_GREEN"))
d1872 1
a1872 1
	else if(!strcmp((char *)s,"bg_RED"))
d1874 1
a1874 1
	else if(!strcmp((char *)s,"bg_BLACK"))
@


1.47
log
@some more minor bknd fixes
@
text
@d408 2
a409 1
		set_attr(t, atr); 
d418 1
a418 1
		if (t->attrib)
@


1.46
log
@Background color for screen item
@
text
@d1537 1
a1537 1
		msetI(t->attr + (bot - amnt) * t->co, atr, amnt * t->co); 
d1611 1
a1611 1
		msetI(t->attr + t->co * top, atr, amnt * t->co); 
@


1.45
log
@Background color
@
text
@d26 1
a26 1
int bg_color = 0;
d385 1
a385 1
int eraeol(SCRN *t, int x, int y)
d400 1
a400 1
		} else if (*--aa != 0) {
d406 1
a406 1
	if ((ss - s > 3 || s[w] != ' ' || a[w] != 0) && t->ce) {
d408 1
a408 1
		set_attr(t, BG_COLOR(bg_color)); 
d411 1
a411 1
		msetI(a, BG_COLOR(bg_color), w); 
d418 1
a418 1
			set_attr(t, BG_COLOR(bg_color)); 
d421 1
a421 1
			*a = 0;
d1354 1
a1354 1
	msetI(t->attr + t->co * y + t->co - n, BG_COLOR(bg_color), n); 
d1466 1
a1466 1
static void doupscrl(SCRN *t, int top, int bot, int amnt)
d1473 1
a1473 1
	set_attr(t, BG_COLOR(bg_color)); 
d1537 1
a1537 1
		msetI(t->attr + (bot - amnt) * t->co, BG_COLOR(bg_color), amnt * t->co); 
d1541 1
a1541 1
static void dodnscrl(SCRN *t, int top, int bot, int amnt)
d1548 1
a1548 1
	set_attr(t, BG_COLOR(bg_color)); 
d1611 1
a1611 1
		msetI(t->attr + t->co * top, BG_COLOR(bg_color), amnt * t->co); 
d1615 1
a1615 1
void nscroll(SCRN *t)
d1627 1
a1627 1
				doupscrl(t, y, z + q, q);
d1636 1
a1636 1
						dodnscrl(t, z + q, p + 1, -q);
d1649 1
a1649 1
	set_attr(t, BG_COLOR(bg_color)); 
a1655 2
	int tmp = bg_color;
	bg_color = 0;
d1659 1
a1659 1
	eraeol(t, 0, t->li - 1);
a1661 1
	bg_color = tmp;
d1760 1
a1760 1
	msetI(t->attr, BG_COLOR(bg_color), t->co * skiptop);  
d1762 1
a1762 1
	msetI(t->attr + skiptop * t->co, BG_COLOR(bg_color), (t->li - skiptop) * t->co); 
d1773 1
a1773 1
	set_attr(t, BG_COLOR(bg_color)); 
d1783 1
a1783 1
			msetI(t->attr, BG_COLOR(bg_color), t->li * t->co); 
d1788 1
a1788 1
			msetI(t->attr, BG_COLOR(bg_color), t->li * t->co); 
d1975 1
a1975 1
		outatr(locale_map, t, scrn, attr, x, y, ' ', BG_COLOR(bg_color)); 
d1982 1
a1982 1
		eraeol(t, x, y);
d2007 1
a2007 1
void genfmt(SCRN *t, int x, int y, int ofst, unsigned char *s, int flg)
a2010 1
	int atr = BG_COLOR(bg_color);
d2090 1
a2090 1
		eraeol(t, x, y);
@


1.44
log
@Fix some resize window bugs, add 256 color support.
@
text
@d26 1
d408 1
a408 1
		set_attr(t, 0);
d411 1
a411 1
		msetI(a, 0, w);
d418 1
a418 1
			set_attr(t, 0);
d1354 1
a1354 1
	msetI(t->attr + t->co * y + t->co - n, 0, n);
d1473 1
a1473 1
	set_attr(t, 0);
d1537 1
a1537 1
		msetI(t->attr + (bot - amnt) * t->co, 0, amnt * t->co);
d1548 1
a1548 1
	set_attr(t, 0);
d1611 1
a1611 1
		msetI(t->attr + t->co * top, 0, amnt * t->co);
d1649 1
a1649 1
	set_attr(t, 0);
d1656 2
d1664 1
d1763 1
a1763 1
	msetI(t->attr, 0, t->co * skiptop);
d1765 1
a1765 1
	msetI(t->attr + skiptop * t->co, 0, (t->li - skiptop) * t->co);
d1776 1
a1776 1
	set_attr(t, 0);
d1786 1
a1786 1
			msetI(t->attr, 0, t->li * t->co);
d1791 1
a1791 1
			msetI(t->attr, 0, t->li * t->co);
d1888 1
a1888 1
	        return FG_NOT_DEFAULT | ((16 + (s[3]-'0')*6*6 + (s[4]-'0')*6 + (s[5]-'0'))<<FG_SHIFT);
d1894 1
a1894 1
	        return BG_NOT_DEFAULT | ((16 + (s[3]-'0')*6*6 + (s[4]-'0')*6 + (s[5]-'0'))<<FG_SHIFT);
d1978 1
a1978 1
		outatr(locale_map, t, scrn, attr, x, y, ' ', 0);
d2014 1
a2014 1
	int atr = 0;
@


1.43
log
@        Reformat mouse.c

        Apply diff patch

        Apply vpath patch

        Apply electrum's mouse patch (send mouse off code during
        shell escape)

        Mouse can now resize windows

        Mouse can position cursor in menus.  Double-click selects
        an item.  Need to add scroll.

@
text
@d32 1
d181 6
a186 2
	if ((t->attrib&FG_MASK)!=(c&FG_MASK))
		if (t->Sf) texec(t->cap,t->Sf,1,7-(((c&FG_VALUE)>>FG_SHIFT)),0,0,0);
d188 6
a193 2
	if ((t->attrib&BG_MASK)!=(c&BG_MASK))
		if (t->Sb) texec(t->cap,t->Sb,1,((c&BG_VALUE)>>BG_SHIFT),0,0,0);
d506 3
d529 1
a529 1
		/* Install color support if it looks like an ansi terminal (it has bold which begins with ESC [) */
d533 3
a535 2
			t->Sf =US "\\E[3%dm";
			t->Sb =US "\\E[4%dm";
d540 20
a559 2
			t->Sf =US "\033[3%p1%dm";
			t->Sb =US "\033[4%p1%dm";
d1806 2
d1840 60
@


1.42
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d24 1
d33 1
a33 1
extern int mid, ttisxterm;
a491 5
	if (ttisxterm) {
		ttputs(US "\33[?1002l");
		ttflsh();
	}

d725 3
d1624 1
d1634 1
a1634 2
	if (ttisxterm)
		ttputs(US "\33[?1002h");
d1644 1
@


1.41
log
@Blocks to work in hex mode.
Overtype mode for hex.
@
text
@d492 1
a492 1
		ttputs("\33[?1002l");
d1635 1
a1635 1
		ttputs("\33[?1002h");
@


1.40
log
@Jesse McGrew's xterm mouse support.
@
text
@d1822 1
d1825 1
a1825 1
void genfield(SCRN *t,int *scrn,int *attr,int x,int y,int ofst,unsigned char *s,int len,int atr,int width,int flg)
d1836 2
d1852 1
a1852 1
						outatr(locale_map, t, scrn, attr, x, y, '>', atr);
d1859 1
a1859 1
					outatr(locale_map, t, scrn, attr, x, y, c, atr);
d1869 1
a1869 1
					outatr(locale_map, t, scrn, attr, x, y, '<', atr);
@


1.39
log
@Highlighter state now includes a saved string.
This improves shell and perl highlighters.
@
text
@d32 1
a32 1
extern int mid;
d491 5
d1634 2
@


1.38
log
@Fix bg_reg -> bg_red.
@
text
@d22 1
d757 1
a757 1
	t->syntab = (int *) joe_malloc(t->li * sizeof(int));
d1433 1
d1485 2
a1486 1
	msetI(t->syntab + top, -1, bot - top);
d1497 2
a1498 1
		msetI(t->syntab + t->li - amnt, -1, amnt);
d1508 1
d1560 2
a1561 1
	msetI(t->syntab + top, -1, bot - top);
d1571 2
a1572 1
		msetI(t->syntab, -1, amnt);
d1668 1
a1668 1
			t->syntab[x - 1] = t->syntab[x - amnt - 1];
d1672 1
a1672 1
			t->syntab[x] = -1;
d1680 2
a1681 1
		msetI(t->syntab + top, -1, amnt);
d1697 1
a1697 1
			t->syntab[x - amnt] = t->syntab[x];
d1701 1
a1701 1
			t->syntab[x] = -1;
d1709 2
a1710 1
		msetI(t->syntab + bot - amnt, -1, amnt);
d1718 1
d1726 2
a1727 1
	msetI(t->syntab + skiptop, -1, t->li - skiptop);
@


1.37
log
@*** empty log message ***
@
text
@d1785 1
a1785 1
	else if(!strcmp((char *)s,"bg_reg"))
@


1.36
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d677 2
d1578 1
a1578 1
		if (have)
@


1.35
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d20 1
d191 1
a191 1
void outatr(int wide,struct charmap *map,SCRN *t,int *scrn,int *attrf,int xx,int yy,int c,int a)
d193 2
a194 2
	if(wide)
		if(utf8) {
a238 1
			unsigned char buf[16];
d244 3
a246 2
				utf8_encode(buf,c);
				c = from_utf8(locale_map,buf);
d250 1
a250 1
			if (!joe_isprint(0,locale_map,c) && !(dspasis && c>=128)) {
d270 1
a270 1
		if (!utf8) {
d275 1
a275 1
			if (!joe_isprint(0,locale_map,c) && !(dspasis && c>=128)) {
d300 1
a300 1
			if (!joe_iswprint(to_uni(map,c)) && !(dspasis && c>=128)) {
d305 4
a308 2
			to_utf8(map,buf,c);
			c = utf8_decode_string(buf);
d310 1
a310 1
			if(*scrn==c && *attrf==a)
d1815 1
a1815 1
		if (utf8) {
d1829 1
a1829 1
						outatr(utf8, locale_map, t, scrn, attr, x, y, '>', atr);
d1836 1
a1836 1
					outatr(utf8, locale_map, t, scrn, attr, x, y, c, atr);
d1846 1
a1846 1
					outatr(utf8, locale_map, t, scrn, attr, x, y, '<', atr);
d1858 1
a1858 1
		outatr(utf8, locale_map, t, scrn, attr, x, y, ' ', 0);
d1872 1
a1872 1
	if (utf8) {
d1929 1
a1929 1
					outatr(utf8, locale_map, t, scrn, attr, x, y, (c&0x7F), atr);
d1939 1
a1939 1
			if (utf8) {
d1952 1
a1952 1
					outatr(utf8, locale_map, t, scrn, attr, x, y, c, atr);
d1963 1
a1963 1
						outatr(utf8, locale_map, t, scrn, attr, x, y, '<', atr);
d2009 1
a2009 1
			if(utf8) {
d2060 1
a2060 1
			if(utf8) {
@


1.34
log
@Elimiante --pedantic warnings.
@
text
@a10 1
#include <ctype.h>
d190 1
a190 1
void outatr(int wide,SCRN *t,int *scrn,int *attrf,int xx,int yy,int c,int a)
d245 1
a245 1
				c = from_utf8(buf);
d249 1
a249 1
			if (!isprint(c) && !(dspasis && c>=128)) {
d271 1
d274 1
a274 1
			if (!isprint(c) && !(dspasis && c>=128)) {
d299 1
a299 1
			if (!isprint(c) && !(dspasis && c>=128)) {
d304 1
a304 1
			to_utf8(buf,c);
d1826 1
a1826 1
						outatr(utf8, t, scrn, attr, x, y, '>', atr);
d1833 1
a1833 1
					outatr(utf8, t, scrn, attr, x, y, c, atr);
d1843 1
a1843 1
					outatr(utf8, t, scrn, attr, x, y, '<', atr);
d1855 1
a1855 1
		outatr(utf8, t, scrn, attr, x, y, ' ', 0);
d1926 1
a1926 1
					outatr(utf8, t, scrn, attr, x, y, (c&0x7F), atr);
d1949 1
a1949 1
					outatr(utf8, t, scrn, attr, x, y, c, atr);
d1960 1
a1960 1
						outatr(utf8, t, scrn, attr, x, y, '<', atr);
@


1.33
log
@Fix highlighter when there are utf-8 characters in file.

No longer depend on wctype.h (working towards not depending on
iconv()).
@
text
@d140 1
a140 1
	// Attributes which have gone off
d155 1
a155 1
	// Attributes which have turned on
d226 1
a226 1
				sprintf(buf,"<%X>",c);
@


1.32
log
@Better handling of iconv() conversion errors.

Better handling of error UTF-8 sequences.
@
text
@d215 1
a215 1
			wid = mk_wcwidth(1,c);
d310 1
a310 1
			wid = mk_wcwidth(0,c);
d429 1
a429 1
	t->x+=mk_wcwidth(1,c);
d1816 1
a1816 1
				wid = mk_wcwidth(1,c);
d1877 1
a1877 1
				col += mk_wcwidth(1,d);
d1940 1
a1940 1
						wid = mk_wcwidth(1,c);
d2009 1
a2009 1
					wid = mk_wcwidth(1,c);
d2060 1
a2060 1
					wid = mk_wcwidth(1,c);
@


1.31
log
@Print <XXXX> for unicode control characters.
@
text
@a131 31
/* Write a multibyte character */

void utf8_putc(int utf8_char)
{
	unsigned char buf[16];

	if (unictrl(utf8_char)) {
		sprintf(buf,"<%X>",utf8_char);
		ttputs(buf);
	} else {
		int len = utf8_encode(buf,utf8_char);
		ttputs(buf);
	}
}

void xlat(int *attr, unsigned char *c)
{
	if(isprint(*c) || (dspasis && *c >= 128 ))
		*attr = 0;
	else {
		*attr = xlata[*c];
		*c = xlatc[*c];
	}
}

void xlat_utf_ctrl(int *attr, unsigned char *c)
{
	*attr = xlata[*c];
	*c = xlatc[*c];
}

d195 1
d197 15
a211 1
			/* UTF-8 char to UTF-8 terminal */
d215 1
a215 1
			wid = mk_wcwidth(c);
d225 7
a231 1
			utf8_putc(c);
d239 1
d241 13
a253 3
			unsigned char buf[10];
			utf8_encode(buf,c);	/* Utf-8 encode character */
			c = from_utf8(buf);	/* Convert to non-utf character */
d272 8
a279 1
			if(*scrn==c && *attrf==a)
d284 1
d295 1
a295 1
			unsigned char buf[10];
d297 7
d310 1
a310 1
			wid = mk_wcwidth(c);
d421 1
d429 2
a430 1
	t->x+=mk_wcwidth(c);
d1811 1
a1811 2
		int a;
		int wid = 0;
d1815 2
a1816 11
			if (c >= 0) {
				if (c<32 || c==127) { /* Control character */
					/* Note that this ignore dspasis */
					a = xlata[c] ^ atr;
					c = xlatc[c];
					wid = 1;
				} else { /* Normal character */
					wid = mk_wcwidth(c);
					a = atr;
				}
			}
a1818 4
			unsigned char bc = c;
			xlat (&a, &bc); /* Uses dspasis as it should */
			c = bc;
			a ^= atr;
d1821 23
a1843 5
		if (col >= ofst) {
			if (x + wid > last_col) {
				/* Character crosses end of field, so fill balance of field with '>' characters instead */
				while (x < last_col) {
					outatr(utf8, t, scrn, attr, x, y, '>', atr);
d1847 2
d1850 2
a1851 21
			} else if(wid) {
				/* Emit character */
				outatr(utf8, t, scrn, attr, x, y, c, a);
				x += wid;
				scrn += wid;
				attr += wid;
			}
		} else if ((col + wid) > ofst) {
			/* Wide character crosses left side of field */
			wid -= ofst - col;
			col = ofst;
			while (wid) {
				outatr(utf8, t, scrn, attr, x, y, '<', a);
				++scrn;
				++attr;
				++x;
				++col;
				--wid;
			}
		} else
			col += wid;
d1877 1
a1877 1
				col += mk_wcwidth(d);
a1924 5
				unsigned char bc = (c&0x7F);	/* Allow only ASCII here */
				int a;
				xlat (&a, &bc); /* Uses dspasis as it should */
				c = bc;
				a ^= atr;
d1926 1
a1926 1
					outatr(utf8, t, scrn, attr, x, y, c, a);
d1935 1
a1935 2
			int wid = 0;
			int a;
d1940 1
a1940 9
					if (c<32 || c==127) { /* ASCII control character */
						/* Note that this ignores dspasis */
						a = xlata[c] ^ atr;
						c = xlatc[c];
						wid = 1;
					} else { /* Normal character */
						wid = mk_wcwidth(c);
						a = atr;
					}
a1943 4
				unsigned char bc = c;
				xlat (&a, &bc); /* Uses dspasis as it should */
				c = bc;
				a ^= atr;
d1947 22
a1968 21
			if (col >= ofst) {
				outatr(utf8, t, scrn, attr, x, y, c, a);
				scrn += wid;
				attr += wid;
				x += wid;
				col += wid;
			} else if (col+wid>ofst) {
				while (col<ofst) {
					++col;
					--wid;
				}
				while (wid) {
					outatr(utf8, t, scrn, attr, x, y, '<', atr);
					++scrn;
					++attr;
					++x;
					++col;
					--wid;
				}
			} else
				col += wid;
d2009 1
a2009 1
					wid = mk_wcwidth(c);
d2060 1
a2060 1
					wid = mk_wcwidth(c);
@


1.30
log
@Allow UTF-8 in menu entries.

Clear up genfield() and genfmt() stuff.  Now control characters in
file names are properly displayed.

When UTF-8 character decodes to 127 - 159, 0 - 31, display it
as a control character.
@
text
@d136 9
a144 3
	unsigned char buf[8];
	int len = utf8_encode(buf,utf8_char);
	ttputs(buf);
d226 1
a227 1
			int zz;
d231 2
a232 1
			zz = mk_wcwidth(c);
d242 5
a246 4
			t->x+=zz;
			if(zz==2) {
				scrn[1]= -1;
				attrf[1]= 0;
d269 1
a269 1
		if(!utf8) {
d287 1
a287 1
			int zz;
d294 1
a294 1
			zz = mk_wcwidth(c);
d304 5
a308 5
			/* utf8_putc(c); */
			t->x+=zz;
			if(zz==2) {
				scrn[1]= -1;
				attrf[1]= 0;
d1799 1
a1799 1
				if (c<32 || c>126 && c<160) { /* Control character */
d1941 1
a1941 1
					if (c<32 || c>126 && c<160) { /* Control character */
@


1.29
log
@First attempt at character set conversion iconv().
Now the file's coding can be different from the terminal's
coding.

Also, applied secure linux patch from RedHat.
@
text
@d21 1
d151 6
a215 2
extern int utf8;

d1761 313
@


1.28
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d213 21
a233 37
	if(*scrn!=c || *attrf!=a)
		if(wide)
			if(utf8) {
				/* UTF-8 char to UTF-8 terminal */
				int zz = mk_wcwidth(c);
				*scrn = c;
				*attrf = a;
				if(t->ins)
					clrins(t);
				if(t->x != xx || t->y != yy)
					cpos(t, xx, yy);
				if(t->attrib != a)
					set_attr(t, a);
				utf8_putc(c);
				t->x+=zz;
				if(zz==2) {
					scrn[1]= -1;
					attrf[1]= 0;
				}
			} else {
				/* UTF-8 char to non-UTF-8 terminal */
				/* For now: assume terminal is UTF-8 */
				int zz = mk_wcwidth(c);
				*scrn = c;
				*attrf = a;
				if(t->ins)
					clrins(t);
				if(t->x != xx || t->y != yy)
					cpos(t, xx, yy);
				if(t->attrib != a)
					set_attr(t, a);
				utf8_putc(c);
				t->x+=zz;
				if(zz==2) {
					scrn[1]= -1;
					attrf[1]= 0;
				}
d235 61
a295 26
		else
			if(!utf8) {
				/* Non UTF-8 char to non UTF-8 terminal */
				*scrn = c;
				*attrf = a;
				if(t->ins)
					clrins(t);
				if(t->x != xx || t->y != yy)
					cpos(t,xx,yy);
				if(t->attrib != a)
					set_attr(t,a);
				ttputc(c);
				t->x++;
			} else {
				/* Non UTF-8 char to UTF-8 terminal */
				/* For now: assume terminal is not utf-8 anyway */
				*scrn = c;
				*attrf = a;
				if(t->ins)
					clrins(t);
				if(t->x != xx || t->y != yy)
					cpos(t,xx,yy);
				if(t->attrib != a)
					set_attr(t,a);
				ttputc(c);
				t->x++;
d297 1
@


1.27
log
@Added -assume_color global option.
@
text
@d142 1
a142 1
	if(isprint(*c) || (dspasis && *c > 128 ))
d207 73
@


1.26
log
@Input of UTF-8 is now working.  For example, you
can cut and paste in an xterm.

Placed UTF-8 encoder and decoder in separate file.
@
text
@d28 1
d386 3
a388 1
/* Install color support if it looks like an ansi terminal (it has bold which begins with ESC [) */
d390 5
a394 5
	if (!t->Sf && t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') { 
		t->ut = 1;
		t->Sf =US "\\E[3%dm";
		t->Sb =US "\\E[4%dm";
	}
d396 6
a401 4
	if (!t->Sf && t->md && t->md[0]=='\033' && t->md[1]=='[') { 
		t->ut = 1;
		t->Sf =US "\033[3%p1%dm";
		t->Sb =US "\033[4%p1%dm";
a402 1
#endif
@


1.25
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d134 3
a136 28
	if (utf8_char < 0x80 || dspasis) {
		ttputc(utf8_char);
	} else if(utf8_char < 0x800) {
		ttputc(0xc0|(utf8_char>>6));
		ttputc(0x80|(utf8_char&0x3F));
	} else if(utf8_char < 0x20000) {
		ttputc(0xe0|(utf8_char>>12));
		ttputc(0x80|((utf8_char>>6)&0x3f));
		ttputc(0x80|((utf8_char)&0x3f));
	} else if(utf8_char < 0x200000) {
		ttputc(0xf0|(utf8_char>>18));
		ttputc(0x80|((utf8_char>>12)&0x3f));
		ttputc(0x80|((utf8_char>>6)&0x3f));
		ttputc(0x80|((utf8_char)&0x3f));
	} else if(utf8_char < 0x4000000) {
		ttputc(0xf8|(utf8_char>>24));
		ttputc(0x80|((utf8_char>>18)&0x3f));
		ttputc(0x80|((utf8_char>>12)&0x3f));
		ttputc(0x80|((utf8_char>>6)&0x3f));
		ttputc(0x80|((utf8_char)&0x3f));
	} else {
		ttputc(0xfC|(utf8_char>>30));
		ttputc(0x80|((utf8_char>>24)&0x3f));
		ttputc(0x80|((utf8_char>>18)&0x3f));
		ttputc(0x80|((utf8_char>>12)&0x3f));
		ttputc(0x80|((utf8_char>>6)&0x3f));
		ttputc(0x80|((utf8_char)&0x3f));
	}
d1099 1
a1099 1
				if(*cs<0 || *cs>=256)
@


1.24
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d26 2
d334 1
a334 1
static void out(char *t, char c)
d349 1
a349 1
	t->li = getnum(t->cap, "li");
d352 1
a352 1
	t->co = getnum(t->cap, "co");
d362 4
a365 4
	t->haz = getflag(t->cap, "hz");
	t->os = getflag(t->cap, "os");
	t->eo = getflag(t->cap, "eo");
	if (getflag(t->cap, "hc"))
d367 1
a367 1
	if (t->os || getflag(t->cap, "ul"))
d372 2
a373 2
	t->xn = getflag(t->cap, "xn");
	t->am = getflag(t->cap, "am");
d375 17
a391 11
	t->ti = jgetstr(t->cap, "ti");
	t->cl = jgetstr(t->cap, "cl");
	t->cd = jgetstr(t->cap, "cd");

	t->te = jgetstr(t->cap, "te");

	t->ut = getflag(t->cap, "ut");
	t->Sb = jgetstr(t->cap, "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap, "Sb");
	t->Sf = jgetstr(t->cap, "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap, "Sf");
d398 1
a398 1
	if (!(t->me = jgetstr(t->cap, "me")))
d400 1
a400 1
	if ((t->mb = jgetstr(t->cap, "mb")))
d402 1
a402 1
	if ((t->md = jgetstr(t->cap, "md")))
d404 1
a404 1
	if ((t->mh = jgetstr(t->cap, "mh")))
d406 1
a406 1
	if ((t->mr = jgetstr(t->cap, "mr")))
d414 2
a415 2
		t->Sf = "\\E[3%dm";
		t->Sb = "\\E[4%dm";
d420 2
a421 2
		t->Sf = "\033[3%p1%dm";
		t->Sb = "\033[4%p1%dm";
d427 2
a428 2
	if (getnum(t->cap, "sg") <= 0 && !t->mr && jgetstr(t->cap, "se")) {
		if ((t->so = jgetstr(t->cap, "so")) != NULL)
d430 1
a430 1
		t->se = jgetstr(t->cap, "se");
d432 1
a432 1
	if (getflag(t->cap, "xs") || getflag(t->cap, "xt"))
d437 2
a438 2
	if (getnum(t->cap, "ug") <= 0 && jgetstr(t->cap, "ue")) {
		if ((t->us = jgetstr(t->cap, "us")) != NULL)
d440 1
a440 1
		t->ue = jgetstr(t->cap, "ue");
d443 1
a443 1
	if (!(t->uc = jgetstr(t->cap, "uc")))
d445 1
a445 1
			t->uc = "_";
d449 1
a449 1
	t->ms = getflag(t->cap, "ms");
d451 27
a477 27
	t->da = getflag(t->cap, "da");
	t->db = getflag(t->cap, "db");
	t->cs = jgetstr(t->cap, "cs");
	t->rr = getflag(t->cap, "rr");
	t->sf = jgetstr(t->cap, "sf");
	t->sr = jgetstr(t->cap, "sr");
	t->SF = jgetstr(t->cap, "SF");
	t->SR = jgetstr(t->cap, "SR");
	t->al = jgetstr(t->cap, "al");
	t->dl = jgetstr(t->cap, "dl");
	t->AL = jgetstr(t->cap, "AL");
	t->DL = jgetstr(t->cap, "DL");
	if (!getflag(t->cap, "ns") && !t->sf)
		t->sf = "\12";

	if (!getflag(t->cap, "in") && baud < 38400) {
		t->dc = jgetstr(t->cap, "dc");
		t->DC = jgetstr(t->cap, "DC");
		t->dm = jgetstr(t->cap, "dm");
		t->ed = jgetstr(t->cap, "ed");

		t->im = jgetstr(t->cap, "im");
		t->ei = jgetstr(t->cap, "ei");
		t->ic = jgetstr(t->cap, "ic");
		t->IC = jgetstr(t->cap, "IC");
		t->ip = jgetstr(t->cap, "ip");
		t->mi = getflag(t->cap, "mi");
d492 6
a497 6
	if (jgetstr(t->cap, "bc"))
		t->bs = jgetstr(t->cap, "bc");
	else if (jgetstr(t->cap, "le"))
		t->bs = jgetstr(t->cap, "le");
	if (getflag(t->cap, "bs"))
		t->bs = "\10";
d501 3
a503 3
	t->lf = "\12";
	if (jgetstr(t->cap, "do"))
		t->lf = jgetstr(t->cap, "do");
d506 1
a506 1
	t->up = jgetstr(t->cap, "up");
d509 1
a509 1
	t->nd = jgetstr(t->cap, "nd");
d512 15
a526 10
	if (getnum(t->cap, "it") > 0)
		t->tw = getnum(t->cap, "it");
	else if (getnum(t->cap, "tw") > 0)
		t->tw = getnum(t->cap, "tw");

	if (!(t->ta = jgetstr(t->cap, "ta")))
		if (getflag(t->cap, "pt"))
			t->ta = "\11";
	t->bt = jgetstr(t->cap, "bt");
	if (getflag(t->cap, "xt")) {
d534 1
a534 1
	t->ho = jgetstr(t->cap, "ho");
d536 1
a536 1
	t->ll = jgetstr(t->cap, "ll");
d539 4
a542 4
	t->cr = "\15";
	if (jgetstr(t->cap, "cr"))
		t->cr = jgetstr(t->cap, "cr");
	if (getflag(t->cap, "nc") || getflag(t->cap, "xr"))
d546 8
a553 8
	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap, "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap, "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap, "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap, "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap, "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap, "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap, "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap, "cm"), 1, 2, 2, 0, 0);
d555 1
a555 1
	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap, "ce"), 1, 2, 2, 0, 0);
d571 1
a571 1
	fprintf(stderr, "Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
a1012 1
#if 0
a1063 1
#endif
d1115 1
a1116 3
		if (x == t->x)
			return 0;
#if 0
d1120 6
d1127 4
a1130 8
			if (t->ins)
				clrins(t);
			do {
				/* int c = (0xFF & *cs);
				int a = (0xFF00 & *cs); */
				int c, a;
				if (*cs==-1) c=' ', a=0;
				else c= *cs, a= *as;
a1131 3
				if (a != t->attrib)
					set_attr(t, a);
				utf8_putc(c);
d1135 1
d1137 2
a1139 2
		}
#endif
d1145 1
d1148 1
d1637 1
a1637 1
int meta_color(char *s)
d1639 1
a1639 1
	if(!strcmp(s,"inverse"))
d1641 1
a1641 1
	else if(!strcmp(s,"underline"))
d1643 1
a1643 1
	else if(!strcmp(s,"bold"))
d1645 1
a1645 1
	else if(!strcmp(s,"blink"))
d1647 1
a1647 1
	else if(!strcmp(s,"dim"))
d1649 1
a1649 1
	else if(!strcmp(s,"white"))
d1651 1
a1651 1
	else if(!strcmp(s,"cyan"))
d1653 1
a1653 1
	else if(!strcmp(s,"magenta"))
d1655 1
a1655 1
	else if(!strcmp(s,"blue"))
d1657 1
a1657 1
	else if(!strcmp(s,"yellow"))
d1659 1
a1659 1
	else if(!strcmp(s,"green"))
d1661 1
a1661 1
	else if(!strcmp(s,"red"))
d1663 1
a1663 1
	else if(!strcmp(s,"black"))
d1665 1
a1665 1
	else if(!strcmp(s,"bg_white"))
d1667 1
a1667 1
	else if(!strcmp(s,"bg_cyan"))
d1669 1
a1669 1
	else if(!strcmp(s,"bg_magenta"))
d1671 1
a1671 1
	else if(!strcmp(s,"bg_blue"))
d1673 1
a1673 1
	else if(!strcmp(s,"bg_yellow"))
d1675 1
a1675 1
	else if(!strcmp(s,"bg_green"))
d1677 1
a1677 1
	else if(!strcmp(s,"bg_reg"))
d1679 1
a1679 1
	else if(!strcmp(s,"bg_black"))
@


1.23
log
@Fix highlighting bug.  Assume terminal supports color if it appears to be
ansi.
@
text
@d128 34
d174 1
a174 1
int attr(SCRN *t, int c)
d272 1
a272 1
	int *s, *ss;
d278 1
d280 1
d285 4
d291 1
a291 1
	if ((ss - s > 3 || s[w] != ' ') && t->ce) {
d293 1
a293 1
		attr(t, 0);
d296 1
d303 1
a303 1
			attr(t, 0);
d306 1
d310 1
d319 1
a319 1
static void outatri(SCRN *t, int x, int y, int c)
a320 2
	unsigned char ch;

d323 7
a329 8
	ch = c;
	c -= ch;
	if (c != t->attrib)
		attr(t, c);
	if (t->haz && ch == '~')
		ch = '\\';
	ttputc(ch);
	++t->x;
d591 1
d623 2
d632 1
d1000 1
d1052 1
d1068 1
a1068 1
		if (t->cRI < x - t->x) {
d1072 8
d1081 1
d1086 7
a1092 7
				int a, c;
				if(*s==-1) c=' ', a=0;
				else c=(0xFF&*s), a=(~0xFF&*s);

				if (a != t->attrib)
					attr(t, a);
				ttputc(c);
d1094 1
d1098 1
d1107 1
d1110 1
d1119 1
a1119 1
				else c=(0xFF& *cs), a=(~0xFF& *cs);
d1122 2
a1123 2
					attr(t, a);
				ttputc(c);
d1125 1
d1130 1
d1133 2
a1134 2
	    (t->ut && t->attrib & BG_NOT_DEFAULT))
		attr(t, t->attrib & ~(INVERSE | UNDERLINE | BG_MASK));
d1142 1
a1142 1
static void doinschr(SCRN *t, int x, int y, int *s, int n)
d1148 1
d1160 1
a1160 1
				outatri(t, x + a, y, s[a]);
d1168 1
a1168 1
				outatri(t, x + a, y, s[a]);
d1172 1
d1174 1
d1196 1
d1198 1
d1202 1
d1204 1
a1204 1
void magic(SCRN *t, int y, int *cs, int *s, int placex)
d1300 1
a1300 1
				doinschr(t, x + q, y, s + x + q, -q);
d1316 1
a1316 1
	attr(t, 0);
d1369 1
d1373 1
d1376 1
a1376 1
	} else
d1378 2
d1388 1
a1388 1
	attr(t, 0);
d1440 1
d1444 1
d1447 1
a1447 1
	} else
d1449 2
d1487 1
a1487 1
	attr(t, 0);
d1513 1
a1513 1
	attr(t, 0);
d1522 1
d1592 1
d1594 1
d1604 1
a1604 1
	attr(t, 0);
d1614 1
d1619 1
@


1.22
log
@Clean up meaning of default color.

Allow syntax to be specified in joerc file: "-syntax perl"

Add class definitions to syntax files.

Add perl and verilog definitions (they need work).

Change joerc to assume files with . in their name do not want word
wrap enabled (except for .txt).
@
text
@d362 15
@


1.21
log
@Fix coloring to revert to terminal default for regular text instead
of white on black.
@
text
@d145 5
a149 2
	e = (AT_MASK&t->attrib & ~c) || ((FG_MASK&t->attrib) && !(FG_MASK&c)) || ((BG_MASK&t->attrib) && !(BG_MASK&c));
	if (e) {		/* If any attribute go off, switch them all off: fixes bug on PCs */
d160 2
d163 1
d170 1
d183 1
d185 2
a186 1
		if (t->Sf) texec(t->cap,t->Sf,1,7-(((c&FG_MASK)>>FG_SHIFT)),0,0,0);
d188 2
a189 1
		if (t->Sb) texec(t->cap,t->Sb,1,((c&BG_MASK)>>BG_SHIFT),0,0,0);
d191 1
d1056 2
a1057 2
	if ((!t->ms && t->attrib & (INVERSE | UNDERLINE | BG_MASK)) ||
	    (t->ut && t->attrib&BG_MASK))
d1059 1
d1528 50
@


1.20
log
@Syntax highlighting baby steps.
@
text
@d145 1
a145 1
	e = (AT_MASK&t->attrib & ~c);
@


1.19
log
@change 0 to NULL where we're talking about pointers
@
text
@d130 1
a130 1
	if(isprint(*c) || (dspasis && *c > 128))
d145 1
a145 1
	e = (t->attrib & ~c);
d176 4
d328 6
d527 1
d552 2
d565 1
d1005 3
a1007 2
				int c = (0xFF & *s);
				int a = (0xFF00 & *s);
d1030 5
a1034 2
				int c = (0xFF & *cs);
				int a = (0xFF00 & *cs);
d1045 3
a1047 2
	if (!t->ms && t->attrib & (INVERSE | UNDERLINE))
		attr(t, t->attrib & ~(INVERSE | UNDERLINE));
d1270 1
d1279 1
d1338 1
d1346 1
d1439 1
d1441 1
a1441 1
		for (x = top; x != top + amnt; ++x)
d1443 2
d1449 1
a1449 1
	if (amnt == bot - top)
d1451 2
d1467 1
d1469 1
a1469 1
		for (x = bot - amnt; x != bot; ++x)
d1471 2
d1477 1
a1477 1
	if (amnt == bot - top)
d1479 2
d1492 1
@


1.18
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d324 4
a327 4
	t->mb = 0;
	t->md = 0;
	t->mh = 0;
	t->mr = 0;
d341 2
a342 2
	t->so = 0;
	t->se = 0;
d349 1
a349 1
		t->so = 0;
d351 2
a352 2
	t->us = 0;
	t->ue = 0;
d395 9
a403 9
		t->dm = 0;
		t->dc = 0;
		t->DC = 0;
		t->ed = 0;
		t->im = 0;
		t->ic = 0;
		t->IC = 0;
		t->ip = 0;
		t->ei = 0;
d407 1
a407 1
	t->bs = 0;
d438 2
a439 2
		t->ta = 0;
		t->bt = 0;
d454 1
a454 1
		t->cr = 0;
d483 1
a483 1
	return 0;
d514 6
a519 6
	t->scrn = 0;
	t->sary = 0;
	t->updtab = 0;
	t->compose = 0;
	t->ofst = 0;
	t->ary = 0;
@


1.17
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d502 4
a505 2
	if (baud >= 38400)
		t->scroll = 0, t->insdel = 0;
d874 2
a875 1
		t->y = y, t->x = x;
d1145 6
a1150 2
				if (cst > best)
					maxaryy = aryy, maxlen = amnt, best = cst, bestback = back;
@


1.16
log
@don't clear screen when nonzero skiptop is given (part 2)
@
text
@d300 4
a303 2
	if (x > 7 && y > 3)
		t->li = y, t->co = x;
d437 4
a440 2
	if (getflag(t->cap, "xt"))
		t->ta = 0, t->bt = 0;
d621 2
a622 1
		int cstunder = x % t->tw + t->cta * ntabs, cstover;
d710 7
a716 4
	if (t->rr)
		hy = t->top, hl = t->bot - 1;
	else
		hy = 0, hl = t->li - 1;
d729 4
a732 2
		if (cost < bestcost)
			bestcost = cost, bestway = 6;
d736 4
a739 2
		if (cost < bestcost)
			bestcost = cost, bestway = 1;
d743 4
a746 2
		if (cost < bestcost)
			bestcost = cost, bestway = 2;
d750 4
a753 2
		if (cost < bestcost)
			bestcost = cost, bestway = 3;
d757 4
a760 2
		if (cost < bestcost)
			bestcost = cost, bestway = 4;
d764 4
a767 2
		if (cost < bestcost)
			bestcost = cost, bestway = 5;
d771 4
a774 2
		if (cost < bestcost)
			bestcost = cost, bestway = 13;
d778 4
a781 2
		if (cost < bestcost)
			bestcost = cost, bestway = 7;
d785 4
a788 2
		if (cost < bestcost)
			bestcost = cost, bestway = 8;
d792 4
a795 2
		if (cost < bestcost)
			bestcost = cost, bestway = 9;
d799 4
a802 2
		if (cost < bestcost)
			bestcost = cost, bestway = 10;
d806 4
a809 2
		if (cost < bestcost)
			bestcost = cost, bestway = 11;
d813 4
a816 2
		if (cost < bestcost)
			bestcost = cost, bestway = 12;
d892 8
a899 5
		if (!t->lf || t->cDO < (y - t->y) * t->clf)
			texec(t->cap, t->DO, 1, y - t->y, 0, 0, 0), t->y = y;
		else
			while (y > t->y)
				texec(t->cap, t->lf, 1, 0, 0, 0, 0), ++t->y;
d902 8
a909 5
		if (!t->up || t->cUP < (t->y - y) * t->cup)
			texec(t->cap, t->UP, 1, t->y - y, 0, 0, 0), t->y = y;
		else
			while (y < t->y)
				texec(t->cap, t->up, 1, 0, 0, 0, 0), --t->y;
d915 2
a916 1
		int cstunder = x % t->tw + t->cta * ntabs, cstover;
d968 8
a975 5
		if (!t->bs || t->cLE < (t->x - x) * t->cbs)
			texec(t->cap, t->LE, 1, t->x - x, 0, 0, 0), t->x = x;
		else
			while (x < t->x)
				texec(t->cap, t->bs, 1, 0, 0, 0, 0), --t->x;
d979 4
a982 3
		if (t->cRI < x - t->x)
			texec(t->cap, t->RI, 1, x - t->x, 0, 0, 0), t->x = x;
		else {
d1036 4
a1039 2
	if (x < 0)
		s -= x, x = 0;
a1082 1

d1102 6
a1107 2
	for (x = 0; x != t->co - 1; ++x)
		t->ary[aryx].next = htab[cs[x] & 255].next, t->ary[aryx].loc = x, ++htab[cs[x] & 255].loc, htab[cs[x] & 255].next = aryx++;
d1145 4
a1148 3
			if (!maxlen)
				ofst[x] = t->co - 1, maxlen = 1;
			else if (best < 2)
d1178 1
a1178 2
				while (s[x + q] == cs[x + q]
				       && x - q < placex)
d1333 2
a1334 1
				doupscrl(t, y, z + q, q), y = z - 1;
d1341 1
a1341 2
						for (z = p; t->sary[z] = 0, (z && t->sary[z - 1]
									     == q); --z) ;
d1406 4
a1409 2
		for (x = bot; x != top + amnt; --x)
			t->sary[x - 1] = (t->sary[x - amnt - 1] == t->li ? t->li : t->sary[x - amnt - 1] - amnt), t->updtab[x - 1] = t->updtab[x - amnt - 1];
d1429 4
a1432 2
		for (x = top + amnt; x != bot; ++x)
			t->sary[x - amnt] = (t->sary[x] == t->li ? t->li : t->sary[x] + amnt), t->updtab[x - amnt] = t->updtab[x];
@


1.15
log
@don't clear screen when nonzero skiptop is given
@
text
@d1323 1
a1323 1
	if (t->cl)
@


1.14
log
@include headers needed to compile without implicit function declarations warnings
@
text
@d504 1
a504 1
	if (t->cl)
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d13 3
@


1.12
log
@change xlat macro into xlat(int *, char *) function
@
text
@a12 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d16 1
d18 1
a18 1
#include "scrn.h"
d281 1
a281 1
	SCRN *t = (SCRN *) malloc(sizeof(SCRN));
d511 1
a511 1
	t->htab = (struct hentry *) malloc(256 * sizeof(struct hentry));
d529 1
a529 1
		free(t->sary);
d531 1
a531 1
		free(t->updtab);
d533 1
a533 1
		free(t->scrn);
d535 1
a535 1
		free(t->compose);
d537 1
a537 1
		free(t->ofst);
d539 7
a545 7
		free(t->ary);
	t->scrn = (int *) malloc(t->li * t->co * sizeof(int));
	t->sary = (int *) calloc(t->li, sizeof(int));
	t->updtab = (int *) malloc(t->li * sizeof(int));
	t->compose = (int *) malloc(t->co * sizeof(int));
	t->ofst = (int *) malloc(t->co * sizeof(int));
	t->ary = (struct hentry *) malloc(t->co * sizeof(struct hentry));
d1336 6
a1341 6
	free(t->scrn);
	free(t->sary);
	free(t->ofst);
	free(t->htab);
	free(t->ary);
	free(t);
@


1.11
log
@change indentation of cases in the switch() statement
@
text
@d11 1
d17 1
d28 40
a67 2
/* How to display characters */

d69 56
a124 58
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	UNDERLINE,

	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,
	INVERSE + UNDERLINE, INVERSE + UNDERLINE, INVERSE + UNDERLINE,
	INVERSE + UNDERLINE,

	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
	INVERSE,
	INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,

	INVERSE + UNDERLINE,
d127 9
a135 26
unsigned char xlatc[256] = {
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
	110,
	111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
	125,
	126, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
	110,
	111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
	125,
	126, 63
};
@


1.10
log
@change indentation of do {} while() cycles
@
text
@d768 1
a768 1
		case 1:
d772 1
a772 1
		case 2:
d777 1
a777 1
		case 3:
d782 1
a782 1
		case 9:
d787 1
a787 1
		case 11:
d791 2
a792 2
	      doch:
		case 4:
d796 1
a796 1
		case 10:
d801 1
a801 1
		case 12:
d806 1
a806 1
		case 8:
d809 2
a810 2
	      docv:
		case 5:
d814 1
a814 1
		case 6:
d818 1
a818 1
		case 7:
d824 1
a824 1
		case 13:
@


1.9
log
@include only headers which are needed
@
text
@d208 1
a208 1
	do
d213 1
a213 1
	while (ss != s) ;
d862 1
a862 1
				do
d864 1
a864 1
				while (--ntabs);
d869 1
a869 1
			do
d871 1
a871 1
			while (--ntabs);
d888 1
a888 1
				do
d890 1
a890 1
				while (--ntabs);
d896 1
a896 1
			do
d898 1
a898 1
			while (--ntabs);
d953 1
a953 2
			}
			while (x != t->x);
d1273 1
a1273 2
				}
				while (p-- != y);
@


1.8
log
@put struct definitions and other goodies into types.h
@
text
@d12 1
d14 2
a16 1
#include "vs.h"
a17 1
#include "tty.h"
@


1.7
log
@use mfwrd() and mbkwd() only as internal functions to mmove()
@
text
@d1 9
a9 17
/* Device independant TTY interface for JOE
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.6
log
@version 2.9.7-pre3
@
text
@d1000 1
a1000 1
	mcpy(t->scrn + x + t->co * y, s, n * sizeof(int));
d1183 1
a1183 1
	mfwrd(t->scrn + top * t->co, t->scrn + (top + amnt) * t->co, (bot - top - amnt) * t->co * sizeof(int));
d1248 1
a1248 1
	mbkwd(t->scrn + (top + amnt) * t->co, t->scrn + top * t->co, (bot - top - amnt) * t->co * sizeof(int));
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d125 1
a125 3
int attr(t, c)
SCRN *t;
int c;
d133 1
a133 1
			texec(t->cap, t->me, 1);
d136 1
a136 1
				texec(t->cap, t->ue, 1);
d138 1
a138 1
				texec(t->cap, t->se, 1);
d145 1
a145 1
			texec(t->cap, t->mr, 1);
d147 1
a147 1
			texec(t->cap, t->so, 1);
d151 1
a151 1
			texec(t->cap, t->us, 1);
d154 1
a154 1
			texec(t->cap, t->mb, 1);
d157 1
a157 1
			texec(t->cap, t->md, 1);
d160 1
a160 1
			texec(t->cap, t->mh, 1);
d167 1
a167 3
void setregn(t, top, bot)
SCRN *t;
int top, bot;
d177 1
a177 1
		texec(t->cap, t->cs, 1, top, bot - 1);
d185 1
a185 2
void setins(t, x)
SCRN *t;
d189 1
a189 1
		texec(t->cap, t->im, 1, x);
d195 1
a195 2
int clrins(t)
SCRN *t;
d198 1
a198 1
		texec(t->cap, t->ei, 1);
d206 1
a206 2
int eraeol(t, x, y)
SCRN *t;
d224 1
a224 1
		texec(t->cap, t->ce, 1);
d246 1
a246 2
void outatri(t, x, y, c)
SCRN *t;
d262 1
a262 3
void out(t, c)
char *t;
char c;
d267 1
a267 2
SCRN *nopen(cap)
CAP *cap;
d398 1
a398 1
	t->cbs = tcost(t->cap, t->bs, 1, 2, 2);
d403 1
a403 1
	t->clf = tcost(t->cap, t->lf, 1, 2, 2);
d406 1
a406 1
	t->cup = tcost(t->cap, t->up, 1, 2, 2);
d423 2
a424 2
	t->cta = tcost(t->cap, t->ta, 1, 2, 2);
	t->cbt = tcost(t->cap, t->bt, 1, 2, 2);
d427 1
a427 1
	t->cho = tcost(t->cap, t->ho, 1, 2, 2);
d429 1
a429 1
	t->cll = tcost(t->cap, t->ll, 1, 2, 2);
d436 1
a436 1
	t->ccr = tcost(t->cap, t->cr, 1, 2, 2);
d438 8
a445 8
	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap, "RI"), 1, 2, 2);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap, "LE"), 1, 2, 2);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap, "UP"), 1, 2, 2);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap, "DO"), 1, 2, 2);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap, "ch"), 1, 2, 2);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap, "cv"), 1, 2, 2);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap, "cV"), 1, 2, 2);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap, "cm"), 1, 2, 2);
d447 1
a447 1
	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap, "ce"), 1, 2, 2);
d488 1
a488 1
		texec(t->cap, t->ti, 1);
d490 1
a490 1
		texec(t->cap, t->cl, 1);
d508 1
a508 2
void nresize(t, w, h)
SCRN *t;
d545 1
a545 3
static int relcost(t, x, y, ox, oy)
register SCRN *t;
register int x, y, ox, oy;
d680 1
a680 3
static void cposs(t, x, y)
register SCRN *t;
register int x, y;
d705 1
a705 1
		cost = tcost(t->cap, t->cm, 1, y, x);
d725 1
a725 1
		cost = relcost(t, x, y, x, t->y) + tcost(t->cap, t->ch, 1, x);
d730 1
a730 1
		cost = relcost(t, x, y, t->x, y) + tcost(t->cap, t->cv, 1, y);
d735 1
a735 1
		cost = relcost(t, x, y, 0, y) + tcost(t->cap, t->cV, 1, y);
d740 1
a740 1
		cost = tcost(t->cap, t->cv, 1, y - hy) + tcost(t->cap, t->ch, 1, x);
d745 1
a745 1
		cost = tcost(t->cap, t->cv, 1, y) + tcost(t->cap, t->cr, 1) + relcost(t, x, y, 0, y);
d750 1
a750 1
		cost = tcost(t->cap, t->ll, 1) + tcost(t->cap, t->ch, 1, x) + relcost(t, x, y, x, hl);
d755 1
a755 1
		cost = tcost(t->cap, t->ll, 1) + tcost(t->cap, t->cv, 1, y) + relcost(t, x, y, 0, y);
d760 1
a760 1
		cost = tcost(t->cap, t->ho, 1) + tcost(t->cap, t->ch, 1, x) + relcost(t, x, y, x, hy);
d765 1
a765 1
		cost = tcost(t->cap, t->ho, 1) + tcost(t->cap, t->cv, 1, y) + relcost(t, x, y, 0, y);
d776 1
a776 1
		texec(t->cap, t->cr, 1);
d780 1
a780 1
		texec(t->cap, t->ho, 1);
d785 1
a785 1
		texec(t->cap, t->ll, 1);
d790 1
a790 1
		texec(t->cap, t->ll, 1);
d795 1
a795 1
		texec(t->cap, t->ho, 1);
d800 1
a800 1
		texec(t->cap, t->ch, 1, x);
d804 1
a804 1
		texec(t->cap, t->ll, 1);
d809 1
a809 1
		texec(t->cap, t->ho, 1);
d814 1
a814 1
		texec(t->cap, t->cr, 1);
d818 1
a818 1
		texec(t->cap, t->cv, 1, y);
d822 1
a822 1
		texec(t->cap, t->cm, 1, y, x);
d826 1
a826 1
		texec(t->cap, t->cv, 1, y);
d828 1
a828 1
		texec(t->cap, t->ch, 1, x);
d832 1
a832 1
		texec(t->cap, t->cV, 1, y);
d844 1
a844 1
			texec(t->cap, t->DO, 1, y - t->y), t->y = y;
d847 1
a847 1
				texec(t->cap, t->lf, 1), ++t->y;
d851 1
a851 1
			texec(t->cap, t->UP, 1, t->y - y), t->y = y;
d854 1
a854 1
				texec(t->cap, t->up, 1), --t->y;
d870 1
a870 1
					texec(t->cap, t->ta, 1);
d877 1
a877 1
				texec(t->cap, t->ta, 1);
d896 1
a896 1
					texec(t->cap, t->bt, 1);
d904 1
a904 1
				texec(t->cap, t->bt, 1);
d913 1
a913 1
			texec(t->cap, t->LE, 1, t->x - x), t->x = x;
d916 1
a916 1
				texec(t->cap, t->bs, 1), --t->x;
d921 1
a921 1
			texec(t->cap, t->RI, 1, x - t->x), t->x = x;
d941 1
a941 3
int cpos(t, x, y)
register SCRN *t;
register int x, y;
d973 1
a973 3
static void doinschr(t, x, y, s, n)
SCRN *t;
int x, y, *s, n;
d987 1
a987 1
				texec(t->cap, t->ic, 1, x);
d989 1
a989 1
				texec(t->cap, t->ip, 1, x);
d994 1
a994 1
			texec(t->cap, t->IC, 1, n);
d1003 1
a1003 3
static void dodelchr(t, x, y, n)
SCRN *t;
int x, y, n;
d1013 1
a1013 1
		texec(t->cap, t->dm, 1, x);	/* Enter delete mode */
d1016 1
a1016 1
				texec(t->cap, t->dc, 1, x);
d1018 2
a1019 2
			texec(t->cap, t->DC, 1, n);
		texec(t->cap, t->ed, 1, x);	/* Exit delete mode */
d1028 1
a1028 3
void magic(t, y, cs, s, placex)
SCRN *t;
int y, *cs, *s;
d1126 1
a1126 3
static void doupscrl(t, top, bot, amnt)
SCRN *t;
int top, bot, amnt;
d1138 1
a1138 1
				texec(t->cap, t->sf, 1, t->li - 1);
d1140 1
a1140 1
			texec(t->cap, t->SF, a, a);
d1148 1
a1148 1
				texec(t->cap, t->dl, 1, top);
d1150 1
a1150 1
			texec(t->cap, t->DL, a, a);
d1158 1
a1158 1
				texec(t->cap, t->sf, 1, bot - 1);
d1160 1
a1160 1
			texec(t->cap, t->SF, a, a);
d1167 1
a1167 1
				texec(t->cap, t->dl, 1, top);
d1169 1
a1169 1
			texec(t->cap, t->DL, a, a);
d1174 1
a1174 1
				texec(t->cap, t->al, 1, bot - amnt);
d1176 1
a1176 1
			texec(t->cap, t->AL, a, a);
d1192 1
a1192 3
static void dodnscrl(t, top, bot, amnt)
SCRN *t;
int top, bot, amnt;
d1204 1
a1204 1
				texec(t->cap, t->sr, 1, 0);
d1206 1
a1206 1
			texec(t->cap, t->SR, a, a);
d1214 1
a1214 1
				texec(t->cap, t->al, 1, top);
d1216 1
a1216 1
			texec(t->cap, t->AL, a, a);
d1224 1
a1224 1
				texec(t->cap, t->sr, 1, top);
d1226 1
a1226 1
			texec(t->cap, t->SR, a, a);
d1233 1
a1233 1
				texec(t->cap, t->dl, 1, bot - amnt);
d1235 1
a1235 1
			texec(t->cap, t->DL, a, a);
d1240 1
a1240 1
				texec(t->cap, t->al, 1, top);
d1242 1
a1242 1
			texec(t->cap, t->AL, a, a);
d1257 1
a1257 2
void nscroll(t)
SCRN *t;
d1290 1
a1290 2
void npartial(t)
SCRN *t;
d1297 1
a1297 2
void nescape(t)
SCRN *t;
d1303 1
a1303 1
		texec(t->cap, t->te, 1);
d1306 1
a1306 2
void nreturn(t)
SCRN *t;
d1309 1
a1309 1
		texec(t->cap, t->ti, 1);
d1311 1
a1311 1
		texec(t->cap, t->cl, 1);
d1315 1
a1315 2
void nclose(t)
SCRN *t;
d1323 1
a1323 1
		texec(t->cap, t->te, 1);
d1334 1
a1334 3
void nscrldn(t, top, bot, amnt)
SCRN *t;
int top, bot, amnt;
d1355 1
a1355 3
void nscrlup(t, top, bot, amnt)
SCRN *t;
int top, bot, amnt;
d1378 1
a1378 2
void nredraw(t)
SCRN *t;
d1397 1
a1397 1
			texec(t->cap, t->cl, 1, 0);
d1403 1
a1403 1
			texec(t->cap, t->cd, 1, 0);
@


1.4
log
@changed as of joe-2.9.6
@
text
@d1 2
a2 3
/*
	Device independant TTY interface for JOE
	Copyright (C) 1992 Joseph H. Allen
d4 14
a17 2
	This file is part of JOE (Joe's Own Editor)
 */
a19 1
#include <signal.h>
d53 1
a53 1
		INVERSE + UNDERLINE,
d55 1
a55 1
		INVERSE + UNDERLINE,
d57 1
a57 1
		INVERSE + UNDERLINE,
d59 1
a59 1
		INVERSE + UNDERLINE,
d61 1
a61 1
		INVERSE + UNDERLINE,
d63 1
a63 1
		INVERSE + UNDERLINE,
d65 1
a65 1
		INVERSE + UNDERLINE,
d67 1
a67 1
		INVERSE + UNDERLINE,
d70 1
a70 1
		INVERSE,
d72 1
a72 1
		INVERSE,
d74 1
a74 1
		INVERSE,
d76 1
a76 1
		INVERSE,
d78 1
a78 1
		INVERSE,
d80 1
a80 1
		INVERSE,
d82 1
a82 1
		INVERSE,
d84 1
a84 1
		INVERSE,
d86 1
a86 1
		INVERSE,
d88 1
a88 1
		INVERSE,
d90 1
a90 1
		INVERSE,
d103 6
a108 4
	96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
		111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
		126, 63,
d115 6
a120 4
	96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
		111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
		126, 63
d125 3
a127 4
int
attr (t, c)
     SCRN *t;
     int c;
d130 1
d133 11
a143 13
	if (e)			/* If any attribute go off, switch them all off: fixes bug on PCs */
	  {
		  if (t->me)
			  texec (t->cap, t->me, 1);
		  else
		    {
			    if (t->ue)
				    texec (t->cap, t->ue, 1);
			    if (t->se)
				    texec (t->cap, t->se, 1);
		    }
		  t->attrib = 0;
	  }
d145 1
a145 1
	if (e & INVERSE)
d147 1
a147 1
			texec (t->cap, t->mr, 1);
d149 2
a150 1
			texec (t->cap, t->so, 1);
d153 1
a153 1
			texec (t->cap, t->us, 1);
d156 1
a156 1
			texec (t->cap, t->mb, 1);
d159 1
a159 1
			texec (t->cap, t->md, 1);
d162 1
a162 1
			texec (t->cap, t->mh, 1);
d169 16
a184 19
void
setregn (t, top, bot)
     SCRN *t;
     int top, bot;
{
	if (!t->cs)
	  {
		  t->top = top;
		  t->bot = bot;
		  return;
	  }
	if (t->top != top || t->bot != bot)
	  {
		  t->top = top;
		  t->bot = bot;
		  texec (t->cap, t->cs, 1, top, bot - 1);
		  t->x = -1;
		  t->y = -1;
	  }
d189 7
a195 9
void
setins (t, x)
     SCRN *t;
{
	if (t->ins != 1 && t->im)
	  {
		  t->ins = 1;
		  texec (t->cap, t->im, 1, x);
	  }
d200 7
a206 9
int
clrins (t)
     SCRN *t;
{
	if (t->ins != 0)
	  {
		  texec (t->cap, t->ei, 1);
		  t->ins = 0;
	  }
d212 2
a213 3
int
eraeol (t, x, y)
     SCRN *t;
d217 1
d223 24
a246 29
		if (*--ss != ' ')
		  {
			  ++ss;
			  break;
		  }
	while (ss != s);
	if ((ss - s > 3 || s[w] != ' ') && t->ce)
	  {
		  cpos (t, x, y);
		  attr (t, 0);
		  texec (t->cap, t->ce, 1);
		  msetI (s, ' ', w);
	  }
	else if (s != ss)
	  {
		  if (t->ins)
			  clrins (t);
		  if (t->x != x || t->y != y)
			  cpos (t, x, y);
		  if (t->attrib)
			  attr (t, 0);
		  while (s != ss)
		    {
			    *s = ' ';
			    ttputc (' ');
			    ++t->x;
			    ++s;
		    }
	  }
d253 2
a254 3
void
outatri (t, x, y, c)
     SCRN *t;
d257 1
d263 1
a263 1
		attr (t, c);
d266 1
a266 1
	ttputc (ch);
d270 3
a272 4
void
out (t, c)
     char *t;
     char c;
d274 1
a274 1
	ttputc (c);
d277 2
a278 3
SCRN *
nopen (cap)
     CAP *cap;
d280 1
a280 1
	SCRN *t = (SCRN *) malloc (sizeof (SCRN));
d282 2
a283 1
	ttopen ();
d286 1
a286 1
	setcap (cap, baud, out, NULL);
d288 1
a288 1
	t->li = getnum (t->cap, "li");
d291 1
a291 1
	t->co = getnum (t->cap, "co");
d295 1
a295 1
	ttgtsz (&x, &y);
d299 4
a302 4
	t->haz = getflag (t->cap, "hz");
	t->os = getflag (t->cap, "os");
	t->eo = getflag (t->cap, "eo");
	if (getflag (t->cap, "hc"))
d304 1
a304 1
	if (t->os || getflag (t->cap, "ul"))
d309 2
a310 2
	t->xn = getflag (t->cap, "xn");
	t->am = getflag (t->cap, "am");
d312 3
a314 3
	t->ti = jgetstr (t->cap, "ti");
	t->cl = jgetstr (t->cap, "cl");
	t->cd = jgetstr (t->cap, "cd");
d316 1
a316 1
	t->te = jgetstr (t->cap, "te");
d323 1
a323 1
	if (!(t->me = jgetstr (t->cap, "me")))
d325 1
a325 1
	if ((t->mb = jgetstr (t->cap, "mb")))
d327 1
a327 1
	if ((t->md = jgetstr (t->cap, "md")))
d329 1
a329 1
	if ((t->mh = jgetstr (t->cap, "mh")))
d331 1
a331 1
	if ((t->mr = jgetstr (t->cap, "mr")))
d337 6
a342 7
	if (getnum (t->cap, "sg") <= 0 && !t->mr && jgetstr (t->cap, "se"))
	  {
		  if (t->so = jgetstr (t->cap, "so"))
			  t->avattr |= INVERSE;
		  t->se = jgetstr (t->cap, "se");
	  }
	if (getflag (t->cap, "xs") || getflag (t->cap, "xt"))
d347 5
a351 6
	if (getnum (t->cap, "ug") <= 0 && jgetstr (t->cap, "ue"))
	  {
		  if (t->us = jgetstr (t->cap, "us"))
			  t->avattr |= UNDERLINE;
		  t->ue = jgetstr (t->cap, "ue");
	  }
d353 1
a353 1
	if (!(t->uc = jgetstr (t->cap, "uc")))
d359 1
a359 1
	t->ms = getflag (t->cap, "ms");
d361 13
a373 13
	t->da = getflag (t->cap, "da");
	t->db = getflag (t->cap, "db");
	t->cs = jgetstr (t->cap, "cs");
	t->rr = getflag (t->cap, "rr");
	t->sf = jgetstr (t->cap, "sf");
	t->sr = jgetstr (t->cap, "sr");
	t->SF = jgetstr (t->cap, "SF");
	t->SR = jgetstr (t->cap, "SR");
	t->al = jgetstr (t->cap, "al");
	t->dl = jgetstr (t->cap, "dl");
	t->AL = jgetstr (t->cap, "AL");
	t->DL = jgetstr (t->cap, "DL");
	if (!getflag (t->cap, "ns") && !t->sf)
d376 24
a399 27
	if (!getflag (t->cap, "in") && baud < 38400)
	  {
		  t->dc = jgetstr (t->cap, "dc");
		  t->DC = jgetstr (t->cap, "DC");
		  t->dm = jgetstr (t->cap, "dm");
		  t->ed = jgetstr (t->cap, "ed");

		  t->im = jgetstr (t->cap, "im");
		  t->ei = jgetstr (t->cap, "ei");
		  t->ic = jgetstr (t->cap, "ic");
		  t->IC = jgetstr (t->cap, "IC");
		  t->ip = jgetstr (t->cap, "ip");
		  t->mi = getflag (t->cap, "mi");
	  }
	else
	  {
		  t->dm = 0;
		  t->dc = 0;
		  t->DC = 0;
		  t->ed = 0;
		  t->im = 0;
		  t->ic = 0;
		  t->IC = 0;
		  t->ip = 0;
		  t->ei = 0;
		  t->mi = 1;
	  }
d402 5
a406 5
	if (jgetstr (t->cap, "bc"))
		t->bs = jgetstr (t->cap, "bc");
	else if (jgetstr (t->cap, "le"))
		t->bs = jgetstr (t->cap, "le");
	if (getflag (t->cap, "bs"))
d409 1
a409 1
	t->cbs = tcost (t->cap, t->bs, 1, 2, 2);
d412 3
a414 3
	if (jgetstr (t->cap, "do"))
		t->lf = jgetstr (t->cap, "do");
	t->clf = tcost (t->cap, t->lf, 1, 2, 2);
d416 2
a417 2
	t->up = jgetstr (t->cap, "up");
	t->cup = tcost (t->cap, t->up, 1, 2, 2);
d419 1
a419 1
	t->nd = jgetstr (t->cap, "nd");
d422 4
a425 4
	if (getnum (t->cap, "it") > 0)
		t->tw = getnum (t->cap, "it");
	else if (getnum (t->cap, "tw") > 0)
		t->tw = getnum (t->cap, "tw");
d427 2
a428 2
	if (!(t->ta = jgetstr (t->cap, "ta")))
		if (getflag (t->cap, "pt"))
d430 2
a431 2
	t->bt = jgetstr (t->cap, "bt");
	if (getflag (t->cap, "xt"))
d434 2
a435 2
	t->cta = tcost (t->cap, t->ta, 1, 2, 2);
	t->cbt = tcost (t->cap, t->bt, 1, 2, 2);
d437 4
a440 4
	t->ho = jgetstr (t->cap, "ho");
	t->cho = tcost (t->cap, t->ho, 1, 2, 2);
	t->ll = jgetstr (t->cap, "ll");
	t->cll = tcost (t->cap, t->ll, 1, 2, 2);
d443 3
a445 3
	if (jgetstr (t->cap, "cr"))
		t->cr = jgetstr (t->cap, "cr");
	if (getflag (t->cap, "nc") || getflag (t->cap, "xr"))
d447 1
a447 1
	t->ccr = tcost (t->cap, t->cr, 1, 2, 2);
d449 8
a456 8
	t->cRI = tcost (t->cap, t->RI = jgetstr (t->cap, "RI"), 1, 2, 2);
	t->cLE = tcost (t->cap, t->LE = jgetstr (t->cap, "LE"), 1, 2, 2);
	t->cUP = tcost (t->cap, t->UP = jgetstr (t->cap, "UP"), 1, 2, 2);
	t->cDO = tcost (t->cap, t->DO = jgetstr (t->cap, "DO"), 1, 2, 2);
	t->cch = tcost (t->cap, t->ch = jgetstr (t->cap, "ch"), 1, 2, 2);
	t->ccv = tcost (t->cap, t->cv = jgetstr (t->cap, "cv"), 1, 2, 2);
	t->ccV = tcost (t->cap, t->cV = jgetstr (t->cap, "cV"), 1, 2, 2);
	t->ccm = tcost (t->cap, t->cm = jgetstr (t->cap, "cm"), 1, 2, 2);
d458 1
a458 1
	t->cce = tcost (t->cap, t->ce = jgetstr (t->cap, "ce"), 1, 2, 2);
d472 3
a474 4
	ttclose ();
	signrm ();
	fprintf (stderr,
		 "Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
d479 1
a479 2
	if ((t->sr || t->SR) && (t->sf || t->SF) && t->cs ||
	    (t->al || t->AL) && (t->dl || t->DL))
d481 5
a485 6
	else
	  {
		  t->scroll = 0;
		  if (baud < 38400)
			  mid = 1;
	  }
d499 1
a499 1
		texec (t->cap, t->ti, 1);
d501 1
a501 1
		texec (t->cap, t->cl, 1);
d510 3
a512 2
	t->htab = (struct hentry *) malloc (256 * sizeof (struct hentry));
	nresize (t, t->co, t->li);
d519 2
a520 3
void
nresize (t, w, h)
     SCRN *t;
d529 1
a529 1
		free (t->sary);
d531 1
a531 1
		free (t->updtab);
d533 1
a533 1
		free (t->scrn);
d535 1
a535 1
		free (t->compose);
d537 1
a537 1
		free (t->ofst);
d539 9
a547 8
		free (t->ary);
	t->scrn = (int *) malloc (t->li * t->co * sizeof (int));
	t->sary = (int *) calloc (t->li, sizeof (int));
	t->updtab = (int *) malloc (t->li * sizeof (int));
	t->compose = (int *) malloc (t->co * sizeof (int));
	t->ofst = (int *) malloc (t->co * sizeof (int));
	t->ary = (struct hentry *) malloc (t->co * sizeof (struct hentry));
	nredraw (t);
d557 3
a559 4
static int
relcost (t, x, y, ox, oy)
     register SCRN *t;
     register int x, y, ox, oy;
d568 41
a608 44
	if (y > oy)
	  {
		  int dist = y - oy;
		  /* Have to go down */
		  if (t->lf)
		    {
			    int mult = dist * t->clf;
			    if (dist < 10 && t->cDO < mult)
				    cost += t->cDO;
			    else if (dist >= 10 && t->cDO + 1 < mult)
				    cost += t->cDO + 1;
			    else
				    cost += mult;
		    }
		  else if (t->DO)
			  if (dist < 10)
				  cost += t->cDO;
			  else
				  cost += t->cDO + 1;
		  else
			  return 10000;
	  }
	else if (y < oy)
	  {
		  int dist = oy - y;
		  /* Have to go up */
		  if (t->up)
		    {
			    int mult = dist * t->cup;
			    if (dist < 10 && t->cUP < mult)
				    cost += t->cUP;
			    else if (dist >= 10 && t->cUP < mult)
				    cost += t->cUP + 1;
			    else
				    cost += mult;
		    }
		  else if (t->UP)
			  if (dist < 10)
				  cost += t->cUP;
			  else
				  cost += t->cUP + 1;
		  else
			  return 10000;
	  }
d613 41
a653 52
	if (x > ox && t->ta)
	  {
		  int dist = x - ox;
		  int ntabs = (dist + ox % t->tw) / t->tw;
		  int cstunder = x % t->tw + t->cta * ntabs, cstover;
		  if (x + t->tw < t->co && t->bs)
			  cstover =
				  t->cbs * (t->tw - x % t->tw) +
				  t->cta * (ntabs + 1);
		  else
			  cstover = 10000;
		  if (dist < 10 && cstunder < t->cRI && cstunder < x - ox
		      && cstover > cstunder)
			  return cost + cstunder;
		  else if (cstunder < t->cRI + 1 && cstunder < x - ox
			   && cstover > cstunder)
			  return cost + cstunder;
		  else if (dist < 10 && cstover < t->cRI && cstover < x - ox)
			  return cost + cstover;
		  else if (cstover < t->cRI + 1 && cstover < x - ox)
			  return cost + cstover;
	  }
	else if (x < ox && t->bt)
	  {
		  int dist = ox - x;
		  int ntabs = (dist + t->tw - ox % t->tw) / t->tw;
		  int cstunder, cstover;
		  if (t->bs)
			  cstunder =
				  t->cbt * ntabs + t->cbs * (t->tw -
							     x % t->tw);
		  else
			  cstunder = 10000;
		  if (x - t->tw >= 0)
			  cstover = t->cbt * (ntabs + 1) + x % t->tw;
		  else
			  cstover = 10000;
		  if (dist < 10 && cstunder < t->cLE
		      && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		      && cstover > cstunder)
			  return cost + cstunder;
		  if (cstunder < t->cLE + 1
		      && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		      && cstover > cstunder)
			  return cost + cstunder;
		  else if (dist < 10 && cstover < t->cRI
			   && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			  return cost + cstover;
		  else if (cstover < t->cRI + 1
			   && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			  return cost + cstover;
	  }
d656 29
a684 31
	if (x < ox)
	  {
		  int dist = ox - x;
		  /* Have to go left */
		  if (t->bs)
		    {
			    int mult = dist * t->cbs;
			    if (t->cLE < mult && dist < 10)
				    cost += t->cLE;
			    else if (t->cLE + 1 < mult)
				    cost += t->cLE + 1;
			    else
				    cost += mult;
		    }
		  else if (t->LE)
			  cost += t->cLE;
		  else
			  return 10000;
	  }
	else if (x > ox)
	  {
		  int dist = x - ox;
		  /* Have to go right */
		  /* Hmm.. this should take into account possible attribute changes */
		  if (t->cRI < dist && dist < 10)
			  cost += t->cRI;
		  else if (t->cRI + 1 < dist)
			  cost += t->cRI + 1;
		  else
			  cost += dist;
	  }
d694 3
a696 4
static void
cposs (t, x, y)
     register SCRN *t;
     register int x, y;
d713 1
a713 1
	bestcost = relcost (t, x, y, t->x, t->y);
d720 65
a784 114
	if (t->ccm < bestcost)
	  {
		  cost = tcost (t->cap, t->cm, 1, y, x);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 6;
	  }
	if (t->ccr < bestcost)
	  {
		  cost = relcost (t, x, y, 0, t->y) + t->ccr;
		  if (cost < bestcost)
			  bestcost = cost, bestway = 1;
	  }
	if (t->cho < bestcost)
	  {
		  cost = relcost (t, x, y, 0, hy) + t->cho;
		  if (cost < bestcost)
			  bestcost = cost, bestway = 2;
	  }
	if (t->cll < bestcost)
	  {
		  cost = relcost (t, x, y, 0, hl) + t->cll;
		  if (cost < bestcost)
			  bestcost = cost, bestway = 3;
	  }
	if (t->cch < bestcost && x != t->x)
	  {
		  cost =
			  relcost (t, x, y, x, t->y) + tcost (t->cap, t->ch,
							      1, x);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 4;
	  }
	if (t->ccv < bestcost && y != t->y)
	  {
		  cost =
			  relcost (t, x, y, t->x, y) + tcost (t->cap, t->cv,
							      1, y);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 5;
	  }
	if (t->ccV < bestcost)
	  {
		  cost =
			  relcost (t, x, y, 0, y) + tcost (t->cap, t->cV, 1,
							   y);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 13;
	  }
	if (t->cch + t->ccv < bestcost && x != t->x && y != t->y)
	  {
		  cost =
			  tcost (t->cap, t->cv, 1, y - hy) + tcost (t->cap,
								    t->ch, 1,
								    x);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 7;
	  }
	if (t->ccv + t->ccr < bestcost && y != t->y)
	  {
		  cost =
			  tcost (t->cap, t->cv, 1, y) + tcost (t->cap, t->cr,
							       1) +
			  relcost (t, x, y, 0, y);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 8;
	  }
	if (t->cll + t->cch < bestcost)
	  {
		  cost =
			  tcost (t->cap, t->ll, 1) + tcost (t->cap, t->ch, 1,
							    x) + relcost (t,
									  x,
									  y,
									  x,
									  hl);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 9;
	  }
	if (t->cll + t->ccv < bestcost)
	  {
		  cost =
			  tcost (t->cap, t->ll, 1) + tcost (t->cap, t->cv, 1,
							    y) + relcost (t,
									  x,
									  y,
									  0,
									  y);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 10;
	  }
	if (t->cho + t->cch < bestcost)
	  {
		  cost =
			  tcost (t->cap, t->ho, 1) + tcost (t->cap, t->ch, 1,
							    x) + relcost (t,
									  x,
									  y,
									  x,
									  hy);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 11;
	  }
	if (t->cho + t->ccv < bestcost)
	  {
		  cost =
			  tcost (t->cap, t->ho, 1) + tcost (t->cap, t->cv, 1,
							    y) + relcost (t,
									  x,
									  y,
									  0,
									  y);
		  if (cost < bestcost)
			  bestcost = cost, bestway = 12;
	  }
d790 63
a852 64
	switch (bestway)
	  {
	  case 1:
		  texec (t->cap, t->cr, 1);
		  t->x = 0;
		  break;
	  case 2:
		  texec (t->cap, t->ho, 1);
		  t->x = 0;
		  t->y = hy;
		  break;
	  case 3:
		  texec (t->cap, t->ll, 1);
		  t->x = 0;
		  t->y = hl;
		  break;
	  case 9:
		  texec (t->cap, t->ll, 1);
		  t->x = 0;
		  t->y = hl;
		  goto doch;
	  case 11:
		  texec (t->cap, t->ho, 1);
		  t->x = 0;
		  t->y = hy;
		doch:
	  case 4:
		  texec (t->cap, t->ch, 1, x);
		  t->x = x;
		  break;
	  case 10:
		  texec (t->cap, t->ll, 1);
		  t->x = 0;
		  t->y = hl;
		  goto docv;
	  case 12:
		  texec (t->cap, t->ho, 1);
		  t->x = 0;
		  t->y = hy;
		  goto docv;
	  case 8:
		  texec (t->cap, t->cr, 1);
		  t->x = 0;
		docv:
	  case 5:
		  texec (t->cap, t->cv, 1, y);
		  t->y = y;
		  break;
	  case 6:
		  texec (t->cap, t->cm, 1, y, x);
		  t->y = y, t->x = x;
		  break;
	  case 7:
		  texec (t->cap, t->cv, 1, y);
		  t->y = y;
		  texec (t->cap, t->ch, 1, x);
		  t->x = x;
		  break;
	  case 13:
		  texec (t->cap, t->cV, 1, y);
		  t->y = y;
		  t->x = 0;
		  break;
	  }
d857 1
a857 1
	if (y > t->y)
d860 1
a860 1
			texec (t->cap, t->DO, 1, y - t->y), t->y = y;
d863 2
a864 2
				texec (t->cap, t->lf, 1), ++t->y;
	else if (y < t->y)
d867 1
a867 1
			texec (t->cap, t->UP, 1, t->y - y), t->y = y;
d870 2
a871 1
				texec (t->cap, t->up, 1), --t->y;
d874 50
a923 69
	if (x > t->x && t->ta)
	  {
		  int ntabs = (x - t->x + t->x % t->tw) / t->tw;
		  int cstunder = x % t->tw + t->cta * ntabs, cstover;
		  if (x + t->tw < t->co && t->bs)
			  cstover =
				  t->cbs * (t->tw - x % t->tw) +
				  t->cta * (ntabs + 1);
		  else
			  cstover = 10000;
		  if (cstunder < t->cRI && cstunder < x - t->x
		      && cstover > cstunder)
		    {
			    if (ntabs)
			      {
				      t->x = x - x % t->tw;
				      do
					      texec (t->cap, t->ta, 1);
				      while (--ntabs);
			      }
		    }
		  else if (cstover < t->cRI && cstover < x - t->x)
		    {
			    t->x = t->tw + x - x % t->tw;
			    ++ntabs;
			    do
				    texec (t->cap, t->ta, 1);
			    while (--ntabs);
		    }
	  }
	else if (x < t->x && t->bt)
	  {
		  int ntabs =
			  ((t->x + t->tw - 1) - (t->x + t->tw - 1) % t->tw -
			   ((x + t->tw - 1) -
			    (x + t->tw - 1) % t->tw)) / t->tw;
		  int cstunder, cstover;
		  if (t->bs)
			  cstunder =
				  t->cbt * ntabs + t->cbs * (t->tw -
							     x % t->tw);
		  else
			  cstunder = 10000;
		  if (x - t->tw >= 0)
			  cstover = t->cbt * (ntabs + 1) + x % t->tw;
		  else
			  cstover = 10000;
		  if (cstunder < t->cLE
		      && (t->bs ? cstunder < (t->x - x) * t->cbs : 1)
		      && cstover > cstunder)
		    {
			    if (ntabs)
			      {
				      do
					      texec (t->cap, t->bt, 1);
				      while (--ntabs);
				      t->x = x + t->tw - x % t->tw;
			      }
		    }
		  else if (cstover < t->cRI
			   && (t->bs ? cstover < (t->x - x) * t->cbs : 1))
		    {
			    t->x = x - x % t->tw;
			    ++ntabs;
			    do
				    texec (t->cap, t->bt, 1);
			    while (--ntabs);
		    }
	  }
d926 1
a926 1
	if (x < t->x)
d929 1
a929 1
			texec (t->cap, t->LE, 1, t->x - x), t->x = x;
d932 2
a933 2
				texec (t->cap, t->bs, 1), --t->x;
	else if (x > t->x)
d937 46
a982 47
			texec (t->cap, t->RI, 1, x - t->x), t->x = x;
		else
		  {
			  int *s = t->scrn + t->x + t->y * t->co;
			  if (t->ins)
				  clrins (t);
			  while (x > t->x)
			    {
				    int c = (0xFF & *s);
				    int a = (0xFF00 & *s);
				    if (a != t->attrib)
					    attr (t, a);
				    ttputc (c);
				    ++s;
				    ++t->x;
			    }
		  }
}

int
cpos (t, x, y)
     register SCRN *t;
     register int x, y;
{
	if (y == t->y)
	  {
		  if (x == t->x)
			  return 0;
		  if (x > t->x && x - t->x < 4 && !t->ins)
		    {
			    int *cs = t->scrn + t->x + t->co * t->y;
			    if (t->ins)
				    clrins (t);
			    do
			      {
				      int c = (0xFF & *cs);
				      int a = (0xFF00 & *cs);
				      if (a != t->attrib)
					      attr (t, a);
				      ttputc (c);
				      ++cs;
				      ++t->x;
			      }
			    while (x != t->x);
			    return 0;
		    }
	  }
d984 1
a984 1
		attr (t, t->attrib & ~(INVERSE | UNDERLINE));
d986 2
a987 2
		setregn (t, 0, t->li);
	cposs (t, x, y);
d991 3
a993 4
static void
doinschr (t, x, y, s, n)
     SCRN *t;
     int x, y, *s, n;
d996 1
d1001 25
a1025 32
	if (t->im || t->ic || t->IC)
	  {
		  cpos (t, x, y);
		  if (n == 1 && t->ic || !t->IC)
		    {
			    if (!t->ic)
				    setins (t, x);
			    for (a = 0; a != n; ++a)
			      {
				      texec (t->cap, t->ic, 1, x);
				      outatri (t, x + a, y, s[a]);
				      texec (t->cap, t->ip, 1, x);
			      }
			    if (!t->mi)
				    clrins (t);
		    }
		  else
		    {
			    texec (t->cap, t->IC, 1, n);
			    for (a = 0; a != n; ++a)
				    outatri (t, x + a, y, s[a]);
		    }
	  }
	mmove (t->scrn + x + t->co * y + n, t->scrn + x + t->co * y,
	       (t->co - (x + n)) * sizeof (int));
	mcpy (t->scrn + x + t->co * y, s, n * sizeof (int));
}

static void
dodelchr (t, x, y, n)
     SCRN *t;
     int x, y, n;
d1028 1
d1033 13
a1045 14
	if (t->dc || t->DC)
	  {
		  cpos (t, x, y);
		  texec (t->cap, t->dm, 1, x);	/* Enter delete mode */
		  if (n == 1 && t->dc || !t->DC)
			  for (a = n; a; --a)
				  texec (t->cap, t->dc, 1, x);
		  else
			  texec (t->cap, t->DC, 1, n);
		  texec (t->cap, t->ed, 1, x);	/* Exit delete mode */
	  }
	mmove (t->scrn + t->co * y + x, t->scrn + t->co * y + x + n,
	       (t->co - (x + n)) * sizeof (int));
	msetI (t->scrn + t->co * y + t->co - n, ' ', n);
d1050 3
a1052 4
void
magic (t, y, cs, s, placex)
     SCRN *t;
     int y, *cs, *s;
d1058 1
d1061 3
a1063 2
	mset (htab, 0, 256 * sizeof (struct hentry));
	msetI (ofst, 0, t->co);
d1067 1
a1067 4
		t->ary[aryx].next = htab[cs[x] & 255].next,
			t->ary[aryx].loc = x,
			++htab[cs[x] & 255].loc,
			htab[cs[x] & 255].next = aryx++;
d1073 42
a1114 56
		else
		  {
			  int aryy;
			  int maxaryy;
			  int maxlen = 0;
			  int best = 0;
			  int bestback = 0;
			  int z;
			  for (aryy = htab[s[x] & 255].next; aryy;
			       aryy = t->ary[aryy].next)
			    {
				    int amnt, back;
				    int tsfo = t->ary[aryy].loc - x;
				    int cst = -abs (tsfo);
				    int pre = 32;
				    for (amnt = 0;
					 x + amnt < t->co - 1
					 && x + tsfo + amnt < t->co - 1;
					 ++amnt)
				      {
					      if (cs[x + tsfo + amnt] !=
						  s[x + amnt]) break;
					      else if (s[x + amnt] & 255 != 32
						       || pre != 32)
						      ++cst;
					      pre = s[x + amnt] & 255;
				      }
				    pre = 32;
				    for (back = 0;
					 back + x > 0 && back + tsfo + x > 0;
					 --back)
				      {
					      if (cs[x + tsfo + back - 1] !=
						  s[x + back - 1])
						      break;
					      else if (s[x + back - 1] & 255
						       != 32 || pre != 32)
						      ++cst;
					      pre = s[x + back - 1] & 255;
				      }
				    if (cst > best)
					    maxaryy = aryy, maxlen =
						    amnt, best =
						    cst, bestback = back;
			    }
			  if (!maxlen)
				  ofst[x] = t->co - 1, maxlen = 1;
			  else if (best < 2)
				  for (z = 0; z != maxlen; ++z)
					  ofst[x + z] = t->co - 1;
			  else
				  for (z = 0; z != maxlen - bestback; ++z)
					  ofst[x + z + bestback] =
						  t->ary[maxaryy].loc - x;
			  x += maxlen;
		  }
d1118 35
a1152 37
	for (x = 0; x != t->co - 1; ++x)
	  {
		  int q = ofst[x];
		  if (q && q != t->co - 1)
			  if (q > 0)
			    {
				    int z, fu;
				    for (z = x;
					 z != t->co - 1 && ofst[z] == q; ++z);
				    while (s[x] == cs[x] && x < placex)
					    ++x;
				    dodelchr (t, x, y, q);
				    for (fu = x; fu != t->co - 1; ++fu)
					    if (ofst[fu] != t->co - 1)
						    ofst[fu] -= q;
				    x = z - 1;
			    }
			  else
			    {
				    int z, fu;
				    for (z = x;
					 z != t->co - 1 && ofst[z] == q; ++z);
				    while (s[x + q] == cs[x + q]
					   && x - q < placex) ++x;
				    doinschr (t, x + q, y, s + x + q, -q);
				    for (fu = x; fu != t->co - 1; ++fu)
					    if (ofst[fu] != t->co - 1)
						    ofst[fu] -= q;
				    x = z - 1;
			    }
	  }
}

static void
doupscrl (t, top, bot, amnt)
     SCRN *t;
     int top, bot, amnt;
d1155 1
d1158 48
a1205 52
	attr (t, 0);
	if (top == 0 && bot == t->li && (t->sf || t->SF))
	  {
		  setregn (t, 0, t->li);
		  cpos (t, 0, t->li - 1);
		  if (amnt == 1 && t->sf || !t->SF)
			  while (a--)
				  texec (t->cap, t->sf, 1, t->li - 1);
		  else
			  texec (t->cap, t->SF, a, a);
		  goto done;
	  }
	if (bot == t->li && (t->dl || t->DL))
	  {
		  setregn (t, 0, t->li);
		  cpos (t, 0, top);
		  if (amnt == 1 && t->dl || !t->DL)
			  while (a--)
				  texec (t->cap, t->dl, 1, top);
		  else
			  texec (t->cap, t->DL, a, a);
		  goto done;
	  }
	if (t->cs && (t->sf || t->SF))
	  {
		  setregn (t, top, bot);
		  cpos (t, 0, bot - 1);
		  if (amnt == 1 && t->sf || !t->SF)
			  while (a--)
				  texec (t->cap, t->sf, 1, bot - 1);
		  else
			  texec (t->cap, t->SF, a, a);
		  goto done;
	  }
	if ((t->dl || t->DL) && (t->al || t->AL))
	  {
		  cpos (t, 0, top);
		  if (amnt == 1 && t->dl || !t->DL)
			  while (a--)
				  texec (t->cap, t->dl, 1, top);
		  else
			  texec (t->cap, t->DL, a, a);
		  a = amnt;
		  cpos (t, 0, bot - amnt);
		  if (amnt == 1 && t->al || !t->AL)
			  while (a--)
				  texec (t->cap, t->al, 1, bot - amnt);
		  else
			  texec (t->cap, t->AL, a, a);
		  goto done;
	  }
	msetI (t->updtab + top, 1, bot - top);
d1209 7
a1215 9
	mfwrd (t->scrn + top * t->co, t->scrn + (top + amnt) * t->co,
	       (bot - top - amnt) * t->co * sizeof (int));
	if (bot == t->li && t->db)
	  {
		  msetI (t->scrn + (t->li - amnt) * t->co, -1, amnt * t->co);
		  msetI (t->updtab + t->li - amnt, 1, amnt);
	  }
	else
		msetI (t->scrn + (bot - amnt) * t->co, ' ', amnt * t->co);
d1218 3
a1220 4
static void
dodnscrl (t, top, bot, amnt)
     SCRN *t;
     int top, bot, amnt;
d1223 1
d1226 48
a1273 52
	attr (t, 0);
	if (top == 0 && bot == t->li && (t->sr || t->SR))
	  {
		  setregn (t, 0, t->li);
		  cpos (t, 0, 0);
		  if (amnt == 1 && t->sr || !t->SR)
			  while (a--)
				  texec (t->cap, t->sr, 1, 0);
		  else
			  texec (t->cap, t->SR, a, a);
		  goto done;
	  }
	if (bot == t->li && (t->al || t->AL))
	  {
		  setregn (t, 0, t->li);
		  cpos (t, 0, top);
		  if (amnt == 1 && t->al || !t->AL)
			  while (a--)
				  texec (t->cap, t->al, 1, top);
		  else
			  texec (t->cap, t->AL, a, a);
		  goto done;
	  }
	if (t->cs && (t->sr || t->SR))
	  {
		  setregn (t, top, bot);
		  cpos (t, 0, top);
		  if (amnt == 1 && t->sr || !t->SR)
			  while (a--)
				  texec (t->cap, t->sr, 1, top);
		  else
			  texec (t->cap, t->SR, a, a);
		  goto done;
	  }
	if ((t->dl || t->DL) && (t->al || t->AL))
	  {
		  cpos (t, 0, bot - amnt);
		  if (amnt == 1 && t->dl || !t->DL)
			  while (a--)
				  texec (t->cap, t->dl, 1, bot - amnt);
		  else
			  texec (t->cap, t->DL, a, a);
		  a = amnt;
		  cpos (t, 0, top);
		  if (amnt == 1 && t->al || !t->AL)
			  while (a--)
				  texec (t->cap, t->al, 1, top);
		  else
			  texec (t->cap, t->AL, a, a);
		  goto done;
	  }
	msetI (t->updtab + top, 1, bot - top);
d1276 7
a1282 9
	mbkwd (t->scrn + (top + amnt) * t->co, t->scrn + top * t->co,
	       (bot - top - amnt) * t->co * sizeof (int));
	if (!top && t->da)
	  {
		  msetI (t->scrn, -1, amnt * t->co);
		  msetI (t->updtab, 1, amnt);
	  }
	else
		msetI (t->scrn + t->co * top, ' ', amnt * t->co);
d1285 2
a1286 3
void
nscroll (t)
     SCRN *t;
d1289 44
a1332 59
	for (y = 0; y != t->li; ++y)
	  {
		  q = t->sary[y];
		  if (have)
			  return;
		  if (q && q != t->li)
			  if (q > 0)
			    {
				    for (z = y; z != t->li && t->sary[z] == q;
					 ++z) t->sary[z] = 0;
				    doupscrl (t, y, z + q, q), y = z - 1;
			    }
			  else
			    {
				    for (r = y;
					 r != t->li && (t->sary[r] < 0
							|| t->sary[r] ==
							t->li); ++r);
				    p = r - 1;
				    do
				      {
					      q = t->sary[p];
					      if (q && q != t->li)
						{
							for (z = p;
							     t->sary[z] =
							     0, (z
								 && t->
								 sary[z -
								      1] ==
								 q); --z);
							dodnscrl (t, z + q,
								  p + 1, -q);
							p = z + 1;
						}
				      }
				    while (p-- != y);
				    y = r - 1;
			    }
	  }
	msetI (t->sary, 0, t->li);
}

void
npartial (t)
     SCRN *t;
{
	attr (t, 0);
	clrins (t);
	setregn (t, 0, t->li);
}

void
nescape (t)
     SCRN *t;
{
	npartial (t);
	cpos (t, 0, t->li - 1);
	eraeol (t, 0, t->li - 1);
d1334 1
a1334 1
		texec (t->cap, t->te, 1);
d1337 2
a1338 3
void
nreturn (t)
     SCRN *t;
d1341 1
a1341 1
		texec (t->cap, t->ti, 1);
d1343 2
a1344 2
		texec (t->cap, t->cl, 1);
	nredraw (t);
d1347 2
a1348 3
void
nclose (t)
     SCRN *t;
a1349 1
	int x;
d1351 4
a1354 4
	attr (t, 0);
	clrins (t);
	setregn (t, 0, t->li);
	cpos (t, 0, t->li - 1);
d1356 9
a1364 9
		texec (t->cap, t->te, 1);
	ttclose ();
	rmcap (t->cap);
	free (t->scrn);
	free (t->sary);
	free (t->ofst);
	free (t->htab);
	free (t->ary);
	free (t);
d1367 3
a1369 4
void
nscrldn (t, top, bot, amnt)
     SCRN *t;
     int top, bot, amnt;
d1372 1
d1375 1
a1375 1
	if (amnt < bot - top && bot - top - amnt < amnt / 2 || !t->scroll)
d1377 6
a1382 11
	if (amnt < bot - top)
	  {
		  for (x = bot; x != top + amnt; --x)
			  t->sary[x - 1] =
				  (t->sary[x - amnt - 1] ==
				   t->li ? t->li : t->sary[x - amnt - 1] -
				   amnt), t->updtab[x - 1] =
				  t->updtab[x - amnt - 1];
		  for (x = top; x != top + amnt; ++x)
			  t->updtab[x] = 1;
	  }
d1385 1
a1385 1
	msetI (t->sary + top, t->li, amnt);
d1387 1
a1387 1
		msetI (t->updtab + top, 1, amnt);
d1390 3
a1392 4
void
nscrlup (t, top, bot, amnt)
     SCRN *t;
     int top, bot, amnt;
d1395 1
d1398 1
a1398 1
	if (amnt < bot - top && bot - top - amnt < amnt / 2 || !t->scroll)
d1400 6
a1405 10
	if (amnt < bot - top)
	  {
		  for (x = top + amnt; x != bot; ++x)
			  t->sary[x - amnt] =
				  (t->sary[x] ==
				   t->li ? t->li : t->sary[x] + amnt),
				  t->updtab[x - amnt] = t->updtab[x];
		  for (x = bot - amnt; x != bot; ++x)
			  t->updtab[x] = 1;
	  }
d1408 1
a1408 1
	msetI (t->sary + bot - amnt, t->li, amnt);
d1410 1
a1410 1
		msetI (t->updtab + bot - amnt, 1, amnt);
d1415 2
a1416 3
void
nredraw (t)
     SCRN *t;
d1419 4
a1422 4
	msetI (t->scrn, ' ', t->co * skiptop);
	msetI (t->scrn + skiptop * t->co, -1, (t->li - skiptop) * t->co);
	msetI (t->sary, 0, t->li);
	msetI (t->updtab + skiptop, -1, t->li - skiptop);
d1429 16
a1444 18
	attr (t, 0);
	clrins (t);
	setregn (t, 0, t->li);

	if (!skiptop)
		if (t->cl)
		  {
			  texec (t->cap, t->cl, 1, 0);
			  t->x = 0;
			  t->y = 0;
			  msetI (t->scrn, ' ', t->li * t->co);
		  }
		else if (t->cd)
		  {
			  cpos (t, 0, 0);
			  texec (t->cap, t->cd, 1, 0);
			  msetI (t->scrn, ' ', t->li * t->co);
		  }
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Device independant TTY interface for JOE
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d17 3
a19 3
int skiptop=0;
int lines=0;
int columns=0;
d25 83
a107 62
unsigned xlata[256]=
 {
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 UNDERLINE,

 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 

 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
 
 INVERSE+UNDERLINE, 
 };

unsigned char xlatc[256]=
 {
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,63
 }; 
d111 41
a151 31
int attr(t,c)
SCRN *t;
int c;
{
int e;
c&=~255;
e=(t->attrib&~c);
if(e) /* If any attribute go off, switch them all off: fixes bug on PCs */
 {
 if(t->me) texec(t->cap,t->me,1);
 else
  {
  if(t->ue) texec(t->cap,t->ue,1);
  if(t->se) texec(t->cap,t->se,1);
  }
 t->attrib=0;
 }
e=(c&~t->attrib);
if(e&INVERSE)
 if(t->mr) texec(t->cap,t->mr,1);
 else if(t->so) texec(t->cap,t->so,1);
if(e&UNDERLINE)
 if(t->us) texec(t->cap,t->us,1);
if(e&BLINK)
 if(t->mb) texec(t->cap,t->mb,1);
if(e&BOLD)
 if(t->md) texec(t->cap,t->md,1);
if(e&DIM)
 if(t->mh) texec(t->cap,t->mh,1);
t->attrib=c;
return 0;
d156 19
a174 17
void setregn(t,top,bot)
SCRN *t;
int top,bot;
{
if(!t->cs)
 {
 t->top=top;
 t->bot=bot;
 return;
 }
if(t->top!=top || t->bot!=bot)
 {
 t->top=top;
 t->bot=bot;
 texec(t->cap,t->cs,1,top,bot-1);
 t->x= -1; t->y= -1;
 }
d179 9
a187 8
void setins(t,x)
SCRN *t;
{
if(t->ins!=1 && t->im)
 {
 t->ins=1;
 texec(t->cap,t->im,1,x);
 }
d192 10
a201 9
int clrins(t)
SCRN *t;
{
if(t->ins!=0)
 {
 texec(t->cap,t->ei,1);
 t->ins=0;
 }
return 0;
d206 41
a246 27
int eraeol(t,x,y)
SCRN *t;
{
int *s, *ss;
int w=t->co-x-1;			/* Don't worry about last column */
if(w<=0) return 0;
s=t->scrn+y*t->co+x;
ss=s+w;
do if(*--ss!=' ') { ++ss; break; } while(ss!=s);
if((ss-s>3 || s[w]!=' ') && t->ce)
 {
 cpos(t,x,y);
 attr(t,0);
 texec(t->cap,t->ce,1);
 msetI(s,' ',w);
 }
else if(s!=ss)
 {
 if(t->ins) clrins(t);
 if(t->x!=x || t->y!=y) cpos(t,x,y);
 if(t->attrib) attr(t,0);
 while(s!=ss)
  {
  *s=' '; ttputc(' '); ++t->x; ++s;
  }
 }
return 0;
d252 21
a272 2
void outatri(t,x,y,c)
SCRN *t;
d274 188
a461 156
unsigned char ch;
if(c== -1) c=' ';
ch=c; c-=ch;
if(c!=t->attrib) attr(t,c);
if(t->haz && ch=='~') ch='\\';
ttputc(ch);
++t->x;
}

void out(t,c)
char *t;
char c;
 {
 ttputc(c);
 }

SCRN *nopen(cap)
CAP *cap;
{
SCRN *t=(SCRN *)malloc(sizeof(SCRN));
int x,y;
ttopen();

t->cap=cap;
setcap(cap,baud,out,NULL);

t->li=getnum(t->cap,"li"); if(t->li<1) t->li=24;
t->co=getnum(t->cap,"co"); if(t->co<2) t->co=80;
x=y=0;
ttgtsz(&x,&y);
if(x>7 && y>3) t->li=y, t->co=x;

t->haz=getflag(t->cap,"hz");
t->os=getflag(t->cap,"os");
t->eo=getflag(t->cap,"eo");
if(getflag(t->cap,"hc")) t->os=1;
if(t->os || getflag(t->cap,"ul")) t->ul=1;
else t->ul=0;

t->xn=getflag(t->cap,"xn");
t->am=getflag(t->cap,"am");

t->ti=jgetstr(t->cap,"ti");
t->cl=jgetstr(t->cap,"cl");
t->cd=jgetstr(t->cap,"cd");

t->te=jgetstr(t->cap,"te");

t->mb=0; t->md=0; t->mh=0; t->mr=0; t->avattr=0;
if(!(t->me=jgetstr(t->cap,"me"))) goto oops;
if((t->mb=jgetstr(t->cap,"mb"))) t->avattr|=BLINK;
if((t->md=jgetstr(t->cap,"md"))) t->avattr|=BOLD;
if((t->mh=jgetstr(t->cap,"mh"))) t->avattr|=DIM;
if((t->mr=jgetstr(t->cap,"mr"))) t->avattr|=INVERSE;
oops:

t->so=0; t->se=0;
if(getnum(t->cap,"sg")<=0 && !t->mr && jgetstr(t->cap,"se"))
 {
 if(t->so=jgetstr(t->cap,"so")) t->avattr|=INVERSE;
 t->se=jgetstr(t->cap,"se");
 }
if(getflag(t->cap,"xs") || getflag(t->cap,"xt")) t->so=0;

t->us=0; t->ue=0;
if(getnum(t->cap,"ug")<=0 && jgetstr(t->cap,"ue"))
 {
 if(t->us=jgetstr(t->cap,"us")) t->avattr|=UNDERLINE;
 t->ue=jgetstr(t->cap,"ue");
 }

if(!(t->uc=jgetstr(t->cap,"uc"))) if(t->ul) t->uc="_";
if(t->uc) t->avattr|=UNDERLINE;

t->ms=getflag(t->cap,"ms");

t->da=getflag(t->cap,"da");
t->db=getflag(t->cap,"db");
t->cs=jgetstr(t->cap,"cs");
t->rr=getflag(t->cap,"rr");
t->sf=jgetstr(t->cap,"sf");
t->sr=jgetstr(t->cap,"sr");
t->SF=jgetstr(t->cap,"SF");
t->SR=jgetstr(t->cap,"SR");
t->al=jgetstr(t->cap,"al");
t->dl=jgetstr(t->cap,"dl");
t->AL=jgetstr(t->cap,"AL");
t->DL=jgetstr(t->cap,"DL");
if(!getflag(t->cap,"ns") && !t->sf) t->sf="\12";

if(!getflag(t->cap,"in") && baud<38400 )
 {
 t->dc=jgetstr(t->cap,"dc");
 t->DC=jgetstr(t->cap,"DC");
 t->dm=jgetstr(t->cap,"dm");
 t->ed=jgetstr(t->cap,"ed");

 t->im=jgetstr(t->cap,"im");
 t->ei=jgetstr(t->cap,"ei");
 t->ic=jgetstr(t->cap,"ic");
 t->IC=jgetstr(t->cap,"IC");
 t->ip=jgetstr(t->cap,"ip");
 t->mi=getflag(t->cap,"mi");
 }
else
 {
 t->dm=0; t->dc=0; t->DC=0; t->ed=0;
 t->im=0; t->ic=0; t->IC=0; t->ip=0; t->ei=0;
 t->mi=1;
 }

t->bs=0;
if(jgetstr(t->cap,"bc")) t->bs=jgetstr(t->cap,"bc");
else if(jgetstr(t->cap,"le")) t->bs=jgetstr(t->cap,"le");
if(getflag(t->cap,"bs")) t->bs="\10";

t->cbs=tcost(t->cap,t->bs,1,2,2);

t->lf="\12";
if(jgetstr(t->cap,"do")) t->lf=jgetstr(t->cap,"do");
t->clf=tcost(t->cap,t->lf,1,2,2);

t->up=jgetstr(t->cap,"up");
t->cup=tcost(t->cap,t->up,1,2,2);

t->nd=jgetstr(t->cap,"nd");

t->tw=8;
if(getnum(t->cap,"it")>0) t->tw=getnum(t->cap,"it");
else if(getnum(t->cap,"tw")>0) t->tw=getnum(t->cap,"tw");

if(!(t->ta=jgetstr(t->cap,"ta"))) if(getflag(t->cap,"pt")) t->ta="\11";
t->bt=jgetstr(t->cap,"bt");
if(getflag(t->cap,"xt")) t->ta=0, t->bt=0;

t->cta=tcost(t->cap,t->ta,1,2,2);
t->cbt=tcost(t->cap,t->bt,1,2,2);

t->ho=jgetstr(t->cap,"ho");
t->cho=tcost(t->cap,t->ho,1,2,2);
t->ll=jgetstr(t->cap,"ll");
t->cll=tcost(t->cap,t->ll,1,2,2);

t->cr="\15";
if(jgetstr(t->cap,"cr")) t->cr=jgetstr(t->cap,"cr");
if(getflag(t->cap,"nc") || getflag(t->cap,"xr")) t->cr=0;
t->ccr=tcost(t->cap,t->cr,1,2,2);

t->cRI=tcost(t->cap,t->RI=jgetstr(t->cap,"RI"),1,2,2);
t->cLE=tcost(t->cap,t->LE=jgetstr(t->cap,"LE"),1,2,2);
t->cUP=tcost(t->cap,t->UP=jgetstr(t->cap,"UP"),1,2,2);
t->cDO=tcost(t->cap,t->DO=jgetstr(t->cap,"DO"),1,2,2);
t->cch=tcost(t->cap,t->ch=jgetstr(t->cap,"ch"),1,2,2);
t->ccv=tcost(t->cap,t->cv=jgetstr(t->cap,"cv"),1,2,2);
t->ccV=tcost(t->cap,t->cV=jgetstr(t->cap,"cV"),1,2,2);
t->ccm=tcost(t->cap,t->cm=jgetstr(t->cap,"cm"),1,2,2);
d463 1
a463 1
t->cce=tcost(t->cap,t->ce=jgetstr(t->cap,"ce"),1,2,2);
d466 17
a482 11
if(t->cm) goto ok;
if(t->ch && t->cv) goto ok;
if(t->ho && (t->lf || t->DO || t->cv)) goto ok;
if(t->ll && (t->up || t->UP || t->cv)) goto ok;
if(t->cr && t->cv) goto ok;
leave=1;
ttclose();
signrm();
fprintf(stderr,"Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
return 0;
ok:
d485 9
a493 7
if((t->sr || t->SR) && (t->sf || t->SF) && t->cs ||
   (t->al || t->AL) && (t->dl || t->DL)) t->scroll=1;
else
 {
 t->scroll=0;
 if(baud<38400) mid=1;
 }
d496 4
a499 2
if((t->im || t->ic || t->IC) && (t->dc || t->DC)) t->insdel=1;
else t->insdel=0;
d502 8
a509 1
if(baud>=38400) t->scroll=0, t->insdel=0;
d512 8
a519 4
t->scrn=0; t->sary=0; t->updtab=0; t->compose=0;
t->ofst=0; t->ary=0;
t->htab=(struct hentry *)malloc(256*sizeof(struct hentry));
nresize(t,t->co,t->li);
d521 2
a522 5
/* Send out terminal initialization string */
if(t->ti) texec(t->cap,t->ti,1);

return t;
} 
d526 29
a554 20
void nresize(t,w,h)
SCRN *t;
{
if(h<4) h=4;
if(w<8) w=8;
t->li=h;
t->co=w;
if(t->sary) free(t->sary);
if(t->updtab) free(t->updtab);
if(t->scrn) free(t->scrn);
if(t->compose) free(t->compose);
if(t->ofst) free(t->ofst);
if(t->ary) free(t->ary);
t->scrn=(int *)malloc(t->li*t->co*sizeof(int));
t->sary=(int *)calloc(t->li,sizeof(int));
t->updtab=(int *)malloc(t->li*sizeof(int));
t->compose=(int *)malloc(t->co*sizeof(int));
t->ofst=(int *)malloc(t->co*sizeof(int));
t->ary=(struct hentry *)malloc(t->co*sizeof(struct hentry));
nredraw(t);
d564 4
a567 3
static int relcost(t,x,y,ox,oy)
register SCRN *t;
register int x,y,ox,oy;
d569 1
a569 1
int cost=0;
d572 2
a573 1
if(oy== -1 || ox== -1) return 10000;
d576 44
a619 32
if(y>oy)
 {
 int dist=y-oy;
 /* Have to go down */
 if(t->lf)
  {
  int mult=dist*t->clf;
  if(dist<10 && t->cDO<mult) cost+=t->cDO;
  else if(dist>=10 && t->cDO+1<mult) cost+=t->cDO+1;
  else cost+=mult;
  }
 else if(t->DO)
  if(dist<10) cost+=t->cDO;
  else cost+=t->cDO+1;
 else return 10000;
 }
else if(y<oy)
 {
 int dist=oy-y;
 /* Have to go up */
 if(t->up)
  {
  int mult=dist*t->cup;
  if(dist<10 && t->cUP<mult) cost+=t->cUP;
  else if(dist>=10 && t->cUP<mult) cost+=t->cUP+1;
  else cost+=mult;
  }
 else if(t->UP)
  if(dist<10) cost+=t->cUP;
  else cost+=t->cUP+1;
 else return 10000;
 }
d624 52
a675 28
if(x>ox && t->ta)
 {
 int dist=x-ox;
 int ntabs=(dist+ox%t->tw)/t->tw;
 int cstunder=x%t->tw+t->cta*ntabs, cstover;
 if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
 else cstover=10000;
 if(dist<10 && cstunder<t->cRI && cstunder<x-ox && cstover>cstunder)
  return cost+cstunder;
 else if(cstunder<t->cRI+1 && cstunder<x-ox && cstover>cstunder)
  return cost+cstunder;
 else if(dist<10 && cstover<t->cRI && cstover<x-ox) return cost+cstover;
 else if(cstover<t->cRI+1 && cstover<x-ox) return cost+cstover;
 }
else if(x<ox && t->bt)
 {
 int dist=ox-x; 
 int ntabs=(dist+t->tw-ox%t->tw)/t->tw;
 int cstunder,cstover;
 if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
 if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
 if(dist<10 && cstunder<t->cLE && (t->bs?cstunder<(ox-x)*t->cbs:1) && cstover>cstunder)
  return cost+cstunder;
 if(cstunder<t->cLE+1 && (t->bs?cstunder<(ox-x)*t->cbs:1) && cstover>cstunder)
  return cost+cstunder;
 else if(dist<10 && cstover<t->cRI && (t->bs?cstover<(ox-x)*t->cbs:1)) return cost+cstover;
 else if(cstover<t->cRI+1 && (t->bs?cstover<(ox-x)*t->cbs:1)) return cost+cstover;
 }
d678 31
a708 23
if(x<ox)
 {
 int dist=ox-x;
 /* Have to go left */
 if(t->bs)
  {
  int mult=dist*t->cbs;
  if(t->cLE<mult && dist<10) cost+=t->cLE;
  else if(t->cLE+1<mult) cost+=t->cLE+1;
  else cost+=mult;
  }
 else if(t->LE) cost+=t->cLE;
 else return 10000;
 }
else if(x>ox)
 {
 int dist=x-ox;
 /* Have to go right */
 /* Hmm.. this should take into account possible attribute changes */
 if(t->cRI<dist && dist<10) cost+=t->cRI;
 else if(t->cRI+1<dist) cost+=t->cRI+1;
 else cost+=dist;
 }
d710 1
a710 1
return cost;
d718 9
a726 8
static void cposs(t,x,y)
register SCRN *t;
register int x,y;
{
register int bestcost,cost;
int bestway;
int hy;
int hl;
d731 4
a734 2
if(t->rr) hy=t->top, hl=t->bot-1;
else hy=0, hl=t->li-1;
d738 2
a739 1
bestcost=relcost(t,x,y,t->x,t->y); bestway=0;
d745 114
a858 70
if(t->ccm<bestcost)
 {
 cost=tcost(t->cap,t->cm,1,y,x);
 if(cost<bestcost) bestcost=cost, bestway=6;
 }
if(t->ccr<bestcost)
 {
 cost=relcost(t,x,y,0,t->y)+t->ccr;
 if(cost<bestcost) bestcost=cost, bestway=1;
 }
if(t->cho<bestcost)
 {
 cost=relcost(t,x,y,0,hy)+t->cho;
 if(cost<bestcost) bestcost=cost, bestway=2;
 }
if(t->cll<bestcost)
 {
 cost=relcost(t,x,y,0,hl)+t->cll;
 if(cost<bestcost) bestcost=cost, bestway=3;
 }
if(t->cch<bestcost && x!=t->x)
 {
 cost=relcost(t,x,y,x,t->y)+tcost(t->cap,t->ch,1,x);
 if(cost<bestcost) bestcost=cost, bestway=4;
 }
if(t->ccv<bestcost && y!=t->y)
 {
 cost=relcost(t,x,y,t->x,y)+tcost(t->cap,t->cv,1,y);
 if(cost<bestcost) bestcost=cost, bestway=5;
 }
if(t->ccV<bestcost)
 {
 cost=relcost(t,x,y,0,y)+tcost(t->cap,t->cV,1,y);
 if(cost<bestcost) bestcost=cost, bestway=13;
 }
if(t->cch+t->ccv<bestcost && x!=t->x && y!=t->y)
 {
 cost=tcost(t->cap,t->cv,1,y-hy)+tcost(t->cap,t->ch,1,x);
 if(cost<bestcost) bestcost=cost, bestway=7;
 }
if(t->ccv+t->ccr<bestcost && y!=t->y)
 {
 cost=tcost(t->cap,t->cv,1,y)+tcost(t->cap,t->cr,1)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=8;
 }
if(t->cll+t->cch<bestcost)
 {
 cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->ch,1,x)+
      relcost(t,x,y,x,hl);
 if(cost<bestcost) bestcost=cost, bestway=9;
 }
if(t->cll+t->ccv<bestcost)
 {
 cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->cv,1,y)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=10;
 }
if(t->cho+t->cch<bestcost)
 {
 cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->ch,1,x)+
      relcost(t,x,y,x,hy);
 if(cost<bestcost) bestcost=cost, bestway=11;
 }
if(t->cho+t->ccv<bestcost)
 {
 cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->cv,1,y)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=12;
 }
d864 64
a927 20
switch(bestway)
 {
case 1: texec(t->cap,t->cr,1); t->x=0; break;
case 2: texec(t->cap,t->ho,1); t->x=0; t->y=hy; break;
case 3: texec(t->cap,t->ll,1); t->x=0; t->y=hl; break;
case 9: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto doch;
case 11: texec(t->cap,t->ho,1); t->x=0; t->y=hy;
  doch:
case 4: texec(t->cap,t->ch,1,x); t->x=x; break;
case 10: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto docv;
case 12: texec(t->cap,t->ho,1); t->x=0; t->y=hy; goto docv;
case 8: texec(t->cap,t->cr,1); t->x=0;
  docv:
case 5: texec(t->cap,t->cv,1,y); t->y=y; break;
case 6: texec(t->cap,t->cm,1,y,x); t->y=y, t->x=x; break;
case 7: texec(t->cap,t->cv,1,y); t->y=y;
        texec(t->cap,t->ch,1,x); t->x=x;
        break;
case 13: texec(t->cap,t->cV,1,y); t->y=y; t->x=0; break;
 }
d932 14
a945 10
if(y>t->y)
 /* Have to go down */
 if(!t->lf || t->cDO<(y-t->y)*t->clf)
  texec(t->cap,t->DO,1,y-t->y), t->y=y;
 else while(y>t->y) texec(t->cap,t->lf,1), ++t->y;
else if(y<t->y)
 /* Have to go up */
 if(!t->up || t->cUP<(t->y-y)*t->cup)
  texec(t->cap,t->UP,1,t->y-y), t->y=y;
 else while(y<t->y) texec(t->cap,t->up,1), --t->y;
d948 69
a1016 42
if(x>t->x && t->ta)
 {
 int ntabs=(x-t->x+t->x%t->tw)/t->tw;
 int cstunder=x%t->tw+t->cta*ntabs, cstover;
 if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
 else cstover=10000;
 if(cstunder<t->cRI && cstunder<x-t->x && cstover>cstunder)
  {
  if(ntabs)
   {
   t->x=x-x%t->tw;
   do texec(t->cap,t->ta,1); while(--ntabs);
   }
  }
 else if(cstover<t->cRI && cstover<x-t->x)
  {
  t->x=t->tw+x-x%t->tw;
  ++ntabs;
  do texec(t->cap,t->ta,1); while(--ntabs);
  }
 }
else if(x<t->x && t->bt)
 {
 int ntabs=((t->x+t->tw-1)-(t->x+t->tw-1)%t->tw-
            ((x+t->tw-1)-(x+t->tw-1)%t->tw))/t->tw;
 int cstunder,cstover;
 if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
 if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
 if(cstunder<t->cLE && (t->bs?cstunder<(t->x-x)*t->cbs:1) && cstover>cstunder)
  {
  if(ntabs)
   {
   do texec(t->cap,t->bt,1); while(--ntabs);
   t->x=x+t->tw-x%t->tw;
   }
  }
 else if(cstover<t->cRI && (t->bs?cstover<(t->x-x)*t->cbs:1))
  {
  t->x=x-x%t->tw; ++ntabs;
  do texec(t->cap,t->bt,1); while(--ntabs);
  }
 }
d1019 128
a1146 102
if(x<t->x)
 /* Have to go left */
 if(!t->bs || t->cLE<(t->x-x)*t->cbs)
  texec(t->cap,t->LE,1,t->x-x), t->x=x;
 else while(x<t->x) texec(t->cap,t->bs,1), --t->x;
else if(x>t->x)
 /* Have to go right */
 /* Hmm.. this should take into account possible attribute changes */
 if(t->cRI<x-t->x) texec(t->cap,t->RI,1,x-t->x), t->x=x;
 else
  {
  int *s=t->scrn+t->x+t->y*t->co;
  if(t->ins) clrins(t);
  while(x>t->x)
   {
   int c= (0xFF&*s);
   int a= (0xFF00&*s);
   if(a!=t->attrib) attr(t,a);
   ttputc(c);
   ++s; ++t->x;
   }
  }
}

int cpos(t,x,y)
register SCRN *t;
register int x,y;
{
if(y==t->y)
 {
 if(x==t->x) return 0;
 if(x>t->x && x-t->x<4 && !t->ins)
  {
  int *cs=t->scrn+t->x+t->co*t->y;
  if(t->ins) clrins(t);
  do
   {
   int c= (0xFF& *cs);
   int a= (0xFF00& *cs);
   if(a!=t->attrib) attr(t,a);
   ttputc(c);
   ++cs; ++t->x;
   } while(x!=t->x);
  return 0;
  }
 }
if(!t->ms && t->attrib&(INVERSE|UNDERLINE))
 attr(t,t->attrib&~(INVERSE|UNDERLINE));
if(y<t->top || y>=t->bot) setregn(t,0,t->li);
cposs(t,x,y);
return 0;
}

static void doinschr(t,x,y,s,n)
SCRN *t;
int x,y,*s,n;
{
int a;
if(x<0) s-=x, x=0;
if(x>=t->co-1 || n<=0) return;
if(t->im || t->ic || t->IC)
 {
 cpos(t,x,y);
 if(n==1 && t->ic || !t->IC)
  {
  if(!t->ic) setins(t,x);
  for(a=0;a!=n;++a)
   {
   texec(t->cap,t->ic,1,x);
   outatri(t,x+a,y,s[a]);
   texec(t->cap,t->ip,1,x);
   }
  if(!t->mi) clrins(t);
  }
 else
  {
  texec(t->cap,t->IC,1,n);
  for(a=0;a!=n;++a) outatri(t,x+a,y,s[a]);
  }
 }
mmove(t->scrn+x+t->co*y+n,t->scrn+x+t->co*y,(t->co-(x+n))*sizeof(int));
mcpy(t->scrn+x+t->co*y,s,n*sizeof(int));
}

static void dodelchr(t,x,y,n)
SCRN *t;
int x,y,n;
{
int a;
if(x<0) x=0;
if(!n || x>=t->co-1) return;
if(t->dc || t->DC)
 {
 cpos(t,x,y);
 texec(t->cap,t->dm,1,x);		/* Enter delete mode */
 if(n==1 && t->dc || !t->DC)
  for(a=n;a;--a) texec(t->cap,t->dc,1,x);
 else texec(t->cap,t->DC,1,n);
 texec(t->cap,t->ed,1,x);		/* Exit delete mode */
 }
mmove(t->scrn+t->co*y+x,t->scrn+t->co*y+x+n,(t->co-(x+n))*sizeof(int));
msetI(t->scrn+t->co*y+t->co-n,' ',n);
d1151 13
a1163 12
void magic(t,y,cs,s,placex)
SCRN *t;
int y,*cs,*s;
{
struct hentry *htab=t->htab;
int *ofst=t->ofst;
int aryx=1;
int x;
if(!(t->im || t->ic || t->IC) ||
   !(t->dc || t->DC)) return;
mset(htab,0,256*sizeof(struct hentry));
msetI(ofst,0,t->co);
d1166 5
a1170 5
for(x=0;x!=t->co-1;++x)
 t->ary[aryx].next=htab[cs[x]&255].next,
 t->ary[aryx].loc=x,
 ++htab[cs[x]&255].loc,
 htab[cs[x]&255].next=aryx++;
d1173 59
a1231 37
for(x=0;x<t->co-1;)
 if(htab[s[x]&255].loc>=15) ofst[x++]= t->co-1;
 else
  {
  int aryy;
  int maxaryy;
  int maxlen=0;
  int best=0;
  int bestback=0;
  int z;
  for(aryy=htab[s[x]&255].next;aryy;aryy=t->ary[aryy].next)
   {
   int amnt,back;
   int tsfo=t->ary[aryy].loc-x;
   int cst= -abs(tsfo);
   int pre=32;
   for(amnt=0;x+amnt<t->co-1 && x+tsfo+amnt<t->co-1;++amnt)
    {
    if(cs[x+tsfo+amnt]!=s[x+amnt]) break;
    else if(s[x+amnt]&255!=32 || pre!=32) ++cst;
    pre=s[x+amnt]&255;
    }
   pre=32;
   for(back=0;back+x>0 && back+tsfo+x>0;--back)
    {
    if(cs[x+tsfo+back-1]!=s[x+back-1]) break;
    else if(s[x+back-1]&255!=32 || pre!=32) ++cst;
    pre=s[x+back-1]&255;
    }
   if(cst>best) maxaryy=aryy, maxlen=amnt, best=cst, bestback=back;
   }
  if(!maxlen) ofst[x]=t->co-1, maxlen=1;
  else if(best<2) for(z=0;z!=maxlen;++z) ofst[x+z]=t->co-1;
  else for(z=0;z!=maxlen-bestback;++z)
   ofst[x+z+bestback]=t->ary[maxaryy].loc-x;
  x+=maxlen;
  }
d1235 371
a1605 290
for(x=0;x!=t->co-1;++x)
 {
 int q=ofst[x];
 if(q && q!=t->co-1)
  if(q>0)
   {
   int z,fu;
   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
   while(s[x]==cs[x] && x<placex) ++x;
   dodelchr(t,x,y,q);
   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
   x=z-1;
   }
  else
   {
   int z,fu;
   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
   while(s[x+q]==cs[x+q] && x-q<placex) ++x;
   doinschr(t,x+q,y,s+x+q,-q);
   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
   x=z-1;
   }
 }
}

static void doupscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sf || t->SF))
 {
 setregn(t,0,t->li);
 cpos(t,0,t->li-1);
 if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,t->li-1);
 else texec(t->cap,t->SF,a,a);
 goto done;
 }
if(bot==t->li && (t->dl || t->DL))
 {
 setregn(t,0,t->li);
 cpos(t,0,top);
 if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
 else texec(t->cap,t->DL,a,a);
 goto done;
 }
if(t->cs && ( t->sf || t->SF ))
 {
 setregn(t,top,bot);
 cpos(t,0,bot-1);
 if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,bot-1);
 else texec(t->cap,t->SF,a,a);
 goto done;
 }
if((t->dl || t->DL) && (t->al || t->AL))
 {
 cpos(t,0,top);
 if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
 else texec(t->cap,t->DL,a,a);
 a=amnt;
 cpos(t,0,bot-amnt);
 if(amnt==1 && t->al || !t->AL) while(a--) texec(t->cap,t->al,1,bot-amnt);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
msetI(t->updtab+top,1,bot-top);
return;

done:
mfwrd(t->scrn+top*t->co,t->scrn+(top+amnt)*t->co,
      (bot-top-amnt)*t->co*sizeof(int));
if(bot==t->li && t->db)
 {
 msetI(t->scrn+(t->li-amnt)*t->co,-1,amnt*t->co);
 msetI(t->updtab+t->li-amnt,1,amnt);
 }
else msetI(t->scrn+(bot-amnt)*t->co,' ',amnt*t->co);
}

static void dodnscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sr || t->SR))
 {
 setregn(t,0,t->li);
 cpos(t,0,0);
 if(amnt==1 && t->sr || !t->SR)
  while(a--) texec(t->cap,t->sr,1,0);
 else texec(t->cap,t->SR,a,a);
 goto done;
 }
if(bot==t->li && (t->al || t->AL))
 {
 setregn(t,0,t->li);
 cpos(t,0,top);
 if(amnt==1 && t->al || !t->AL)
  while(a--) texec(t->cap,t->al,1,top);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
if(t->cs && (t->sr || t->SR))
 {
 setregn(t,top,bot);
 cpos(t,0,top);
 if(amnt==1 && t->sr || !t->SR)
  while(a--) texec(t->cap,t->sr,1,top);
 else texec(t->cap,t->SR,a,a);
 goto done;
 }
if((t->dl || t->DL) && (t->al || t->AL))
 {
 cpos(t,0,bot-amnt);
 if(amnt==1 && t->dl || !t->DL)
  while(a--) texec(t->cap,t->dl,1,bot-amnt);
 else texec(t->cap,t->DL,a,a);
 a=amnt;
 cpos(t,0,top);
 if(amnt==1 && t->al || !t->AL)
  while(a--) texec(t->cap,t->al,1,top);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
msetI(t->updtab+top,1,bot-top);
return;
done:
mbkwd(t->scrn+(top+amnt)*t->co,t->scrn+top*t->co,
      (bot-top-amnt)*t->co*sizeof(int));
if(!top && t->da)
 {
 msetI(t->scrn,-1,amnt*t->co);
 msetI(t->updtab,1,amnt);
 }
else msetI(t->scrn+t->co*top,' ',amnt*t->co);
}

void nscroll(t)
SCRN *t;
{
int y,z,q,r,p;
for(y=0;y!=t->li;++y)
 {
 q=t->sary[y];
 if(have) return;
 if(q && q!=t->li)
  if(q>0)
   {
   for(z=y;z!=t->li && t->sary[z]==q;++z) t->sary[z]=0;
   doupscrl(t,y,z+q,q), y=z-1;
   }
  else
   {
   for(r=y;r!=t->li && (t->sary[r]<0 || t->sary[r]==t->li);++r);
   p=r-1; do
    {
    q=t->sary[p];
    if(q && q!=t->li)
     {
     for(z=p;t->sary[z]=0, (z && t->sary[z-1]==q);--z);
     dodnscrl(t,z+q,p+1,-q);
     p=z+1;
     }
    }
    while(p--!=y);
   y=r-1;
   }
 }
msetI(t->sary,0,t->li);
}

void npartial(t)
SCRN *t;
 {
 attr(t,0);
 clrins(t);
 setregn(t,0,t->li);
 }

void nescape(t)
SCRN *t;
 {
 npartial(t);
 cpos(t,0,t->li-1);
 eraeol(t,0,t->li-1);
 if(t->te) texec(t->cap,t->te,1);
 }

void nreturn(t)
SCRN *t;
 {
 if(t->ti) texec(t->cap,t->ti,1);
 nredraw(t);
 }

void nclose(t)
SCRN *t;
{
int x;
leave=1;
attr(t,0);
clrins(t);
setregn(t,0,t->li);
cpos(t,0,t->li-1);
if(t->te) texec(t->cap,t->te,1);
ttclose();
rmcap(t->cap);
free(t->scrn);
free(t->sary);
free(t->ofst);
free(t->htab);
free(t->ary);
free(t);
}

void nscrldn(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
 {
 for(x=bot;x!=top+amnt;--x)
  t->sary[x-1]=(t->sary[x-amnt-1]==t->li?t->li:t->sary[x-amnt-1]-amnt),
  t->updtab[x-1]=t->updtab[x-amnt-1];
 for(x=top;x!=top+amnt;++x) t->updtab[x]=1;
 }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+top,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+top,1,amnt);
}

void nscrlup(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
 {
 for(x=top+amnt;x!=bot;++x)
  t->sary[x-amnt]=(t->sary[x]==t->li?t->li:t->sary[x]+amnt),
  t->updtab[x-amnt]=t->updtab[x];
 for(x=bot-amnt;x!=bot;++x) t->updtab[x]=1;
 }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+bot-amnt,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+bot-amnt,1,amnt);
}

extern int dostaupd;

void nredraw(t)
SCRN *t;
{
dostaupd=1;
msetI(t->scrn,' ',t->co*skiptop);
msetI(t->scrn+skiptop*t->co,-1,(t->li-skiptop)*t->co);
msetI(t->sary,0,t->li);
msetI(t->updtab+skiptop,-1,t->li-skiptop);
t->x= -1;
t->y= -1;
t->top=t->li;
t->bot=0;
t->attrib= -1;
t->ins= -1;
attr(t,0);
clrins(t);
setregn(t,0,t->li);

if(!skiptop)
 if(t->cl)
  {
  texec(t->cap,t->cl,1,0);
  t->x=0; t->y=0;
  msetI(t->scrn,' ',t->li*t->co);
  }
 else if(t->cd)
  {
  cpos(t,0,0);
  texec(t->cap,t->cd,1,0);
  msetI(t->scrn,' ',t->li*t->co);
  }
@


1.2
log
@changes for joe-2.9.1
@
text
@a25 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d21 1
d876 1
a876 1
   int cst= -Iabs(tsfo);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
