head	1.43;
access;
symbols
	joe_3_5:1.39
	joe-3_4:1.36
	help:1.36
	joe_3_1:1.23
	joe_3_0:1.17
	joe_2_9_8:1.11
	joe_2_9_8_pre1:1.10
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.04.01.13.32;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.28.06.10.58;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.10.14.07.18;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.26.22.48.38;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.05.04.50.00;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.05.04.17.52;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.30.00.39.17;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.28.15.13.13;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.28.06.17.08;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.26.05.47.32;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.21.04.46.59;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.14.20.21.37;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.02.06.02.22;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.08.04.42.41;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.07.19.43.29;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.07.00.48.43;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.03.22.55.50;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.03.12.28.47;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.18.02.26.36;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.15.14.29.07;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.21.04.43.49;	author jhallen;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.04.17.39.02;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.55.00;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.55;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.55;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/*
 *	Menu selection window
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int bg_menu;

int transpose;

static void menufllw(MENU *m)
{
	if (transpose) {
		if ((m->cursor % m->lines) < m->top)
			m->top = m->cursor % m->lines;
		else if (m->cursor % m->lines >= (m->top % m->lines) + m->h)
			m->top = (m->cursor % m->lines) - (m->h - 1);
	} else {
		if (m->cursor < m->top)
			m->top = m->cursor - m->cursor % m->perline;
		else if (m->cursor >= m->top+m->perline*m->h)
			m->top = m->cursor - m->cursor % m->perline - m->perline*(m->h-1);
	}
}

static void menudisp(MENU *m)
{
	int col;
	int x;
	int y;
	int *s = m->t->t->scrn + m->x + m->y * m->t->t->co;
	int *a = m->t->t->attr + m->x + m->y * m->t->t->co;
	struct utf8_sm sm;
	int cut = m->nitems % m->lines;
	if (!cut) cut = m->lines;

	utf8_init(&sm);

	for (y = 0; y != m->h; ++y) {
		col = 0;
		if (transpose) {
			if (y < m->lines)
				for (x = 0; x < ((y + m->top) >= cut ? m->perline - 1 : m->perline) ; ++x) {
					int atr;
					int index = x * m->lines + y + m->top;
			
					if (index == m->cursor && m->t->curwin == m->parent)
						atr = INVERSE|BG_COLOR(bg_menu);
					else
						atr = BG_COLOR(bg_menu);

					if (col == m->w)
						break;

					/* Generate field */
					genfield(m->t->t,
						 s + col,
						 a + col,
						 m->x + col,
						 m->y + y,
						 0,
						 m->list[index],
						 zlen(m->list[index]),
						 atr,
						 m->width,
						 0,NULL);

					col += m->width;

					/* Space between columns */
					if (col != m->w) {
						outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', BG_COLOR(bg_menu));
						++col;
					}
				}
		} else {
			for (x = 0; x != m->perline && y * m->perline + x + m->top < m->nitems; ++x) {
				int atr;
				int index = x + y * m->perline + m->top;
		
				if (index == m->cursor && m->t->curwin==m->parent)
					atr = INVERSE|BG_COLOR(bg_menu);
				else
					atr = BG_COLOR(bg_menu);

				if (col == m->w)
					break;

				/* Generate field */
				genfield(m->t->t,
					 s + col,
					 a + col,
					 m->x + col,
					 m->y + y,
					 0,
					 m->list[index],
					 zlen(m->list[index]),
					 atr,
					 m->width,
					 0,NULL);

				col += m->width;

				/* Space between columns */
				if (col != m->w) {
					outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', BG_COLOR(bg_menu));
					++col;
				}
			}
		}
		/* Clear to end of line */
		if (col != m->w)
			eraeol(m->t->t, m->x + col, m->y + y, BG_COLOR(bg_menu));
		s += m->t->t->co;
		a += m->t->t->co;
	}
	if (transpose) {
		m->parent->cury = (m->cursor % m->lines) - m->top;
		col = txtwidth(locale_map,m->list[m->cursor],zlen(m->list[m->cursor]));
		if (col < m->width)
			m->parent->curx = (m->cursor / m->lines) * (m->width + 1) + col;
		else
			m->parent->curx = (m->cursor / m->lines) * (m->width + 1) + m->width;
	} else {
		m->parent->cury = (m->cursor - m->top) / m->perline;
		col = txtwidth(locale_map,m->list[m->cursor],zlen(m->list[m->cursor]));
		if (col < m->width)
			m->parent->curx = ((m->cursor - m->top) % m->perline) * (m->width + 1) + col;
		else
			m->parent->curx = ((m->cursor - m->top) % m->perline) * (m->width + 1) + m->width;
	}
}

static void menumove(MENU *m, int x, int y)
{
	m->x = x;
	m->y = y;
}

static int mlines(unsigned char **s, int w)
{
	int x;
	int lines;
	int width;
	int nitems;
	int perline;

	for (x = 0, width = 0; s[x]; ++x) {
		int d = txtwidth(locale_map,s[x],zlen(s[x]));
		if (d > width)
			width = d;
	}
	nitems = x;
	if (width > w)
		width = w - 1;
	perline = w / (width + 1);

	lines = (nitems + perline - 1) / perline;

	return lines;
}

static void mconfig(MENU *m)
{
	/* Configure menu display parameters */
	if (m->list) {
		int x;
		/* int lines; */

		m->top = 0;
		for (x = 0, m->width = 0; m->list[x]; ++x) {
			int d = txtwidth(locale_map,m->list[x],zlen(m->list[x]));
			if (d > m->width)
				m->width = d;
		}
		m->nitems = x;
		if (m->width > m->w)
			m->width = m->w - 1;

		m->fitline = m->w / (m->width + 1);

		m->lines = (m->nitems + m->fitline - 1) / m->fitline;

		if (transpose)
			m->perline = (m->nitems + m->lines - 1) / m->lines;
		else
			m->perline = m->fitline;
	}
}

static void menuresz(MENU *m, int wi, int he)
{
	m->w = wi;
	m->h = he;
	mconfig(m);
}

int umbol(MENU *m)
{
	if (transpose)
		m->cursor %= m->lines;
	else
		m->cursor -= m->cursor % m->perline;
	return 0;
}

int umbof(MENU *m)
{
	m->cursor = 0;
	return 0;
}

int umeof(MENU *m)
{
	if (m->nitems) {
		if (transpose && (m->nitems % m->lines != 0)) {
			m->cursor = m->lines - 1 + (m->lines * (m->perline - 2));
		} else {
			m->cursor = m->nitems - 1;
		}
	}
	return 0;
}

int umeol(MENU *m)
{
	if (transpose) {
		int cut = m->nitems % m->lines;
		if (!cut) cut = m->lines;
		m->cursor %= m->lines;
		if (m->cursor >= cut)
			m->cursor += m->lines * (m->perline - 2);
		else
			m->cursor += m->lines * (m->perline - 1);
	} else {
		m->cursor -= m->cursor % m->perline;

		if (m->cursor+m->perline-1 >= m->nitems)
			m->cursor = m->nitems - 1;
		else
			m->cursor += m->perline - 1;
	}

	return 0;
}

int umrtarw(MENU *m)
{
	if (transpose) {
		int cut = m->nitems % m->lines;
		if (!cut) cut = m->lines;
		if (m->cursor % m->lines >= cut) {
			if (m->cursor / m->lines != m->perline - 2) {
				m->cursor += m->lines;
				return 0;
			}
		} else {
			if (m->cursor / m->lines != m->perline - 1) {
				m->cursor += m->lines;
				return 0;
			}
		}
		if ((m->cursor % m->lines) + 1 < m->lines) {
			m->cursor = m->cursor % m->lines + 1;
			return 0;
		}
		return -1;
	} else if (m->cursor + 1 < m->nitems) {
		++m->cursor;
		return 0;
	} else
		return -1;
}

int umtab(MENU *m)
{
	if (m->cursor + 1 >= m->nitems)
		m->cursor = 0;
	else
		++ m->cursor;
	return 0;
}

int umltarw(MENU *m)
{
	if (transpose && m->cursor >= m->lines) {
		m->cursor -= m->lines;
		return 0;
	} else if (transpose && m->cursor) {
		int cut = m->nitems % m->lines;
		if (!cut) cut = m->lines;
		--m->cursor;
		if (m->cursor >= cut)
			m->cursor += (m->perline - 2) * m->lines;
		else
			m->cursor += (m->perline - 1) * m->lines;
		return 0;
	} else if (!transpose && m->cursor) {
		--m->cursor;
		return 0;
	} else
		return -1;
}

int umuparw(MENU *m)
{
	if (transpose && (m->cursor % m->lines)) {
		--m->cursor;
		return 0;
	} else if (!transpose && m->cursor >= m->perline) {
		m->cursor -= m->perline;
		return 0;
	} else
		return -1;
}

int umdnarw(MENU *m)
{
	if (transpose) {
		if (m->cursor != m->nitems - 1 && m->cursor % m->lines != m->lines - 1) {
			++m->cursor;
			return 0;
		} else {
			return -1;
		}
	} else {
		int col = m->cursor % m->perline;

	        m->cursor -= col;

		if (m->cursor + m->perline < m->nitems) {
			m->cursor += m->perline;
			if (m->cursor + col >= m->nitems)
				if (m->nitems)
					m->cursor = m->nitems - 1;
				else
					m->cursor = 0;
			else
				m->cursor += col;
			return 0;
		} else {
			m->cursor += col;
			return -1;
		}
	}
}

void menujump(MENU *m,int x,int y)
{
	int pos = m->top;
	if (transpose) {
		pos += y;
		pos += (x / (m->width + 1)) * m->lines;
	} else {
		pos += y * m->perline;
		pos += x / (m->width + 1);
	}
	if (pos >= m->nitems)
		pos = m->nitems - 1;
	if (pos < 0)
		pos = 0;
	m->cursor = pos;
}

int mscrup(MENU *m,int amnt)
{
	if (transpose) {
		if (m->top >= amnt) {
			m->top -= amnt;
			m->cursor -= amnt;
			return 0;
		} else if (m->top) {
			m->cursor -= m->top;
			m->top = 0;
			return 0;
		} else if (m->cursor % m->lines) {
			m->cursor -= (m->cursor % m->lines);
			return 0;
		} else
			return -1;
	} else {
		if (m->top >= amnt*m->perline) {
			m->top -= amnt*m->perline;
			m->cursor -= amnt*m->perline;
			return 0;
		} else if (m->top) {
			m->cursor -= m->top;
			m->top = 0;
			return 0;
		} else if (m->cursor >= m->perline) {
			m->cursor = m->cursor % m->perline;
			return 0;
		} else
			return -1;
	}
}

int umscrup(MENU *m)
{
	return mscrup(m, 1);
}

int umpgup(MENU *m)
{
	return mscrup(m, (m->h + 1) / 2);
}

int mscrdn(MENU *m, int amnt)
{
	if (transpose) {
		int col = m->cursor / m->lines;
		int y = m->cursor % m->lines;
		int h = m->lines;
		int t = m->top;
		int cut = m->nitems % m->lines;
		if (!cut) cut = m->lines;
		m->cursor %= m->lines;

		if (t + m->h + amnt <= h) {
			m->top += amnt;
			m->cursor += amnt;
			if (m->cursor >= cut && col == m->perline - 1)
				--col;
			m->cursor += col * m->lines;
			return 0;
		} else if (t + m->h < h) {
			amnt = h - (t + m->h);
			m->top += amnt;
			m->cursor += amnt;
			if (m->cursor >= cut && col == m->perline - 1)
				--col;
			m->cursor += col * m->lines;
			return 0;
		} else if (y + 1 != h) {
			m->cursor = h - 1;
			if (m->cursor >= cut && col == m->perline - 1)
				--col;
			m->cursor += col * m->lines;
			return 0;
		} else {
			m->cursor += col * m->lines;
			return -1;
		}
	} else {
		int col = m->cursor % m->perline;
		int y = m->cursor / m->perline;
		int h = (m->nitems + m->perline - 1) / m->perline;
		int t = m->top / m->perline;
		m->cursor -= col;

		if (t + m->h + amnt <= h) {
			m->top += amnt*m->perline;
			m->cursor += amnt*m->perline;
			if (m->cursor + col >= m->nitems)
				if (m->nitems)
					m->cursor = m->nitems - 1;
				else
					m->cursor = 0;
			else
				m->cursor += col;
			return 0;
		} else if (t + m->h < h) {
			amnt = h - (t + m->h);
			m->top += amnt*m->perline;
			m->cursor += amnt*m->perline;
			if (m->cursor + col >= m->nitems)
				if (m->nitems)
					m->cursor = m->nitems - 1;
				else
					m->cursor = 0;
			else
				m->cursor += col;
			return 0;
		} else if (y+1!=h) {
			m->cursor = (h-1)*m->perline;
			if (m->cursor + col >= m->nitems)
				if (m->nitems)
					m->cursor = m->nitems - 1;
				else
					m->cursor = 0;
			else
				m->cursor += col;
			return 0;
		} else {
			m->cursor += col;
			return -1;
		}
	}
}

int umscrdn(MENU *m)
{
	return mscrdn(m, 1);
}

int umpgdn(MENU *m)
{
	return mscrdn(m, (m->h + 1) / 2);
}

static int umrtn(MENU *m)
{
	dostaupd = 1;
	if (m->func)
		return m->func(m, m->cursor, m->object, 0);
	else
		return -1;
}

int umbacks(MENU *m)
{
	if (m->backs)
		return m->backs(m, m->cursor, m->object);
	else
		return -1;
}

static int umkey(MENU *m, int c)
{
	int x;
	int n = 0;

	if (c == '0') {
		if (m->func)
			return m->func(m, m->cursor, m->object, 2);
		else
			return -1;
	}
	if (c == '1') {
		if (m->func)
			return m->func(m, m->cursor, m->object, 1);
		else
			return -1;
	}
	c &= 0x1F;
	for (x = 0; x != m->nitems; ++x)
		if ((m->list[x][0] & 0x1F) == c)
			++n;
	if (!n)
		return -1;
	if (n == 1)
		for (x = 0; x != m->nitems; ++x)
			if ((m->list[x][0] & 0x1F) == c) {
				m->cursor = x;
				return umrtn(m);
			}
	do {
		++m->cursor;
		if (m->cursor == m->nitems)
			m->cursor = 0;
	} while ((m->list[m->cursor][0] & 0x1F) != c);

	return -1;
}

static int menuabort(MENU *m)
{
	W *w = m->parent;
	int (*func) () = m->abrt;
	void *object = m->object;
	int x = m->cursor;
	W *win = w->win;

	joe_free(m);
	if (func)
		return func(win->object, x, object);
	else
		return -1;
}

WATOM watommenu = {
	USTR "menu",
	menudisp,
	menufllw,
	menuabort,
	umrtn,
	umkey,
	menuresz,
	menumove,
	NULL,
	NULL,
	TYPEMENU
};

void ldmenu(MENU *m, unsigned char **s, int cursor)
{
	m->list = s;
	m->cursor = cursor;
	mconfig(m);
}

int menu_above;

MENU *mkmenu(W *w, W *targ, unsigned char **s, int (*func) (/* ??? */), int (*abrt) (/* ??? */), int (*backs) (/* ??? */), int cursor, void *object)
{
	W *new;
	MENU *m;
	int lines;
	int h = (w->main->h*40) / 100; /* 40% of window size */
	if (!h)
		h = 1;
	
	if (s) {
		lines = mlines(s,w->t->w-1);
		if (lines < h)
			h = lines;
	}

	new = wcreate(w->t, &watommenu, w, targ, targ->main, h, NULL);

	if (!new) {
		return NULL;
	}
	wfit(new->t);
	new->object = (void *) (m = (MENU *) joe_malloc(sizeof(MENU)));
	m->parent = new;
	m->func = func;
	m->abrt = abrt;
	m->backs = backs;
	m->object = object;
	m->t = w->t;
	m->h = new->h;
	m->w = new->w;
	m->x = new->x;
	m->y = new->y;
	m->top = 0;
	ldmenu(m, s, cursor);
	w->t->curwin = new;
	return m;
}

/* Simplified menu */

struct choose_result {
	Coroutine t;
	int answer;
};

int choose_cont(MENU *m, int c, void *object,int flg)
{
	struct choose_result *r = (struct choose_result *)object;
	m->object = NULL;
	wabort(m->parent);
	r->answer = c;
	co_resume(&r->t, flg);
	return 0;
}

int choose_abrt(BW *bw, int c, void *object)
{
	if (object) {
		struct choose_result *r = (struct choose_result *)object;
		r->answer = c;
		co_resume(&r->t, -1);
	}
	return -1;
}

int choose_baks(MENU *m, int c, void *object)
{
	struct choose_result *r = (struct choose_result *)object;
	m->object = NULL;
	wabort(m->parent);
	r->answer = c;
	co_resume(&r->t, 3);
	return -1;
}

/* Return value:
    0 means return hit
    1 means '1' hit
    2 means '0' hit
    -1 means ^C hit (menu abort)
    3 means backspace hit
    in all cases, final cursor position is recorded in *cursor
*/

int choose(W *w,				/* Menu goes below this window */
           W *targ,				/* But menu is for this window */
           unsigned char **s,			/* Array of menu items */
           int *cursor)				/* Cursor position in and out */
{
	struct choose_result t;
	int ret;
	MENU *m;
	m = mkmenu(w, targ, s, choose_cont, choose_abrt, choose_baks, *cursor, &t);

	if (!m)
		return -1;

	/* We get woken up when user hits a key */
	ret = co_yield(&t.t, 0);
	*cursor = t.answer;
	return ret;
}

static unsigned char *cull(unsigned char *a, unsigned char *b)
{
	int x;

	for (x = 0; a[x] && b[x] && a[x] == b[x]; ++x) ;
	return vstrunc(a, x);
}

unsigned char *find_longest(unsigned char **lst)
{
	unsigned char *com;
	int x;

	if (!valen(lst))
		return vstrunc(NULL, 0);
	com = vsncpy(NULL, 0, sv(lst[0]));
	for (x = 1; x != valen(lst); ++x)
		com = cull(com, lst[x]);
	return com;
}

unsigned char *mcomplete(MENU *m)
{
	unsigned char *com;
	int x;

	if (!m->nitems)
		return vstrunc(NULL, 0);
	com = vsncpy(NULL, 0, sz(m->list[0]));
	for (x = 1; x != m->nitems; ++x)
		com = cull(com, m->list[x]);
	return com;
}
@


1.42
log
@More work on coroutine refactoring.
@
text
@a657 1
		return -1;
d659 1
@


1.41
log
@menu explorer bugs
@
text
@d122 1
a122 1
		col = txtwidth(m->list[m->cursor],zlen(m->list[m->cursor]));
d129 1
a129 1
		col = txtwidth(m->list[m->cursor],zlen(m->list[m->cursor]));
d152 1
a152 1
		int d = txtwidth(s[x],zlen(s[x]));
d175 1
a175 1
			int d = txtwidth(m->list[x],zlen(m->list[x]));
d528 1
a528 1
			return m->func(m, m->cursor, m->object, -1);
d597 1
a597 1
MENU *mkmenu(W *w, W *targ, unsigned char **s, int (*func) (/* ??? */), int (*abrt) (/* ??? */), int (*backs) (/* ??? */), int cursor, void *object, int *notify)
d612 1
a612 1
	new = wcreate(w->t, &watommenu, w, targ, targ->main, h, NULL, notify);
a614 2
		if (notify)
			*notify = 1;
d635 65
@


1.40
log
@semiautomatic variables
@
text
@d45 33
a77 31
			for (x = 0; x < ((y + m->top) >= cut ? m->perline - 1 : m->perline) ; ++x) {
				int atr;
				int index = x * m->lines + y + m->top;
		
				if (index == m->cursor && m->t->curwin == m->parent)
					atr = INVERSE|BG_COLOR(bg_menu);
				else
					atr = BG_COLOR(bg_menu);

				if (col == m->w)
					break;

				/* Generate field */
				genfield(m->t->t,
					 s + col,
					 a + col,
					 m->x + col,
					 m->y + y,
					 0,
					 m->list[index],
					 zlen(m->list[index]),
					 atr,
					 m->width,
					 0,NULL);

				col += m->width;

				/* Space between columns */
				if (col != m->w) {
					outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', BG_COLOR(bg_menu));
					++col;
a78 1
			}
@


1.39
log
@UC -> USTR
@
text
@d649 1
a649 1
	if (!lst || !aLEN(lst))
d652 1
a652 1
	for (x = 1; x != aLEN(lst); ++x)
@


1.38
log
@change US to UC
@
text
@d574 1
a574 1
	UC "menu",
@


1.37
log
@fix left arrow coredump
@
text
@d574 1
a574 1
	US "menu",
@


1.36
log
@update documents
@
text
@d292 2
d295 4
a298 1
		m->cursor += (m->perline - 1) * m->lines;
@


1.35
log
@transpose menus
@
text
@d217 1
a217 1
	if (m->nitems)
d220 1
a220 1
		} else
d222 2
@


1.34
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d12 2
d16 11
a26 4
	if (m->cursor < m->top)
		m->top = m->cursor - m->cursor % m->perline;
	else if (m->cursor >= m->top+m->perline*m->h)
		m->top = m->cursor - m->cursor % m->perline - m->perline*(m->h-1);
d37 2
d44 67
a110 30
		for (x = 0; x != m->perline && y*m->perline+x+m->top<m->nitems; ++x) {
			int atr;
	
			if (x + y*m->perline + m->top == m->cursor && m->t->curwin==m->parent)
				atr = INVERSE|BG_COLOR(bg_menu);
			else
				atr = BG_COLOR(bg_menu);

			if (col == m->w)
				break;

			/* Generate field */
			genfield(m->t->t,
			         s + col,
			         a + col,
			         m->x + col,
			         m->y + y,
			         0,
			         m->list[x + y*m->perline + m->top],
			         zlen(m->list[x + y*m->perline + m->top]),
			         atr,
			         m->width,
			         0,NULL);

			col += m->width;

			/* Space between columns */
			if (col != m->w) {
				outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', BG_COLOR(bg_menu));
				++col;
d119 15
a133 6
	m->parent->cury = (m->cursor - m->top) / m->perline;
	col = txtwidth(m->list[m->cursor],zlen(m->list[m->cursor]));
	if (col < m->width)
		m->parent->curx = ((m->cursor - m->top) % m->perline) * (m->width + 1) + col;
	else
		m->parent->curx = ((m->cursor - m->top) % m->perline) * (m->width + 1) + m->width;
a180 1
		m->perline = m->w / (m->width + 1);
d182 8
a189 1
		/* lines = (m->nitems + m->perline - 1) / m->perline; */
d202 4
a205 1
	m->cursor -= m->cursor % m->perline;
d218 4
a221 1
		m->cursor = m->nitems - 1;
d227 10
a236 1
	m->cursor -= m->cursor % m->perline;
d238 5
a242 4
	if (m->cursor+m->perline-1 >= m->nitems)
		m->cursor = m->nitems - 1;
	else
		m->cursor += m->perline - 1;
d249 20
a268 1
	if (m->cursor + 1 < m->nitems) {
d286 8
a293 1
	if (m->cursor) {
d302 4
a305 1
	if (m->cursor >= m->perline) {
d314 9
a322 1
	int col = m->cursor % m->perline;
d324 1
a324 1
        m->cursor -= col;
d326 7
a332 5
	if (m->cursor + m->perline < m->nitems) {
		m->cursor += m->perline;
		if (m->cursor + col >= m->nitems)
			if (m->nitems)
				m->cursor = m->nitems - 1;
d334 3
a336 2
				m->cursor = 0;
		else
d338 2
a339 4
		return 0;
	} else {
		m->cursor += col;
		return -1;
d346 7
a352 2
	pos += y * m->perline;
	pos += x / (m->width + 1);
d362 29
a390 13
	if (m->top >= amnt*m->perline) {
		m->top -= amnt*m->perline;
		m->cursor -= amnt*m->perline;
		return 0;
	} else if (m->top) {
		m->cursor -= m->top;
		m->top = 0;
		return 0;
	} else if (m->cursor >= m->perline) {
		m->cursor = m->cursor % m->perline;
		return 0;
	} else
		return -1;
d405 49
a453 12
	int col = m->cursor % m->perline;
	int y = m->cursor / m->perline;
	int h = (m->nitems + m->perline - 1) / m->perline;
	int t = m->top / m->perline;
	m->cursor -= col;

	if (t + m->h + amnt <= h) {
		m->top += amnt*m->perline;
		m->cursor += amnt*m->perline;
		if (m->cursor + col >= m->nitems)
			if (m->nitems)
				m->cursor = m->nitems - 1;
d455 11
a465 11
				m->cursor = 0;
		else
			m->cursor += col;
		return 0;
	} else if (t + m->h < h) {
		amnt = h - (t + m->h);
		m->top += amnt*m->perline;
		m->cursor += amnt*m->perline;
		if (m->cursor + col >= m->nitems)
			if (m->nitems)
				m->cursor = m->nitems - 1;
d467 9
a475 9
				m->cursor = 0;
		else
			m->cursor += col;
		return 0;
	} else if (y+1!=h) {
		m->cursor = (h-1)*m->perline;
		if (m->cursor + col >= m->nitems)
			if (m->nitems)
				m->cursor = m->nitems - 1;
d477 3
a479 2
				m->cursor = 0;
		else
d481 2
a482 4
		return 0;
	} else {
		m->cursor += col;
		return -1;
@


1.33
log
@menu_above option
@
text
@a7 1
#include "config.h"
a9 8

#include "scrn.h"
#include "utils.h"
#include "va.h"
#include "vs.h"
#include "utf8.h"
#include "w.h"

a11 2
extern int dostaupd;

d34 1
a34 1
			int atr, z, lcol;
@


1.32
log
@File selection menu is now above prompt instead of below it.
@
text
@d424 2
d441 1
a441 1
	new = wcreate(w->t, &watommenu, w, targ, w->main, h, NULL, notify);
@


1.31
log
@fix gcc-4.0.0 warnings
@
text
@d424 1
a424 1
MENU *mkmenu(W *w, unsigned char **s, int (*func) (/* ??? */), int (*abrt) (/* ??? */), int (*backs) (/* ??? */), int cursor, void *object, int *notify)
d439 1
a439 1
	new = wcreate(w->t, &watommenu, w, w, w->main, h, NULL, notify);
@


1.30
log
@Mnior mouse fixes
@
text
@a10 1
#include <string.h>
d63 1
a63 1
			         strlen((char *)m->list[x + y*m->perline + m->top]),
d83 1
a83 1
	col = txtwidth(m->list[m->cursor],strlen((char *)m->list[m->cursor]));
d105 1
a105 1
		int d = txtwidth(s[x],strlen((char *)(s[x])));
d128 1
a128 1
			int d = txtwidth(m->list[x],strlen((char *)(m->list[x])));
@


1.29
log
@Background color for screen item
@
text
@d250 1
a250 1
int umpgup(MENU *m)
a251 1
	int amnt = (m->h+1)/2;
d267 11
a277 1
int umpgdn(MENU *m)
a278 1
	int amnt = (m->h+1)/2;
d322 1
d324 8
@


1.28
log
@Background color
@
text
@d20 2
a22 1
extern int bg_color;
d49 1
a49 1
				atr = INVERSE|BG_COLOR(bg_color);
d51 1
a51 1
				atr = BG_COLOR(bg_color);
d73 1
a73 1
				outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', BG_COLOR(bg_color));
d79 1
a79 1
			eraeol(m->t->t, m->x + col, m->y + y);
@


1.27
log
@        Reformat mouse.c

        Apply diff patch

        Apply vpath patch

        Apply electrum's mouse patch (send mouse off code during
        shell escape)

        Mouse can now resize windows

        Mouse can position cursor in menus.  Double-click selects
        an item.  Need to add scroll.

@
text
@d21 1
d48 1
a48 1
				atr = INVERSE;
d50 1
a50 1
				atr = 0;
d72 1
a72 1
				outatr(locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
@


1.26
log
@Blocks to work in hex mode.
Overtype mode for hex.
@
text
@d236 12
@


1.25
log
@Fix menu resize bug
@
text
@d65 1
a65 1
			         0);
@


1.24
log
@Fix syntax file warnings.
Add -jump_menu
@
text
@a94 6
static void menuresz(MENU *m, int wi, int he)
{
	m->w = wi;
	m->h = he;
}

d140 7
@


1.23
log
@Tab completion insanity!  Completion in ^K F plus ESC-TAB in text windows.
@
text
@d46 1
a46 1
			if (x + y*m->perline + m->top == m->cursor)
@


1.22
log
@joe a b c, now windows are in order a, b, c.

TAB completion now works on last path in prompt window:
for example '!ls foo', tab will complete the foo.

Added menu_explorer option.  When set: menu stays up when
a directory is seleted.  When clear: directory is added
to path and menu is closed.

Menus are now 40% of window size (or smaller if they are
not filled).

Cursor is now position after selected menu entry.
@
text
@d15 1
d441 13
@


1.21
log
@TAB key now cycles through menu entries.  This is useful
for tab completion: just keep hitting tab until you see the
file you want, then hit enter.

TAB completion is more "bash"-like: if you complete a directory
name a menu does not appear, the directory just gets added to the
prompt.
@
text
@d81 5
a85 1
	m->parent->curx = ((m->cursor - m->top) % m->perline) * (m->width + 1);
d100 23
d128 1
d140 2
d394 1
a394 1
	W *new = wcreate(w->t, &watommenu, w, w, w->main, 4, NULL, notify);
d396 12
@


1.20
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d155 9
@


1.19
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d70 1
a70 1
				outatr(utf8, locale_map, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
d117 1
a117 1
	m->cursor = m->top;
d136 4
a139 2
	if (m->top + m->perline < m->nitems)
		m->cursor = m->top + m->perline - 1;
d141 2
a142 1
		umeof(m);
@


1.18
log
@Elimiante --pedantic warnings.
@
text
@d70 1
a70 1
				outatr(utf8, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
@


1.17
log
@Allow UTF-8 in menu entries.

Clear up genfield() and genfmt() stuff.  Now control characters in
file names are properly displayed.

When UTF-8 character decodes to 127 - 159, 0 - 31, display it
as a control character.
@
text
@d104 1
a104 1
			int d = txtwidth(m->list[x],strlen(m->list[x]));
@


1.16
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d16 1
a19 1
extern int utf8;
d36 3
d43 1
a43 1
			int atr, z;
d49 1
d52 17
a68 13
			for (z = 0; m->list[x + y*m->perline + m->top][z]; ++z) {
				if (col == m->w)
					break;
				outatr(utf8, m->t->t, s + col, a + col, m->x + col, m->y+y, m->list[x + y*m->perline + m->top][z], atr);
				++col;
			}
			while (z < m->width) {
				if (col == m->w)
					break;
				outatr(utf8, m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
				++col;
				++z;
			}
d74 1
d76 3
a78 3
			eraeol(m->t->t, m->x + col, m->y+y);
	s += m->t->t->co;
	a += m->t->t->co;
d103 5
a107 3
		for (x = 0, m->width = 0; m->list[x]; ++x)
			if (strlen((char *)m->list[x]) > m->width)
				m->width = strlen((char *)m->list[x]);
@


1.15
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d19 1
d43 1
a43 1
				atr = INVERSE|FG_YELLOW;
d51 1
a51 1
				outatr(m->t->t, s + col, a + col, m->x + col, m->y+y, m->list[x + y*m->perline + m->top][z], atr);
d57 1
a57 1
				outatr(m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
d62 1
a62 1
				outatr(m->t->t, s + col, a + col, m->x + col, m->y+y, ' ', 0);
@


1.14
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d94 2
a95 2
			if (strlen(m->list[x]) > m->width)
				m->width = strlen(m->list[x]);
d318 1
a318 1
	"menu",
d331 1
a331 1
void ldmenu(MENU *m, char **s, int cursor)
d338 1
a338 1
MENU *mkmenu(W *w, char **s, int (*func) (/* ??? */), int (*abrt) (/* ??? */), int (*backs) (/* ??? */), int cursor, void *object, int *notify)
d366 1
a366 1
static char *cull(char *a, char *b)
d374 1
a374 1
char *mcomplete(MENU *m)
d376 1
a376 1
	char *com;
@


1.13
log
@Syntax highlighting baby steps.
@
text
@d34 1
d50 1
a50 1
				outatr(m->t->t, s + col, m->x + col, m->y+y, m->list[x + y*m->perline + m->top][z], atr);
d56 1
a56 1
				outatr(m->t->t, s + col, m->x + col, m->y+y, ' ', 0);
d61 1
a61 1
				outatr(m->t->t, s + col, m->x + col, m->y+y, ' ', 0);
d68 1
@


1.12
log
@Menus are now four lines instead of one.
@
text
@d41 1
a41 1
				atr = INVERSE;
@


1.11
log
@change 0 to NULL where we're talking about pointers
@
text
@d22 4
a25 1
	m->top = m->cursor - m->cursor % m->perline;
d32 1
d35 9
a43 11
	col = 0;
	for (x = 0; x != m->perline && m->list[x + m->top]; ++x) {
		int atr, z;

		if (x + m->top == m->cursor)
			atr = INVERSE;
		else
			atr = 0;
		if (col == m->w)
			break;
		for (z = 0; m->list[x + m->top][z]; ++z) {
d46 17
a62 13
			outatr(m->t->t, s + col, m->x + col, m->y, m->list[x + m->top][z], atr);
			++col;
		}
		while (z < m->width) {
			if (col == m->w)
				break;
			outatr(m->t->t, s + col, m->x + col, m->y, ' ', 0);
			++col;
			++z;
		}
		if (col != m->w) {
			outatr(m->t->t, s + col, m->x + col, m->y, ' ', 0);
			++col;
d64 3
d68 2
a69 4
	if (col != m->w)
		eraeol(m->t->t, m->x + col, m->y);
	m->parent->cury = 0;
	m->parent->curx = (m->cursor - m->top) * (m->width + 1);
d158 4
d164 20
d185 55
a239 3
	} else if (m->top + m->perline < m->nitems)
		return umeof(m);
	else
d241 2
d338 1
a338 1
	W *new = wcreate(w->t, &watommenu, w, w, w->main, 1, NULL, notify);
d358 1
@


1.10
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d239 2
a240 2
	0,
	0,
d259 1
a259 1
		return 0;
@


1.9
log
@include only headers which are needed
@
text
@a11 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d14 1
d223 1
a223 1
	free(m);
d262 1
a262 1
	new->object = (void *) (m = (MENU *) malloc(sizeof(MENU)));
@


1.8
log
@put struct definitions and other goodies into types.h
@
text
@d15 1
d17 1
a18 2
#include "vs.h"
#include "menu.h"
@


1.7
log
@use mkmenu(W *, ...) instead of mkmenu(BASE *, ...)
@
text
@d1 9
a9 8
/* Menu selection window
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
a10 10
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "config.h"
@


1.6
log
@version 2.9.7-pre3
@
text
@d262 1
a262 1
MENU *mkmenu(BASE *obw, char **s, int (*func) (/* ??? */), int (*abrt) (/* ??? */), int (*backs) (/* ??? */), int cursor, void *object, int *notify)
a263 1
	W *w = obw->parent;
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d31 1
a31 2
void menufllw(m)
MENU *m;
d36 1
a36 2
void menudisp(m)
MENU *m;
d76 1
a76 2
void menumove(m, x, y)
MENU *m;
d82 1
a82 2
void menuresz(m, wi, he)
MENU *m;
d88 1
a88 2
void mconfig(m)
MENU *m;
d105 1
a105 2
int umbol(m)
MENU *m;
d111 1
a111 2
int umbof(m)
MENU *m;
d117 1
a117 2
int umeof(m)
MENU *m;
d124 1
a124 2
int umeol(m)
MENU *m;
d133 1
a133 2
int umrtarw(m)
MENU *m;
d142 1
a142 2
int umltarw(m)
MENU *m;
d151 1
a151 2
int umuparw(m)
MENU *m;
d160 1
a160 2
int umdnarw(m)
MENU *m;
d171 1
a171 2
int umrtn(m)
MENU *m;
d180 1
a180 2
int umbacks(m)
MENU *m;
d188 1
a188 2
int umkey(m, c)
MENU *m;
d226 1
a226 2
static int menuabort(m)
MENU *m;
d255 1
a255 3
void ldmenu(m, s, cursor)
MENU *m;
char **s;
d262 1
a262 8
MENU *mkmenu(obw, s, func, abrt, backs, cursor, object, notify)
BASE *obw;
char **s;
int (*func) ();
int (*abrt) ();
int (*backs) ();
void *object;
int *notify;
d290 1
a290 2
char *cull(a, b)
char *a, *b;
d298 1
a298 2
char *mcomplete(m)
MENU *m;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d1 2
a2 3
/*
	Menu selection window
	Copyright (C) 1992 Joseph H. Allen
d4 14
a17 2
	This file is part of JOE (Joe's Own Editor)
*/
d20 4
a27 1
#include <string.h>
d31 3
a33 1
void menufllw (MENU *m) {
d37 3
a39 1
void menudisp (MENU *m) {
d47 4
a50 3
		if (x + m->top == m->cursor) {
			  atr = INVERSE;
		} else {
d52 1
a52 2
		}
		if (col == m->w) {
a53 1
		}
d55 1
a55 1
			if (col == m->w) {
d57 1
a57 2
		    	}
			outatr (m->t->t, s + col, m->x + col, m->y, m->list[x + m->top][z], atr);
d61 1
a61 1
			if (col == m->w) {
d63 1
a63 2
			}
			outatr (m->t->t, s + col, m->x + col, m->y, ' ', 0);
d68 2
a69 2
			outatr (m->t->t, s + col, m->x + col, m->y, ' ', 0);
			 ++col;
d72 2
a73 3
	if (col != m->w) {
		eraeol (m->t->t, m->x + col, m->y);
	}
d78 3
a80 1
void menumove (MENU *m, int x, int y) {
d85 3
a87 1
void menuresz (MENU *m, int wi, int he) {
d92 3
a94 1
void mconfig (MENU *m) {
d100 3
a102 5
		for (x = 0, m->width = 0; m->list[x]; ++x) {
			if (strlen (m->list[x]) > m->width) {
				m->width = strlen (m->list[x]);
			}
		}
d104 1
a104 1
		if (m->width > m->w) {
a105 1
		}
d110 3
a112 1
int umbol (MENU *m) {
d117 3
a119 1
int umbof (MENU *m) {
d124 4
a127 2
int umeof (MENU *m) {
	if (m->nitems) {
a128 1
	}
d132 4
a135 2
int umeol (MENU *m) {
	if (m->top + m->perline < m->nitems) {
d137 2
a138 3
	} else {
		umeof (m);
	}
d142 3
a144 1
int umrtarw (MENU *m) {
d148 1
a148 1
	} else {
a149 1
	}
d152 3
a154 1
int umltarw (MENU *m) {
d158 1
a158 1
	} else {
a159 1
	}
d162 3
a164 1
int umuparw (MENU *m) {
d168 1
a168 1
	} else {
a169 1
	}
d172 3
a174 1
int umdnarw (MENU *m) {
d176 5
a180 5
		  m->cursor += m->perline;
		  return 0;
	} else if (m->top + m->perline < m->nitems) {
		return umeof (m);
	} else {
a181 1
	}
d184 3
a186 1
int umrtn (MENU *m) {
d188 3
a190 3
	if (m->func) {
		return m->func (m, m->cursor, m->object, 0);
	} else {
a191 1
	}
d194 6
a199 4
int umbacks (MENU *m) {
	if (m->backs) {
		return m->backs (m, m->cursor, m->object);
	} else {
a200 1
	}
d203 3
a205 1
int umkey (MENU *m, int c) {
d210 3
a212 3
		if (m->func) {
			return m->func (m, m->cursor, m->object, -1);
		} else {
a213 1
		}
d216 3
a218 3
		if (m->func) {
			return m->func (m, m->cursor, m->object, 1);
		} else {
a219 1
		}
d222 2
a223 2
	for (x = 0; x != m->nitems; ++x) {
		if ((m->list[x][0] & 0x1F) == c) {
d225 1
a225 3
		}
	}
	if (!n) {
d227 2
a228 3
	}
	if (n == 1) {
		for (x = 0; x != m->nitems; ++x) {
d231 1
a231 1
				return umrtn (m);
a232 2
		}
	}
d235 1
a235 1
		if (m->cursor == m->nitems) {
a236 1
		}
d238 1
d242 3
a244 1
static int menuabort (MENU *m) {
d251 4
a254 4
	free (m);
	if (func) {
		return func (win->object, x, object);
	} else {
a255 1
	}
d258 12
a269 2
WATOM watommenu = { 
	"menu", menudisp, menufllw, menuabort, umrtn, umkey, menuresz, menumove, 0, 0, TYPEMENU
d272 4
a275 1
void ldmenu (MENU *m, char **s, int cursor) {
d278 1
a278 1
	mconfig (m);
d281 9
a289 1
MENU *mkmenu (BASE *obw, char **s, int (*func)(), int (*abrt)(), int (*backs)(), int cursor, void *object, int *notify) {
d291 1
a291 1
	W *new = wcreate (w->t, &watommenu, w, w, w->main, 1, NULL, notify);
d295 1
a295 1
		if (notify) {
a296 1
		}
d299 2
a300 2
	wfit (new->t);
	new->object = (void *) (m = (MENU *) malloc (sizeof (MENU)));
d311 1
a311 1
	ldmenu (m, s, cursor);
d316 3
a318 1
char *cull (char *a, char *b) {
d320 3
a322 2
	for (x = 0; a[x] && b[x] && a[x] == b[x]; ++x);
	return vstrunc (a, x);
d325 3
a327 1
char *mcomplete (MENU *m) {
d330 6
a335 7
	if (!m->nitems) {
		return vstrunc (NULL, 0);
	}
	com = vsncpy (NULL, 0, sz (m->list[0]));
	for (x = 1; x != m->nitems; ++x) {
		com = cull (com, m->list[x]);
	}
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* Menu selection window
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d17 272
a288 270
void menufllw(m)
MENU *m;
 {
 m->top=m->cursor-m->cursor%m->perline;
 }

void menudisp(m)
MENU *m;
 {
 int col;
 int x;
 int *s=m->t->t->scrn+m->x+m->y*m->t->t->co;
 col=0;
 for(x=0;x!=m->perline && m->list[x+m->top];++x)
  {
  int atr,z;
  if(x+m->top==m->cursor) atr=INVERSE;
  else atr=0;
  if(col==m->w) break;
  for(z=0;m->list[x+m->top][z];++z)
   {
   if(col==m->w) break;
   outatr(m->t->t, s+col, m->x+col, m->y, m->list[x+m->top][z], atr);
   ++col;
   }
  while(z<m->width)
   {
   if(col==m->w) break;
   outatr(m->t->t,s+col,m->x+col,m->y,' ',0);
   ++col; ++z;
   }
  if(col!=m->w)
   {
   outatr(m->t->t,s+col,m->x+col,m->y,' ',0);
   ++col;
   }
  }
 if(col!=m->w) eraeol(m->t->t,m->x+col,m->y);
 m->parent->cury=0;
 m->parent->curx=(m->cursor-m->top)*(m->width+1);
 }

void menumove(m,x,y)
MENU *m;
 {
 m->x=x;
 m->y=y;
 }

void menuresz(m,wi,he)
MENU *m;
 {
 m->w=wi;
 m->h=he;
 }

void mconfig(m)
MENU *m;
 {
 /* Configure menu display parameters */
 if(m->list)
  {
  int x;
  m->top=0;
  for(x=0,m->width=0;m->list[x];++x)
   if(strlen(m->list[x])>m->width) m->width=strlen(m->list[x]);
  m->nitems=x;
  if(m->width>m->w) m->width=m->w-1;
  m->perline=m->w/(m->width+1);
  }
 }

int umbol(m)
MENU *m;
 {
 m->cursor=m->top;
 return 0;
 }

int umbof(m)
MENU *m;
 {
 m->cursor=0;
 return 0;
 }

int umeof(m)
MENU *m;
 {
 if(m->nitems) m->cursor=m->nitems-1;
 return 0;
 }

int umeol(m)
MENU *m;
 {
 if(m->top+m->perline<m->nitems)
  m->cursor=m->top+m->perline-1;
 else umeof(m);
 return 0;
 }

int umrtarw(m)
MENU *m;
 {
 if(m->cursor+1<m->nitems) { ++m->cursor; return 0; }
 else return -1;
 }

int umltarw(m)
MENU *m;
 {
 if(m->cursor) { --m->cursor; return 0; }
 else return -1;
 }

int umuparw(m)
MENU *m;
 {
 if(m->cursor>=m->perline)
  {
  m->cursor-=m->perline;
  return 0;
  }
 else return -1;
 }

int umdnarw(m)
MENU *m;
 {
 if(m->cursor+m->perline<m->nitems)
  {
  m->cursor+=m->perline;
  return 0;
  }
 else
  if(m->top+m->perline<m->nitems) return umeof(m);
  else return -1;
 }

int umrtn(m)
MENU *m;
 {
 dostaupd=1;
 if(m->func) return m->func(m,m->cursor,m->object,0);
 else return -1;
 }

int umbacks(m)
MENU *m;
 {
 if(m->backs) return m->backs(m,m->cursor,m->object);
 else return -1;
 }

int umkey(m,c)
MENU *m;
 {
 int x;
 int n=0;
 if(c=='0')
  if(m->func) return m->func(m,m->cursor,m->object,-1);
  else return -1;
 if(c=='1')
  if(m->func) return m->func(m,m->cursor,m->object,1);
  else return -1;
 c&=0x1F;
 for(x=0;x!=m->nitems;++x) if((m->list[x][0]&0x1F)==c) ++n;
 if(!n) return -1;
 if(n==1)
  for(x=0;x!=m->nitems;++x)
   if((m->list[x][0]&0x1F)==c)
    {
    m->cursor=x;
    return umrtn(m);
    }
 do
  {
  ++m->cursor;
  if(m->cursor==m->nitems) m->cursor=0;
  } while((m->list[m->cursor][0]&0x1F)!=c);
 return -1;
 }

static int menuabort(m)
MENU *m;
 {
 W *w=m->parent;
 int (*func)()=m->abrt;
 void *object=m->object;
 int x=m->cursor;
 W *win=w->win;
 free(m);
 if(func) return func(win->object,x,object);
 else return -1;
 }

WATOM watommenu=
 {
 "menu",
 menudisp,
 menufllw,
 menuabort,
 umrtn,
 umkey,
 menuresz,
 menumove,
 0,
 0,
 TYPEMENU
 };

void ldmenu(m,s,cursor)
MENU *m;
char **s;
 {
 m->list=s;
 m->cursor=cursor;
 mconfig(m);
 }

MENU *mkmenu(obw,s,func,abrt,backs,cursor,object,notify)
BASE *obw;
char **s;
int (*func)();
int (*abrt)();
int (*backs)();
void *object;
int *notify;
 {
 W *w=obw->parent;
 W *new=wcreate(w->t,&watommenu,w,w,w->main,1,NULL,notify);
 MENU *m;
 if(!new)
  {
  if(notify) *notify=1;
  return 0;
  }
 wfit(new->t);
 new->object=(void *)(m=(MENU *)malloc(sizeof(MENU)));
 m->parent=new;
 m->func=func;
 m->abrt=abrt;
 m->backs=backs;
 m->object=object;
 m->t=w->t;
 m->h=new->h; m->w=new->w; m->x=new->x; m->y=new->y;
 ldmenu(m,s,cursor);
 w->t->curwin=new;
 return m;
 }

char *cull(a,b)
char *a, *b;
 {
 int x;
 for(x=0;a[x] && b[x] && a[x]==b[x];++x);
 return vstrunc(a,x);
 }

char *mcomplete(m)
MENU *m;
 {
 char *com;
 int x;
 if(!m->nitems) return vstrunc(NULL,0);
 com=vsncpy(NULL,0,sz(m->list[0]));
 for(x=1;x!=m->nitems;++x) com=cull(com,m->list[x]);
 return com;
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@a22 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d25 1
d94 1
a94 1
   if(zlen(m->list[x])>m->width) m->width=zlen(m->list[x]);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
