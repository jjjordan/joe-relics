head	1.91;
access;
symbols
	joe_3_5:1.81
	joe-3_4:1.75
	help:1.75
	joe_3_1:1.41
	joe_3_0:1.25
	joe_2_9_8:1.19
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.7
	joe_2_9_7_pre2:1.6
	joe_2_9_6:1.5
	joe_2_9_5:1.4
	joe_2_9_4:1.3
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.91
date	2008.11.02.04.05.09;	author jhallen;	state Exp;
branches;
next	1.90;

1.90
date	2008.10.29.02.06.05;	author jhallen;	state Exp;
branches;
next	1.89;

1.89
date	2008.10.28.22.55.41;	author jhallen;	state Exp;
branches;
next	1.88;

1.88
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.04.01.13.32;	author jhallen;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.31.20.51.39;	author jhallen;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.18.23.31.53;	author jhallen;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.07.02.29.49;	author jhallen;	state Exp;
branches;
next	1.78;

1.78
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.77;

1.77
date	2006.06.01.17.44.40;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.01.03.08.20;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.24.16.04.14;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.21.18.03.34;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.01.00.40.35;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.28.23.51.28;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.24.04.30.49;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.21.20.40.13;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.21.19.51.08;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.02.06.47.51;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.30.04.40.47;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.30.00.39.17;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.29.06.26.54;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2005.03.26.05.47.31;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.22.03.22.37;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.21.18.16.49;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.20.03.31.25;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.18.21.52.33;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.17.23.54.46;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.16.23.19.28;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.16.16.18.42;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.16.00.00.55;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.14.16.35.54;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.14.03.21.35;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.14.00.23.08;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.14.00.07.49;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.05.05.06.18;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.05.03.53.17;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.02.03.31.35;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.27.05.29.32;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.21.14.47.36;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.29.04.49.43;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.26.22.20.09;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.15.02.01.14;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.14.07.30.39;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.14.04.23.04;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.13.00.23.45;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.12.02.06.37;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.11.20.02.50;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.11.14.14.04;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.08.04.42.41;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.07.00.48.43;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.06.19.20.28;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.06.18.32.49;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.06.16.23.12;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.16.35.11;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.23.02.14.07;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.20.14.45.53;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.17.13.13.15;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.21.04.43.49;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.09.50.55;	author vsamel;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.24.09.18.09;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.38.57;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.20.07.18.19;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.12.49;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.15.09.23.55;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.33;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.55.00;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.34;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.34;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Coroutine version of menus with macros
@
text
@/*
 *	Command execution
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int joe_beep = 0;

/* Command table */

int ubeep(BW *bw, int k)
{
	ttputc(7);
	return 0;
}

CMD cmds[] = {
	{USTR "abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL},
	{USTR "abortbuf", TYPETW, uabortbuf, NULL, 0, NULL},
	{USTR "arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL},
	{USTR "ask", TYPETW + TYPEPW, uask, NULL, 0, NULL},
	{USTR "uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
	{USTR "backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, USTR "delch"},
	{USTR "backsmenu", TYPEMENU, umbacks, NULL, 1, NULL},
	{USTR "backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, USTR "delw"},
	{USTR "beep", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ubeep, NULL, 0, NULL},
	{USTR "begin_marking", TYPETW + TYPEPW, ubegin_marking, NULL, 0, NULL},
	{USTR "bknd", TYPETW, ubknd, NULL, 0, NULL},
	{USTR "bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, USTR "fwrdc"},
	{USTR "blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkcpy, NULL, 1, NULL},
	{USTR "blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD + EBLOCK, ublkdel, NULL, 0, NULL},
	{USTR "blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkmove, NULL, 0, NULL},
	{USTR "blksave", TYPETW + TYPEPW + EBLOCK, ublksave, NULL, 0, NULL},
	{USTR "bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL},
	{USTR "bofmenu", TYPEMENU, umbof, NULL, 0, NULL},
	{USTR "bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL},
	{USTR "bolmenu", TYPEMENU, umbol, NULL, 0, NULL},
	{USTR "bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, USTR "eop"},
	{USTR "bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL},
	{USTR "bufed", TYPETW, ubufed, NULL, 0, NULL},
	{USTR "build", TYPETW + TYPEPW, ubuild, NULL, 0, NULL},
	{USTR "byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL},
	{USTR "cancel", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ucancel, NULL, 0, NULL},
	{USTR "center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL},
	{USTR "charset", TYPETW + TYPEPW, ucharset, NULL, 0, NULL}, 
	{USTR "ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
	{USTR "col", TYPETW + TYPEPW, ucol, NULL, 0, NULL},
	{USTR "complete", TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
	{USTR "copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL},
	{USTR "crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, USTR "crawlr"},
	{USTR "crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, USTR "crawll"},
	{USTR "defmdown", TYPETW+TYPEPW+TYPEQW+TYPEMENU, udefmdown, 0, 0, 0 },
	{USTR "defmup", TYPETW+TYPEPW, udefmup, 0, 0, 0 },
	{USTR "defmdrag", TYPETW+TYPEPW, udefmdrag, 0, 0, 0 },
	{USTR "defm2down", TYPETW+TYPEPW+TYPEMENU, udefm2down, 0, 0, 0 },
	{USTR "defm2up", TYPETW+TYPEPW, udefm2up, 0, 0, 0 },
	{USTR "defm2drag", TYPETW+TYPEPW, udefm2drag, 0, 0, 0 },
	{USTR "defm3down", TYPETW+TYPEPW, udefm3down, 0, 0, 0 },
	{USTR "defm3up", TYPETW+TYPEPW, udefm3up, 0, 0, 0 },
	{USTR "defm3drag", TYPETW+TYPEPW, udefm3drag, 0, 0, 0 },
	{USTR "delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, USTR "deleol"},
	{USTR "delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, USTR "backs"},
	{USTR "deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, USTR "delbol"}, 
	{USTR "dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL}, 
	{USTR "delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, USTR "backw"},
	{USTR "dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, USTR "uparw"},
	{USTR "dnarwmenu", TYPEMENU, umdnarw, NULL, 1, USTR "uparwmenu"}, 
	{USTR "dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, USTR "upslide"},
	{USTR "dnslidemenu", TYPEMENU, umscrdn, NULL, 1, USTR "upslidemenu"},
	{USTR "drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL},
	{USTR "dupw", TYPETW, uduptw, NULL, 0, NULL},
	{USTR "edit", TYPETW, uedit, NULL, 0, NULL},
	{USTR "else", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelse, 0, 0, 0 },
	{USTR "elsif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelsif, 0, 0, 0 },
	{USTR "endif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uendif, 0, 0, 0 },
	{USTR "eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL},
	{USTR "eofmenu", TYPEMENU, umeof, NULL, 0, NULL},
	{USTR "eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL},
	{USTR "eolmenu", TYPEMENU, umeol, NULL, 0, NULL},
	{USTR "eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, USTR "bop"},
	{USTR "execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL},
	{USTR "explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL},
	{USTR "exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL},
	{USTR "ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL},
	{USTR "filt", TYPETW + TYPEPW + EMOD + EBLOCK, ufilt, NULL, 0, NULL},
	{USTR "finish", TYPETW + TYPEPW + EMOD, ufinish, NULL, 1, NULL},
	{USTR "fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL},
	{USTR "format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL},
	{USTR "fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL},
	{USTR "fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, USTR "bkwdc"},
	{USTR "gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL},
	{USTR "grep", TYPETW, ugrep, NULL, 0, NULL},
	{USTR "groww", TYPETW+TYPEPW, ugroww, NULL, 1, USTR "shrinkw"},
	{USTR "if", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uif, 0, 0, 0 },
	{USTR "isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{USTR "jump", TYPETW, ujump, NULL, 0, NULL },
	{USTR "killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL},
	{USTR "killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
	{USTR "help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL},
	{USTR "home", TYPETW + TYPEPW + EFIXXCOL, uhome, NULL, 0, NULL},
	{USTR "hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
	{USTR "hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL},
	{USTR "insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, USTR "delch"},
	{USTR "keymap", TYPETW, ukeymap, 0, 0, 0 },    /* JM */
	{USTR "insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL}, 
	{USTR "language", TYPETW + TYPEPW, ulanguage, NULL, 0, NULL}, 
	{USTR "lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ulindent, NULL, 1, USTR "rindent"},
	{USTR "line", TYPETW + TYPEPW, uline, NULL, 0, NULL},
	{USTR "lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL}, 
	{USTR "lower", TYPETW + TYPEPW + EMOD + EBLOCK, ulower, NULL, 0, NULL},
	{USTR "ltarw", TYPETW + TYPEPW /* + EFIXXCOL + ECHKXCOL */, u_goto_left, NULL, 1, USTR "rtarw"},
	{USTR "ltarwmenu", TYPEMENU, umltarw, NULL, 1, USTR "rtarwmenu"},
	{USTR "macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL},
	{USTR "debug_joe", TYPETW + EFIXXCOL, udebug_joe, NULL, 0, NULL},
	{USTR "markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL},
	{USTR "markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL},
	{USTR "markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL},
	{USTR "math", TYPETW + TYPEPW, umath, NULL, 0, NULL},
	{USTR "menu", TYPETW + TYPEPW + TYPEQW, umenu, NULL, 0, NULL},
	{USTR "mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL},
	{USTR "msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL},
	{USTR "mfit", TYPETW, umfit, NULL, 0, NULL},
	{USTR "mwind", TYPETW, umwind, NULL, 0, NULL},
	{USTR "name", TYPETW + TYPEPW, uname_joe, NULL, 0, NULL}, 
	{USTR "nbuf", TYPETW, unbuf, NULL, 1, USTR "pbuf"},
	{USTR "nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, USTR "pedge"}, 
	{USTR "nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, USTR "prevpos"}, 
	{USTR "nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, USTR "prevw"},
	{USTR "nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, USTR "prevword"},
	{USTR "nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL},
	{USTR "notmod", TYPETW, unotmod, NULL, 0, NULL},
	{USTR "nxterr", TYPETW, unxterr, NULL, 1, USTR "prverr"},
	{USTR "open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, USTR "deleol"},
	{USTR "parserr", TYPETW, uparserr, NULL, 0, NULL},
	{USTR "paste", TYPETW + TYPEPW + EMOD, upaste, NULL, 0, NULL },
	{USTR "pbuf", TYPETW, upbuf, NULL, 1, USTR "nbuf"},
	{USTR "pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, USTR "nedge"}, 
	{USTR "pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, USTR "pgup"},
	{USTR "pgdnmenu", TYPEMENU, umpgdn, NULL, 1, USTR "pgupmenu"}, 
	{USTR "pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, USTR "pgdn"},
	{USTR "pgupmenu", TYPEMENU, umpgup, NULL, 1, USTR "pgdnmenu"}, 
	{USTR "picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL},
	{USTR "play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */ 
	{USTR "prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, USTR "nextpos"}, 
	{USTR "prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, USTR "nextw"}, 
	{USTR "prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, USTR "nextword"},
	{USTR "prverr", TYPETW, uprverr, NULL, 1, USTR "nxterr"},
	{USTR "psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL},
	{USTR "pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
	{USTR "qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL},
	{USTR "query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL},
	{USTR "querysave", TYPETW, uquerysave, NULL, 0, NULL},
	{USTR "quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL},
	{USTR "quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL},
	{USTR "record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL},
	{USTR "redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, USTR "undo"},
	{USTR "reload", TYPETW, ureload, NULL, 0, NULL },
	{USTR "reloadall", TYPETW, ureload_all, NULL, 0, NULL },
	{USTR "retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL},
	{USTR "rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL}, 
	{USTR "rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, urindent, NULL, 1, USTR "lindent"},
	{USTR "run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
	{USTR "rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL},
	{USTR "rtarw", TYPETW + TYPEPW /* + EFIXXCOL */, u_goto_right, NULL, 1, USTR "ltarw"}, /* EFIX removed for picture mode */
	{USTR "rtarwmenu", TYPEMENU, umrtarw, NULL, 1, USTR "ltarwmenu"},
	{USTR "rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL},
	{USTR "save", TYPETW + TYPEPW, usave, NULL, 0, NULL},
	{USTR "savenow", TYPETW + TYPEPW, usavenow, NULL, 0, NULL},
	{USTR "scratch", TYPETW + TYPEPW, uscratch, NULL, 0, NULL},
	{USTR "select", TYPETW + TYPEPW, uselect, NULL, 0, NULL},
	{USTR "setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL},
	{USTR "shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL},
	{USTR "showerr", TYPETW + TYPEPW, ucurrent_msg, NULL, 0, NULL},
	{USTR "shrinkw", TYPETW, ushrnk, NULL, 1, USTR "groww"},
	{USTR "splitw", TYPETW, usplitw, NULL, 0, NULL},
	{USTR "stat", TYPETW + TYPEPW, ustat, NULL, 0, NULL},
	{USTR "stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL},
	{USTR "swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL},
	{USTR "switch", TYPETW + TYPEPW, uswitch, NULL, 0, NULL},
	{USTR "sys", TYPETW + TYPEPW, usys, NULL, 0, NULL },
	{USTR "tabmenu", TYPEMENU, umtab, NULL, 1, USTR "ltarwmenu"},
	{USTR "tag", TYPETW + TYPEPW, utag, NULL, 0, NULL},
	{USTR "toggle_marking", TYPETW + TYPEPW, utoggle_marking, NULL, 0, NULL},
	{USTR "then", TYPEPW+EMOD, urtn, 0, 0, 0 },
	{USTR "tomarkb", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkb, NULL, 0, NULL},
	{USTR "tomarkbk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkbk, NULL, 0, NULL},
	{USTR "tomarkk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkk, NULL, 0, NULL},
	{USTR "tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL},
	{USTR "tomouse", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utomouse, 0, 0, 0 },
	{USTR "tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL},
	{USTR "tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL},
	{USTR "tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL},
	{USTR "txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL}, 
	{USTR "type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, USTR "backs"},
	{USTR "undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, USTR "redo"},
	{USTR "uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, USTR "dnarw"},
	{USTR "uparwmenu", TYPEMENU, umuparw, NULL, 1, USTR "dnarwmenu"}, 
	{USTR "upper", TYPETW + TYPEPW + EMOD + EBLOCK, uupper, NULL, 0, NULL},
	{USTR "upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, USTR "dnslide"},
	{USTR "upslidemenu", TYPEMENU, umscrup, NULL, 1, USTR "dnslidemenu"},
	{USTR "xtmouse", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uxtmouse, 0, 0, 0 },
	{USTR "yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL},
	{USTR "yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL},
	{USTR "yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL}
};

/* Steal Lock dialog */

int nolocks;

#define LOCKMSG2 _("Could not create lock. (I) edit anyway, (Q) cancel edit? ")
#define LOCKMSG1 _("Locked by %s. (S)teal lock, (I) edit anyway, (Q) cancel edit? ")

unsigned char *steallock_key= (unsigned char *) _("|steal the lock|sS");
unsigned char *canceledit_key= (unsigned char *) _("|cancel edit due to lock|qQ");
unsigned char *ignorelock_key= (unsigned char *) _("|ignore lock, continue with edit|iI");

/* Try to lock: start dialog if we can't.  Returns 0 if we couldn't lock */

int try_lock(BW *bw,B *b)
{
	/* First time we modify the file */
	/* If we're a plain file, acquire lock */
	if (!nolocks && plain_file(b)) {
		unsigned char bf1[256];
		unsigned char bf[300];
		int x;
		/* It's a plain file- try to lock it */
		while (lock_it(b->name,bf1)) {
			int c;
			for(x=0;bf1[x] && bf1[x]!=':';++x);
			bf1[x]=0;
			if(bf1[0])
				joe_snprintf_1(bf,sizeof(bf),joe_gettext(LOCKMSG1),bf1);
			else
				joe_snprintf_0(bf,sizeof(bf),joe_gettext(LOCKMSG2));
			c = query(bw->parent, sz(bf), QW_NOMACRO); /* This should not take input from macro */
			if (c == -1)
				return 0;
			else if (yncheck(steallock_key, c)) {
				unlock_it(b->name);
			} else if (yncheck(ignorelock_key, c)) {
				b->locked = 1;
				b->ignored_lock = 1;
				return 1;
			} else if (yncheck(canceledit_key, c)) {
				return 0;
			}
		}
		/* Remember to unlock it */
		b->locked = 1;
	}
	return 1;
}

/* Called when we are about to modify a buffer */
/* Returns 0 if we're not allowed to modify buffer */

#define CHECK_INTERVAL 15
int nomodcheck;

int modify_logic(BW *bw,B *b)
{
	if (last_time > b->check_time + CHECK_INTERVAL) {
		b->check_time = last_time;
		if (!nomodcheck && !b->gave_notice && check_mod(b)) {
			int c = query(bw->parent, sz(joe_gettext(_("Notice: File on disk changed! (hit ^C to continue)  "))), QW_NOMACRO); /* Should not take macro input */
			if (c != -1)
				b->gave_notice = 1;
			return 0;
		}
	}

	if (b != bw->b) {
		if (!b->didfirst) {
			/* This happens when we try to block move from a window
			   which is not on the screen */
			if (bw->o.mfirst) {
				msgnw(bw->parent,joe_gettext(_("Modify other window first for macro")));
				return 0;
			}
			b->didfirst = 1;
			if (bw->o.mfirst)
				exmacro(bw->o.mfirst,1);
		}
		if (b->rdonly) {
			msgnw(bw->parent,joe_gettext(_("Other buffer is read only")));
			if (joe_beep)
				ttputc(7);
			return 0;
		} else if (!b->changed && !b->locked) {
			if (!try_lock(bw,b))
				return 0;
		}
	} else {
		if (!b->didfirst) {
			b->didfirst = 1;
			if (bw->o.mfirst)
				exmacro(bw->o.mfirst,1);
		}
		if (b->rdonly) {
			msgnw(bw->parent,joe_gettext(_("Read only")));
			if (joe_beep)
				ttputc(7);
			return 0;
		} else if (!b->changed && !b->locked) {
			if (!try_lock(bw,b))
				return 0;
		}
	}
	return 1;
}

/* Execute a command n with key k */

typedef int(cmd_func_t)(void *obj, int);

int call_cmd(va_list args)
{
	unsigned char *gc;
	int rtn;
	cmd_func_t *func;
	void *obj;
	int k;
	func = va_arg(args, cmd_func_t *);
	obj = va_arg(args, void *);
	k = va_arg(args, int);

	gc = vsmk(1);
	rtn = func(obj, k);
	obj_free(gc);

	return rtn;
}

int execmd(CMD *cmd, int k)
{
	BW *bw = (BW *) maint->curwin->object;
	int ret = -1;

	/* Warning: bw is a BW * only if maint->curwin->watom->what &
	    (TYPETW|TYPEPW) */

	/* Send data to shell window: this is broken ^K ^H (help) sends its ^H to shell */
	if ((maint->curwin->watom->what & TYPETW) && bw->b->pid && piseof(bw->cursor) &&
	(k==3 || k==9 || k==13 || k==8 || k==127 || k==4 || (cmd->func==utype && k>=32 && k<256))) {
		unsigned char c = k;
		joe_write(bw->b->out, &c, 1);
		return 0;
	}

	if (cmd->m) {
		ret = exmacro(cmd->m, 0);
		return ret;
	}

	/* We don't execute if we have to fix the column position first
	 * (i.e., left arrow when cursor is in middle of nowhere) */
	if (cmd->flag & ECHKXCOL) {
		if (bw->o.hex)
			bw->cursor->xcol = piscol(bw->cursor);
		else if (bw->cursor->xcol != piscol(bw->cursor))
			goto skip;
	}

	/* Don't execute command if we're in wrong type of window */
	if (!(cmd->flag & maint->curwin->watom->what))
		goto skip;

	/* Complete selection for block commands */
	if ((cmd->flag & EBLOCK) && nowmarking)
		utoggle_marking(maint->curwin->object);

	/* We are about to modify the file */
	if ((maint->curwin->watom->what & TYPETW) && (cmd->flag & EMOD)) {
		if (!modify_logic(bw,bw->b))
			goto skip;
	}

	/* Execute command */
	ret = co_call(call_cmd, cmd->func, maint->curwin->object, k);
	/* ret = cmd->func(maint->curwin->object, k); */

	if (smode)
		--smode;

	/* Don't update anything if we're going to leave */
	if (leave) {
		return 0;
	}

	/* cmd->func could have changed bw on us */
	/* This is bad: maint->curwin might not be the same window */
	/* Safer would be to attach a pointer to curwin- if curwin
	   gets clobbered, so does pointer. */
	bw = (BW *) maint->curwin->object;

	/* Maintain position history */
	/* If command was not a positioning command */
	if (!(cmd->flag & EPOS)
	    && (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		afterpos();

	/* If command was not a movement */
	if (!(cmd->flag & (EMOVE | EPOS)) && (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		aftermove(maint->curwin, bw->cursor);

	if (cmd->flag & EKILL)
		justkilled = 1;
	else
		justkilled = 0;

      skip:

	/* Make dislayed cursor column equal the actual cursor column
	 * for commands which arn't simple vertical movements */
	if (cmd->flag & EFIXXCOL)
		bw->cursor->xcol = piscol(bw->cursor);

	/* Recenter cursor to middle of screen */
	if (cmd->flag & EMID) {
		int omid = mid;

		mid = 1;
		dofollows();
		mid = omid;
	}

	if (joe_beep && ret)
		ttputc(7);
	return ret;
}

void do_auto_scroll()
{
	static CMD *scrup = 0;
	static CMD *scrdn = 0;
	static CMD *drag = 0;
	if (!scrup) {
		scrup = findcmd(USTR "upslide");
		scrdn = findcmd(USTR "dnslide");
		drag = findcmd(USTR "defmdrag");
	}
	if (auto_scroll > 0)
		execmd(scrdn,0);
	else if (auto_scroll < 0)
		execmd(scrup,0);

	execmd(drag,0);
		
	reset_trig_time();
}

/* Return command table index for given command name */

HASH *cmdhash = NULL;

static void izcmds(void)
{
	int x;

	cmdhash = htmk(256);
	for (x = 0; x != sizeof(cmds) / sizeof(CMD); ++x)
		htadd(cmdhash, cmds[x].name, cmds + x);
}

CMD *findcmd(unsigned char *s)
{
	if (!cmdhash)
		izcmds();
	return (CMD *) htfind(cmdhash, s);
}

void addcmd(unsigned char *s, MACRO *m)
{
	CMD *cmd = (CMD *) joe_malloc(sizeof(CMD));

	if (!cmdhash)
		izcmds();
	cmd->name = zdup(s);
	cmd->flag = 0;
	cmd->func = NULL;
	cmd->m = m;
	cmd->arg = 1;
	cmd->negarg = NULL;
	htadd(cmdhash, cmd->name, cmd);
}

static unsigned char **getcmds(void)
{
	unsigned char **s = vaensure(NULL, sizeof(cmds) / sizeof(CMD));
	int x;
	HENTRY *e;

	for (x = 0; x != cmdhash->len; ++x)
		for (e = cmdhash->tab[x]; e; e = e->next)
			s = vaadd(s, vsncpy(NULL, 0, sz(e->name)));
	vasort(av(s));
	return s;
}

/* Command line */

unsigned char **scmds = NULL;	/* Array of command names */

static int cmdcmplt(BW *bw)
{
	if (!scmds) {
		scmds = getcmds();
		vaperm(scmds);
	}
	return simple_cmplt(bw,scmds);
}

B *cmdhist = NULL;

int uexecmd(BW *bw)
{
	MACRO *mac;
	int ret = -1;
	unsigned char *s = ask(bw->parent, joe_gettext(USTR _("Command: ")),
	&cmdhist, USTR _("cmd"), cmdcmplt, locale_map, 0, 0, NULL);

	if (s) {
		mac = mparse(NULL, s, &ret);
		if (ret < 0 || !mac) {
			msgnw(bw->parent, joe_gettext(_("No such command")));
		} else {
			ret = exmacro(mac, 1);
			rmmacro(mac);
		}
	}

	return ret;
}
@


1.90
log
@Add reloadall command.
@
text
@d122 1
@


1.89
log
@Add reload command
@
text
@d160 1
@


1.88
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d159 1
@


1.87
log
@More work on coroutine refactoring.
@
text
@d234 1
a234 1
				joe_snprintf_1(bf,sizeof(bf),LOCKMSG1,bf1);
d236 1
a236 1
				joe_snprintf_0(bf,sizeof(bf),LOCKMSG2);
d316 2
d322 1
a322 1
	int (*func)(void *obj, int k);
d325 1
a325 1
	func = va_arg(args, int (*)(void *obj, int));
@


1.86
log
@more work on coroutine refactor
prompt window experiment
@
text
@d237 1
a237 1
			c = query(bw->parent, sz(bf), 0); /* This should not take input from macro */
d267 1
a267 1
			int c = query(bw->parent, sz(joe_gettext(_("Notice: File on disk changed! (hit ^C to continue)  "))), 0); /* Should not take macro input */
@


1.85
log
@more refactoring
@
text
@d96 1
a96 1
	{USTR "groww", TYPETW, ugroww, NULL, 1, USTR "shrinkw"},
a217 54
int steal_lock(BW *bw,int c,B *b,int *notify)
{
	if (yncheck(steallock_key, c)) {
		unsigned char bf1[256];
		unsigned char *bf = 0;
		unlock_it(b->name);
		if (lock_it(b->name,bf1)) {
			int x;
			for(x=0;bf1[x] && bf1[x]!=':';++x);
			bf1[x]=0;
			if(bf1[0])
				bf = vsfmt(bf, 0, joe_gettext(LOCKMSG1),bf1);
			else
				bf = vsfmt(bf, 0, joe_gettext(LOCKMSG2));
			if (mkqw(bw->parent, sv(bf), steal_lock, NULL, b, notify)) {
				return 0;
			} else {
				if (notify)
					*notify = -1;
				return -1;
			}
		} else {
			b->locked=1;
			if (notify)
				*notify = 1;
			return 0;
		}
	} else if (yncheck(ignorelock_key, c)) {
		b->locked=1;
		b->ignored_lock=1;
		if (notify)
			*notify = 1;
		return 0;
	} else if (yncheck(canceledit_key, c)) {
		if (notify)
			*notify = 1;
		return 0;
	} else {
		if (mkqw(bw->parent, sz(joe_gettext(LOCKMSG2)), steal_lock, NULL, b, notify)) {
			return 0;
		} else
			return -1;
	}
}

int file_changed(BW *bw,int c,B *b,int *notify)
{
	if (mkqw(bw->parent, sz(joe_gettext(_("Notice: File on disk changed! (hit ^C to continue)  "))), file_changed, NULL, b, notify)) {
		b->gave_notice = 1;
		return 0;
	} else
		return -1;
}

d229 2
a230 1
		if (lock_it(b->name,bf1)) {
d237 2
a238 5
			if (mkqw(bw->parent, sz(bf), steal_lock, NULL, b, NULL)) {
				uquery(bw); /* Don't accept macro input for this... */
				if (!b->locked)
					return 0;
			} else
d240 9
a248 3
		} else {
			/* Remember to unlock it */
			b->locked = 1;
d250 2
d267 3
a269 1
			file_changed(bw,0,b,NULL);
@


1.84
log
@fix tags.
switch more wmkpw to ask
@
text
@d291 1
a291 1
				uquery(bw);
d566 1
a566 1
	&cmdhist, USTR _("cmd"), cmdcmplt, NULL, locale_map, 0, 0, NULL);
@


1.83
log
@coroutines
@
text
@d559 3
a561 1
static int docmd(BW *bw, unsigned char *s, void *object, int *notify)
d565 2
d568 8
a575 6
	mac = mparse(NULL, s, &ret);
	if (ret < 0) {
		msgnw(bw->parent,joe_gettext(_("No such command")));
	} else {
		ret = exmacro(mac, 1);
		rmmacro(mac);
a577 2
	if (notify)
		*notify = 1;
a579 11

B *cmdhist = NULL;

int uexecmd(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(USTR _("Command: ")), &cmdhist, docmd, USTR "cmd", NULL, cmdcmplt, NULL, NULL, locale_map, 0)) {
		return 0;
	} else {
		return -1;
	}
}
@


1.82
log
@semiautomatic variables
@
text
@d362 18
a382 1
	unsigned char *gc = vsmk(1); /* Garbage collection point */
a392 1
		obj_free(gc);
a397 1
		obj_free(gc);
d425 2
a426 1
	ret = cmd->func(maint->curwin->object, k);
a432 1
		obj_free(gc);
a474 1
	obj_free(gc);
@


1.81
log
@UC -> USTR
@
text
@d222 1
a222 1
		unsigned char bf[300];
d229 1
a229 1
				joe_snprintf_1(bf,sizeof(bf),joe_gettext(LOCKMSG1),bf1);
d231 2
a232 2
				joe_snprintf_0(bf,sizeof(bf),joe_gettext(LOCKMSG2));
			if (mkqw(bw->parent, sz(bf), steal_lock, NULL, b, notify)) {
d365 1
d376 1
d380 5
a384 2
	if (cmd->m)
		return exmacro(cmd->m, 0);
d416 2
a417 1
	if (leave)
d419 1
d460 1
d528 1
a528 1
	vasort(s, aLen(s));
d538 1
a538 1
	if (!scmds)
d540 2
a557 12
#ifdef junk
	CMD *cmd = findcmd(s);
	vsrm(s);	/* allocated in pw.c::rtnpw() */
	if (!cmd)
		msgnw(bw->parent,joe_gettext(_("No such command")));
	else {
		mac = mkmacro(-1, 0, 0, cmd);
		ret = exmacro(mac, 1);
		rmmacro(mac);
	}
#endif

@


1.80
log
@change US to UC
@
text
@d21 184
a204 184
	{UC "abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL},
	{UC "abortbuf", TYPETW, uabortbuf, NULL, 0, NULL},
	{UC "arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL},
	{UC "ask", TYPETW + TYPEPW, uask, NULL, 0, NULL},
	{UC "uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
	{UC "backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, UC "delch"},
	{UC "backsmenu", TYPEMENU, umbacks, NULL, 1, NULL},
	{UC "backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, UC "delw"},
	{UC "beep", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ubeep, NULL, 0, NULL},
	{UC "begin_marking", TYPETW + TYPEPW, ubegin_marking, NULL, 0, NULL},
	{UC "bknd", TYPETW, ubknd, NULL, 0, NULL},
	{UC "bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, UC "fwrdc"},
	{UC "blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkcpy, NULL, 1, NULL},
	{UC "blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD + EBLOCK, ublkdel, NULL, 0, NULL},
	{UC "blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkmove, NULL, 0, NULL},
	{UC "blksave", TYPETW + TYPEPW + EBLOCK, ublksave, NULL, 0, NULL},
	{UC "bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL},
	{UC "bofmenu", TYPEMENU, umbof, NULL, 0, NULL},
	{UC "bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL},
	{UC "bolmenu", TYPEMENU, umbol, NULL, 0, NULL},
	{UC "bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, UC "eop"},
	{UC "bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL},
	{UC "bufed", TYPETW, ubufed, NULL, 0, NULL},
	{UC "build", TYPETW + TYPEPW, ubuild, NULL, 0, NULL},
	{UC "byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL},
	{UC "cancel", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ucancel, NULL, 0, NULL},
	{UC "center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL},
	{UC "charset", TYPETW + TYPEPW, ucharset, NULL, 0, NULL}, 
	{UC "ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
	{UC "col", TYPETW + TYPEPW, ucol, NULL, 0, NULL},
	{UC "complete", TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
	{UC "copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL},
	{UC "crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, UC "crawlr"},
	{UC "crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, UC "crawll"},
	{UC "defmdown", TYPETW+TYPEPW+TYPEQW+TYPEMENU, udefmdown, 0, 0, 0 },
	{UC "defmup", TYPETW+TYPEPW, udefmup, 0, 0, 0 },
	{UC "defmdrag", TYPETW+TYPEPW, udefmdrag, 0, 0, 0 },
	{UC "defm2down", TYPETW+TYPEPW+TYPEMENU, udefm2down, 0, 0, 0 },
	{UC "defm2up", TYPETW+TYPEPW, udefm2up, 0, 0, 0 },
	{UC "defm2drag", TYPETW+TYPEPW, udefm2drag, 0, 0, 0 },
	{UC "defm3down", TYPETW+TYPEPW, udefm3down, 0, 0, 0 },
	{UC "defm3up", TYPETW+TYPEPW, udefm3up, 0, 0, 0 },
	{UC "defm3drag", TYPETW+TYPEPW, udefm3drag, 0, 0, 0 },
	{UC "delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, UC "deleol"},
	{UC "delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, UC "backs"},
	{UC "deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, UC "delbol"}, 
	{UC "dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL}, 
	{UC "delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, UC "backw"},
	{UC "dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, UC "uparw"},
	{UC "dnarwmenu", TYPEMENU, umdnarw, NULL, 1, UC "uparwmenu"}, 
	{UC "dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, UC "upslide"},
	{UC "dnslidemenu", TYPEMENU, umscrdn, NULL, 1, UC "upslidemenu"},
	{UC "drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL},
	{UC "dupw", TYPETW, uduptw, NULL, 0, NULL},
	{UC "edit", TYPETW, uedit, NULL, 0, NULL},
	{UC "else", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelse, 0, 0, 0 },
	{UC "elsif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelsif, 0, 0, 0 },
	{UC "endif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uendif, 0, 0, 0 },
	{UC "eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL},
	{UC "eofmenu", TYPEMENU, umeof, NULL, 0, NULL},
	{UC "eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL},
	{UC "eolmenu", TYPEMENU, umeol, NULL, 0, NULL},
	{UC "eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, UC "bop"},
	{UC "execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL},
	{UC "explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL},
	{UC "exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL},
	{UC "ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL},
	{UC "filt", TYPETW + TYPEPW + EMOD + EBLOCK, ufilt, NULL, 0, NULL},
	{UC "finish", TYPETW + TYPEPW + EMOD, ufinish, NULL, 1, NULL},
	{UC "fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL},
	{UC "format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL},
	{UC "fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL},
	{UC "fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, UC "bkwdc"},
	{UC "gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL},
	{UC "grep", TYPETW, ugrep, NULL, 0, NULL},
	{UC "groww", TYPETW, ugroww, NULL, 1, UC "shrinkw"},
	{UC "if", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uif, 0, 0, 0 },
	{UC "isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{UC "jump", TYPETW, ujump, NULL, 0, NULL },
	{UC "killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL},
	{UC "killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
	{UC "help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL},
	{UC "home", TYPETW + TYPEPW + EFIXXCOL, uhome, NULL, 0, NULL},
	{UC "hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
	{UC "hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL},
	{UC "insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, UC "delch"},
	{UC "keymap", TYPETW, ukeymap, 0, 0, 0 },    /* JM */
	{UC "insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL}, 
	{UC "language", TYPETW + TYPEPW, ulanguage, NULL, 0, NULL}, 
	{UC "lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ulindent, NULL, 1, UC "rindent"},
	{UC "line", TYPETW + TYPEPW, uline, NULL, 0, NULL},
	{UC "lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL}, 
	{UC "lower", TYPETW + TYPEPW + EMOD + EBLOCK, ulower, NULL, 0, NULL},
	{UC "ltarw", TYPETW + TYPEPW /* + EFIXXCOL + ECHKXCOL */, u_goto_left, NULL, 1, UC "rtarw"},
	{UC "ltarwmenu", TYPEMENU, umltarw, NULL, 1, UC "rtarwmenu"},
	{UC "macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL},
	{UC "debug_joe", TYPETW + EFIXXCOL, udebug_joe, NULL, 0, NULL},
	{UC "markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL},
	{UC "markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL},
	{UC "markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL},
	{UC "math", TYPETW + TYPEPW, umath, NULL, 0, NULL},
	{UC "mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL},
	{UC "msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL},
	{UC "mfit", TYPETW, umfit, NULL, 0, NULL},
	{UC "mwind", TYPETW, umwind, NULL, 0, NULL},
	{UC "name", TYPETW + TYPEPW, uname_joe, NULL, 0, NULL}, 
	{UC "nbuf", TYPETW, unbuf, NULL, 1, UC "pbuf"},
	{UC "nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, UC "pedge"}, 
	{UC "nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, UC "prevpos"}, 
	{UC "nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, UC "prevw"},
	{UC "nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, UC "prevword"},
	{UC "nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL},
	{UC "notmod", TYPETW, unotmod, NULL, 0, NULL},
	{UC "nxterr", TYPETW, unxterr, NULL, 1, UC "prverr"},
	{UC "open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, UC "deleol"},
	{UC "parserr", TYPETW, uparserr, NULL, 0, NULL},
	{UC "paste", TYPETW + TYPEPW + EMOD, upaste, NULL, 0, NULL },
	{UC "pbuf", TYPETW, upbuf, NULL, 1, UC "nbuf"},
	{UC "pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, UC "nedge"}, 
	{UC "pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, UC "pgup"},
	{UC "pgdnmenu", TYPEMENU, umpgdn, NULL, 1, UC "pgupmenu"}, 
	{UC "pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, UC "pgdn"},
	{UC "pgupmenu", TYPEMENU, umpgup, NULL, 1, UC "pgdnmenu"}, 
	{UC "picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL},
	{UC "play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */ 
	{UC "prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, UC "nextpos"}, 
	{UC "prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, UC "nextw"}, 
	{UC "prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, UC "nextword"},
	{UC "prverr", TYPETW, uprverr, NULL, 1, UC "nxterr"},
	{UC "psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL},
	{UC "pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
	{UC "qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL},
	{UC "query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL},
	{UC "querysave", TYPETW, uquerysave, NULL, 0, NULL},
	{UC "quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL},
	{UC "quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL},
	{UC "record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL},
	{UC "redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, UC "undo"},
	{UC "retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL},
	{UC "rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL}, 
	{UC "rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, urindent, NULL, 1, UC "lindent"},
	{UC "run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
	{UC "rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL},
	{UC "rtarw", TYPETW + TYPEPW /* + EFIXXCOL */, u_goto_right, NULL, 1, UC "ltarw"}, /* EFIX removed for picture mode */
	{UC "rtarwmenu", TYPEMENU, umrtarw, NULL, 1, UC "ltarwmenu"},
	{UC "rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL},
	{UC "save", TYPETW + TYPEPW, usave, NULL, 0, NULL},
	{UC "savenow", TYPETW + TYPEPW, usavenow, NULL, 0, NULL},
	{UC "scratch", TYPETW + TYPEPW, uscratch, NULL, 0, NULL},
	{UC "select", TYPETW + TYPEPW, uselect, NULL, 0, NULL},
	{UC "setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL},
	{UC "shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL},
	{UC "showerr", TYPETW + TYPEPW, ucurrent_msg, NULL, 0, NULL},
	{UC "shrinkw", TYPETW, ushrnk, NULL, 1, UC "groww"},
	{UC "splitw", TYPETW, usplitw, NULL, 0, NULL},
	{UC "stat", TYPETW + TYPEPW, ustat, NULL, 0, NULL},
	{UC "stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL},
	{UC "swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL},
	{UC "switch", TYPETW + TYPEPW, uswitch, NULL, 0, NULL},
	{UC "sys", TYPETW + TYPEPW, usys, NULL, 0, NULL },
	{UC "tabmenu", TYPEMENU, umtab, NULL, 1, UC "ltarwmenu"},
	{UC "tag", TYPETW + TYPEPW, utag, NULL, 0, NULL},
	{UC "toggle_marking", TYPETW + TYPEPW, utoggle_marking, NULL, 0, NULL},
	{UC "then", TYPEPW+EMOD, urtn, 0, 0, 0 },
	{UC "tomarkb", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkb, NULL, 0, NULL},
	{UC "tomarkbk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkbk, NULL, 0, NULL},
	{UC "tomarkk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkk, NULL, 0, NULL},
	{UC "tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL},
	{UC "tomouse", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utomouse, 0, 0, 0 },
	{UC "tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL},
	{UC "tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL},
	{UC "tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL},
	{UC "txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL}, 
	{UC "type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, UC "backs"},
	{UC "undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, UC "redo"},
	{UC "uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, UC "dnarw"},
	{UC "uparwmenu", TYPEMENU, umuparw, NULL, 1, UC "dnarwmenu"}, 
	{UC "upper", TYPETW + TYPEPW + EMOD + EBLOCK, uupper, NULL, 0, NULL},
	{UC "upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, UC "dnslide"},
	{UC "upslidemenu", TYPEMENU, umscrup, NULL, 1, UC "dnslidemenu"},
	{UC "xtmouse", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uxtmouse, 0, 0, 0 },
	{UC "yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL},
	{UC "yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL},
	{UC "yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL}
d462 3
a464 3
		scrup = findcmd(UC "upslide");
		scrdn = findcmd(UC "dnslide");
		drag = findcmd(UC "defmdrag");
d569 1
a569 1
	if (wmkpw(bw->parent, joe_gettext(UC _("Command: ")), &cmdhist, docmd, UC "cmd", NULL, cmdcmplt, NULL, NULL, locale_map, 0)) {
@


1.79
log
@|comments| in gettext strings
@
text
@d21 184
a204 184
	{US "abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL},
	{US "abortbuf", TYPETW, uabortbuf, NULL, 0, NULL},
	{US "arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL},
	{US "ask", TYPETW + TYPEPW, uask, NULL, 0, NULL},
	{US "uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
	{US "backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, US "delch"},
	{US "backsmenu", TYPEMENU, umbacks, NULL, 1, NULL},
	{US "backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, US "delw"},
	{US "beep", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ubeep, NULL, 0, NULL},
	{US "begin_marking", TYPETW + TYPEPW, ubegin_marking, NULL, 0, NULL},
	{US "bknd", TYPETW, ubknd, NULL, 0, NULL},
	{US "bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, US "fwrdc"},
	{US "blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkcpy, NULL, 1, NULL},
	{US "blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD + EBLOCK, ublkdel, NULL, 0, NULL},
	{US "blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkmove, NULL, 0, NULL},
	{US "blksave", TYPETW + TYPEPW + EBLOCK, ublksave, NULL, 0, NULL},
	{US "bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL},
	{US "bofmenu", TYPEMENU, umbof, NULL, 0, NULL},
	{US "bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL},
	{US "bolmenu", TYPEMENU, umbol, NULL, 0, NULL},
	{US "bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, US "eop"},
	{US "bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL},
	{US "bufed", TYPETW, ubufed, NULL, 0, NULL},
	{US "build", TYPETW + TYPEPW, ubuild, NULL, 0, NULL},
	{US "byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL},
	{US "cancel", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ucancel, NULL, 0, NULL},
	{US "center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL},
	{US "charset", TYPETW + TYPEPW, ucharset, NULL, 0, NULL}, 
	{US "ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
	{US "col", TYPETW + TYPEPW, ucol, NULL, 0, NULL},
	{US "complete", TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
	{US "copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL},
	{US "crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, US "crawlr"},
	{US "crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, US "crawll"},
	{US "defmdown", TYPETW+TYPEPW+TYPEQW+TYPEMENU, udefmdown, 0, 0, 0 },
	{US "defmup", TYPETW+TYPEPW, udefmup, 0, 0, 0 },
	{US "defmdrag", TYPETW+TYPEPW, udefmdrag, 0, 0, 0 },
	{US "defm2down", TYPETW+TYPEPW+TYPEMENU, udefm2down, 0, 0, 0 },
	{US "defm2up", TYPETW+TYPEPW, udefm2up, 0, 0, 0 },
	{US "defm2drag", TYPETW+TYPEPW, udefm2drag, 0, 0, 0 },
	{US "defm3down", TYPETW+TYPEPW, udefm3down, 0, 0, 0 },
	{US "defm3up", TYPETW+TYPEPW, udefm3up, 0, 0, 0 },
	{US "defm3drag", TYPETW+TYPEPW, udefm3drag, 0, 0, 0 },
	{US "delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, US "deleol"},
	{US "delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, US "backs"},
	{US "deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, US "delbol"}, 
	{US "dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL}, 
	{US "delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, US "backw"},
	{US "dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, US "uparw"},
	{US "dnarwmenu", TYPEMENU, umdnarw, NULL, 1, US "uparwmenu"}, 
	{US "dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, US "upslide"},
	{US "dnslidemenu", TYPEMENU, umscrdn, NULL, 1, US "upslidemenu"},
	{US "drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL},
	{US "dupw", TYPETW, uduptw, NULL, 0, NULL},
	{US "edit", TYPETW, uedit, NULL, 0, NULL},
	{US "else", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelse, 0, 0, 0 },
	{US "elsif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uelsif, 0, 0, 0 },
	{US "endif", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uendif, 0, 0, 0 },
	{US "eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL},
	{US "eofmenu", TYPEMENU, umeof, NULL, 0, NULL},
	{US "eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL},
	{US "eolmenu", TYPEMENU, umeol, NULL, 0, NULL},
	{US "eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, US "bop"},
	{US "execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL},
	{US "explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL},
	{US "exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL},
	{US "ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL},
	{US "filt", TYPETW + TYPEPW + EMOD + EBLOCK, ufilt, NULL, 0, NULL},
	{US "finish", TYPETW + TYPEPW + EMOD, ufinish, NULL, 1, NULL},
	{US "fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL},
	{US "format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL},
	{US "fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL},
	{US "fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, US "bkwdc"},
	{US "gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL},
	{US "grep", TYPETW, ugrep, NULL, 0, NULL},
	{US "groww", TYPETW, ugroww, NULL, 1, US "shrinkw"},
	{US "if", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMETA, uif, 0, 0, 0 },
	{US "isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{US "jump", TYPETW, ujump, NULL, 0, NULL },
	{US "killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL},
	{US "killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
	{US "help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL},
	{US "home", TYPETW + TYPEPW + EFIXXCOL, uhome, NULL, 0, NULL},
	{US "hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
	{US "hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL},
	{US "insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, US "delch"},
	{US "keymap", TYPETW, ukeymap, 0, 0, 0 },    /* JM */
	{US "insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL}, 
	{US "language", TYPETW + TYPEPW, ulanguage, NULL, 0, NULL}, 
	{US "lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ulindent, NULL, 1, US "rindent"},
	{US "line", TYPETW + TYPEPW, uline, NULL, 0, NULL},
	{US "lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL}, 
	{US "lower", TYPETW + TYPEPW + EMOD + EBLOCK, ulower, NULL, 0, NULL},
	{US "ltarw", TYPETW + TYPEPW /* + EFIXXCOL + ECHKXCOL */, u_goto_left, NULL, 1, US "rtarw"},
	{US "ltarwmenu", TYPEMENU, umltarw, NULL, 1, US "rtarwmenu"},
	{US "macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL},
	{US "debug_joe", TYPETW + EFIXXCOL, udebug_joe, NULL, 0, NULL},
	{US "markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL},
	{US "markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL},
	{US "markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL},
	{US "math", TYPETW + TYPEPW, umath, NULL, 0, NULL},
	{US "mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL},
	{US "msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL},
	{US "mfit", TYPETW, umfit, NULL, 0, NULL},
	{US "mwind", TYPETW, umwind, NULL, 0, NULL},
	{US "name", TYPETW + TYPEPW, uname_joe, NULL, 0, NULL}, 
	{US "nbuf", TYPETW, unbuf, NULL, 1, US "pbuf"},
	{US "nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, US "pedge"}, 
	{US "nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, US "prevpos"}, 
	{US "nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, US "prevw"},
	{US "nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, US "prevword"},
	{US "nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL},
	{US "notmod", TYPETW, unotmod, NULL, 0, NULL},
	{US "nxterr", TYPETW, unxterr, NULL, 1, US "prverr"},
	{US "open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, US "deleol"},
	{US "parserr", TYPETW, uparserr, NULL, 0, NULL},
	{US "paste", TYPETW + TYPEPW + EMOD, upaste, NULL, 0, NULL },
	{US "pbuf", TYPETW, upbuf, NULL, 1, US "nbuf"},
	{US "pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, US "nedge"}, 
	{US "pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, US "pgup"},
	{US "pgdnmenu", TYPEMENU, umpgdn, NULL, 1, US "pgupmenu"}, 
	{US "pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, US "pgdn"},
	{US "pgupmenu", TYPEMENU, umpgup, NULL, 1, US "pgdnmenu"}, 
	{US "picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL},
	{US "play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */ 
	{US "prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, US "nextpos"}, 
	{US "prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, US "nextw"}, 
	{US "prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, US "nextword"},
	{US "prverr", TYPETW, uprverr, NULL, 1, US "nxterr"},
	{US "psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL},
	{US "pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
	{US "qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL},
	{US "query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL},
	{US "querysave", TYPETW, uquerysave, NULL, 0, NULL},
	{US "quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL},
	{US "quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL},
	{US "record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL},
	{US "redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, US "undo"},
	{US "retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL},
	{US "rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL}, 
	{US "rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, urindent, NULL, 1, US "lindent"},
	{US "run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
	{US "rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL},
	{US "rtarw", TYPETW + TYPEPW /* + EFIXXCOL */, u_goto_right, NULL, 1, US "ltarw"}, /* EFIX removed for picture mode */
	{US "rtarwmenu", TYPEMENU, umrtarw, NULL, 1, US "ltarwmenu"},
	{US "rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL},
	{US "save", TYPETW + TYPEPW, usave, NULL, 0, NULL},
	{US "savenow", TYPETW + TYPEPW, usavenow, NULL, 0, NULL},
	{US "scratch", TYPETW + TYPEPW, uscratch, NULL, 0, NULL},
	{US "select", TYPETW + TYPEPW, uselect, NULL, 0, NULL},
	{US "setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL},
	{US "shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL},
	{US "showerr", TYPETW + TYPEPW, ucurrent_msg, NULL, 0, NULL},
	{US "shrinkw", TYPETW, ushrnk, NULL, 1, US "groww"},
	{US "splitw", TYPETW, usplitw, NULL, 0, NULL},
	{US "stat", TYPETW + TYPEPW, ustat, NULL, 0, NULL},
	{US "stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL},
	{US "swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL},
	{US "switch", TYPETW + TYPEPW, uswitch, NULL, 0, NULL},
	{US "sys", TYPETW + TYPEPW, usys, NULL, 0, NULL },
	{US "tabmenu", TYPEMENU, umtab, NULL, 1, US "ltarwmenu"},
	{US "tag", TYPETW + TYPEPW, utag, NULL, 0, NULL},
	{US "toggle_marking", TYPETW + TYPEPW, utoggle_marking, NULL, 0, NULL},
	{US "then", TYPEPW+EMOD, urtn, 0, 0, 0 },
	{US "tomarkb", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkb, NULL, 0, NULL},
	{US "tomarkbk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkbk, NULL, 0, NULL},
	{US "tomarkk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkk, NULL, 0, NULL},
	{US "tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL},
	{US "tomouse", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utomouse, 0, 0, 0 },
	{US "tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL},
	{US "tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL},
	{US "tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL},
	{US "txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL}, 
	{US "type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, US "backs"},
	{US "undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, US "redo"},
	{US "uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, US "dnarw"},
	{US "uparwmenu", TYPEMENU, umuparw, NULL, 1, US "dnarwmenu"}, 
	{US "upper", TYPETW + TYPEPW + EMOD + EBLOCK, uupper, NULL, 0, NULL},
	{US "upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, US "dnslide"},
	{US "upslidemenu", TYPEMENU, umscrup, NULL, 1, US "dnslidemenu"},
	{US "xtmouse", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uxtmouse, 0, 0, 0 },
	{US "yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL},
	{US "yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL},
	{US "yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL}
d462 3
a464 3
		scrup = findcmd(US "upslide");
		scrdn = findcmd(US "dnslide");
		drag = findcmd(US "defmdrag");
d569 1
a569 1
	if (wmkpw(bw->parent, joe_gettext(US _("Command: ")), &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL, locale_map, 0)) {
@


1.78
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@d214 3
a216 3
unsigned char *steallock_key= (unsigned char *) _("sS");
unsigned char *canceledit_key= (unsigned char *) _("qQ");
unsigned char *ignorelock_key= (unsigned char *) _("iI");
@


1.77
log
@aspell localized
@
text
@d214 4
d220 1
a220 1
	if (c=='s' || c=='S') {
d245 1
a245 1
	} else if (c=='i' || c=='I') {
d251 1
a251 1
	} else if (c=='q' || c=='Q') {
@


1.76
log
@multi-line qw, startup log
@
text
@d48 1
d109 1
@


1.75
log
@Less annoying lock messages.
@
text
@d209 2
a210 2
#define LOCKMSG2 _("Could not create lock. (I) edit anyway, (Q) cancel? ")
#define LOCKMSG1 _("Locked by %s (S)teal lock, (I) edit anyway, (Q) cancel? ")
d533 10
a543 1

d552 2
@


1.74
log
@gettext()
@
text
@d260 1
d308 1
a308 1
		if (!nomodcheck && check_mod(b)) {
@


1.73
log
@Better grep-find
@
text
@d209 2
a210 2
#define LOCKMSG2 "Could not create lock. (I) edit anyway, (Q) cancel? "
#define LOCKMSG1 "Locked by %s (S)teal lock, (I) edit anyway, (Q) cancel? "
d223 1
a223 1
				joe_snprintf_1((char *)bf,sizeof(bf),LOCKMSG1,bf1);
d225 1
a225 1
				joe_snprintf_0((char *)bf,sizeof(bf),LOCKMSG2);
d250 1
a250 1
		if (mkqw(bw->parent, sc(LOCKMSG2), steal_lock, NULL, b, notify)) {
d259 1
a259 1
	if (mkqw(bw->parent, sc("Notice: File on disk changed! (hit ^C to continue)  "), file_changed, NULL, b, notify)) {
d280 1
a280 1
				joe_snprintf_1((char *)bf,sizeof(bf),LOCKMSG1,bf1);
d282 1
a282 1
				joe_snprintf_0((char *)bf,sizeof(bf),LOCKMSG2);
d318 1
a318 1
				msgnw(bw->parent,US "Modify other window first for macro");
d326 1
a326 1
			msgnw(bw->parent, US "Other buffer is read only");
d341 1
a341 1
			msgnw(bw->parent, US "Read only");
d536 1
a536 1
		msgnw(bw->parent, US "No such command");
d551 1
a551 1
	if (wmkpw(bw->parent, US "cmd: ", &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL, locale_map, 0)) {
@


1.72
log
@A option for search
Restore cursor to old position
@
text
@d171 1
@


1.71
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d122 2
@


1.70
log
@add joe_debug
@
text
@a7 1
#include "config.h"
a9 36

#include "b.h"
#include "bw.h"
#include "cmd.h"
#include "mouse.h"
#include "hash.h"
#include "help.h"
#include "macro.h"
#include "main.h"
#include "menu.h"
#include "path.h"
#include "poshist.h"
#include "pw.h"
#include "rc.h"
#include "tty.h"
#include "tw.h"
#include "ublock.h"
#include "uedit.h"
#include "uerror.h"
#include "ufile.h"
#include "uformat.h"
#include "uisrch.h"
#include "umath.h"
#include "undo.h"
#include "usearch.h"
#include "ushell.h"
#include "utag.h"
#include "utils.h"
#include "va.h"
#include "vs.h"
#include "utf8.h"
#include "kbd.h"
#include "w.h"

extern int nowmarking;
extern int smode;
a10 2
int uexecmd(BW *bw);
int udebug_joe(BW *bw);
a296 1
extern long last_time;
d309 17
a325 5
	if (!b->didfirst) {
		/* This happens when we try to block move from a window
		   which is not on the screen */
		if (b!=bw->b) {
			msgnw(bw->parent,US "Modify other window first");
d327 3
d331 10
a340 11
		b->didfirst = 1;
		if (bw->o.mfirst)
			exmacro(bw->o.mfirst,1);
	}
	if (b->rdonly) {
		msgnw(bw->parent, US "Read only");
		if (joe_beep)
			ttputc(7);
		return 0;
	} else if (!b->changed && !b->locked) {
		if (!try_lock(bw,b))
d342 4
d362 1
a362 1
	(k==3 || k==9 || k==13 || k==8 || k==127 || k==4 || cmd->func==utype && k>=32 && k<256)) {
d373 1
a373 1
	if (cmd->flag & ECHKXCOL)
d378 1
a445 2
extern int auto_scroll;

@


1.69
log
@improve lock message
@
text
@d49 1
d154 1
@


1.68
log
@Fix bug where ESC x complete command core dumps.
@
text
@d243 3
d257 1
a257 1
				joe_snprintf_1((char *)bf,sizeof(bf),"Locked by %s  (S)teal, (I)gnore, (Q)uit? ",bf1);
d259 1
a259 1
				joe_snprintf_0((char *)bf,sizeof(bf),"Could not create lock.  (S)teal, (I)gnore, (Q)uit? ");
d284 1
a284 1
		if (mkqw(bw->parent, sc("Could not lock.  (S)teal, (I)gnore, (Q)uit? "), steal_lock, NULL, b, notify)) {
d314 1
a314 1
				joe_snprintf_1((char *)bf,sizeof(bf),"Locked by %s  (S)teal, (I)gnore, (Q)uit? ",bf1);
d316 1
a316 1
				joe_snprintf_0((char *)bf,sizeof(bf),"Could not create lock.  (S)teal, (I)gnore, (Q)uit? ");
@


1.67
log
@fix gcc-4.0.0 warnings
@
text
@d88 1
a88 1
	{US "complete", TYPETW + TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
@


1.66
log
@Grep find improvements
@
text
@a10 1
#include <string.h>
d510 1
a510 1
	cmd->name = joe_strdup(s);
@


1.65
log
@grep find
@
text
@d133 1
@


1.64
log
@Autoscroll
@
text
@d136 1
@


1.63
log
@fix mouse & hex bugs
@
text
@d461 22
@


1.62
log
@Mnior mouse fixes
@
text
@d169 1
a169 1
	{US "paste", TYPETW + EMOD, upaste, NULL, 0, NULL },
@


1.61
log
@XTerm hack.
@
text
@d110 1
d231 1
@


1.60
log
@        Reformat mouse.c

        Apply diff patch

        Apply vpath patch

        Apply electrum's mouse patch (send mouse off code during
        shell escape)

        Mouse can now resize windows

        Mouse can position cursor in menus.  Double-click selects
        an item.  Need to add scroll.

@
text
@d168 1
@


1.59
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d96 1
a96 1
	{US "defm2down", TYPETW+TYPEPW, udefm2down, 0, 0, 0 },
@


1.58
log
@Fix: segfault, xcol for hex, backspace
@
text
@d250 1
a250 1
				joe_snprintf_1(bf,sizeof(bf),"Locked by %s  (S)teal, (I)gnore, (Q)uit? ",bf1);
d252 1
a252 1
				joe_snprintf_0(bf,sizeof(bf),"Could not create lock.  (S)teal, (I)gnore, (Q)uit? ");
d307 1
a307 1
				joe_snprintf_1(bf,sizeof(bf),"Locked by %s  (S)teal, (I)gnore, (Q)uit? ",bf1);
d309 1
a309 1
				joe_snprintf_0(bf,sizeof(bf),"Could not create lock.  (S)teal, (I)gnore, (Q)uit? ");
d370 3
d417 3
@


1.57
log
@Current directory stuff
@
text
@d383 5
a387 3
	if ((cmd->flag & ECHKXCOL)
	    && bw->cursor->xcol != piscol(bw->cursor))
		goto skip;
@


1.56
log
@Get ` to send control keys to shell
@
text
@d198 1
@


1.55
log
@Get joe to compile on irix
@
text
@d371 1
a371 1
	(k==3 || k==13 || k==8 || k==127 || k==4 || cmd->func==utype && k>=32 && k<256)) {
@


1.54
log
@Get tab completion to work on user names.
@
text
@d48 1
a48 1
int beep = 0;
d352 1
a352 1
		if (beep)
d444 1
a444 1
	if (beep && ret)
@


1.53
log
@Fix ~ expansion insanity
@
text
@d157 1
a157 1
	{US "name", TYPETW + TYPEPW, uname, NULL, 0, NULL}, 
@


1.52
log
@Fix line number accounting for joerc files.
Check if system joerc file is newer than home directory one.
@
text
@d531 1
a531 1
	if (wmkpw(bw->parent, US "cmd: ", &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL, locale_map)) {
@


1.51
log
@File changed check.
@
text
@d276 1
a276 1
		if (mkqw(bw->parent, sc("Could not lock.  Take it? "), steal_lock, NULL, b, notify)) {
@


1.50
log
@FIx some math and first change bugs.
@
text
@d283 8
d326 4
d332 7
@


1.49
log
@Perforce macro and support for it.
@
text
@d238 1
a238 1
int steal_lock(BW *bw,int c,unsigned char *s,int *notify)
d243 2
a244 2
		unlock_it(bw->b->name);
		if (lock_it(bw->b->name,bf1)) {
d252 1
a252 1
			if (mkqw(bw->parent, sz(bf), steal_lock, NULL, NULL, notify)) {
d260 1
a260 1
			bw->b->locked=1;
d266 2
a267 2
		bw->b->locked=1;
		bw->b->ignored_lock=1;
d276 1
a276 1
		if (mkqw(bw->parent, sc("Could not lock.  Take it? "), steal_lock, NULL, NULL, notify)) {
d283 60
d377 1
a377 9
		if (!bw->b->didfirst) {
			bw->b->didfirst = 1;
			if (bw->o.mfirst)
				exmacro(bw->o.mfirst,1);
		}
		if (bw->b->rdonly) {
			msgnw(bw->parent, US "Read only");
			if (beep)
				ttputc(7);
a378 26
		} else if (!bw->b->changed && !bw->b->locked) {
			/* First time we modify the file */
			/* If we're a plain file, acquire lock */
			if (!nolocks && plain_file(bw->b)) {
				unsigned char bf1[256];
				unsigned char bf[300];
				int x;
				/* It's a plain file- try to lock it */
				if (lock_it(bw->b->name,bf1)) {
					for(x=0;bf1[x] && bf1[x]!=':';++x);
					bf1[x]=0;
					if(bf1[0])
						joe_snprintf_1(bf,sizeof(bf),"Locked by %s  (S)teal, (I)gnore, (Q)uit? ",bf1);
					else
						joe_snprintf_0(bf,sizeof(bf),"Could not create lock.  (S)teal, (I)gnore, (Q)uit? ");
					if (mkqw(bw->parent, sz(bf), steal_lock, NULL, NULL, NULL)) {
						uquery(bw);
						if (!bw->b->locked)
							goto skip;
					}
				} else {
					/* Remember to unlock it */
					bw->b->locked = 1;
				}
			}
		}
@


1.48
log
@make locking optional
@
text
@d208 1
d317 5
@


1.47
log
@file locking.
@
text
@d235 2
d324 1
a324 1
			if (bw->b->name && bw->b->name[0]!='!' && bw->b->name[0]!='>') {
@


1.46
log
@Fix -marking
@
text
@d233 47
d312 33
a344 5
	if ((maint->curwin->watom->what & TYPETW) && bw->b->rdonly && (cmd->flag & EMOD)) {
		msgnw(bw->parent, US "Read only");
		if (beep)
			ttputc(7);
		goto skip;
@


1.45
log
@fix autoindent in open, and prevent ^K E in prompts
@
text
@d46 1
a46 1
extern int marking;
d262 1
a262 1
	if ((cmd->flag & EBLOCK) && marking)
@


1.44
log
@Fix keymap command.  Add name command.
@
text
@d70 1
a70 1
	{US "bknd", TYPETW + TYPEPW, ubknd, NULL, 0, NULL},
d112 1
a112 1
	{US "edit", TYPETW + TYPEPW, uedit, NULL, 0, NULL},
@


1.43
log
@Jesse McGrew's xterm mouse support.
@
text
@d157 1
@


1.42
log
@Fix -pedantic warnings.
@
text
@d16 1
d43 1
d93 9
d113 3
d133 1
d142 1
d210 1
d215 1
d226 1
@


1.41
log
@aspell support.
Added Home, End, Inserst, Delete key sequences.
@
text
@d327 1
a327 1
	cmd->name = (unsigned char *)strdup((char *)s);
@


1.40
log
@Fix lockup problem: do not allow querysave in
prompt windows.
@
text
@d220 1
a220 1
	/* Send data to shell window */
@


1.39
log
@Renamed dropon to toggle_marking and added
begin_marking.
@
text
@d167 1
a167 1
	{US "querysave", TYPETW + TYPEPW, uquerysave, NULL, 0, NULL},
@


1.38
log
@Many jpicorc.in improvements.
@
text
@d67 1
a99 1
	{US "dropon", TYPETW + TYPEPW, udropon, NULL, 0, NULL},
d193 1
d243 1
a243 1
		udropon(maint->curwin->object);
@


1.37
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d82 1
@


1.36
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d218 8
@


1.35
log
@Added "upper" and "lower" functions (no longer depend on "tr" command).
Fix jmacs transpose word command.
@
text
@d80 1
d119 1
d166 1
d180 1
d252 1
@


1.34
log
@^K E prompts to load original file from disk.
@
text
@d128 1
d200 1
@


1.33
log
@Improved Ctrl-space marking.
@
text
@d184 1
@


1.32
log
@Warn if file changed on save.
@
text
@d44 1
d69 4
a72 4
	{US "blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkcpy, NULL, 1, NULL},
	{US "blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, ublkdel, NULL, 0, NULL},
	{US "blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkmove, NULL, 0, NULL},
	{US "blksave", TYPETW + TYPEPW, ublksave, NULL, 0, NULL},
d109 1
a109 1
	{US "filt", TYPETW + TYPEPW + EMOD, ufilt, NULL, 0, NULL},
d113 1
a113 1
	{US "fmtblk", TYPETW + EMOD + EFIXXCOL, ufmtblk, NULL, 1, NULL},
d125 1
a125 1
	{US "lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, ulindent, NULL, 1, US "rindent"},
d169 1
a169 1
	{US "rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, urindent, NULL, 1, US "lindent"},
d186 3
a188 3
	{US "tomarkb", TYPETW + TYPEPW + EFIXXCOL, utomarkb, NULL, 0, NULL},
	{US "tomarkbk", TYPETW + TYPEPW + EFIXXCOL, utomarkbk, NULL, 0, NULL},
	{US "tomarkk", TYPETW + TYPEPW + EFIXXCOL, utomarkk, NULL, 0, NULL},
d224 4
@


1.31
log
@Tab completion insanity!  Completion in ^K F plus ESC-TAB in text windows.
@
text
@d50 6
d65 1
@


1.30
log
@TAB key now cycles through menu entries.  This is useful
for tab completion: just keep hitting tab until you see the
file you want, then hit enter.

TAB completion is more "bash"-like: if you complete a directory
name a menu does not appear, the directory just gets added to the
prompt.
@
text
@d102 1
@


1.29
log
@Ctrl-<space> drops anchor and turns on marking mode.
@
text
@d175 1
@


1.28
log
@Added "select" for Ctrl-arrow key selecting.
@
text
@d89 1
a89 1
	{US "select", TYPETW + TYPEPW, uselect, NULL, 0, NULL},
d167 1
@


1.27
log
@Added drop_no_redrop function.
@
text
@d89 1
a89 1
	{US "drop_no_redrop", TYPETW + TYPEPW, udrop_no_redrop, NULL, 0, NULL},
@


1.26
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d89 1
@


1.25
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@d41 1
d349 1
a349 1
	if (wmkpw(bw->parent, US "cmd: ", &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL, -1)) {
@


1.24
log
@Applied David Phillips' smart home key patch.

Changed  ` u to ` x.
@
text
@d117 1
a117 1
	{US "ltarw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_left, NULL, 1, US "rtarw"},
d161 1
a161 1
	{US "rtarw", TYPETW + TYPEPW + EFIXXCOL, u_goto_right, NULL, 1, US "ltarw"},
d316 1
a316 43
unsigned char **scmds = NULL;

static unsigned char **regsub(unsigned char **z, int len, unsigned char *s)
{
	unsigned char **lst = NULL;
	int x;

	for (x = 0; x != len; ++x)
		if (rmatch(s, z[x]))
			lst = vaadd(lst, vsncpy(NULL, 0, sz(z[x])));
	return lst;
}

static void inscmd(BW *bw, unsigned char *line)
{
	P *p = pdup(bw->cursor);

	p_goto_bol(p);
	p_goto_eol(bw->cursor);
	bdel(p, bw->cursor);
	binsm(bw->cursor, sv(line));
	p_goto_eol(bw->cursor);
	prm(p);
	bw->cursor->xcol = piscol(bw->cursor);
}

static int cmdabrt(BW *bw, int x, unsigned char *line)
{
	if (line) {
		inscmd(bw, line);
		vsrm(line);
	}
	return -1;
}

static int cmdrtn(MENU *m, int x, unsigned char *line)
{
	inscmd(m->parent->win->object, m->list[x]);
	vsrm(line);
	m->object = NULL;
	wabort(m->parent);
	return 0;
}
a319 6
	MENU *m;
	P *p, *q;
	unsigned char *line;
	unsigned char *line1;
	unsigned char **lst;

d322 1
a322 37
	p = pdup(bw->cursor);
	p_goto_bol(p);
	q = pdup(bw->cursor);
	p_goto_eol(q);
	line = brvs(p, (int) (q->byte - p->byte));	/* Assumes short lines :-) */
	prm(p);
	prm(q);
	m = mkmenu(bw->parent, NULL, cmdrtn, cmdabrt, NULL, 0, line, NULL);
	if (!m)
		return -1;
	line1 = vsncpy(NULL, 0, sv(line));
	line1 = vsadd(line1, '*');
	lst = regsub(scmds, aLEN(scmds), line1);
	vsrm(line1);
	ldmenu(m, lst, 0);
	if (!lst) {
		wabort(m->parent);
		if(beep)
			ttputc(7);
		return -1;
	} else {
		if (aLEN(lst) == 1)
			return cmdrtn(m, 0, line);
		else if (smode || isreg(line))
			return 0;
		else {
			unsigned char *com = mcomplete(m);

			vsrm(m->object);
			m->object = com;
			wabort(m->parent);
			smode = 2;
			if(beep)
				ttputc(7);
			return 0;
		}
	}
@


1.23
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d109 1
@


1.22
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d431 1
a431 1
	if (wmkpw(bw->parent, US "cmd: ", &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL)) {
@


1.21
log
@Menus are now four lines instead of one.
@
text
@d50 138
a187 138
	{"abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL},
	{"abortbuf", TYPETW, uabortbuf, NULL, 0, NULL},
	{"arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL},
	{"ask", TYPETW + TYPEPW, uask, NULL, 0, NULL},
	{"uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
	{"backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, "delch"},
	{"backsmenu", TYPEMENU, umbacks, NULL, 1, NULL},
	{"backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, "delw"},
	{"bknd", TYPETW + TYPEPW, ubknd, NULL, 0, NULL},
	{"bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, "fwrdc"},
	{"blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkcpy, NULL, 1, NULL},
	{"blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, ublkdel, NULL, 0, NULL},
	{"blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkmove, NULL, 0, NULL},
	{"blksave", TYPETW + TYPEPW, ublksave, NULL, 0, NULL},
	{"bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL},
	{"bofmenu", TYPEMENU, umbof, NULL, 0, NULL},
	{"bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL},
	{"bolmenu", TYPEMENU, umbol, NULL, 0, NULL},
	{"bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, "eop"},
	{"bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL},
	{"bufed", TYPETW, ubufed, NULL, 0, NULL},
	{"byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL},
	{"center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL},
	{"ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
	{"col", TYPETW + TYPEPW, ucol, NULL, 0, NULL},
	{"complete", TYPETW + TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
	{"copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL},
	{"crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, "crawlr"},
	{"crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, "crawll"},
	{"delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, "deleol"},
	{"delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, "backs"},
	{"deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, "delbol"}, 
	{"dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL}, 
	{"delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, "backw"},
	{"dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, "uparw"},
	{"dnarwmenu", TYPEMENU, umdnarw, NULL, 1, "uparwmenu"}, 
	{"dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, "upslide"},
	{"drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL},
	{"dupw", TYPETW, uduptw, NULL, 0, NULL},
	{"edit", TYPETW + TYPEPW, uedit, NULL, 0, NULL},
	{"eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL},
	{"eofmenu", TYPEMENU, umeof, NULL, 0, NULL},
	{"eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL},
	{"eolmenu", TYPEMENU, umeol, NULL, 0, NULL},
	{"eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, "bop"},
	{"execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL},
	{"explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL},
	{"exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL},
	{"ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL},
	{"filt", TYPETW + TYPEPW + EMOD, ufilt, NULL, 0, NULL},
	{"fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL},
	{"format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL},
	{"fmtblk", TYPETW + EMOD + EFIXXCOL, ufmtblk, NULL, 1, NULL},
	{"fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, "bkwdc"},
	{"gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL},
	{"groww", TYPETW, ugroww, NULL, 1, "shrinkw"},
	{"isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{"killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
	{"help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL},
	{"hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
	{"hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL},
	{"insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, "delch"},
	{"insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL}, 
	{"lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, ulindent, NULL, 1, "rindent"},
	{"line", TYPETW + TYPEPW, uline, NULL, 0, NULL},
	{"lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL}, 
	{"ltarw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_left, NULL, 1, "rtarw"},
	{"ltarwmenu", TYPEMENU, umltarw, NULL, 1, "rtarwmenu"},
	{"macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL},
	{"markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL},
	{"markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL},
	{"markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL},
	{"math", TYPETW + TYPEPW, umath, NULL, 0, NULL},
	{"mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL},
	{"msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL},
	{"nbuf", TYPETW, unbuf, NULL, 1, "pbuf"},
	{"nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, "pedge"}, 
	{"nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, "prevpos"}, 
	{"nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, "prevw"},
	{"nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, "prevword"},
	{"nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL},
	{"notmod", TYPETW, unotmod, NULL, 0, NULL},
	{"nxterr", TYPETW, unxterr, NULL, 1, "prverr"},
	{"open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, "deleol"},
	{"parserr", TYPETW, uparserr, NULL, 0, NULL},
	{"pbuf", TYPETW, upbuf, NULL, 1, "nbuf"},
	{"pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, "nedge"}, 
	{"pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, "pgup"},
	{"pgdnmenu", TYPEMENU, umpgdn, NULL, 1, "pgupmenu"}, 
	{"pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, "pgdn"},
	{"pgupmenu", TYPEMENU, umpgup, NULL, 1, "pgdnmenu"}, 
	{"picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL},
	{"play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */ 
	{"prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, "nextpos"}, 
	{"prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, "nextw"}, 
	{"prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, "nextword"},
	{"prverr", TYPETW, uprverr, NULL, 1, "nxterr"},
	{"psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL},
	{"pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
	{"qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL},
	{"query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL},
	{"quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL},
	{"quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL},
	{"record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL},
	{"redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, "undo"},
	{"retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL},
	{"rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL}, 
	{"rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, urindent, NULL, 1, "lindent"},
	{"run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
	{"rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL},
	{"rtarw", TYPETW + TYPEPW + EFIXXCOL, u_goto_right, NULL, 1, "ltarw"},
	{"rtarwmenu", TYPEMENU, umrtarw, NULL, 1, "ltarwmenu"},
	{"rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL},
	{"save", TYPETW + TYPEPW, usave, NULL, 0, NULL},
	{"setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL},
	{"shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL},
	{"shrinkw", TYPETW, ushrnk, NULL, 1, "groww"},
	{"splitw", TYPETW, usplitw, NULL, 0, NULL},
	{"stat", TYPETW + TYPEPW, ustat, NULL, 0, NULL},
	{"stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL},
	{"swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL},
	{"tag", TYPETW + TYPEPW, utag, NULL, 0, NULL},
	{"tomarkb", TYPETW + TYPEPW + EFIXXCOL, utomarkb, NULL, 0, NULL},
	{"tomarkbk", TYPETW + TYPEPW + EFIXXCOL, utomarkbk, NULL, 0, NULL},
	{"tomarkk", TYPETW + TYPEPW + EFIXXCOL, utomarkk, NULL, 0, NULL},
	{"tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL},
	{"tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL},
	{"tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL},
	{"tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL},
	{"txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL}, 
	{"type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, "backs"},
	{"undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, "redo"},
	{"uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, "dnarw"},
	{"uparwmenu", TYPEMENU, umuparw, NULL, 1, "dnarwmenu"}, 
	{"upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, "dnslide"},
	{"yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL},
	{"yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL},
	{"yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL}
d211 1
a211 1
		msgnw(bw->parent, "Read only");
d278 1
a278 1
CMD *findcmd(char *s)
d291 1
a291 1
	cmd->name = strdup(s);
d300 1
a300 1
static char **getcmds(void)
d302 1
a302 1
	char **s = vaensure(NULL, sizeof(cmds) / sizeof(CMD));
d315 1
a315 1
char **scmds = NULL;
d317 1
a317 1
static char **regsub(char **z, int len, char *s)
d319 1
a319 1
	char **lst = NULL;
d328 1
a328 1
static void inscmd(BW *bw, char *line)
d341 1
a341 1
static int cmdabrt(BW *bw, int x, char *line)
d350 1
a350 1
static int cmdrtn(MENU *m, int x, char *line)
d363 3
a365 3
	char *line;
	char *line1;
	char **lst;
d395 1
a395 1
			char *com = mcomplete(m);
d408 1
a408 1
static int docmd(BW *bw, char *s, void *object, int *notify)
d416 1
a416 1
		msgnw(bw->parent, "No such command");
d418 1
a418 1
		mac = mkmacro(MAXINT, 0, 0, cmd);
d431 1
a431 1
	if (wmkpw(bw->parent, "cmd: ", &cmdhist, docmd, "cmd", NULL, cmdcmplt, NULL, NULL)) {
@


1.20
log
@don't beep when not asked
@
text
@d138 1
d140 1
@


1.19
log
@fix memleak in docmd()
@
text
@d384 2
a385 1
		ttputc(7);
d399 2
a400 1
			ttputc(7);
@


1.18
log
@change 0 to NULL where we're talking about pointers
@
text
@d410 1
@


1.17
log
@change type of variables holding string to unsigned char *
@
text
@d50 136
a185 136
	{"abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, 0, 0, 0},
	{"abortbuf", TYPETW, uabortbuf, 0, 0, 0},
	{"arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, 0, 0, 0},
	{"ask", TYPETW + TYPEPW, uask, 0, 0, 0},
	{"uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, 0, 0, 0},
	{"backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, 0, 1, "delch"},
	{"backsmenu", TYPEMENU, umbacks, 0, 1, 0},
	{"backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, 0, 1, "delw"},
	{"bknd", TYPETW + TYPEPW, ubknd, 0, 0, 0},
	{"bkwdc", TYPETW + TYPEPW, ubkwdc, 0, 1, "fwrdc"},
	{"blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkcpy, 0, 1, 0},
	{"blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, ublkdel, 0, 0, 0},
	{"blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD, ublkmove, 0, 0, 0},
	{"blksave", TYPETW + TYPEPW + 0, ublksave, 0, 0, 0},
	{"bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, 0, 0, 0},
	{"bofmenu", TYPEMENU, umbof, 0, 0, 0},
	{"bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, 0, 0, 0},
	{"bolmenu", TYPEMENU, umbol, 0, 0, 0},
	{"bop", TYPETW + TYPEPW + EFIXXCOL, ubop, 0, 1, "eop"},
	{"bos", TYPETW + TYPEPW + EMOVE, ubos, 0, 0, 0},
	{"bufed", TYPETW, ubufed, 0, 0, 0},
	{"byte", TYPETW + TYPEPW, ubyte, 0, 0, 0},
	{"center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, 0, 1, 0},
	{"ctrl", TYPETW + TYPEPW + EMOD, uctrl, 0, 0, 0},
	{"col", TYPETW + TYPEPW, ucol, 0, 0, 0},
	{"complete", TYPETW + TYPEPW + EMINOR + EMOD, ucmplt, 0, 0, 0},
	{"copy", TYPETW + TYPEPW, ucopy, 0, 0, 0},
	{"crawll", TYPETW + TYPEPW, ucrawll, 0, 1, "crawlr"},
	{"crawlr", TYPETW + TYPEPW, ucrawlr, 0, 1, "crawll"},
	{"delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, 0, 1, "deleol"},
	{"delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, 0, 1, "backs"},
	{"deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, 0, 1, "delbol"}, 
	{"dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, 0, 1, 0}, 
	{"delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, 0, 1, "backw"},
	{"dnarw", TYPETW + TYPEPW + EMOVE, udnarw, 0, 1, "uparw"},
	{"dnarwmenu", TYPEMENU, umdnarw, 0, 1, "uparwmenu"}, 
	{"dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, 0, 1, "upslide"},
	{"drop", TYPETW + TYPEPW, udrop, 0, 0, 0},
	{"dupw", TYPETW, uduptw, 0, 0, 0},
	{"edit", TYPETW + TYPEPW, uedit, 0, 0, 0},
	{"eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, 0, 0, 0},
	{"eofmenu", TYPEMENU, umeof, 0, 0, 0},
	{"eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, 0, 0, 0},
	{"eolmenu", TYPEMENU, umeol, 0, 0, 0},
	{"eop", TYPETW + TYPEPW + EFIXXCOL, ueop, 0, 1, "bop"},
	{"execmd", TYPETW + TYPEPW, uexecmd, 0, 0, 0},
	{"explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, 0, 0, 0},
	{"exsave", TYPETW + TYPEPW, uexsve, 0, 0, 0},
	{"ffirst", TYPETW + TYPEPW, pffirst, 0, 0, 0},
	{"filt", TYPETW + TYPEPW + EMOD, ufilt, 0, 0, 0},
	{"fnext", TYPETW + TYPEPW, pfnext, 0, 1, 0},
	{"format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, 0, 1, 0},
	{"fmtblk", TYPETW + EMOD + EFIXXCOL, ufmtblk, 0, 1, 0},
	{"fwrdc", TYPETW + TYPEPW, ufwrdc, 0, 1, "bkwdc"},
	{"gomark", TYPETW + TYPEPW + EMOVE, ugomark, 0, 0, 0},
	{"groww", TYPETW, ugroww, 0, 1, "shrinkw"},
	{"isrch", TYPETW + TYPEPW, uisrch, 0, 0, 0},
	{"killproc", TYPETW + TYPEPW, ukillpid, 0, 0, 0},
	{"help", TYPETW + TYPEPW + TYPEQW, u_help, 0, 0, 0},
	{"hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, 0, 0, 0},
	{"hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, 0, 0, 0},
	{"insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, 0, 1, "delch"},
	{"insf", TYPETW + TYPEPW + EMOD, uinsf, 0, 0, 0}, 
	{"lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, ulindent, 0, 1, "rindent"},
	{"line", TYPETW + TYPEPW, uline, 0, 0, 0},
	{"lose", TYPETW + TYPEPW, ulose, 0, 0, 0}, 
	{"ltarw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_left, 0, 1, "rtarw"},
	{"ltarwmenu", TYPEMENU, umltarw, 0, 1, "rtarwmenu"},
	{"macros", TYPETW + EFIXXCOL, umacros, 0, 0, 0},
	{"markb", TYPETW + TYPEPW + 0, umarkb, 0, 0, 0},
	{"markk", TYPETW + TYPEPW + 0, umarkk, 0, 0, 0},
	{"markl", TYPETW + TYPEPW, umarkl, 0, 0, 0},
	{"math", TYPETW + TYPEPW, umath, 0, 0, 0},
	{"mode", TYPETW + TYPEPW + TYPEQW, umode, 0, 0, 0},
	{"msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, 0, 0, 0},
	{"nbuf", TYPETW, unbuf, 0, 1, "pbuf"},
	{"nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, 0, 1, "pedge"}, 
	{"nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, 0, 1, "prevpos"}, 
	{"nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, 0, 1, "prevw"},
	{"nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, 0, 1, "prevword"},
	{"nmark", TYPETW + TYPEPW, unmark, 0, 0, 0},
	{"notmod", TYPETW, unotmod, 0, 0, 0},
	{"nxterr", TYPETW, unxterr, 0, 1, "prverr"},
	{"open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, 0, 1, "deleol"},
	{"parserr", TYPETW, uparserr, 0, 0, 0},
	{"pbuf", TYPETW, upbuf, 0, 1, "nbuf"},
	{"pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, 0, 1, "nedge"}, 
	{"pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, 0, 1, "pgup"},
	{"pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, 0, 1, "pgdn"},
	{"picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, 0, 1, 0},
	{"play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, 0, 1, 0},	/* EFIXX? */ 
	{"prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, 0, 1, "nextpos"}, 
	{"prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, 0, 1, "nextw"}, 
	{"prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, 0, 1, "nextword"},
	{"prverr", TYPETW, uprverr, 0, 1, "nxterr"},
	{"psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, 0, 0, 0},
	{"pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, 0, 0, 0},
	{"qrepl", TYPETW + TYPEPW + EMOD, pqrepl, 0, 0, 0},
	{"query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, 0, 0, 0},
	{"quote", TYPETW + TYPEPW + EMOD, uquote, 0, 0, 0},
	{"quote8", TYPETW + TYPEPW + EMOD, uquote8, 0, 0, 0},
	{"record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, 0, 0, 0},
	{"redo", TYPETW + TYPEPW + EFIXXCOL, uredo, 0, 1, "undo"},
	{"retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, 0, 0, 0},
	{"rfirst", TYPETW + TYPEPW, prfirst, 0, 0, 0}, 
	{"rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, urindent, 0, 1, "lindent"},
	{"run", TYPETW + TYPEPW, urun, 0, 0, 0},
	{"rsrch", TYPETW + TYPEPW, ursrch, 0, 0, 0},
	{"rtarw", TYPETW + TYPEPW + EFIXXCOL, u_goto_right, 0, 1, "ltarw"},
	{"rtarwmenu", TYPEMENU, umrtarw, 0, 1, "ltarwmenu"},
	{"rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, 0, 1, 0},
	{"save", TYPETW + TYPEPW, usave, 0, 0, 0},
	{"setmark", TYPETW + TYPEPW, usetmark, 0, 0, 0},
	{"shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, 0, 0, 0},
	{"shrinkw", TYPETW, ushrnk, 0, 1, "groww"},
	{"splitw", TYPETW, usplitw, 0, 0, 0},
	{"stat", TYPETW + TYPEPW, ustat, 0, 0, 0},
	{"stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, 0, 0, 0},
	{"swap", TYPETW + TYPEPW + EFIXXCOL, uswap, 0, 0, 0},
	{"tag", TYPETW + TYPEPW, utag, 0, 0, 0},
	{"tomarkb", TYPETW + TYPEPW + EFIXXCOL, utomarkb, 0, 0, 0},
	{"tomarkbk", TYPETW + TYPEPW + EFIXXCOL, utomarkbk, 0, 0, 0},
	{"tomarkk", TYPETW + TYPEPW + EFIXXCOL, utomarkk, 0, 0, 0},
	{"tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, 0, 0, 0},
	{"tos", TYPETW + TYPEPW + EMOVE, utos, 0, 0, 0},
	{"tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, 0, 0, 0},
	{"tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, 0, 0, 0},
	{"txt", TYPETW + TYPEPW, utxt, 0, 0, 0}, 
	{"type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, 0, 1, "backs"},
	{"undo", TYPETW + TYPEPW + EFIXXCOL, uundo, 0, 1, "redo"},
	{"uparw", TYPETW + TYPEPW + EMOVE, uuparw, 0, 1, "dnarw"},
	{"uparwmenu", TYPEMENU, umuparw, 0, 1, "dnarwmenu"}, 
	{"upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, 0, 1, "dnslide"},
	{"yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, 0, 1, 0},
	{"yapp", TYPETW + TYPEPW + EKILL, uyapp, 0, 0, 0},
	{"yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, 0, 1, 0}
d265 1
a265 1
HASH *cmdhash = 0;
d291 1
a291 1
	cmd->func = 0;
d294 1
a294 1
	cmd->negarg = 0;
d313 1
a313 1
char **scmds = 0;
d317 1
a317 1
	char **lst = 0;
d352 1
a352 1
	m->object = 0;
d422 1
a422 1
B *cmdhist = 0;
@


1.16
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d283 1
a283 1
void addcmd(char *s, MACRO *m)
@


1.15
log
@unwrap array elements in initialization of cmds[]
@
text
@d341 4
a344 2
	if (line)
		inscmd(bw, line), vsrm(line);
@


1.14
log
@correct "negated macro" for nbuf/pbuf macros in cmds[] initialization
@
text
@d55 1
a55 3

	{"backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD,
	 ubacks, 0, 1, "delch"},
d57 1
a57 5


	{"backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD,
	 ubackw, 0,
	 1, "delw"},
d61 1
a61 3

	{"blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, ublkdel,
	 0, 0, 0},
d79 5
a83 13

	{"delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl,
	 0, 1, "deleol"},

	{"delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD,
	 udelch, 0, 1, "backs"},
	{"deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, 0, 1, "delbol"},

	{"dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln,
	 0, 1, 0},

	{"delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD,
	 u_word_delete, 0, 1, "backw"},
d85 2
a86 6
	{"dnarwmenu", TYPEMENU, umdnarw, 0, 1, "uparwmenu"},


	{"dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE,
	 udnslide, 0, 1,
	 "upslide"},
d112 2
a113 4
	{"insf", TYPETW + TYPEPW + EMOD, uinsf, 0, 0, 0},

	{"lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, ulindent, 0, 1,
	 "rindent"},
d115 2
a116 4
	{"lose", TYPETW + TYPEPW, ulose, 0, 0, 0},

	{"ltarw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_left,
	 0, 1, "rtarw"},
d126 4
a129 9
	{"nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, 0, 1, "pedge"},

	{"nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, 0, 1,
	 "prevpos"},

	{"nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, 0, 1,
	 "prevw"},
	{"nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, 0, 1,
	 "prevword"},
d136 8
a143 18
	{"pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, 0, 1, "nedge"},

	{"pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, 0,
	 1, "pgup"},
	{"pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, 0, 1,
	 "pgdn"},
	{"picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill,
	 0, 1, 0},
	{"play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, 0, 1, 0},	/* EFIXX? */

	{"prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, 0, 1,
	 "nextpos"},

	{"prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, 0, 1,
	 "nextw"},

	{"prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, 0, 1,
	 "nextword"},
d154 2
a155 4
	{"rfirst", TYPETW + TYPEPW, prfirst, 0, 0, 0},

	{"rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, urindent, 0, 1,
	 "lindent"},
d177 2
a178 6
	{"txt", TYPETW + TYPEPW, utxt, 0, 0, 0},


	{"type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD,
	 utype, 0, 1,
	 "backs"},
d181 2
a182 6
	{"uparwmenu", TYPEMENU, umuparw, 0, 1, "dnarwmenu"},


	{"upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE,
	 uupslide, 0, 1,
	 "dnslide"},
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d149 1
a149 1
	{"nbuf", TYPETW, unbuf, 0, 1, "upbuf"},
d164 1
a164 1
	{"pbuf", TYPETW, upbuf, 0, 1, "unbuf"},
@


1.12
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@a12 1

d38 1
d334 1
a334 1
	CMD *cmd = (CMD *) malloc(sizeof(CMD));
@


1.11
log
@include only headers which are needed
@
text
@d471 1
a471 1
int uexecmd(BW * bw)
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@d12 3
a14 4
#include "vs.h"
#include "va.h"
#include "w.h"
#include "tw.h"
d16 8
d25 3
a27 4
#include "tab.h"
#include "qw.h"
#include "menu.h"
#include "help.h"
d30 1
d33 2
a36 1
#include "uisrch.h"
d39 3
a41 8
#include "poshist.h"
#include "macro.h"
#include "hash.h"
#include "rc.h"
#include "umath.h"
#include "uerror.h"
#include "path.h"
#include "cmd.h"
@


1.9
log
@use mkmenu(W *, ...) instead of mkmenu(BASE *, ...)
@
text
@d1 9
a9 2

/* Command execution */
a11 2

#include "config.h"
@


1.8
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d413 1
a413 1
	m = mkmenu(bw, NULL, cmdrtn, cmdabrt, NULL, 0, line, NULL);
@


1.7
log
@version 2.9.7-pre3
@
text
@d250 1
a250 1
		msgnw(bw, "Read only");
d450 1
a450 1
		msgnw(bw, "No such command");
@


1.6
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d37 1
a37 1
int uexecmd();
d231 1
a231 2
int execmd(cmd, k)
CMD *cmd;
d308 1
a308 1
void izcmds()
d317 1
a317 2
CMD *findcmd(s)
char *s;
d324 1
a324 3
void addcmd(s, m)
char *s;
MACRO *m;
d339 1
a339 1
char **getcmds()
d356 1
a356 3
char **regsub(z, len, s)
char **z;
char *s;
d367 1
a367 3
void inscmd(bw, line)
BW *bw;
char *line;
d380 1
a380 3
int cmdabrt(bw, x, line)
BW *bw;
char *line;
d387 1
a387 3
int cmdrtn(m, x, line)
MENU *m;
char *line;
d396 1
a396 2
int cmdcmplt(bw)
BW *bw;
d443 1
a443 5
int docmd(bw, s, object, notify)
BW *bw;
char *s;
void *object;
int *notify;
@


1.5
log
@changed as of joe-2.9.6
@
text
@d1 1
d37 1
a37 1
int uexecmd ();
d47 3
a49 1
	{"backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, 0, 1, "delch"},
d51 5
a55 1
	{"backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, 0, 1, "delw"},
d59 3
a61 1
	{"blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, ublkdel, 0, 0, 0},
d79 6
a84 2
	{"delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, 0, 1, "deleol"},
	{"delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, 0, 1, "backs"},
d86 7
a92 3
	{"dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, 0, 1, 0},
	{"delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, 0, 1, "backw"},
	{"dnarw", TYPETW + TYPEPW + EMOVE, u_goto_down, 0, 1, "uparw"},
d94 5
a98 1
	{"dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, 0, 1, "upslide"},
d125 3
a127 1
	{"lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, ulindent, 0, 1, "rindent"},
d130 3
a132 1
	{"ltarw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_left, 0, 1, "rtarw"},
d143 8
a150 3
	{"nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, 0, 1, "prevpos"},
	{"nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, 0, 1, "prevw"},
	{"nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, 0, 1, "prevword"},
d158 7
a164 3
	{"pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, 0, 1, "pgup"},
	{"pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, 0, 1, "pgdn"},
	{"picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, 0, 1, 0},
d166 9
a174 3
	{"prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, 0, 1, "nextpos"},
	{"prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, 0, 1, "nextw"},
	{"prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, 0, 1, "nextword"},
d186 3
a188 1
	{"rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD, urindent, 0, 1, "lindent"},
d211 5
a215 1
	{"type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, 0, 1, "backs"},
d217 1
a217 1
	{"uparw", TYPETW + TYPEPW + EMOVE, u_goto_up, 0, 1, "dnarw"},
d219 5
a223 1
	{"upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, 0, 1, "dnslide"},
d231 2
a232 3
int
execmd (cmd, k)
     CMD *cmd;
d238 1
a238 1
		return exmacro (cmd->m, 0);
d242 2
a243 1
	if ((cmd->flag & ECHKXCOL) && bw->cursor->xcol != piscol (bw->cursor))
d250 6
a255 8
	if ((maint->curwin->watom->what & TYPETW) && bw->b->rdonly &&
	    (cmd->flag & EMOD))
	  {
		  msgnw (bw, "Read only");
		  if (beep)
			  ttputc (7);
		  goto skip;
	  }
d258 1
a258 1
	ret = cmd->func (maint->curwin->object, k);
d271 3
a273 3
	if (!(cmd->flag & EPOS) &&
	    (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		afterpos ();
d276 2
a277 3
	if (!(cmd->flag & (EMOVE | EPOS)) &&
	    (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		aftermove (maint->curwin, bw->cursor);
d289 1
a289 1
		bw->cursor->xcol = piscol (bw->cursor);
d292 7
a298 7
	if (cmd->flag & EMID)
	  {
		  int omid = mid;
		  mid = 1;
		  dofollows ();
		  mid = omid;
	  }
d301 1
a301 1
		ttputc (7);
d309 1
a309 2
void
izcmds ()
d312 4
a315 3
	cmdhash = htmk (256);
	for (x = 0; x != sizeof (cmds) / sizeof (CMD); ++x)
		htadd (cmdhash, cmds[x].name, cmds + x);
d318 2
a319 3
CMD *
findcmd (s)
     char *s;
d322 2
a323 2
		izcmds ();
	return (CMD *) htfind (cmdhash, s);
d326 3
a328 4
void
addcmd (s, m)
     char *s;
     MACRO *m;
d330 2
a331 1
	CMD *cmd = (CMD *) malloc (sizeof (CMD));
d333 2
a334 2
		izcmds ();
	cmd->name = strdup (s);
d340 1
a340 1
	htadd (cmdhash, cmd->name, cmd);
d343 1
a343 2
char **
getcmds ()
d345 1
a345 1
	char **s = vaensure (NULL, sizeof (cmds) / sizeof (CMD));
d348 1
d351 2
a352 2
			s = vaadd (s, vsncpy (NULL, 0, sz (e->name)));
	vasort (s, aLen (s));
d360 3
a362 4
char **
regsub (z, len, s)
     char **z;
     char *s;
d366 1
d368 2
a369 2
		if (rmatch (s, z[x]))
			lst = vaadd (lst, vsncpy (NULL, 0, sz (z[x])));
d373 18
a390 19
void
inscmd (bw, line)
     BW *bw;
     char *line;
{
	P *p = pdup (bw->cursor);
	p_goto_bol (p);
	p_goto_eol (bw->cursor);
	bdel (p, bw->cursor);
	binsm (bw->cursor, sv (line));
	p_goto_eol (bw->cursor);
	prm (p);
	bw->cursor->xcol = piscol (bw->cursor);
}

int
cmdabrt (bw, x, line)
     BW *bw;
     char *line;
d393 1
a393 1
		inscmd (bw, line), vsrm (line);
d397 3
a399 4
int
cmdrtn (m, x, line)
     MENU *m;
     char *line;
d401 2
a402 2
	inscmd (m->parent->win->object, m->list[x]);
	vsrm (line);
d404 1
a404 1
	wabort (m->parent);
d408 2
a409 3
int
cmdcmplt (bw)
     BW *bw;
d416 1
d418 9
a426 9
		scmds = getcmds ();
	p = pdup (bw->cursor);
	p_goto_bol (p);
	q = pdup (bw->cursor);
	p_goto_eol (q);
	line = brvs (p, (int) (q->byte - p->byte));	/* Assumes short lines :-) */
	prm (p);
	prm (q);
	m = mkmenu (bw, NULL, cmdrtn, cmdabrt, NULL, 0, line, NULL);
d429 32
a460 36
	line1 = vsncpy (NULL, 0, sv (line));
	line1 = vsadd (line1, '*');
	lst = regsub (scmds, aLEN (scmds), line1);
	vsrm (line1);
	ldmenu (m, lst, 0);
	if (!lst)
	  {
		  wabort (m->parent);
		  ttputc (7);
		  return -1;
	  }
	else
	  {
		  if (aLEN (lst) == 1)
			  return cmdrtn (m, 0, line);
		  else if (smode || isreg (line))
			  return 0;
		  else
		    {
			    char *com = mcomplete (m);
			    vsrm (m->object);
			    m->object = com;
			    wabort (m->parent);
			    smode = 2;
			    ttputc (7);
			    return 0;
		    }
	  }
}

int
docmd (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
d464 2
a465 1
	CMD *cmd = findcmd (s);
d467 6
a472 7
		msgnw (bw, "No such command");
	else
	  {
		  mac = mkmacro (MAXINT, 0, 0, cmd);
		  ret = exmacro (mac, 1);
		  rmmacro (mac);
	  }
d480 3
a482 2
int uexecmd (BW *bw) {
	if (wmkpw (bw->parent, "cmd: ", &cmdhist, docmd, "cmd", NULL, cmdcmplt, NULL, NULL)) {
@


1.4
log
@changed as of joe-2.9.5
@
text
@d35 2
a36 2
int beep=0;
int uexecmd();
d40 137
a176 138
CMD cmds[]=
{
  { "abort", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uabort, 0, 0, 0 },
  { "abortbuf", TYPETW, uabortbuf, 0, 0, 0 },
  { "arg", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uarg, 0, 0, 0 },
  { "ask", TYPETW+TYPEPW, uask, 0, 0, 0 },
  { "uarg", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uuarg, 0, 0, 0 },
  { "backs", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR+EKILL+EMOD, ubacks, 0, 1, "delch" },
  { "backsmenu", TYPEMENU, umbacks, 0, 1, 0 },
  { "backw", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EKILL+EMOD, ubackw, 0, 1, "delw" },
  { "bknd", TYPETW+TYPEPW, ubknd, 0, 0, 0 },
  { "bkwdc", TYPETW+TYPEPW, ubkwdc, 0, 1, "fwrdc" },
  { "blkcpy", TYPETW+TYPEPW+EFIXXCOL+EMOD, ublkcpy, 0, 1, 0 },
  { "blkdel", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, ublkdel, 0, 0, 0 },
  { "blkmove", TYPETW+TYPEPW+EFIXXCOL+EMOD, ublkmove, 0, 0, 0 },
  { "blksave", TYPETW+TYPEPW+0, ublksave, 0, 0, 0 },
  { "bof", TYPETW+TYPEPW+EMOVE+EFIXXCOL, ubof, 0, 0, 0 },
  { "bofmenu", TYPEMENU, umbof, 0, 0, 0 },
  { "bol", TYPETW+TYPEPW+EFIXXCOL, ubol, 0, 0, 0 },
  { "bolmenu", TYPEMENU, umbol, 0, 0, 0 },
  { "bop", TYPETW+TYPEPW+EFIXXCOL, ubop, 0, 1, "eop" },
  { "bos", TYPETW+TYPEPW+EMOVE, ubos, 0, 0, 0 },
  { "bufed", TYPETW, ubufed, 0, 0, 0 },
  { "byte", TYPETW+TYPEPW, ubyte, 0, 0, 0 },
  { "center", TYPETW+TYPEPW+EFIXXCOL+EMOD, ucenter, 0, 1, 0 },
  { "ctrl", TYPETW+TYPEPW+EMOD, uctrl, 0, 0, 0 },
  { "col", TYPETW+TYPEPW, ucol, 0, 0, 0 },
  { "complete", TYPETW+TYPEPW+EMINOR+EMOD, ucmplt, 0, 0, 0 },
  { "copy", TYPETW+TYPEPW, ucopy, 0, 0, 0 },
  { "crawll", TYPETW+TYPEPW, ucrawll, 0, 1, "crawlr" },
  { "crawlr", TYPETW+TYPEPW, ucrawlr, 0, 1, "crawll" },
  { "delbol", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, udelbl, 0, 1, "deleol" },
  { "delch", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR+EKILL+EMOD, udelch, 0, 1, "backs" },
  { "deleol", TYPETW+TYPEPW+EKILL+EMOD, udelel, 0, 1, "delbol" },
  { "dellin", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, udelln, 0, 1, 0 },
  { "delw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL+EKILL+EMOD, u_word_delete, 0, 1, "backw" },
  { "dnarw", TYPETW+TYPEPW+EMOVE, udnarw, 0, 1, "uparw" },
  { "dnarwmenu", TYPEMENU, umdnarw, 0, 1, "uparwmenu" },
  { "dnslide", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, udnslide, 0, 1, "upslide" },
  { "drop", TYPETW+TYPEPW, udrop, 0, 0, 0 },
  { "dupw", TYPETW, uduptw, 0, 0, 0 },
  { "edit", TYPETW+TYPEPW, uedit, 0, 0, 0 },
  { "eof", TYPETW+TYPEPW+EFIXXCOL+EMOVE, ueof, 0, 0, 0 },
  { "eofmenu", TYPEMENU, umeof, 0, 0, 0 },
  { "eol", TYPETW+TYPEPW+EFIXXCOL, ueol, 0, 0, 0 },
  { "eolmenu", TYPEMENU, umeol, 0, 0, 0 },
  { "eop", TYPETW+TYPEPW+EFIXXCOL, ueop, 0, 1, "bop" },
  { "execmd", TYPETW+TYPEPW, uexecmd, 0, 0, 0 },
  { "explode", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uexpld, 0, 0, 0 },
  { "exsave", TYPETW+TYPEPW, uexsve, 0, 0, 0 },
  { "ffirst", TYPETW+TYPEPW, pffirst, 0, 0, 0 },
  { "filt", TYPETW+TYPEPW+EMOD, ufilt, 0, 0, 0 },
  { "fnext", TYPETW+TYPEPW, pfnext, 0, 1, 0 },
  { "format", TYPETW+TYPEPW+EFIXXCOL+EMOD, uformat, 0, 1, 0 },
  { "fmtblk", TYPETW+EMOD+EFIXXCOL, ufmtblk, 0, 1, 0 },
  { "fwrdc", TYPETW+TYPEPW, ufwrdc, 0, 1, "bkwdc" },
  { "gomark", TYPETW+TYPEPW+EMOVE, ugomark, 0, 0, 0 },
  { "groww", TYPETW, ugroww, 0, 1, "shrinkw" },
  { "isrch", TYPETW+TYPEPW, uisrch, 0, 0, 0 },
  { "killproc", TYPETW+TYPEPW, ukillpid, 0, 0, 0 },
  { "help", TYPETW+TYPEPW+TYPEQW, u_help, 0, 0, 0 },
  { "hnext", TYPETW+TYPEPW+TYPEQW, u_help_next, 0, 0, 0 },
  { "hprev", TYPETW+TYPEPW+TYPEQW, u_help_prev, 0, 0, 0 },
  { "insc", TYPETW+TYPEPW+EFIXXCOL+EMOD, uinsc, 0, 1, "delch" },
  { "insf", TYPETW+TYPEPW+EMOD, uinsf, 0, 0, 0 },
  { "lindent", TYPETW+TYPEPW+EFIXXCOL+EMOD, ulindent, 0, 1, "rindent" },
  { "line", TYPETW+TYPEPW, uline, 0, 0, 0 },
  { "lose", TYPETW+TYPEPW, ulose, 0, 0, 0 },
  { "ltarw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, ultarw, 0, 1, "rtarw" },
  { "ltarwmenu", TYPEMENU, umltarw, 0, 1, "rtarwmenu" },
  { "macros", TYPETW+EFIXXCOL, umacros, 0, 0, 0 },
  { "markb", TYPETW+TYPEPW+0, umarkb, 0, 0, 0 },
  { "markk", TYPETW+TYPEPW+0, umarkk, 0, 0, 0 },
  { "markl", TYPETW+TYPEPW, umarkl, 0, 0, 0 },
  { "math", TYPETW+TYPEPW, umath, 0, 0, 0 },
  { "mode", TYPETW+TYPEPW+TYPEQW, umode, 0, 0, 0 },
  { "msg", TYPETW+TYPEPW+TYPEQW+TYPEMENU, umsg, 0, 0, 0 },
  { "nbuf", TYPETW, unbuf, 0, 1, "upbuf" },
  { "nedge", TYPETW+TYPEPW+EFIXXCOL, unedge, 0, 1, "pedge" },
  { "nextpos", TYPETW+TYPEPW+EFIXXCOL+EMID+EPOS, unextpos, 0, 1, "prevpos" },
  { "nextw", TYPETW+TYPEPW+TYPEMENU+TYPEQW, unextw, 0, 1, "prevw" },
  { "nextword", TYPETW+TYPEPW+EFIXXCOL, unxtwrd, 0, 1, "prevword" },
  { "nmark", TYPETW+TYPEPW, unmark, 0, 0, 0 },
  { "notmod", TYPETW, unotmod, 0, 0, 0 },
  { "nxterr", TYPETW, unxterr, 0, 1, "prverr" },
  { "open", TYPETW+TYPEPW+EFIXXCOL+EMOD, uopen, 0, 1, "deleol" },
  { "parserr", TYPETW, uparserr, 0, 0, 0 },
  { "pbuf", TYPETW, upbuf, 0, 1, "unbuf" },
  { "pedge", TYPETW+TYPEPW+EFIXXCOL, upedge, 0, 1, "nedge" },
  { "pgdn", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgdn, 0, 1, "pgup" },
  { "pgup", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgup, 0, 1, "pgdn" },
  { "picokill", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, upicokill, 0, 1, 0 },
  { "play", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uplay, 0, 1, 0 }, /* EFIXX? */
  { "prevpos", TYPETW+TYPEPW+EPOS+EMID+EFIXXCOL, uprevpos, 0, 1, "nextpos" },
  { "prevw", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uprevw, 0, 1, "nextw" },
  { "prevword", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, uprvwrd, 0, 1, "nextword" },
  { "prverr", TYPETW, uprverr, 0, 1, "nxterr" },
  { "psh", TYPETW+TYPEPW+TYPEMENU+TYPEQW, upsh, 0, 0, 0 },
  { "pop", TYPETW+TYPEPW+TYPEMENU+TYPEQW, upop, 0, 0, 0 },
  { "qrepl", TYPETW+TYPEPW+EMOD, pqrepl, 0, 0, 0 },
  { "query", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uquery, 0, 0, 0 },
  { "quote", TYPETW+TYPEPW+EMOD, uquote, 0, 0, 0 },
  { "quote8", TYPETW+TYPEPW+EMOD, uquote8, 0, 0, 0 },
  { "record", TYPETW+TYPEPW+TYPEMENU+TYPEQW, urecord, 0, 0, 0 },
  { "redo", TYPETW+TYPEPW+EFIXXCOL, uredo, 0, 1, "undo" },
  { "retype", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uretyp, 0, 0, 0 },
  { "rfirst", TYPETW+TYPEPW, prfirst, 0, 0, 0 },
  { "rindent", TYPETW+TYPEPW+EFIXXCOL+EMOD, urindent, 0, 1, "lindent" },
  { "run", TYPETW+TYPEPW, urun, 0, 0, 0 },
  { "rsrch", TYPETW+TYPEPW, ursrch, 0, 0, 0 },
  { "rtarw", TYPETW+TYPEPW+EFIXXCOL, urtarw, 0, 1, "ltarw" },
  { "rtarwmenu", TYPEMENU, umrtarw, 0, 1, "ltarwmenu" },
  { "rtn", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOD, urtn, 0, 1, 0 },
  { "save", TYPETW+TYPEPW, usave, 0, 0, 0 },
  { "setmark", TYPETW+TYPEPW, usetmark, 0, 0, 0 },
  { "shell", TYPETW+TYPEPW+TYPEMENU+TYPEQW, ushell, 0, 0, 0 },
  { "shrinkw", TYPETW, ushrnk, 0, 1, "groww" },
  { "splitw", TYPETW, usplitw, 0, 0, 0 },
  { "stat", TYPETW+TYPEPW, ustat, 0, 0, 0 },
  { "stop", TYPETW+TYPEPW+TYPEMENU+TYPEQW, ustop, 0, 0, 0 },
  { "swap", TYPETW+TYPEPW+EFIXXCOL, uswap, 0, 0, 0 },
  { "tag", TYPETW+TYPEPW, utag, 0, 0, 0 },
  { "tomarkb", TYPETW+TYPEPW+EFIXXCOL, utomarkb, 0, 0, 0 },
  { "tomarkbk", TYPETW+TYPEPW+EFIXXCOL, utomarkbk, 0, 0, 0 },
  { "tomarkk", TYPETW+TYPEPW+EFIXXCOL, utomarkk, 0, 0, 0 },
  { "tomatch", TYPETW+TYPEPW+EFIXXCOL, utomatch, 0, 0, 0 },
  { "tos", TYPETW+TYPEPW+EMOVE, utos, 0, 0, 0 },
  { "tw0", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utw0, 0, 0, 0 },
  { "tw1", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utw1, 0, 0, 0 },
  { "txt", TYPETW+TYPEPW, utxt, 0, 0, 0 },
  { "type", TYPETW+TYPEPW+TYPEQW+TYPEMENU+EMINOR+EMOD, utype, 0, 1, "backs" },
  { "undo", TYPETW+TYPEPW+EFIXXCOL, uundo, 0, 1, "redo" },
  { "uparw", TYPETW+TYPEPW+EMOVE, uuparw, 0, 1, "dnarw" },
  { "uparwmenu", TYPEMENU, umuparw, 0, 1, "dnarwmenu" },
  { "upslide", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, uupslide, 0, 1, "dnslide" },
  { "yank", TYPETW+TYPEPW+EFIXXCOL+EMOD, uyank, 0, 1, 0 },
  { "yapp", TYPETW+TYPEPW+EKILL, uyapp, 0, 0, 0 },
  { "yankpop", TYPETW+TYPEPW+EFIXXCOL+EMOD, uyankpop, 0, 1, 0 }
d181 76
a256 65
int execmd(cmd,k)
CMD *cmd;
 {
 BW *bw=(BW *)maint->curwin->object;
 int ret= -1;

 if(cmd->m) return exmacro(cmd->m,0);

 /* We don't execute if we have to fix the column position first
  * (i.e., left arrow when cursor is in middle of nowhere) */
 if((cmd->flag&ECHKXCOL) && bw->cursor->xcol!=piscol(bw->cursor))
  goto skip;

 /* Don't execute command if we're in wrong type of window */
 if(!(cmd->flag&maint->curwin->watom->what)) goto skip;

 if((maint->curwin->watom->what&TYPETW) && bw->b->rdonly &&
    (cmd->flag&EMOD))
  {
  msgnw(bw,"Read only");
  if(beep) ttputc(7);
  goto skip;
  }

 /* Execute command */
 ret=cmd->func(maint->curwin->object,k);

 if(smode) --smode;

 /* Don't update anything if we're going to leave */
 if(leave) return 0;

 bw=(BW *)maint->curwin->object;

 /* Maintain position history */
 /* If command was not a positioning command */
 if(!(cmd->flag&EPOS) &&
    (maint->curwin->watom->what&(TYPETW|TYPEPW)))
  afterpos();

 /* If command was not a movement */
 if(!(cmd->flag&(EMOVE|EPOS)) &&
    (maint->curwin->watom->what&(TYPETW|TYPEPW)))
  aftermove(maint->curwin,bw->cursor);

 if(cmd->flag&EKILL) justkilled=1;
 else justkilled=0;

 skip:

 /* Make dislayed cursor column equal the actual cursor column
  * for commands which arn't simple vertical movements */
 if(cmd->flag&EFIXXCOL) bw->cursor->xcol=piscol(bw->cursor);

 /* Recenter cursor to middle of screen */
 if(cmd->flag&EMID)
  {
  int omid=mid; mid=1;
  dofollows();
  mid=omid;
  }

 if(beep && ret) ttputc(7);
 return ret;
 }
d260 1
a260 1
HASH *cmdhash=0;
d262 47
a308 40
void izcmds()
 {
 int x;
 cmdhash=htmk(256);
 for(x=0;x!=sizeof(cmds)/sizeof(CMD);++x) htadd(cmdhash,cmds[x].name,cmds+x);
 }

CMD *findcmd(s)
char *s;
 {
 if(!cmdhash) izcmds();
 return (CMD *)htfind(cmdhash,s);
 }

void addcmd(s,m)
char *s;
MACRO *m;
 {
 CMD *cmd=(CMD *)malloc(sizeof(CMD));
 if(!cmdhash) izcmds();
 cmd->name=strdup(s);
 cmd->flag=0;
 cmd->func=0;
 cmd->m=m;
 cmd->arg=1;
 cmd->negarg=0;
 htadd(cmdhash,cmd->name,cmd);
 }

char **getcmds()
 {
 char **s=vaensure(NULL,sizeof(cmds)/sizeof(CMD));
 int x;
 HENTRY *e;
 for(x=0;x!=cmdhash->len;++x)
  for(e=cmdhash->tab[x];e;e=e->next)
   s=vaadd(s,vsncpy(NULL,0,sz(e->name)));
 vasort(s,aLen(s));
 return s;
 }
d312 1
a312 1
char **scmds=0;
d314 133
a446 113
char **regsub(z,len,s)
char **z;
char *s;
 {
 char **lst=0;
 int x;
 for(x=0;x!=len;++x) if(rmatch(s,z[x])) lst=vaadd(lst,vsncpy(NULL,0,sz(z[x])));
 return lst;
 }

void inscmd(bw,line)
BW *bw;
char *line;
 {
 P *p=pdup(bw->cursor); pbol(p);
 peol(bw->cursor);
 bdel(p,bw->cursor);
 binsm(bw->cursor,sv(line)); peol(bw->cursor);
 prm(p);
 bw->cursor->xcol=piscol(bw->cursor);
 }

int cmdabrt(bw,x,line)
BW *bw;
char *line;
 {
 if(line) inscmd(bw,line), vsrm(line);
 return -1;
 }

int cmdrtn(m,x,line)
MENU *m;
char *line;
 {
 inscmd(m->parent->win->object,m->list[x]);
 vsrm(line);
 m->object=0;
 wabort(m->parent);
 return 0;
 }

int cmdcmplt(bw)
BW *bw;
 {
 MENU *m;
 P *p, *q; 
 char *line;
 char *line1;
 char **lst;
 if(!scmds) scmds=getcmds();
 p=pdup(bw->cursor); pbol(p);
 q=pdup(bw->cursor); peol(q);
 line=brvs(p,(int)(q->byte-p->byte)); /* Assumes short lines :-) */
 prm(p); prm(q);
 m=mkmenu(bw,NULL,cmdrtn,cmdabrt,NULL,0,line,NULL);
 if(!m) return -1;
 line1=vsncpy(NULL,0,sv(line));
 line1=vsadd(line1,'*');
 lst=regsub(scmds,aLEN(scmds),line1);
 vsrm(line1);
 ldmenu(m,lst,0);
 if(!lst)
  {
  wabort(m->parent);
  ttputc(7);
  return -1;
  }
 else
  {
  if(aLEN(lst)==1) return cmdrtn(m,0,line);
  else if(smode || isreg(line)) return 0;
  else
   {
   char *com=mcomplete(m);
   vsrm(m->object);
   m->object=com;
   wabort(m->parent);
   smode=2;
   ttputc(7);
   return 0;
   }
  }
 }

int docmd(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 MACRO *mac;
 int ret= -1;
 CMD *cmd=findcmd(s);
 if(!cmd)
  msgnw(bw,"No such command");
 else
  {
  mac=mkmacro(MAXINT,0,0,cmd);
  ret=exmacro(mac,1);
  rmmacro(mac);
  }
 if(notify) *notify=1;
 return ret;
 }

B *cmdhist=0;

int uexecmd(bw)
BW *bw;
 {
 if(wmkpw(bw,"cmd: ",&cmdhist,docmd,"cmd",NULL,cmdcmplt,NULL,NULL)) return 0;
 else return -1;
 }
@


1.3
log
@changed as of joe-2.9.4
@
text
@a31 1
#include "zstr.h"
@


1.2
log
@changed as of joe-2.9.2
@
text
@d76 1
a76 1
  { "delw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL+EKILL+EMOD, udelw, 0, 1, "backw" },
d101 3
a103 3
  { "help", TYPETW+TYPEPW+TYPEQW, uhelp, 0, 0, 0 },
  { "hnext", TYPETW+TYPEPW+TYPEQW, uhnext, 0, 0, 0 },
  { "hprev", TYPETW+TYPEPW+TYPEQW, uhprev, 0, 0, 0 },
@


1.1
log
@Initial revision
@
text
@d3 2
d273 1
a273 1
 cmd->name=zdup(s);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
