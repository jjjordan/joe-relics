head	1.44;
access;
symbols
	joe_3_5:1.42
	joe-3_4:1.38
	help:1.38
	joe_3_1:1.24
	joe_3_0:1.18
	joe_2_9_8:1.15
	joe_2_9_8_pre1:1.12
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.7
	joe_2_9_7_pre2:1.6
	joe_2_9_6:1.5
	joe_2_9_5:1.4
	joe_2_9_4:1.3
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.18.23.28.56;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.05.01.26.32;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.21.18.03.34;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.21.16.29.49;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.12.02.07.05;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.10.18.24.28;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.23.04.28.14;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.21.20.40.14;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.21.19.51.08;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.26.05.28.10;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.14.04.23.09;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.13.00.23.46;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.06.16.11.25;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.03.22.55.53;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.20.21.10.58;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.04.17.39.23;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.44
log
@more refactoring
@
text
@/*
 *	Compiler error handler
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Error database */

typedef struct error ERROR;

struct error {
	LINK(ERROR) link;	/* Linked list of errors */
	long line;		/* Target line number */
	long org;		/* Original target line number */
	unsigned char *file;	/* Target file name */
	long src;		/* Error-file line number */
	unsigned char *msg;	/* The message */
} errors = { { &errors, &errors} };
ERROR *errptr = &errors;	/* Current error row */

B *errbuf = NULL;		/* Buffer with error messages */

/* Function which allows stepping through all error buffers,
   for multi-file search and replace.  Give it a buffer.  It finds next
   buffer in error list.  Look at 'berror' for error information. */

/* This is made to work like bafter: it does not increment refcount of buffer */

B *beafter(B *b)
{
	struct error *e;
	unsigned char *name = b->name;
	if (!name) name = USTR "";
	for (e = errors.link.next; e != &errors; e = e->link.next)
		if (!zcmp(name, e->file))
			break;
	if (e == &errors) {
		/* Given buffer is not in list?  Return first buffer in list. */
		e = errors.link.next;
	}
	while (e != &errors && !zcmp(name, e->file))
		e = e->link.next;
	berror = 0;
	if (e != &errors) {
		B *b = bfind(e->file);
		/* bfind bumps refcount, so we have to unbump it */
		if (b->count == 1)
			b->orphan = 1; /* Oops */
		else
			--b->count;
		return b;
	}
	return 0;
}

/* Insert and delete notices */

void inserr(unsigned char *name, long int where, long int n, int bol)
{
	ERROR *e;

	if (!n)
		return;

	if (name) {
		for (e = errors.link.next; e != &errors; e = e->link.next) {
			if (!zcmp(e->file, name)) {
				if (e->line > where)
					e->line += n;
				else if (e->line == where && bol)
					e->line += n;
			}
		}
	}
}

void delerr(unsigned char *name, long int where, long int n)
{
	ERROR *e;

	if (!n)
		return;

	if (name) {
		for (e = errors.link.next; e != &errors; e = e->link.next) {
			if (!zcmp(e->file, name)) {
				if (e->line > where + n)
					e->line -= n;
				else if (e->line > where)
					e->line = where;
			}
		}
	}
}

/* Abort notice */

void abrerr(unsigned char *name)
{
	ERROR *e;

	if (name)
		for (e = errors.link.next; e != &errors; e = e->link.next)
			if (!zcmp(e->file, name))
				e->line = e->org;
}

/* Save notice */

void saverr(unsigned char *name)
{
	ERROR *e;

	if (name)
		for (e = errors.link.next; e != &errors; e = e->link.next)
			if (!zcmp(e->file, name))
				e->org = e->line;
}

/* Pool of free error nodes */
ERROR errnodes = { {&errnodes, &errnodes} };

/* Free an error node */

static void freeerr(ERROR *n)
{
	obj_free(n->file);
	obj_free(n->msg);
	enquef(ERROR, link, &errnodes, n);
}

/* Free all errors */

static void freeall(void)
{
	while (!qempty(ERROR, link, &errors))
		freeerr(deque_f(ERROR, link, errors.link.next));
	errptr = &errors;
}

/* Parse error messages into database */

/* From joe's joe 2.9 */

/* First word (allowing ., /, _ and -) with a . is the file name.  Next number
   is line number.  Then there should be a ':' */

static void parseone(struct charmap *map,unsigned char *s,unsigned char **rtn_name,long *rtn_line)
{
	int x, y, flg;
	unsigned char *name = NULL;
	long line = -1;

	y=0;
	flg=0;

	do {
		/* Skip to first word */
		for (x = y; s[x] && !(joe_isalnum_(map,s[x]) || s[x] == '.' || s[x] == '/'); ++x) ;

		/* Skip to end of first word */
		for (y = x; joe_isalnum_(map,s[y]) || s[y] == '.' || s[y] == '/' || s[y]=='-'; ++y)
			if (s[y] == '.')
				flg = 1;
	} while (!flg && x!=y);

	/* Save file name */
	if (x != y)
		name = vsncpy(NULL, 0, s + x, y - x);

	/* Skip to first number */
	for (x = y; s[x] && (s[x] < '0' || s[x] > '9'); ++x) ;

	/* Skip to end of first number */
	for (y = x; s[y] >= '0' && s[y] <= '9'; ++y) ;

	/* Save line number */
	if (x != y)
		sscanf((char *)(s + x), "%ld", &line);
	if (line != -1)
		--line;

	/* Look for ':' */
	flg = 0;
	while (s[y]) {
	/* Allow : anywhere on line: works for MIPS C compiler */
/*
	for (y = 0; s[y];)
*/
		if (s[y]==':') {
			flg = 1;
			break;
		}
		++y;
	}

	if (!flg)
		line = -1;

	*rtn_name = name;
	*rtn_line = line;
}

/* Parser for file name lists from grep, find and ls.
 *
 * filename
 * filename:*
 * filename:line-number:*
 */

void parseone_grep(struct charmap *map,unsigned char *s,unsigned char **rtn_name,long *rtn_line)
{
	int y;
	unsigned char *name = NULL;
	long line = -1;

	/* Skip to first : or end of line */
	for (y = 0;s[y] && s[y] != ':';++y);
	if (y) {
		/* This should be the file name */
		name = vsncpy(NULL,0,s,y);
		line = 0;
		if (s[y] == ':') {
			/* Maybe there's a line number */
			++y;
			while (s[y] >= '0' && s[y] <= '9')
				line = line * 10 + (s[y++] - '0');
			--line;
			if (line < 0 || s[y] != ':') {
				/* Line number is only valid if there's a second : */
				line = 0;
			}
		}
	}

	*rtn_name = name;
	*rtn_line = line;
}

static int parseit(struct charmap *map,unsigned char *s, long int row,
  void (*parseone)(struct charmap *map, unsigned char *s, unsigned char **rtn_name, long *rtn_line))
{
	unsigned char *name = NULL;
	long line = -1;
	ERROR *err;

	parseone(map,s,&name,&line);

	if (name) {
		if (line != -1) {
			/* We have an error */
			err = (ERROR *) alitem(&errnodes, sizeof(ERROR));
			err->file = name;
			obj_perm(err->file);
			err->org = err->line = line;
			err->src = row;
			err->msg = vsncpy(NULL, 0, sc("\\i"));
			err->msg = vsncpy(sv(err->msg), sv(s));
			obj_perm(err->msg);
			enqueb(ERROR, link, &errors, err);
			return 1;
		}
	}
	return 0;
}

/* Parse the error output contained in a buffer */

static long parserr(B *b)
{
	P *p = pdup(b->bof, USTR "parserr");
	P *q = pdup(p, USTR "parserr");
	unsigned char *s = 0;
	long nerrs = 0;

	freeall();
	do {
		pset(q, p);
		p_goto_eol(p);
		s = brvs(s, q, (int) (p->byte - q->byte));
		if (s) {
			nerrs += parseit(b->o.charmap, s, q->line, (b->parseone ? b->parseone : parseone));
		}
	} while (pgetc(p) != NO_MORE_DATA);
	prm(p);
	prm(q);
	return nerrs;
}

BW *find_a_good_bw(B *b)
{
	W *w;
	BW *bw = 0;
	/* Find lowest window with buffer */
	if ((w = maint->topwin) != NULL) {
		do {
			if ((w->watom->what&TYPETW) && ((BW *)w->object)->b==b && w->y>=0)
				bw = (BW *)w->object;
			w = w->link.next;
		} while (w != maint->topwin);
	}
	if (bw)
		return bw;
	/* Otherwise just find lowest window */
	if ((w = maint->topwin) != NULL) {
		do {
			if ((w->watom->what&TYPETW) && w->y>=0)
				bw = (BW *)w->object;
			w = w->link.next;
		} while (w != maint->topwin);
	}
	return bw;
}

int parserrb(B *b)
{
	BW *bw;
	int n;
	errbuf = b;
	freeall();
	n = parserr(b);
	bw = find_a_good_bw(b);
	if (n)
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%d messages found")), n));
	else
		msgnw(bw->parent, joe_gettext(_("No messages found")));
	return 0;
}

int uparserr(BW *bw)
{
	int n;
	errbuf = bw->b;
	freeall();
	n = parserr(bw->b);
	if (n)
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%d messages found")), n));
	else
		msgnw(bw->parent, joe_gettext(_("No messages found")));
	return 0;
}

int jump_to_file_line(BW *bw,unsigned char *file,int line,unsigned char *msg)
{
	int omid;
	if (!bw->b->name || zcmp(file, bw->b->name)) {
		if (doswitch(bw, vsdup(file)))
			return -1;
		bw = (BW *) maint->curwin->object;
	}
	omid = mid;
	mid = 1;
	pline(bw->cursor, line);
	dofollows();
	mid = omid;
	bw->cursor->xcol = piscol(bw->cursor);
	if (msg)
		msgnw(bw->parent, msg);
	return 0;
}

/* Show current message */

int ucurrent_msg(BW *bw)
{
	if (errptr != &errors) {
		msgnw(bw->parent, errptr->msg);
		return 0;
	} else {
		msgnw(bw->parent, joe_gettext(_("No messages")));
		return -1;
	}
}

/* Find line in error database: return pointer to message */

ERROR *srcherr(BW *bw,unsigned char *file,long line)
{
	ERROR *p;
	for (p = errors.link.next; p != &errors; p=p->link.next)
		if (!zcmp(p->file,file) && p->org == line) {
			errptr = p;
			setline(errbuf, errptr->src);
			return errptr;
			}
	return 0;
}

int ujump(BW *bw)
{
	int rtn = -1;
	P *p = pdup(bw->cursor, USTR "ujump");
	P *q = pdup(p, USTR "ujump");
	unsigned char *s;
	p_goto_bol(p);
	p_goto_eol(q);
	s = brvs(NULL, p, (int) (q->byte - p->byte));
	prm(p);
	prm(q);
	if (s) {
		unsigned char *name = NULL;
		long line = -1;
		if (bw->b->parseone)
			bw->b->parseone(bw->b->o.charmap,s,&name,&line);
		else
			parseone(bw->b->o.charmap,s,&name,&line);
		if (name && line != -1) {
			ERROR *p = srcherr(bw, name, line);
			uprevw((BASE *)bw);
			/* Check that we made it to a tw */
			if (p)
				rtn = jump_to_file_line(maint->curwin->object,name,p->line,NULL /* p->msg */);
			else
				rtn = jump_to_file_line(maint->curwin->object,name,line,NULL);
		}
	}
	return rtn;
}

int unxterr(BW *bw)
{
	if (errptr->link.next == &errors) {
		msgnw(bw->parent, joe_gettext(_("No more errors")));
		return -1;
	}
	errptr = errptr->link.next;
	setline(errbuf, errptr->src);
	return jump_to_file_line(bw,errptr->file,errptr->line,NULL /* errptr->msg */);
}

int uprverr(BW *bw)
{
	if (errptr->link.prev == &errors) {
		msgnw(bw->parent, joe_gettext(_("No more errors")));
		return -1;
	}
	errptr = errptr->link.prev;
	setline(errbuf, errptr->src);
	return jump_to_file_line(bw,errptr->file,errptr->line,NULL /* errptr->msg */);
}
@


1.43
log
@semiautomatic variables
@
text
@d350 1
a350 1
		if (doswitch(bw, vsdup(file), NULL, NULL))
@


1.42
log
@UC -> USTR
@
text
@d130 2
a131 2
	vsrm(n->file);
	vsrm(n->msg);
d257 1
d262 1
d265 1
a265 2
		} else
			vsrm(name);
d276 1
a280 2
		unsigned char *s;

d283 1
a283 1
		s = brvs(q, (int) (p->byte - q->byte));
a285 1
			vsrm(s);
d327 1
a327 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("%d messages found")), n);
d329 1
a329 2
		joe_snprintf_0(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("No messages found")));
	msgnw(bw->parent, msgbuf);
d340 1
a340 1
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("%d messages found")), n);
d342 1
a342 2
		joe_snprintf_0(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("No messages found")));
	msgnw(bw->parent, msgbuf);
d360 2
a361 1
	msgnw(bw->parent, msg);
d400 1
a400 1
	s = brvs(p, (int) (q->byte - p->byte));
a417 1
			vsrm(name);
a418 1
		vsrm(s);
@


1.41
log
@change US to UC
@
text
@d36 1
a36 1
	if (!name) name = UC "";
d273 2
a274 2
	P *p = pdup(b->bof, UC "parserr");
	P *q = pdup(p, UC "parserr");
d397 2
a398 2
	P *p = pdup(bw->cursor, UC "ujump");
	P *q = pdup(p, UC "ujump");
@


1.40
log
@fix warnings
@
text
@d36 1
a36 1
	if (!name) name = US "";
d273 2
a274 2
	P *p = pdup(b->bof, US "parserr");
	P *q = pdup(p, US "parserr");
d397 2
a398 2
	P *p = pdup(bw->cursor, US "ujump");
	P *q = pdup(p, US "ujump");
@


1.39
log
@fix bugs: missing joe_gettext, core dump on re
@
text
@a35 1
	int er;
a53 1
		er = berror;
@


1.38
log
@gettext()
@
text
@d35 1
d37 1
d39 1
a39 1
		if (!zcmp(b->name, e->file))
d45 1
a45 1
	while (e != &errors && !zcmp(b->name, e->file))
@


1.37
log
@Better grep-find
@
text
@d328 1
a328 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%d messages found", n);
d330 1
a330 1
		joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "No messages found");
d342 1
a342 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%d messages found", n);
d344 1
a344 1
		joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "No messages found");
d375 1
a375 1
		msgnw(bw->parent, US "No messages");
d430 1
a430 1
		msgnw(bw->parent, US "No more errors");
d441 1
a441 1
		msgnw(bw->parent, US "No more errors");
@


1.36
log
@e option for s&r
@
text
@d207 38
a244 1
static int parseit(struct charmap *map,unsigned char *s, long int row)
d285 1
a285 1
			nerrs += parseit(b->o.charmap, s, q->line);
d367 13
d408 4
a411 1
		parseone(bw->b->o.charmap,s,&name,&line);
@


1.35
log
@A option for search
Restore cursor to old position
@
text
@d18 1
a18 1
	unsigned char *file;		/* Target file name */
d20 1
a20 1
	unsigned char *msg;		/* The message */
d26 33
d189 4
@


1.34
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d324 1
a324 1
			unextw((BASE *)bw);
d327 1
a327 1
				rtn = jump_to_file_line(maint->curwin->object,name,p->line,p->msg);
d345 1
a345 1
	return jump_to_file_line(bw,errptr->file,errptr->line,errptr->msg);
d356 1
a356 1
	return jump_to_file_line(bw,errptr->file,errptr->line,errptr->msg);
@


1.33
log
@new cvs server
@
text
@a7 1
#include "config.h"
a9 13
#include <stdio.h>

#include "b.h"
#include "bw.h"
#include "main.h"
#include "queue.h"
#include "tw.h"
#include "ufile.h"
#include "utils.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"

d254 1
a254 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%ld messages found", n);
d268 1
a268 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%ld messages found", n);
@


1.32
log
@add joe_debug
@
text
@d309 1
a309 1
unsigned char *srcherr(BW *bw,unsigned char *file,long line)
d313 1
a313 1
		if (!zcmp(p->file,file) && p->org==line) {
d316 1
a316 1
			return errptr->msg;
d337 1
a337 1
			unsigned char *msg = srcherr(bw, name, line);
d340 4
a343 1
			rtn = jump_to_file_line(maint->curwin->object,name,line,msg);
@


1.31
log
@Improve highlighting performance.
@
text
@d213 2
a214 2
	P *p = pdup(b->bof);
	P *q = pdup(p);
d324 2
a325 2
	P *p = pdup(bw->cursor);
	P *q = pdup(p);
@


1.30
log
@fix gcc-4.0.0 warnings
@
text
@d46 3
d65 3
@


1.29
log
@Ada syntax file
@
text
@d48 1
a48 1
			if (!strcmp(e->file, name)) {
d64 1
a64 1
			if (!strcmp(e->file, name)) {
d82 1
a82 1
			if (!strcmp(e->file, name))
d94 1
a94 1
			if (!strcmp(e->file, name))
d286 1
a286 1
	if (!bw->b->name || strcmp(file, bw->b->name)) {
d307 1
a307 1
		if (!strcmp(p->file,file) && p->org==line) {
@


1.28
log
@Grep find improvements
@
text
@d332 1
a332 1
			unextw(bw);
@


1.27
log
@grep find
@
text
@d301 14
d331 4
a334 1
			rtn = jump_to_file_line(bw,name,line,"");
@


1.26
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d126 1
a126 1
static int parseit(struct charmap *map,unsigned char *s, long int row)
a130 1
	ERROR *err;
d171 15
d187 1
a187 1
		if (line != -1 && flg) {
d283 1
a283 1
int unxterr(BW *bw)
d286 2
a287 8

	if (errptr->link.next == &errors) {
		msgnw(bw->parent, US "No more errors");
		return -1;
	}
	errptr = errptr->link.next;
	if (!bw->b->name || strcmp(errptr->file, bw->b->name)) {
		if (doswitch(bw, vsdup(errptr->file), NULL, NULL))
d293 1
a293 2
	pline(bw->cursor, errptr->line);
	setline(errbuf, errptr->src);
d297 1
a297 1
	msgnw(bw->parent, errptr->msg);
d301 35
a337 2
	int omid;

a342 8
	if (!bw->b->name || strcmp(errptr->file, bw->b->name)) {
		if (doswitch(bw, vsdup(errptr->file), NULL, NULL))
			return -1;
		bw = (BW *) maint->curwin->object;
	}
	omid = mid;
	mid = 1;
	pline(bw->cursor, errptr->line);
d344 1
a344 5
	dofollows();
	mid = omid;
	bw->cursor->xcol = piscol(bw->cursor);
	msgnw(bw->parent, errptr->msg);
	return 0;
@


1.25
log
@Allow - in compiler error parser file names.
@
text
@d279 1
a279 1
		if (doedit(bw, vsdup(errptr->file), NULL, NULL))
d304 1
a304 1
		if (doedit(bw, vsdup(errptr->file), NULL, NULL))
@


1.24
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d123 2
a124 1
/* First word on line with a '.' in it.  This is the file name.  The next number after that is the line number. */
d141 1
a141 1
		for (y = x; joe_isalnum_(map,s[y]) || s[y] == '.' || s[y] == '/'; ++y)
@


1.23
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d247 1
a247 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "%ld messages found", n);
d249 1
a249 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "No messages found");
d261 1
a261 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "%ld messages found", n);
d263 1
a263 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "No messages found");
@


1.22
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d213 41
d261 1
a261 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "%ld errors found", n);
d263 1
a263 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "No errors found");
@


1.21
log
@Improve error parser: require ':' on error lines.

Make macro 'compile' for error parsing.

'compile' macro always uses same buffer.

^X ` in jmacs now goes to next error.
@
text
@d215 1
d218 5
a222 1
	snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Parsed %ld lines", parserr(bw->b));
@


1.20
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d161 10
d172 1
a172 1
		if (line != -1) {
@


1.19
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d21 1
d125 1
a125 1
static int parseit(int wide,struct charmap *map,unsigned char *s, long int row)
d137 1
a137 1
		for (x = y; s[x] && !(isalnum_(wide,map,s[x]) || s[x] == '.' || s[x] == '/'); ++x) ;
d140 1
a140 1
		for (y = x; isalnum_(wide,map,s[y]) || s[y] == '.' || s[y] == '/'; ++y)
d194 1
a194 1
			nerrs += parseit(b->o.utf8, b->o.charmap, s, q->line);
@


1.18
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d124 1
a124 1
static int parseit(int wide,unsigned char *s, long int row)
d136 1
a136 1
		for (x = y; s[x] && !(isalnum_(wide,s[x]) || s[x] == '.' || s[x] == '/'); ++x) ;
d139 1
a139 1
		for (y = x; isalnum_(wide,s[y]) || s[y] == '.' || s[y] == '/'; ++y)
d193 1
a193 1
			nerrs += parseit(b->o.utf8, s, q->line);
@


1.17
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d124 1
a124 1
static int parseit(unsigned char *s, long int row)
d136 1
a136 1
		for (x = y; s[x] && !(isalnum_(s[x]) || s[x] == '.' || s[x] == '/'); ++x) ;
d139 1
a139 1
		for (y = x; isalnum_(s[y]) || s[y] == '.' || s[y] == '/'; ++y)
d193 1
a193 1
			nerrs += parseit(s, q->line);
@


1.16
log
@Slight improvement in error parser for ^[ c
@
text
@d31 1
a31 1
	char *file;		/* Target file name */
d33 1
a33 1
	char *msg;		/* The message */
d41 1
a41 1
void inserr(char *name, long int where, long int n, int bol)
d57 1
a57 1
void delerr(char *name, long int where, long int n)
d75 1
a75 1
void abrerr(char *name)
d87 1
a87 1
void saverr(char *name)
d124 1
a124 1
static int parseit(char *s, long int row)
d127 1
a127 1
	char *name = NULL;
d156 1
a156 1
		sscanf(s + x, "%ld", &line);
d187 1
a187 1
		char *s;
d206 1
a206 1
	snprintf(msgbuf, JOE_MSGBUFSIZE, "Parsed %ld lines", parserr(bw->b));
d216 1
a216 1
		msgnw(bw->parent, "No more errors");
d241 1
a241 1
		msgnw(bw->parent, "No more errors");
@


1.15
log
@change 0 to NULL where we're talking about pointers
@
text
@d120 4
d126 1
a126 1
	int x, y;
d131 12
a142 4
	/* Skip to first word */
	for (x = 0; s[x] && !(isalnum_(s[x]) || s[x] == '.' || s[x] == '/'); ++x) ;
	/* Skip to end of first word */
	for (y = x; isalnum_(s[y]) || s[y] == '.' || s[y] == '/'; ++y) ;
@


1.14
log
@fix segafults in isalpha()-like functions
@
text
@d37 1
a37 1
B *errbuf = 0;			/* Buffer with error messages */
d123 1
a123 1
	char *name = 0;
@


1.13
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d184 1
a184 1
	} while (pgetc(p) != MAXINT);
@


1.12
log
@change indentation of do {} while() cycles
@
text
@d34 1
a34 5
} errors = {

	{
	&errors, &errors}
};
d98 1
a98 2
ERROR errnodes = { {&errnodes, &errnodes}
};
@


1.11
log
@include only headers which are needed
@
text
@d189 1
a189 2
	}
	while (pgetc(p) != MAXINT);
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@a10 1
#include <string.h>
a12 1
#include "queue.h"
a13 3
#include "vs.h"
#include "ufile.h"
#include "w.h"
a14 2
#include "utils.h"
#include "ufile.h"
d16 1
a16 1
#include "uerror.h"
d18 4
@


1.9
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d1 9
a9 1
/* Compiler error handler */
@


1.8
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d195 1
a195 1
	snprintf(msgbuf, MSGBUFSIZE, "Parsed %ld lines", parserr(bw->b));
@


1.7
log
@version 2.9.7-pre3
@
text
@d196 1
a196 1
	msgnw(bw, msgbuf);
d205 1
a205 1
		msgnw(bw, "No more errors");
d221 1
a221 1
	msgnw(bw, errptr->msg);
d230 1
a230 1
		msgnw(bw, "No more errors");
d246 1
a246 1
	msgnw(bw, errptr->msg);
@


1.6
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d40 1
a40 4
void inserr(name, where, n, bol)
char *name;
long where;
long n;
d56 1
a56 4
void delerr(name, where, n)
char *name;
long where;
long n;
d74 1
a74 2
void abrerr(name)
char *name;
d86 1
a86 2
void saverr(name)
char *name;
d102 1
a102 2
void freeerr(n)
ERROR *n;
d111 1
a111 1
void freeall()
d120 1
a120 3
int parseit(s, row)
char *s;
long row;
d167 1
a167 2
long parserr(b)
B *b;
d191 1
a191 2
int uparserr(bw)
BW *bw;
d200 1
a200 2
int unxterr(bw)
BW *bw;
d225 1
a225 2
int uprverr(bw)
BW *bw;
@


1.5
log
@changed as of joe-2.9.6
@
text
@d23 1
a23 1
	LINK (ERROR) link;	/* Linked list of errors */
d29 5
a33 2
}
errors = { { &errors, &errors } };
d40 5
a44 1
void inserr (char *name, long where, long n, int bol) {
d49 2
a50 2
			if (!strcmp (e->file, name)) {
				if (e->line > where) {
d52 1
a52 1
				} else if (e->line == where && bol) {
a53 1
				}
d59 5
a63 1
void delerr (char *name, long where, long n) {
d68 2
a69 2
			if (!strcmp (e->file, name)) {
				if (e->line > where + n) {
d71 1
a71 1
				} else if (e->line > where) {
a72 1
				}
d80 3
a82 1
void abrerr (char *name) {
d84 4
a87 3
	if (name) {
		for (e = errors.link.next; e != &errors; e = e->link.next) {
			if (!strcmp (e->file, name)) {
a88 3
			}
		}
	}
d93 3
a95 1
void saverr (char *name) {
d97 4
a100 3
	if (name) {
		for (e = errors.link.next; e != &errors; e = e->link.next) {
			if (!strcmp (e->file, name)) {
a101 3
			}
		}
	}
d105 2
a106 1
ERROR errnodes = { {&errnodes, &errnodes} };
d110 6
a115 4
void freeerr (ERROR *n) {
	vsrm (n->file);
	vsrm (n->msg);
	enquef (ERROR, link, &errnodes, n);
d120 4
a123 4
void freeall () {
	while (!qempty (ERROR, link, &errors)) {
		freeerr (deque (ERROR, link, errors.link.next));
	}
d129 4
a132 1
int parseit (char *s, long row) {
d139 1
a139 1
	for (x = 0; s[x] && !(isalnum_ (s[x]) || s[x] == '.' || s[x] == '/'); ++x);
d141 1
a141 1
	for (y = x; isalnum_ (s[y]) || s[y] == '.' || s[y] == '/'; ++y);
d144 2
a145 3
	if (x != y) {
		name = vsncpy (NULL, 0, s + x, y - x);
	}
d148 1
a148 1
	for (x = y; s[x] && (s[x] < '0' || s[x] > '9'); ++x);
d151 1
a151 1
	for (y = x; s[y] >= '0' && s[y] <= '9'; ++y);
d154 3
a156 4
	if (x != y) {
		sscanf (s + x, "%ld", &line);
	}
	if (line != -1) {
d158 1
a158 1
	}
d161 11
a171 12
			  /* We have an error */
			  err = (ERROR *) alitem (&errnodes, sizeof (ERROR));
			  err->file = name;
			  err->org = err->line = line;
			  err->src = row;
			  err->msg = vsncpy (NULL, 0, sc ("\\i"));
			  err->msg = vsncpy (sv (err->msg), sv (s));
			  enqueb (ERROR, link, &errors, err);
			  return 1;
		} else {
			vsrm (name);
		}
d178 5
a182 3
long parserr (B *b) {
	P *p = pdup (b->bof);
	P *q = pdup (p);
d184 2
a185 1
	freeall ();
d188 4
a191 3
		pset (q, p);
		p_goto_eol (p);
		s = brvs (q, (int) (p->byte - q->byte));
d193 2
a194 2
			nerrs += parseit (s, q->line);
			vsrm (s);
d196 4
a199 3
	} while (pgetc (p) != MAXINT);
	prm (p);
	prm (q);
d203 3
a205 1
int uparserr (BW *bw) {
d207 3
a209 3
	freeall ();
	snprintf (msgbuf, MSGBUFSIZE, "Parsed %ld lines", parserr (bw->b));
	msgnw (bw, msgbuf);
d213 3
a215 1
int unxterr (BW *bw) {
d217 1
d219 2
a220 2
		  msgnw (bw, "No more errors");
		  return -1;
d223 2
a224 2
	if (!bw->b->name || strcmp (errptr->file, bw->b->name)) {
		if (doedit (bw, vsdup (errptr->file), NULL, NULL)) {
a225 1
		}
d230 3
a232 3
	pline (bw->cursor, errptr->line);
	setline (errbuf, errptr->src);
	dofollows ();
d234 2
a235 2
	bw->cursor->xcol = piscol (bw->cursor);
	msgnw (bw, errptr->msg);
d239 3
a241 1
int uprverr (BW *bw) {
d243 1
d245 1
a245 1
		msgnw (bw, "No more errors");
d249 2
a250 2
	if (!bw->b->name || strcmp (errptr->file, bw->b->name)) {
		if (doedit (bw, vsdup (errptr->file), NULL, NULL)) {
a251 1
		}
d256 3
a258 3
	pline (bw->cursor, errptr->line);
	setline (errbuf, errptr->src);
	dofollows ();
d260 2
a261 2
	bw->cursor->xcol = piscol (bw->cursor);
	msgnw (bw, errptr->msg);
@


1.4
log
@changed as of joe-2.9.5
@
text
@d4 2
d8 1
a8 1
#include "vs.h" 
d16 1
d22 10
a31 10
struct error
 {
 LINK(ERROR) link;	/* Linked list of errors */
 long line;			/* Target line number */
 long org;			/* Original target line number */
 char *file;			/* Target file name */
 long src;			/* Error-file line number */
 char *msg;			/* The message */
 } errors={{&errors,&errors}};
ERROR *errptr= &errors;	/* Current error row */
d33 1
a33 1
B *errbuf=0;		/* Buffer with error messages */
d37 31
a67 25
void inserr(name,where,n,bol)
char *name;
long where;
long n;
 {
 ERROR *e;
 if(name)
  for(e=errors.link.next;e!=&errors;e=e->link.next)
   if(!strcmp(e->file,name))
    if(e->line>where) e->line+=n;
    else if(e->line==where && bol) e->line+=n;
 }

void delerr(name,where,n)
char *name;
long where;
long n;
 {
 ERROR *e;
 if(name)
  for(e=errors.link.next;e!=&errors;e=e->link.next)
   if(!strcmp(e->file,name))
    if(e->line>where+n) e->line-=n;
    else if(e->line>where) e->line=where;
 }
d71 10
a80 8
void abrerr(name)
char *name;
 {
 ERROR *e;
 if(name)
  for(e=errors.link.next;e!=&errors;e=e->link.next)
   if(!strcmp(e->file,name)) e->line=e->org;
 }
d84 10
a93 8
void saverr(name)
char *name;
 {
 ERROR *e;
 if(name)
  for(e=errors.link.next;e!=&errors;e=e->link.next)
   if(!strcmp(e->file,name)) e->org=e->line;
 }
d96 1
a96 1
ERROR errnodes={{&errnodes,&errnodes}};
d100 5
a104 7
void freeerr(n)
ERROR *n;
 {
 vsrm(n->file);
 vsrm(n->msg);
 enquef(ERROR,link,&errnodes,n);
 }
d108 6
a113 6
void freeall()
 {
 while(!qempty(ERROR,link,&errors))
  freeerr(deque(ERROR,link,errors.link.next));
 errptr= &errors;
 }
d117 46
a162 43
int parseit(s,row)
char *s;
long row;
 {
 int x, y;
 char *name=0;
 long line= -1;
 ERROR *err;

 /* Skip to first word */
 for(x=0;s[x] && !(isalnum_(s[x]) || s[x]=='.' || s[x]=='/');++x);
 /* Skip to end of first word */
 for(y=x;isalnum_(s[y]) || s[y]=='.' || s[y]=='/';++y);

 /* Save file name */ 
 if(x!=y) name=vsncpy(NULL,0,s+x,y-x);
 
 /* Skip to first number */
 for(x=y;s[x] && (s[x]<'0' || s[x]>'9');++x);

 /* Skip to end of first number */
 for(y=x;s[y]>='0' && s[y]<='9';++y);
 
 /* Save line number */
 if(x!=y) sscanf(s+x,"%ld",&line);
 if(line!= -1) --line;

 if(name)
  if(line!= -1)
   {
   /* We have an error */
   err=(ERROR *)alitem(&errnodes,sizeof(ERROR));
   err->file=name;
   err->org=err->line=line;
   err->src=row;
   err->msg=vsncpy(NULL,0,sc("\\i"));
   err->msg=vsncpy(sv(err->msg),sv(s));
   enqueb(ERROR,link,&errors,err);
   return 1;
   }
  else vsrm(name);
 return 0;
 }
d166 75
a240 81
long parserr(b)
B *b;
 {
 P *p=pdup(b->bof);
 P *q=pdup(p);
 long nerrs=0;
 freeall();
 do
  {
  char *s;
  pset(q,p); peol(p);
  s=brvs(q,(int)(p->byte-q->byte));
  if(s)
   {
   nerrs+=parseit(s,q->line);
   vsrm(s);
   }
  } while(pgetc(p)!= MAXINT);
 prm(p); prm(q);
 return nerrs;
 }

int uparserr(bw)
BW *bw;
 {
 errbuf=bw->b;
 freeall();
 sprintf(msgbuf,"Parsed %ld lines",parserr(bw->b));
 msgnw(bw,msgbuf);
 return 0;
 }

int unxterr(bw)
BW *bw;
 {
 int omid;
 if(errptr->link.next==&errors)
  {
  msgnw(bw,"No more errors");
  return -1;
  }
 errptr=errptr->link.next;
 if(!bw->b->name || strcmp(errptr->file,bw->b->name))
  {
  if(doedit(bw,vsdup(errptr->file),NULL,NULL)) return -1;
  bw=(BW *)maint->curwin->object;
  }
 omid=mid; mid=1;
 pline(bw->cursor,errptr->line);
 setline(errbuf,errptr->src);
 dofollows();
 mid=omid;
 bw->cursor->xcol=piscol(bw->cursor);
 msgnw(bw,errptr->msg);
 return 0;
 }

int uprverr(bw)
BW *bw;
 {
 int omid;
 if(errptr->link.prev==&errors)
  {
  msgnw(bw,"No more errors");
  return -1;
  }
 errptr=errptr->link.prev;
 if(!bw->b->name || strcmp(errptr->file,bw->b->name))
  {
  if(doedit(bw,vsdup(errptr->file),NULL,NULL)) return -1;
  bw=(BW *)maint->curwin->object;
  }
 omid=mid; mid=1;
 pline(bw->cursor,errptr->line);
 setline(errbuf,errptr->src);
 dofollows();
 mid=omid;
 bw->cursor->xcol=piscol(bw->cursor);
 msgnw(bw,errptr->msg);
 return 0;
 }
@


1.3
log
@changed as of joe-2.9.4
@
text
@d10 1
a10 1
#include "zstr.h"
@


1.2
log
@changed as of joe-2.9.2
@
text
@d116 1
a116 1
 for(x=0;s[x] && !(crest(s[x]) || s[x]=='.' || s[x]=='/');++x);
d118 1
a118 1
 for(y=x;crest(s[y]) || s[y]=='.' || s[y]=='/';++y);
@


1.1
log
@Initial revision
@
text
@d3 1
d42 1
a42 1
   if(!zcmp(e->file,name))
d55 1
a55 1
   if(!zcmp(e->file,name))
d68 1
a68 1
   if(!zcmp(e->file,name)) e->line=e->org;
d79 1
a79 1
   if(!zcmp(e->file,name)) e->org=e->line;
d194 1
a194 1
 if(!bw->b->name || zcmp(errptr->file,bw->b->name))
d219 1
a219 1
 if(!bw->b->name || zcmp(errptr->file,bw->b->name))
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
