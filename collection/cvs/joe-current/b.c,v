head	1.102;
access;
symbols
	joe_3_5:1.84
	joe-3_4:1.77
	help:1.77
	joe_3_1:1.49
	joe_3_0:1.37
	joe_2_9_8:1.26
	joe_2_9_8_pre1:1.15
	joe_2_9_7:1.8
	joe_2_9_7_pre3:1.8
	joe_2_9_7_pre2:1.7
	joe_2_9_6:1.6
	joe_2_9_5:1.5
	joe_2_9_4:1.4
	joe_2_9_2:1.3
	joe_2_9_1:1.2
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.102
date	2008.11.23.21.54.30;	author jhallen;	state Exp;
branches;
next	1.101;

1.101
date	2008.11.02.20.20.40;	author jhallen;	state Exp;
branches;
next	1.100;

1.100
date	2008.11.01.02.39.20;	author jhallen;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.01.02.26.04;	author jhallen;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.01.02.07.46;	author jhallen;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.01.00.50.29;	author jhallen;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.29.18.51.34;	author jhallen;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.29.16.58.33;	author jhallen;	state Exp;
branches;
next	1.94;

1.94
date	2008.10.29.02.40.47;	author jhallen;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.29.02.06.05;	author jhallen;	state Exp;
branches;
next	1.92;

1.92
date	2008.10.29.01.45.38;	author jhallen;	state Exp;
branches;
next	1.91;

1.91
date	2008.10.28.22.55.41;	author jhallen;	state Exp;
branches;
next	1.90;

1.90
date	2008.10.27.17.18.22;	author jhallen;	state Exp;
branches;
next	1.89;

1.89
date	2008.10.26.23.34.41;	author jhallen;	state Exp;
branches;
next	1.88;

1.88
date	2008.10.25.01.02.36;	author jhallen;	state Exp;
branches;
next	1.87;

1.87
date	2008.10.23.21.53.49;	author jhallen;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.10.22.24.47;	author shallot;	state Exp;
branches;
next	1.85;

1.85
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.18.23.31.53;	author jhallen;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.18.23.16.08;	author jhallen;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.17.22.32.02;	author jhallen;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.13.20.12.33;	author jhallen;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.15.18.18.28;	author jhallen;	state Exp;
branches;
next	1.78;

1.78
date	2006.06.07.01.56.34;	author jhallen;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.24.16.04.14;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.21.18.03.34;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.21.16.29.49;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.19.17.00.56;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.14.18.13.27;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.05.20.20.17;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.05.19.17.05;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.04.00.57.37;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.04.00.41.01;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.03.21.01.30;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.08.03.00.56;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2006.02.22.18.44.33;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.10.18.24.28;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.24.04.30.49;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.22.03.22.36;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.20.00.58.24;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.19.01.22.41;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.16.00.00.54;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.14.19.29.45;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.14.03.21.35;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.14.00.22.52;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.14.00.07.49;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.21.14.47.36;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.27.14.06.33;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.26.22.20.08;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.14.04.23.02;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.13.00.23.45;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.11.20.02.49;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.11.13.56.10;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.11.00.33.25;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.10.16.06.34;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.04.16.35.11;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.03.22.55.39;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.03.12.17.01;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.25.15.52.36;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.23.17.56.39;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.22.03.40.20;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.22.00.57.08;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.16.21.10.14;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.14.17.09.47;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.12.20.11.16;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.12.13.58.26;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.09.22.01.06;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.09.18.48.47;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.08.15.20.38;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.19.02.11.48;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.20.07.18.18;	author vsamel;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.20.07.16.06;	author vsamel;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.02.10.47.27;	author vsamel;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.10.12.11.52;	author vsamel;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.10.12.09.38;	author vsamel;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.13.15.31.08;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.13.15.30.28;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.13.15.29.37;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.13.15.29.05;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.04.13.20.50;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.33;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.31;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.35.52;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.14.39.51;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.04.38.36;	author polesapart;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.48.08;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.32;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.32;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.102
log
@Fix pfwrd/pbkwd documentation.
@
text
@ /*
 *	Editor engine
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef HAVE_PWD_H
#include <pwd.h>
#endif

#ifndef S_ISLNK
#ifdef S_IFLNK
#define S_ISLNK(n) (((n) & (S_IFMT)) == (S_IFLNK))
#else
#define S_ISLNK(n) (0)
#endif
#endif

extern int errno;

#ifdef WITH_SELINUX
#include <selinux/selinux.h>
static int selinux_enabled = -1;
#endif

int guesscrlf = 0;
int guessindent = 0;

int berror;
int force = 0;
VFILE *vmem;

unsigned char *msgs[] = {
	USTR _("No error"),
	USTR _("New File"),
	USTR _("Error reading file"),
	USTR _("Error seeking file"),
	USTR _("Error opening file"),
	USTR _("Error writing file"),
	USTR _("File on disk is newer")
};

/* Get size of gap (amount of free space) */
#define GGAPSZ(hdr) ((hdr)->ehole - (hdr)->hole)

/* Get number of characters in gap buffer */
#define GSIZE(hdr) (SEGSIZ - GGAPSZ(hdr))

/* Get char from buffer (with jumping around the gap) */
#define GCHAR(p) ((p)->ofst >= (p)->hdr->hole ? (p)->ptr[(p)->ofst + GGAPSZ((p)->hdr)] \
					      : (p)->ptr[(p)->ofst])

/* Set position of gap */
static void gstgap(H *hdr, unsigned char *ptr, int ofst)
{
	if (ofst > hdr->hole) {
		mmove(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole);
		vchanged(ptr);
	} else if (ofst < hdr->hole) {
		mmove(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst);
		vchanged(ptr);
	}
	hdr->ehole = ofst + hdr->ehole - hdr->hole;
	hdr->hole = ofst;
}

/* Insert a block */
static void ginsm(H *hdr, unsigned char *ptr, int ofst, unsigned char *blk, int size)
{
	if (ofst != hdr->hole)
		gstgap(hdr, ptr, ofst);
	mmove(ptr + hdr->hole, blk, size);
	hdr->hole += size;
	vchanged(ptr);
}

/* Read block */
static void grmem(H *hdr, unsigned char *ptr, int ofst, unsigned char *blk, int size)
{
	if (ofst < hdr->hole)
		if (size > hdr->hole - ofst) {
			mmove(blk, ptr + ofst, hdr->hole - ofst);
			mmove(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
		} else
			mmove(blk, ptr + ofst, size);
	else
		mmove(blk, ptr + ofst + hdr->ehole - hdr->hole, size);
}


static H nhdrs = { {&nhdrs, &nhdrs} };
static H ohdrs = { {&ohdrs, &ohdrs} };

/* Header allocation */
static H *halloc(void)
{
	H *h;

	if (qempty(H, link, &ohdrs)) {
		h = (H *) alitem(&nhdrs, sizeof(H));
		h->seg = my_valloc(vmem, (long) SEGSIZ);
	} else
		h = deque_f(H, link, ohdrs.link.next);
	h->hole = 0;
	h->ehole = SEGSIZ;
	h->nlines = 0;
	izque(H, link, h);
	return h;
}

static void hfree(H *h)
{
	enquef(H, link, &ohdrs, h);
}

static void hfreechn(H *h)
{
	splicef(H, link, &ohdrs, h);
}


static P frptrs = { {&frptrs, &frptrs} };

/* Pointer allocation */
static P *palloc(void)
{
	return alitem(&frptrs, sizeof(P));
}

static void pfree(P *p)
{
	enquef(P, link, &frptrs, p);
}

/* Doubly linked list of buffers and free buffer structures */
B bufs = { {&bufs, &bufs} };
static B frebufs = { {&frebufs, &frebufs} };

void set_file_pos_orphaned()
{
	B *b;
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->orphan && b->oldcur)
			set_file_pos(b->name,b->oldcur->line);
}

/* Find next buffer in list: for multi-file search and replace */
/* This does not bump reference count on found buffer */

B *bafter(B *b)
{
	for (b = b->link.next; b->internal || b->scratch || b == &bufs; b = b->link.next);
	return b;
}

int udebug_joe(BW *bw)
{
	unsigned char *buf = vsmk(128);

	B *b;
	P *p;

	binss(bw->cursor, USTR "Buffers and pointers (the number of pointers per buffer should not grow, except for 20 from markpos):\n\n");
	pnextl(bw->cursor);

	for (b = bufs.link.next; b != &bufs; b = b->link.next) {
		if (b->name)
			buf = vsfmt(buf, 0, USTR "Buffer %s\n", b->name);
		else
			buf = vsfmt(buf, 0, USTR "Buffer 0x%p\n", (void *)b);
		binss(bw->cursor, buf);
		pnextl(bw->cursor);
		for (p = b->bof->link.next; p != b->bof; p = p->link.next) {
			buf = vsfmt(buf, 0, USTR "  Pointer created by %s\n", p->tracker);
			binss(bw->cursor, buf);
			pnextl(bw->cursor);
		}
	}
	dump_syntax(bw);
	return 0;
}

B *bnext(void)
{
	B *b;

	do {
		b = bufs.link.prev;
		deque(B, link, &bufs);
		enqueb(B, link, b, &bufs);
	} while (b->internal);
	return b;
}

B *bprev(void)
{
	B *b;

	do {
		b = bufs.link.next;
		deque(B, link, &bufs);
		enquef(B, link, b, &bufs);
	} while (b->internal);
	return b;
}

/* Make a buffer out of a chain */
static B *bmkchn(H *chn, B *prop, long amnt, long nlines)
{
	B *b = alitem(&frebufs, sizeof(B));

	b->undo = undomk(b);
	if (prop)
		b->o = prop->o;
	else
		b->o = pdefault;
	mset(b->marks, 0, sizeof(b->marks));
	b->rdonly = 0;
	b->orphan = 0;
	b->oldcur = NULL;
	b->oldtop = NULL;
	b->backup = 1;
	b->internal = 1;
	b->scratch = 0;
	b->changed = 0;
	b->gave_notice = 0;
	b->locked = 0;
	b->ignored_lock = 0;
	b->didfirst = 0;
	b->count = 1;
	b->name = NULL;
	b->er = -3;
	b->bof = palloc();
	b->mod_time = 0;
	b->check_time = time(NULL);
	izque(P, link, b->bof);
	b->bof->end = 0;
	b->bof->b = b;
	b->bof->owner = NULL;
	b->bof->hdr = chn;
	b->bof->ptr = vlock(vmem, b->bof->hdr->seg);
	b->bof->ofst = 0;
	b->bof->byte = 0;
	b->bof->line = 0;
	b->bof->col = 0;
	b->bof->xcol = 0;
	b->bof->valcol = 1;
	b->bof->tracker = USTR "bmkchn";
	b->eof = pdup(b->bof, USTR "bmkchn");
	b->eof->end = 1;
	vunlock(b->eof->ptr);
	b->eof->hdr = chn->link.prev;
	b->eof->ptr = vlock(vmem, b->eof->hdr->seg);
	b->eof->ofst = GSIZE(b->eof->hdr);
	b->eof->byte = amnt;
	b->eof->line = nlines;
	b->eof->valcol = 0;
	b->pid = 0;
	b->out = -1;
	b->db = 0;
	b->parseone = 0;
	enquef(B, link, &bufs, b);
	pcoalesce(b->bof);
	pcoalesce(b->eof);
	return b;
}

/* Create an empty buffer */
B *bmk(B *prop)
{
	return bmkchn(halloc(), prop, 0L, 0L);
}

/* Eliminate a buffer */
void brm(B *b)
{
	if (b && !--b->count) {
		if (b->changed)
			abrerr(b->name);
		if (b->locked && !b->ignored_lock && plain_file(b))
			unlock_it(b->name);
		if (b == errbuf)
			errbuf = NULL;
		if (b->undo)
			undorm(b->undo);
		if (b->eof) {
			hfreechn(b->eof->hdr);
			while (!qempty(P, link, b->bof))
				prm(b->bof->link.next);
			prm(b->bof);
		}
		if (b->name)
			joe_free(b->name);
		if (b->db)
			rm_all_lattr_db(b->db);
		demote(B, link, &frebufs, b);
	}
}

void brmall()
{
	while (!qempty(B, link, &bufs))
		brm(bufs.link.next);
}

/* Replace contents of b with n.  n is destroyed. */

void breplace(B *b, B *n)
{
	P *p, *next;

	/* Take out many references to b */

	abrerr(b->name);

	if (b->locked && !b->ignored_lock && plain_file(b)) {
		unlock_it(b->name);
		b->locked = 0;
	}

	if (b == errbuf)
		errbuf = NULL;

	if (b->undo) {
		undorm(b->undo);
		b->undo = 0;
	}

	/* Remove all vfile references */
	for (p = b->eof->link.next; p != b->eof; p = p->link.next)
		if (p->ptr)
			vunlock(p->ptr);
	if (b->eof->ptr)
		vunlock(b->eof->ptr);

	/* Delete buffer */
	hfreechn(b->eof->hdr);

	/* Delete file name */
	if (b->name)
		joe_free(b->name);

	reset_all_lattr_db(b->db);
	
	/* Take new name */
	b->name = zdup(n->name);

	/* Take bof Pointer */
	/* Taking n->bof's vlock */
	b->bof->ofst = n->bof->ofst;
	b->bof->ptr = n->bof->ptr;
	b->bof->hdr = n->bof->hdr;
	b->bof->byte = 0;
	b->bof->line = 0;
	b->bof->col = 0;
	b->bof->xcol = 0;
	b->bof->valcol = 1;
	b->bof->end = 0;

	/* Take eof Pointer */
	/* Taking b->eof's vlock */
	b->eof->ofst = n->eof->ofst;
	b->eof->ptr = n->eof->ptr;
	b->eof->hdr = n->eof->hdr;
	b->eof->byte = n->eof->byte;
	b->eof->line = n->eof->line;
	b->eof->col = n->eof->col;
	b->eof->xcol = n->eof->xcol;
	b->eof->valcol = n->eof->valcol;
	b->eof->end = 1;

	/* Reset other pointers */
	for (p = b->eof->link.next; p != b->eof; p = p->link.next)
		if (p != b->bof) {
			long goal_line = p->line;
			long goal_col = p->xcol;
			p->ptr = 0; /* No need for pset to unlock: we already did it */
			if (goal_line > b->eof->line) {
				pset(p, b->eof);
				p_goto_bol(p);
			} else {
				pset(p, b->bof);
				pline(p, goal_line);
				pcol(p, goal_col);
			}
		}

	/* OK, delete pointers from n */
	for (p = n->eof->link.next; p != n->eof; p = next) {
		next = p->link.next;
		if (p != n->bof)
			prm(p);
	}

	/* Delete bof and eof pointers */
	/* Don't delete their locks, they were transferred. */
	n->bof->ptr = 0;
	prm(n->bof);
	n->bof = 0;
	n->eof->ptr = 0;
	prm(n->eof);
	n->eof = 0;

	b->undo = undomk(b);
	b->changed = 0;
	b->rdonly = n->rdonly;
	b->mod_time = n->mod_time;

	/* Delete rest of n */
	brm(n);
}

P *poffline(P *p)
{
	if (p->ptr) {
		vunlock(p->ptr);
		p->ptr = NULL;
	}
	return p;
}

P *ponline(P *p)
{
	if (!p->ptr)
		p->ptr = vlock(vmem, p->hdr->seg);
	return p;
}

B *boffline(B *b)
{
	P *p = b->bof;

	do {
		poffline(p);
	} while ((p = p->link.next) != b->bof);
	return b;
}

B *bonline(B *b)
{
	P *p = b->bof;

	do {
		ponline(p);
	} while ((p = p->link.next) != b->bof);
	return b;
}

P *pdup(P *p, unsigned char *tr)
{
	P *n = palloc();

	n->end = 0;
	n->ptr = NULL;
	n->owner = NULL;
	n->tracker = tr;
	enquef(P, link, p, n);
	return pset(n, p);
}

P *pdupown(P *p, P **o, unsigned char *tr)
{
	P *n = palloc();

	n->end = 0;
	n->ptr = NULL;
	n->owner = o;
	n->tracker = tr;
	enquef(P, link, p, n);
	pset(n, p);
	if (*o)
		prm(*o);
	*o = n;
	return n;
}

void prm(P *p)
{
	if (!p)
		return;
	if (p->owner)
		*p->owner = NULL;
	if (p->ptr)
		vunlock(p->ptr);
	pfree(deque_f(P, link, p));
}

P *pset(P *n, P *p)
{
	if (n != p) {
		n->b = p->b;
		n->ofst = p->ofst;
		n->hdr = p->hdr;
		if (n->ptr)
			vunlock(n->ptr);
		if (p->ptr) {
			n->ptr = p->ptr;
			vupcount(n->ptr);
		} else
			n->ptr = vlock(vmem, n->hdr->seg);
		n->byte = p->byte;
		n->line = p->line;
		n->col = p->col;
		n->valcol = p->valcol;
	}
	return n;
}

P *p_goto_bof(P *p)
{
	return pset(p, p->b->bof);
}

P *p_goto_eof(P *p)
{
	return pset(p, p->b->eof);
}

/* is p at the beginning of file? */
int pisbof(P *p)
{
	return p->hdr == p->b->bof->hdr && !p->ofst;
}

/* is p at the end of file? */
int piseof(P *p)
{
	return p->ofst == GSIZE(p->hdr);
}

/* is p at the end of line? */
int piseol(P *p)
{
	int c;

	if (piseof(p))
		return 1;
	c = brc(p);
	if (c == '\n')
		return 1;
	if (p->b->o.crlf)
		if (c == '\r') {
			P *q = pdup(p, USTR "piseol");

			pfwrd(q, 1L);
			if (pgetb(q) == '\n') {
				prm(q);
				return 1;
			} else
				prm(q);
		}
	return 0;
}

/* is p at the beginning of line? */
int pisbol(P *p)
{
	int c;

	if (pisbof(p))
		return 1;
	c = prgetb(p);
	pgetb(p);
	return c == '\n';
}

/* is p at the beginning of word? */
int pisbow(P *p)
{
	P *q = pdup(p, USTR "pisbow");
	int c = brc(p);
	int d = prgetc(q);

	prm(q);
	if (joe_isalnum_(p->b->o.charmap,c) && (!joe_isalnum_(p->b->o.charmap,d) || pisbof(p)))
		return 1;
	else
		return 0;
}

/* is p at the end of word? */
int piseow(P *p)
{
	P *q = pdup(p, USTR "piseow");
	int d = brc(q);
	int c = prgetc(q);

	prm(q);
	if (joe_isalnum_(p->b->o.charmap,c) && (!joe_isalnum_(p->b->o.charmap,d) || piseof(p)))
		return 1;
	else
		return 0;
}

/* is p on the blank line (ie. full of spaces/tabs)? */
int pisblank(P *p)
{
	P *q = pdup(p, USTR "pisblank");

	p_goto_bol(q);
	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetb(q);
	if (piseol(q)) {
		prm(q);
		return 1;
	} else {
		prm(q);
		return 0;
	}
}

/* is p at end of line or spaces followed by end of line? */
int piseolblank(P *p)
{
	P *q = pdup(p, USTR "piseolblank");

	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetb(q);
	if (piseol(q)) {
		prm(q);
		return 1;
	} else {
		prm(q);
		return 0;
	}
}

/* return column of first nonblank character */
long pisindent(P *p)
{
	P *q = pdup(p, USTR "pisindent");
	long col;

	p_goto_bol(q);
	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetc(q);
	col = q->col;
	prm(q);
	return col;
}

/* return true if all characters to left of cursor match c */

int pispure(P *p,int c)
{
	P *q = pdup(p, USTR "pispure");
	p_goto_bol(q);
	while (q->byte!=p->byte)
		if (pgetc(q)!=c) {
			prm(q);
			return 0;
                }
	prm(q);
	return 1;
}

int pnext(P *p)
{
	if (p->hdr == p->b->eof->hdr) {
		p->ofst = GSIZE(p->hdr);
		return 0;
	}
	p->hdr = p->hdr->link.next;
	p->ofst = 0;
	vunlock(p->ptr);
	p->ptr = vlock(vmem, p->hdr->seg);
	return 1;
}

int pprev(P *p)
{
	if (p->hdr == p->b->bof->hdr) {
		p->ofst = 0;
		return 0;
	}
	p->hdr = p->hdr->link.prev;
	p->ofst = GSIZE(p->hdr);
	vunlock(p->ptr);
	p->ptr = vlock(vmem, p->hdr->seg);
	return 1;
}

/* return current byte and move p to the next byte.  column will be unchanged. */
int pgetb(P *p)
{
	unsigned char c;

	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	c = GCHAR(p);
	if (++p->ofst == GSIZE(p->hdr))
		pnext(p);
	++p->byte;
	if (c == '\n') {
		++(p->line);
		p->col = 0;
		p->valcol = 1;
	} else if (p->b->o.crlf && c == '\r') {
		if (brc(p) == '\n')
			return pgetb(p);
		else
			p->valcol = 0;
	} else {
		p->valcol = 0;
	}
	return c;
}

/* return current character and move p to the next character.  column will be updated if it was valid. */
int pgetc(P *p)
{
	if (p->b->o.charmap->type) {
		int val;
		int c; /* , oc; */
		int d;
		int n; /* , m; */
		int wid;

		val = p->valcol;	/* Remember if column number was valid */
		c = pgetb(p);		/* Get first byte */
		/* oc = c; */

		if (c==NO_MORE_DATA)
			return c;

		if ((c&0xE0)==0xC0) { /* Two bytes */
			n = 1;
			c &= 0x1F;
		} else if ((c&0xF0)==0xE0) { /* Three bytes */
			n = 2;
			c &= 0x0F;
		} else if ((c&0xF8)==0xF0) { /* Four bytes */
			n = 3;
			c &= 0x07;
		} else if ((c&0xFC)==0xF8) { /* Five bytes */
			n = 4;
			c &= 0x03;
		} else if ((c&0xFE)==0xFC) { /* Six bytes */
			n = 5;
			c &= 0x01;
		} else if ((c&0x80)==0x00) { /* One byte */
			n = 0;
		} else { /* 128-191, 254, 255: Not a valid UTF-8 start character */
			n = 0;
			c = 'X';
			/* c -= 384; */
		}

		/* m = n; */

		if (n) {
			while (n) {
				d = brc(p);
				if ((d&0xC0)!=0x80)
					break;
				pgetb(p);
				c = ((c<<6)|(d&0x3F));
				--n;
			}
			if (n) { /* FIXME: there was a bad UTF-8 sequence */
				/* How to represent this? */
				/* pbkwd(p,m-n);
				c = oc - 384; */
				c = 'X';
				wid = 1;
			} else if (val)
				wid = joe_wcwidth(1,c);
		} else {
			wid = 1;
		}

		if (val) { /* Update column no. if it was valid to start with */
			p->valcol = 1;
			if (c=='\t')
				p->col += (p->b->o.tab) - (p->col) % (p->b->o.tab);
			else if (c=='\n')
				p->col = 0;
			else
				p->col += wid;
		}

		return c;
	} else {
		unsigned char c;

		if (p->ofst == GSIZE(p->hdr))
			return NO_MORE_DATA;
		c = GCHAR(p);
		if (++p->ofst == GSIZE(p->hdr))
			pnext(p);
		++p->byte;

		if (c == '\n') {
			++(p->line);
			p->col = 0;
			p->valcol = 1;
		} else if (p->b->o.crlf && c == '\r') {
			if (brc(p) == '\n')
				return pgetc(p);
			else
				++p->col;
		} else {
			if (c == '\t')
				p->col += (p->b->o.tab) - (p->col) % (p->b->o.tab);
			else
				++(p->col);
		}
		return c;
	}
}

/* move p n bytes forward */
P *pfwrd(P *p, long n)
{
	if (!n)
		return p;
	p->valcol = 0;
	do {
		if (p->ofst == GSIZE(p->hdr))
			do {
				if (!p->ofst) {
					p->byte += GSIZE(p->hdr);
					n -= GSIZE(p->hdr);
					p->line += p->hdr->nlines;
				}
				if (!pnext(p))
					return NULL;
			} while (n > GSIZE(p->hdr));
		if (GCHAR(p) == '\n')
			++p->line;
		++p->byte;
		++p->ofst;
	} while (--n);
	if (p->ofst == GSIZE(p->hdr))
		pnext(p);
	return p;
}

/* move p to the previous byte: does not take into account -crlf mode */
static int prgetb1(P *p)
{
	unsigned char c;

	if (!p->ofst)
		if (!pprev(p))
			return NO_MORE_DATA;
	--p->ofst;
	c = GCHAR(p);
	--p->byte;
	p->valcol = 0;
	if (c == '\n')
		--p->line;
	return c;
}

/* move p to the previous byte */
int prgetb(P *p)
{
	int c = prgetb1(p);

	if (p->b->o.crlf && c == '\n') {
		c = prgetb1(p);
		if (c == '\r')
			return '\n';
		if (c != NO_MORE_DATA)
			pgetb(p);
		c = '\n';
	}
	return c;
}

/* move p to the previous character (try to keep col updated) */
int prgetc(P *p)
{
	if (p->b->o.charmap->type) {

		if (pisbol(p))
			return prgetb(p);
		else {
			P *q = pdup(p, USTR "prgetc");
			P *r;
			p_goto_bol(q);
			r = pdup(q, USTR "prgetc");
			while (q->byte<p->byte) {
				pset(r, q);
				pgetc(q);
			}
			pset(p,r);
			prm(r);
			prm(q);
			return brch(p);
		}

#if 0
		int d = 0;
		int c;
		int n = 0;
		int val = p->valcol;
		for(;;) {
			c = prgetb(p);
			if (c == NO_MORE_DATA)
				return NO_MORE_DATA;
			else if ((c&0xC0)==0x80) {
				d |= ((c&0x3F)<<n);
				n += 6;
			} else if ((c&0x80)==0x00) { /* One char */
				d = c;
				break;
			} else if ((c&0xE0)==0xC0) { /* Two chars */
				d |= ((c&0x1F)<<n);
				break;
			} else if ((c&0xF0)==0xE0) { /* Three chars */
				d |= ((c&0x0F)<<n);
				break;
			} else if ((c&0xF8)==0xF0) { /* Four chars */
				d |= ((c&0x07)<<n);
				break;
			} else if ((c&0xFC)==0xF8) { /* Five chars */
				d |= ((c&0x03)<<n);
				break;
			} else if ((c&0xFE)==0xFC) { /* Six chars */
				d |= ((c&0x01)<<n);
				break;
			} else { /* FIXME: Invalid (0xFE or 0xFF found) */
				break;
			}
		}

		if (val && c!='\t' && c!='\n') {
			p->valcol = 1;
			p->col -= joe_wcwidth(1,d);
		}
		
		return d;
#endif
	}
	else {
		return prgetb(p);
	}
}

/* move p n bytes backwards */
P *pbkwd(P *p, long n)
{
	if (!n)
		return p;
	p->valcol = 0;
	do {
		if (!p->ofst)
			do {
				if (p->ofst) {
					p->byte -= p->ofst;
					n -= p->ofst;
					p->line -= p->hdr->nlines;
				}
				if (!pprev(p))
					return NULL;
			} while (n > GSIZE(p->hdr));
		--p->ofst;
		--p->byte;
		if (GCHAR(p) == '\n')
			--p->line;
	} while (--n);
	return p;
}

/* move p n characters forwards/backwards according to loc */
P *pgoto(P *p, long loc)
{
	if (loc > p->byte)
		pfwrd(p, loc - p->byte);
	else if (loc < p->byte)
		pbkwd(p, p->byte - loc);
	return p;
}

/* make p->col valid */
P *pfcol(P *p)
{
	long pos = p->byte;

	p_goto_bol(p);
	while (p->byte < pos)
		pgetc(p);
	return p;
}

/* move p to the beginning of line */
P *p_goto_bol(P *p)
{
	if (pprevl(p))
		pgetb(p);
	p->col = 0;
	p->valcol = 1;
	return p;
}

/* move p to the indentation point */
P *p_goto_indent(P *p, int c)
{
	int d;
	p_goto_bol(p);
	while ((d=brc(p)), d==c || ((c==' ' || c=='\t') && (d==' ' || d=='\t')))
		pgetc(p);
	return p;
}

/* move p to the end of line */
P *p_goto_eol(P *p)
{
	if (p->b->o.crlf || p->b->o.charmap->type)
		while (!piseol(p))
			pgetc(p);
	else
		while (p->ofst != GSIZE(p->hdr)) {
			unsigned char c;

			c = GCHAR(p);
			if (c == '\n')
				break;
			else {
				++p->byte;
				++p->ofst;
				if (c == '\t')
					p->col += p->b->o.tab - p->col % p->b->o.tab;
				else
					++p->col;
				if (p->ofst == GSIZE(p->hdr))
					pnext(p);
			}
		}
	return p;
}

/* move p to the beginning of next line */
P *pnextl(P *p)
{
	int c;

	do {
		if (p->ofst == GSIZE(p->hdr))
			do {
				p->byte += GSIZE(p->hdr) - p->ofst;
				if (!pnext(p))
					return NULL;
			} while (!p->hdr->nlines);
		c = GCHAR(p);
		++p->byte;
		++p->ofst;
	} while (c != '\n');
	++p->line;
	p->col = 0;
	p->valcol = 1;
	if (p->ofst == GSIZE(p->hdr))
		pnext(p);
	return p;
}

/* move p to the end of previous line */
P *pprevl(P *p)
{
	int c;

	p->valcol = 0;
	do {
		if (!p->ofst)
			do {
				p->byte -= p->ofst;
				if (!pprev(p))
					return NULL;
			} while (!p->hdr->nlines);
		--p->ofst;
		--p->byte;
		c = GCHAR(p);
	} while (c != '\n');
	--p->line;
	if (p->b->o.crlf && c == '\n') {
		int k = prgetb1(p);

		if (k != '\r' && k != NO_MORE_DATA)
			pgetb(p);
	}
	return p;
}

/* move p to the given 'line' line */
P *pline(P *p, long line)
{
	if (line > p->b->eof->line) {
		pset(p, p->b->eof);
		return p;
	}
	if (line < labs(p->line - line)) {
		pset(p, p->b->bof);
	}
	if (labs(p->b->eof->line - line) < labs(p->line - line)) {
		pset(p, p->b->eof);
	}
	if (p->line == line) {
		p_goto_bol(p);
		return p;
	}
	while (line > p->line)
		pnextl(p);
	if (line < p->line) {
		while (line < p->line)
			pprevl(p);
		p_goto_bol(p);
	}
	return p;
}

/* move p to the given 'goalcol' column */
/* lands at exact column or on character which would cause us to go past goalcol */
P *pcol(P *p, long goalcol)
{
	p_goto_bol(p);
	if(p->b->o.charmap->type) {
		do {
			int c;
			int wid;

			c = brch(p);

			if (c == NO_MORE_DATA)
				break;

			if (c == '\n')
				break;

			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;

			if (c == '\t')
				wid = p->b->o.tab - p->col % p->b->o.tab;
			else
				wid = joe_wcwidth(1,c);

			if (p->col + wid > goalcol)
				break;

			pgetc(p);
		} while (p->col != goalcol);
	} else {
		do {
			unsigned char c;
			int wid;

			if (p->ofst == GSIZE(p->hdr))
				break;
			c = GCHAR(p);
			if (c == '\n')
				break;
			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;
			if (c == '\t')
				wid = p->b->o.tab - p->col % p->b->o.tab;
			else
				wid = 1;
			if (p->col + wid > goalcol)
				break;
			if (++p->ofst == GSIZE(p->hdr))
				pnext(p);
			++p->byte;
			p->col += wid;
		} while (p->col != goalcol);
	}
	return p;
}

/* Move to goal column, then skip backwards to just after first non-whitespace character */
P *pcolwse(P *p, long goalcol)
{
	int c;

	pcol(p, goalcol);
	do {
		c = prgetc(p);
	} while (c == ' ' || c == '\t');
	if (c != NO_MORE_DATA)
		pgetc(p);
	return p;
}

/* Move p to goalcol: stops after first character which equals or exceeds goal col (unlike
   pcol() which will stops before character which would exceed goal col) */
P *pcoli(P *p, long goalcol)
{
	p_goto_bol(p);
	if (p->b->o.charmap->type) {
		while (p->col < goalcol) {
			int c;
			c = brc(p);

			if (c == NO_MORE_DATA)
				break;

			if (c == '\n')
				break;

			if (p->b->o.crlf && c=='\r' && piseol(p))
				break;

			pgetc(p);
		}
	} else {
		while (p->col < goalcol) {
			unsigned char c;

			if (p->ofst == GSIZE(p->hdr))
				break;
			c = GCHAR(p);
			if (c == '\n')
				break;

			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;

			if (c == '\t')
				p->col += p->b->o.tab - p->col % p->b->o.tab;
			else
				++p->col;
			if (++p->ofst == GSIZE(p->hdr))
				pnext(p);
			++p->byte;
		}
	}
	return p;
}

/* fill space between curent column and 'to' column with tabs/spaces */
void pfill(P *p, long to, int usetabs)
{
	if (usetabs=='\t')
		while (piscol(p) < to)
			if (p->col + p->b->o.tab - p->col % p->b->o.tab <= to) {
				binsc(p, '\t');
				pgetc(p);
			} else {
				binsc(p, ' ');
				pgetc(p);
			}
	else
		while (piscol(p) < to) {
			binsc(p, usetabs);
			pgetc(p);
		}
}

/* delete sequence of whitespaces - backwards */
void pbackws(P *p)
{
	int c;
	P *q = pdup(p, USTR "pbackws");

	do {
		c = prgetc(q);
	} while (c == ' ' || c == '\t');
	if (c != NO_MORE_DATA)
		pgetc(q);
	bdel(q, p);
	prm(q);
}

static int frgetc(P *p)
{
	if (!p->ofst)
		pprev(p);
	--p->ofst;
	return GCHAR(p);
}

static void ffwrd(P *p, int n)
{
	while (n > GSIZE(p->hdr) - p->ofst) {
		n -= GSIZE(p->hdr) - p->ofst;
		if (!pnext(p))
			return;
	}
	if ((p->ofst += n) == GSIZE(p->hdr))
		pnext(p);
}

/* forward find pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *ffind(P *p, unsigned char *s, int len)
{
	long amnt = p->b->eof->byte - p->byte;
	int x;
	unsigned char table[256], c;

	if (len > amnt)
		return NULL;
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = 0; x != len - 1; ++x)
		table[s[x]] = x;
	ffwrd(p, len);
	amnt -= len;
	x = len;
	do {
		if ((c = frgetc(p)) != s[--x]) {
			if (table[c] == 255) {
				ffwrd(p, len + 1);
				amnt -= x + 1;
			} else if (x <= table[c]) {
				ffwrd(p, len - x + 1);
				--amnt;
			} else {
				ffwrd(p, len - table[c]);
				amnt -= x - table[c];
			}
			if (amnt < 0)
				return NULL;
			else
				x = len;
		}
	} while (x);
	return p;
}

/* forward find (case insensitive) pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *fifind(P *p, unsigned char *s, int len)
{
	long amnt = p->b->eof->byte - p->byte;
	int x;
	struct charmap *map = p->b->o.charmap;
	unsigned char table[256], c;

	if (len > amnt)
		return NULL;
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = 0; x != len - 1; ++x)
		table[s[x]] = x;
	ffwrd(p, len);
	amnt -= len;
	x = len;
	do {
		if ((c = joe_tolower(map,frgetc(p))) != s[--x]) {
			if (table[c] == 255) {
				ffwrd(p, len + 1);
				amnt -= x + 1;
			} else if (x <= table[c]) {
				ffwrd(p, len - x + 1);
				--amnt;
			} else {
				ffwrd(p, len - table[c]);
				amnt -= x - table[c];
			}
			if (amnt < 0)
				return NULL;
			else
				x = len;
		}
	} while (x);
	return p;
}

/* move cursor p to q's position and set p's col, line, ofst, byte etc. accordingly */
/* same as rgetto() but p is before q */
static P *getto(P *p, P *q)
{
	while (p->hdr != q->hdr || p->ofst != q->ofst) {
		if (GCHAR(p) == '\n')
			++p->line;
		++p->byte;
		++p->ofst;
		if (p->ofst == GSIZE(p->hdr))
			pnext(p);
		while (!p->ofst && p->hdr != q->hdr) {
			p->byte += GSIZE(p->hdr);
			p->line += p->hdr->nlines;
			pnext(p);
		}
	}
	return p;
}

/* find forward substring s in text pointed by p and set p after found substring */
P *pfind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p, USTR "pfind");

	if (ffind(q, s, len)) {
		getto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* same as pfind() but case insensitive */
P *pifind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p, USTR "pifind");

	if (fifind(q, s, len)) {
		getto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

static void fbkwd(P *p, int n)
{
	while (n > p->ofst) {
		n -= p->ofst;
		if (!pprev(p))
			return;
	}
	if (p->ofst >= n)
		p->ofst -= n;
	else
		p->ofst = 0;
}

static int fpgetc(P *p)
{
	int c;

	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	c = GCHAR(p);
	if (++p->ofst == GSIZE(p->hdr))
		pnext(p);
	return c;
}

/* backward find pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *frfind(P *p, unsigned char *s, int len)
{
	long amnt = p->byte;
	int x;
	unsigned char table[256], c;

	if (len > p->b->eof->byte - p->byte) {
		x = len - (p->b->eof->byte - p->byte);
		if (amnt < x)
			return NULL;
		amnt -= x;
		fbkwd(p, x);
	}
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1) ;
	x = 0;
	do {
		if ((c = fpgetc(p)) != s[x++]) {
			if (table[c] == 255) {
				fbkwd(p, len + 1);
				amnt -= len - x + 1;
			} else if (len - table[c] <= x) {
				fbkwd(p, x + 1);
				--amnt;
			} else {
				fbkwd(p, len - table[c]);
				amnt -= len - table[c] - x;
			}
			if (amnt < 0)
				return NULL;
			else
				x = 0;
		}
	} while (x != len);
	fbkwd(p, len);
	return p;
}

/* backward find (case insensitive) pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *frifind(P *p, unsigned char *s, int len)
{
	long amnt = p->byte;
	int x;
	unsigned char table[256], c;
	struct charmap *map = p->b->o.charmap;

	if (len > p->b->eof->byte - p->byte) {
		x = len - (p->b->eof->byte - p->byte);
		if (amnt < x)
			return NULL;
		amnt -= x;
		fbkwd(p, x);
	}
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1) ;
	x = 0;
	do {
		if ((c = joe_tolower(map,fpgetc(p))) != s[x++]) {
			if (table[c] == 255) {
				fbkwd(p, len + 1);
				amnt -= len - x + 1;
			} else if (len - table[c] <= x) {
				fbkwd(p, x + 1);
				--amnt;
			} else {
				fbkwd(p, len - table[c]);
				amnt -= len - table[c] - x;
			}
			if (amnt < 0)
				return NULL;
			else
				x = 0;
		}
	} while (x != len);
	fbkwd(p, len);
	return p;
}

/* move cursor p to q's position and set p's col, line, ofst, byte etc. accordingly */
/* same as getto() but q is before p */
static P *rgetto(P *p, P *q)
{
	while (p->hdr != q->hdr || p->ofst != q->ofst) {
		if (!p->ofst)
			do {
				if (p->ofst) {
					p->byte -= p->ofst;
					p->line -= p->hdr->nlines;
				}
				pprev(p);
			} while (p->hdr != q->hdr);
		--p->ofst;
		--p->byte;
		if (GCHAR(p) == '\n')
			--p->line;
	}
	return p;
}

/* find backward substring s in text pointed by p and set p on the first of found substring */
P *prfind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p, USTR "prfind");

	if (frfind(q, s, len)) {
		rgetto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* same as prfind() but case insensitive */
P *prifind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p, USTR "prifind");

	if (frifind(q, s, len)) {
		rgetto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* copy text between 'from' and 'to' into new buffer */
B *bcpy(P *from, P *to)
{
	H anchor, *l;
	unsigned char *ptr;
	P *q;

	if (from->byte >= to->byte)
		return bmk(from->b);

	q = pdup(from, USTR "bcpy");
	izque(H, link, &anchor);

	if (q->hdr == to->hdr) {
		l = halloc();
		ptr = vlock(vmem, l->seg);
		if (q->ofst != q->hdr->hole)
			gstgap(q->hdr, q->ptr, q->ofst);
		l->nlines = mcnt(q->ptr + q->hdr->ehole, '\n', l->hole = to->ofst - q->ofst);
		mmove(ptr, q->ptr + q->hdr->ehole, l->hole);
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
	} else {
		l = halloc();
		ptr = vlock(vmem, l->seg);
		if (q->ofst != q->hdr->hole)
			gstgap(q->hdr, q->ptr, q->ofst);
		l->nlines = mcnt(q->ptr + q->hdr->ehole, '\n', l->hole = SEGSIZ - q->hdr->ehole);
		mmove(ptr, q->ptr + q->hdr->ehole, l->hole);
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
		pnext(q);
		while (q->hdr != to->hdr) {
			l = halloc();
			ptr = vlock(vmem, l->seg);
			l->nlines = q->hdr->nlines;
			mmove(ptr, q->ptr, q->hdr->hole);
			mmove(ptr + q->hdr->hole, q->ptr + q->hdr->ehole, SEGSIZ - q->hdr->ehole);
			l->hole = GSIZE(q->hdr);
			vchanged(ptr);
			vunlock(ptr);
			enqueb(H, link, &anchor, l);
			pnext(q);
		}
		if (to->ofst) {
			l = halloc();
			ptr = vlock(vmem, l->seg);
			if (to->ofst != to->hdr->hole)
				gstgap(to->hdr, to->ptr, to->ofst);
			l->nlines = mcnt(to->ptr, '\n', to->ofst);
			mmove(ptr, to->ptr, l->hole = to->ofst);
			vchanged(ptr);
			vunlock(ptr);
			enqueb(H, link, &anchor, l);
		}
	}

	l = anchor.link.next;
	deque(H, link, &anchor);
	prm(q);

	return bmkchn(l, from->b, to->byte - from->byte, to->line - from->line);
}

/* Coalesce small blocks into a single larger one */
void pcoalesce(P *p)
{
	if (p->hdr != p->b->eof->hdr && GSIZE(p->hdr) + GSIZE(p->hdr->link.next) <= SEGSIZ - SEGSIZ / 4) {
		H *hdr = p->hdr->link.next;
		unsigned char *ptr = vlock(vmem, hdr->seg);
		int osize = GSIZE(p->hdr);
		int size = GSIZE(hdr);
		P *q;

		gstgap(hdr, ptr, size);
		ginsm(p->hdr, p->ptr, GSIZE(p->hdr), ptr, size);
		p->hdr->nlines += hdr->nlines;
		vunlock(ptr);
		hfree(deque_f(H, link, hdr));
		for (q = p->link.next; q != p; q = q->link.next)
			if (q->hdr == hdr) {
				q->hdr = p->hdr;
				if (q->ptr) {
					vunlock(q->ptr);
					q->ptr = vlock(vmem, q->hdr->seg);
				}
				q->ofst += osize;
			}
	}
	if (p->hdr != p->b->bof->hdr && GSIZE(p->hdr) + GSIZE(p->hdr->link.prev) <= SEGSIZ - SEGSIZ / 4) {
		H *hdr = p->hdr->link.prev;
		unsigned char *ptr = vlock(vmem, hdr->seg);
		int size = GSIZE(hdr);
		P *q;

		gstgap(hdr, ptr, size);
		ginsm(p->hdr, p->ptr, 0, ptr, size);
		p->hdr->nlines += hdr->nlines;
		vunlock(ptr);
		hfree(deque_f(H, link, hdr));
		p->ofst += size;
		for (q = p->link.next; q != p; q = q->link.next)
			if (q->hdr == hdr) {
				q->hdr = p->hdr;
				if (q->ptr)
					vunlock(q->ptr);
				q->ptr = vlock(vmem, q->hdr->seg);
			} else if (q->hdr == p->hdr)
				q->ofst += size;
	}
}

/* Delete the text between two pointers from a buffer and return it in a new
 * buffer.
 *
 * This routine calls these functions:
 *  gstgap	- to position gaps
 *  halloc	- to allocate new header/segment pairs
 *  vlock	- virtual memory routines
 *  vunlock
 *  vchanged
 *  vupcount
 *  mcnt	- to count NLs
 *  snip	- queue routines
 *  enqueb
 *  splicef
 *  scrdel	- to tell screen update to scroll when NLs are deleted
 *  bmkchn	- to make a buffer out of a chain
 */

/* This is only to be used for bdel() */
static B *bcut(P *from, P *to)
{
	H *h,			/* The deleted text */
	*i;
	unsigned char *ptr;
	P *p;
	long nlines;		/* No. EOLs to delete */
	long amnt;		/* No. bytes to delete */
	int toamnt;		/* Amount to delete from segment in 'to' */
	int bofmove = 0;	/* Set if bof got deleted */
	struct lattr_db *db;

	if (!(amnt = to->byte - from->byte))
		return NULL;	/* ...nothing to delete */

	nlines = to->line - from->line;

	if (from->hdr == to->hdr) {	/* Delete is within a single segment */
		/* Move gap to deletion point */
		if (from->ofst != from->hdr->hole)
			gstgap(from->hdr, from->ptr, from->ofst);

		/* Store the deleted text */
		h = halloc();
		ptr = vlock(vmem, h->seg);
		mmove(ptr, from->ptr + from->hdr->ehole, (int) amnt);
		h->hole = amnt;
		h->nlines = nlines;
		vchanged(ptr);
		vunlock(ptr);

		/* Delete */
		from->hdr->ehole += amnt;
		from->hdr->nlines -= nlines;

		toamnt = amnt;
	} else {		/* Delete crosses segments */
		H *a;

		if ((toamnt = to->ofst) != 0) {
			/* Delete beginning of to */
			/* Move gap to deletion point */
			/* To could be deleted if it's at the end of the file */
			if (to->ofst != to->hdr->hole)
				gstgap(to->hdr, to->ptr, to->ofst);

			/* Save deleted text */
			i = halloc();
			ptr = vlock(vmem, i->seg);
			mmove(ptr, to->ptr, to->hdr->hole);
			i->hole = to->hdr->hole;
			i->nlines = mcnt(to->ptr, '\n', to->hdr->hole);
			vchanged(ptr);
			vunlock(ptr);

			/* Delete */
			to->hdr->nlines -= i->nlines;
			to->hdr->hole = 0;
		} else
			i = 0;

		/* Delete end of from */
		if (!from->ofst) {
			/* ... unless from needs to be deleted too */
			a = from->hdr->link.prev;
			h = NULL;
			if (a == from->b->eof->hdr)
				bofmove = 1;
		} else {
			a = from->hdr;
			/* Move gap to deletion point */
			if (from->ofst != from->hdr->hole)
				gstgap(from->hdr, from->ptr, from->ofst);

			/* Save deleted text */
			h = halloc();
			ptr = vlock(vmem, h->seg);
			mmove(ptr, from->ptr + from->hdr->ehole, SEGSIZ - from->hdr->ehole);
			h->hole = SEGSIZ - from->hdr->ehole;
			h->nlines = mcnt(ptr, '\n', h->hole);
			vchanged(ptr);
			vunlock(ptr);

			/* Delete */
			from->hdr->nlines -= h->nlines;
			from->hdr->ehole = SEGSIZ;
		}

		/* Make from point to header/segment of to */
		from->hdr = to->hdr;
		vunlock(from->ptr);
		from->ptr = to->ptr;
		vupcount(to->ptr);
		from->ofst = 0;

		/* Delete headers/segments between a and to->hdr (if there are any) */
		if (a->link.next != to->hdr)
			if (!h) {
				h = snip(H, link, a->link.next, to->hdr->link.prev);
				if (i)
					enqueb(H, link, h, i);
			} else {
				splicef(H, link, h, snip(H, link, a->link.next, to->hdr->link.prev));
				if (i)
					enqueb(H, link, h, i);
		} else if (!h)
			h = i;
		else if (i)
			enqueb(H, link, h, i);
	}

	/* If to is empty, then it must have been at the end of the file.  If
	   the file did not become empty, delete to */
	if (!GSIZE(to->hdr) && from->byte) {
		H *ph = from->hdr->link.prev;

		hfree(deque_f(H, link, from->hdr));
		vunlock(from->ptr);
		from->hdr = ph;
		from->ptr = vlock(vmem, from->hdr->seg);
		from->ofst = GSIZE(ph);
		vunlock(from->b->eof->ptr);
		from->b->eof->ptr = from->ptr;
		vupcount(from->ptr);
		from->b->eof->hdr = from->hdr;
		from->b->eof->ofst = from->ofst;
	}

	/* The deletion is now done */

	/* Scroll if necessary */

	if (bofmove)
		pset(from->b->bof, from);
	for (db = from->b->db; db; db = db->next)
		lattr_del(db, from->line, nlines);
	if (!pisbol(from)) {
		scrdel(from->b, from->line, nlines, 1);
		delerr(from->b->name, from->line, nlines);
	} else {
		scrdel(from->b, from->line, nlines, 0);
		delerr(from->b->name, from->line, nlines);
	}

	/* Fix pointers */

	for (p = from->link.next; p != from; p = p->link.next)
		if (p->line == from->line && p->byte > from->byte)
			p->valcol = 0;
	for (p = from->link.next; p != from; p = p->link.next) {
		if (p->byte >= from->byte) {
			if (p->byte <= from->byte + amnt) {
				if (p->ptr) {
					pset(p, from);
				} else {
					poffline(pset(p, from));
				}
			} else {
				if (p->hdr == to->hdr)
					p->ofst -= toamnt;
				p->byte -= amnt;
				p->line -= nlines;
			}
		}
	}

	pcoalesce(from);

	/* Make buffer out of deleted text and return it */
	return bmkchn(h, from->b, amnt, nlines);
}

void bdel(P *from, P *to)
{
	if (to->byte - from->byte) {
		B *b = bcut(from, to);

		if (from->b->undo)
			undodel(from->b->undo, from->byte, b);
		else
			brm(b);
		from->b->changed = 1;
	}
}

/* Split a block at p's ofst */
/* p is placed in the new block such that it points to the same text but with
 * p->ofst==0
 */
static void bsplit(P *p)
{
	if (p->ofst) {
		H *hdr;
		unsigned char *ptr;
		P *pp;

		hdr = halloc();
		ptr = vlock(vmem, hdr->seg);

		if (p->ofst != p->hdr->hole)
			gstgap(p->hdr, p->ptr, p->ofst);
		mmove(ptr, p->ptr + p->hdr->ehole, SEGSIZ - p->hdr->ehole);
		hdr->hole = SEGSIZ - p->hdr->ehole;
		hdr->nlines = mcnt(ptr, '\n', hdr->hole);
		p->hdr->nlines -= hdr->nlines;
		vchanged(ptr);
		p->hdr->ehole = SEGSIZ;

		enquef(H, link, p->hdr, hdr);

		vunlock(p->ptr);

		for (pp = p->link.next; pp != p; pp = pp->link.next)
			if (pp->hdr == p->hdr && pp->ofst >= p->ofst) {
				pp->hdr = hdr;
				if (pp->ptr) {
					vunlock(pp->ptr);
					pp->ptr = ptr;
					vupcount(ptr);
				}
				pp->ofst -= p->ofst;
			}

		p->ptr = ptr;
		p->hdr = hdr;
		p->ofst = 0;
	}
}

/* Make a chain out of a block of memory (the block must not be empty) */
static H *bldchn(unsigned char *blk, int size, long *nlines)
{
	H anchor, *l;

	*nlines = 0;
	izque(H, link, &anchor);
	do {
		unsigned char *ptr;
		int amnt;

		ptr = vlock(vmem, (l = halloc())->seg);
		if (size > SEGSIZ)
			amnt = SEGSIZ;
		else
			amnt = size;
		mmove(ptr, blk, amnt);
		l->hole = amnt;
		l->ehole = SEGSIZ;
		(*nlines) += (l->nlines = mcnt(ptr, '\n', amnt));
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
		blk += amnt;
		size -= amnt;
	} while (size);
	l = anchor.link.next;
	deque(H, link, &anchor);
	return l;
}

/* Insert a chain into a buffer (this does not update pointers) */
static void inschn(P *p, H *a)
{
	if (!p->b->eof->byte) {	/* P's buffer is empty: replace the empty segment in p with a */
		hfree(p->hdr);
		p->hdr = a;
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
		pset(p->b->bof, p);

		p->b->eof->hdr = a->link.prev;
		vunlock(p->b->eof->ptr);
		p->b->eof->ptr = vlock(vmem, p->b->eof->hdr->seg);
		p->b->eof->ofst = GSIZE(p->b->eof->hdr);
	} else if (piseof(p)) {	/* We're at the end of the file: append a to the file */
		p->b->eof->hdr = a->link.prev;
		spliceb(H, link, p->b->bof->hdr, a);
		vunlock(p->b->eof->ptr);
		p->b->eof->ptr = vlock(vmem, p->b->eof->hdr->seg);
		p->b->eof->ofst = GSIZE(p->b->eof->hdr);
		p->hdr = a;
		vunlock(p->ptr);
		p->ptr = vlock(vmem, p->hdr->seg);
		p->ofst = 0;
	} else if (pisbof(p)) {	/* We're at the beginning of the file: insert chain and set bof pointer */
		p->hdr = spliceb_f(H, link, p->hdr, a);
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
		pset(p->b->bof, p);
	} else {		/* We're in the middle of the file: split and insert */
		bsplit(p);
		p->hdr = spliceb_f(H, link, p->hdr, a);
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
	}
}

static void fixupins(P *p, long amnt, long nlines, H *hdr, int hdramnt)
{
	P *pp;
	struct lattr_db *db;

	if (!pisbol(p))
		scrins(p->b, p->line, nlines, 1);
	else
		scrins(p->b, p->line, nlines, 0);

	for (db = p->b->db; db; db = db->next)
		lattr_ins(db, p->line, nlines);

	inserr(p->b->name, p->line, nlines, pisbol(p));	/* FIXME: last arg ??? */

	for (pp = p->link.next; pp != p; pp = pp->link.next)
		if (pp->line == p->line && (pp->byte > p->byte || (pp->end && pp->byte == p->byte)))
			pp->valcol = 0;
	for (pp = p->link.next; pp != p; pp = pp->link.next)
		if (pp->byte == p->byte && !pp->end)
			if (pp->ptr)
				pset(pp, p);
			else
				poffline(pset(pp, p));
		else if (pp->byte > p->byte || (pp->end && pp->byte == p->byte)) {
			pp->byte += amnt;
			pp->line += nlines;
			if (pp->hdr == hdr)
				pp->ofst += hdramnt;
		}
	if (p->b->undo)
		undoins(p->b->undo, p, amnt);
	p->b->changed = 1;

}

/* Insert a buffer at pointer position (the buffer goes away) */
P *binsb(P *p, B *b)
{
	if (b->eof->byte) {
		P *q = pdup(p, USTR "binsb");

		inschn(q, b->bof->hdr);
		b->eof->hdr = halloc();
		fixupins(q, b->eof->byte, b->eof->line, NULL, 0);
		pcoalesce(q);
		prm(q);
	}
	brm(b);
	return p;
}

/* insert memory block 'blk' at 'p' */
P *binsm(P *p, unsigned char *blk, int amnt)
{
	long nlines;
	H *h = NULL;
	int hdramnt = 0; /* Only used if h is set */
	P *q;

	if (!amnt)
		return p;
	q = pdup(p, USTR "binsm");
	if (amnt <= GGAPSZ(q->hdr)) {
		h = q->hdr;
		hdramnt = amnt;
		ginsm(q->hdr, q->ptr, q->ofst, blk, amnt);
		q->hdr->nlines += (nlines = mcnt(blk, '\n', amnt));
	} else if (!q->ofst && q->hdr != q->b->bof->hdr && amnt <= GGAPSZ(q->hdr->link.prev)) {
		pprev(q);
		ginsm(q->hdr, q->ptr, q->ofst, blk, amnt);
		q->hdr->nlines += (nlines = mcnt(blk, '\n', amnt));
	} else {
		H *a = bldchn(blk, amnt, &nlines);

		inschn(q, a);
	}
	fixupins(q, (long) amnt, nlines, h, hdramnt);
	pcoalesce(q);
	prm(q);
	return p;
}

/* insert byte 'c' at 'p' */
P *binsbyte(P *p, unsigned char c)
{
	if (p->b->o.crlf && c == '\n')
		return binsm(p, USTR "\r\n", 2);
	else
		return binsm(p, &c, 1);
}

/* UTF-8 encode a character and insert it */
P *binsc(P *p, int c)
{
	if (c>127 && p->b->o.charmap->type) {
		unsigned char buf[8];
		int len = utf8_encode(buf,c);
		return binsm(p,buf,len);
	} else {
		unsigned char ch = c;
		if (p->b->o.crlf && c == '\n')
			return binsm(p, USTR "\r\n", 2);
		else
			return binsm(p, &ch, 1);
	}
}

/* insert zero-terminated string 's' at 'p' */
P *binss(P *p, unsigned char *s)
{
	return binsm(p, s, zlen(s));
}

/* Read 'size' bytes from file or stream.  Stops and returns amnt. read
 * when requested size has been read or when end of file condition occurs.
 * Returns with -2 in error for read error or 0 in error for success.
 */
static int bkread(int fi, unsigned char *buff, int size)
{
	int a, b;

	if (!size) {
		berror = 0;
		return 0;
	}
	for (a = b = 0; (a < size) && ((b = joe_read(fi, buff + a, size - a)) > 0); a += b) ;
	if (b < 0)
		berror = -2;
	else
		berror = 0;
	return a;
}

/* Read up to 'max' bytes from a file into a buffer */
/* Returns with 0 in error or -2 in error for read error */
B *bread(int fi, long int max)
{
	H anchor, *l;
	long lines = 0, total = 0;
	int amnt;
	unsigned char *seg;

	izque(H, link, &anchor);
	berror = 0;
	while (seg = vlock(vmem, (l = halloc())->seg), !berror && (amnt = bkread(fi, seg, max >= SEGSIZ ? SEGSIZ : (int) max))) {
		total += amnt;
		max -= amnt;
		l->hole = amnt;
		lines += (l->nlines = mcnt(seg, '\n', amnt));
		vchanged(seg);
		vunlock(seg);
		enqueb(H, link, &anchor, l);
	}
	hfree(l);
	vunlock(seg);
	if (!total)
		return bmk(NULL);
	l = anchor.link.next;
	deque(H, link, &anchor);
	return bmkchn(l, NULL, total, lines);
}

/* Parse file name.
 *
 * Removes ',xxx,yyy' from end of name and puts their value into skip and amnt
 * Replaces ~user/ with directory of given user
 * Replaces ~/ with $HOME
 *
 * Returns new variable length string.
 */
unsigned char *parsens(unsigned char *s, off_t *skip, off_t *amnt)
{
	unsigned char *n = vsncpy(NULL, 0, sz(s));
	int x;

	*skip = 0;
	*amnt = MAXLONG;
	x = obj_len(n) - 1;
	if (x > 0 && n[x] >= '0' && n[x] <= '9') {
		for (x = obj_len(n) - 1; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
		if (n[x] == ',' && x && n[x-1] != '\\') {
			n[x] = 0;
#if SIZEOF_LONG_LONG && SIZEOF_LONG_LONG == SIZEOF_OFF_T
			if (n[x + 1] == 'x' || n[x + 1] == 'X')
				sscanf((char *)(n + x + 2), "%llx", skip);
			else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				sscanf((char *)(n + x + 3), "%llx", skip);
			else if (n[x + 1] == '0')
				sscanf((char *)(n + x + 1), "%llo", skip);
			else
				sscanf((char *)(n + x + 1), "%lld", skip);
#else
			if (n[x + 1] == 'x' || n[x + 1] == 'X')
				sscanf((char *)(n + x + 2), "%lx", skip);
			else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				sscanf((char *)(n + x + 3), "%lx", skip);
			else if (n[x + 1] == '0')
				sscanf((char *)(n + x + 1), "%lo", skip);
			else
				sscanf((char *)(n + x + 1), "%ld", skip);
#endif
			--x;
			if (x > 0 && n[x] >= '0' && n[x] <= '9') {
				for (; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
				if (n[x] == ',' && x && n[x-1] != '\\') {
					n[x] = 0;
					*amnt = *skip;

#if SIZEOF_LONG_LONG && SIZEOF_LONG_LONG == SIZEOF_OFF_T
					if (n[x + 1] == 'x' || n[x + 1] == 'X')
						sscanf((char *)(n + x + 2), "%llx", skip);
					else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
						sscanf((char *)(n + x + 3), "%llx", skip);
					else if (n[x + 1] == '0')
						sscanf((char *)(n + x + 1), "%llo", skip);
					else
						sscanf((char *)(n + x + 1), "%lld", skip);
#else
					if (n[x + 1] == 'x' || n[x + 1] == 'X')
						sscanf((char *)(n + x + 2), "%lx", skip);
					else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
						sscanf((char *)(n + x + 3), "%lx", skip);
					else if (n[x + 1] == '0')
						sscanf((char *)(n + x + 1), "%lo", skip);
					else
						sscanf((char *)(n + x + 1), "%ld", skip);
#endif
				}
			}
		}
	}
	/* Don't do this here: do it in prompt buffer instead, so we're just like
	   the shell doing it on the command line. */
	/* n = canonical(n); */
	return n;
}

/* Canonicalize file name: do ~ expansion */

unsigned char *canonical(unsigned char *n)
{
#ifndef __MSDOS__
	int x;
	unsigned char *s;
	if (n[0] == '~') {
		for (x = 1; n[x] && n[x] != '/'; ++x) ;
		if (n[x] == '/') {
			if (x == 1) {
				unsigned char *z;

				s = (unsigned char *)getenv("HOME");
				z = vsncpy(NULL, 0, sz(s));
				z = vsncpy(sv(z), sz(n + x));
				n = z;
			} else {
				struct passwd *passwd;

				n[x] = 0;
				passwd = getpwnam((char *)(n + 1));
				n[x] = '/';
				if (passwd) {
					unsigned char *z = vsdupz((unsigned char *)(passwd->pw_dir));

					z = vscatz(z, n + x);
					n = z;
				}
			}
		}
	}
#endif
	return n;
}

int euclid(int a, int b)
{
	if (!a)
		return b;
	while (b)
		if (a > b)
			a -= b;
		else
			b -= a;
	return a;
}

/* return column of first nonblank character, but don't count comments */
int found_space;
int found_tab;

long pisindentg(P *p)
{
	int i_spc = 0;
	int i_tab = 0;
	P *q = pdup(p, USTR "pisindentg");
	long col;
	int ch;

	p_goto_bol(q);
	while (joe_isblank(p->b->o.charmap,ch = brc(q))) {
		if (ch == ' ')
			i_spc = 1;
		else if (ch == '\t')
			i_tab = 1;
		pgetc(q);
	}
	col = q->col;
	if (ch == '*' || ch == '/' || ch == '-' || ch =='%' || ch == '#' || ch == '\r' || ch == '\n')
		col = 0;
	if (col) {
		found_space |= i_spc;
		found_tab |= i_tab;
	}
	prm(q);
	return col;
}

unsigned char *dequote(unsigned char *s)
{
        static unsigned char buf[1024];
        unsigned char *p = buf;
        while (*s) {
                if (*s =='\\')
                        ++s;
                if (*s)
                        *p++ = *s++;
        }
        *p = 0;
        return buf;
}

/* Load file into new buffer and return the new buffer */
/* Returns with error set to 0 for success,
 * -1 for new file (file doesn't exist)
 * -2 for read error
 * -3 for seek error
 * -4 for open error
 */
B *bload(unsigned char *s)
{
	unsigned char buffer[SEGSIZ];
	FILE *fi = 0;
	B *b = 0;
	off_t skip, amnt;
	unsigned char *n;
	int nowrite = 0;
	P *p;
	int x;
	long mod_time = 0;
	struct stat sbuf;

	if (!s || !s[0]) {
		berror = -1;
		b = bmk(NULL);
		setopt(b,USTR "");
		b->rdonly = b->o.readonly;
		b->er = berror;
		return b;
	}

	n = parsens(s, &skip, &amnt);

	/* Open file or stream */
#ifndef __MSDOS__
	if (n[0] == '!') {
		nescape(maint->t);
		ttclsn();
		fi = popen((char *)dequote(n + 1), "r");
	} else
#endif
	if (!zcmp(n, USTR "-")) {
#ifdef junk
		FILE *f;
		struct stat y;
		fi = stdin;
		/* Make sure stdin is not tty */
		if (fstat(fileno(fi), &y)) 
			goto no_stat;
		if (y.st_mode & S_IFCHR) {
			no_stat:
			b = bmk(NULL);
			goto empty;
		}
#endif
		/* Now we always just create an empty buffer for "-" */
		b = bmk(NULL);
		goto empty;
	} else {
		fi = fopen((char *)dequote(n), "r+");
		if (!fi)
			nowrite = 1;
		else
			fclose(fi);
		fi = fopen((char *)dequote(n), "r");
		if (!fi)
			nowrite = 0;
		if (fi) {
			fstat(fileno(fi),&sbuf);
			mod_time = sbuf.st_mtime;
		}
	}
	joesep(n);

	/* Abort if couldn't open */
	if (!fi) {
		if (errno == ENOENT)
			berror = -1;
		else
			berror = -4;
		b = bmk(NULL);
		setopt(b,n);
		b->rdonly = b->o.readonly;
		goto opnerr;
	}

	/* Skip data if we need to */
	if (skip && lseek(fileno(fi), skip, 0) < 0) {
		int r;

		while (skip > SEGSIZ) {
			r = bkread(fileno(fi), buffer, SEGSIZ);
			if (r != SEGSIZ || berror) {
				berror = -3;
				goto err;
			}
			skip -= SEGSIZ;
		}
		skip -= bkread(fileno(fi), buffer, (int) skip);
		if (skip || berror) {
			berror = -3;
			goto err;
		}
	}

	/* Read from stream into new buffer */
	b = bread(fileno(fi), amnt);
	empty:
	b->mod_time = mod_time;
	setopt(b,n);
	b->rdonly = b->o.readonly;

	/* Close stream */
err:
#ifndef __MSDOS__
	if (s[0] == '!')
		pclose(fi);
	else
#endif
	if (zcmp(n, USTR "-"))
		fclose(fi);

opnerr:
	if (s[0] == '!') {
		ttopnn();
		nreturn(maint->t);
	}

	/* Set name */
	b->name = joesep(zdup(s));

	/* Set flags */
	if (berror || s[0] == '!' || skip || amnt != MAXLONG) {
		b->backup = 1;
		b->changed = 0;
	} else if (!zcmp(n, USTR "-")) {
		b->backup = 1;
		b->changed = 1;
	} else {
		b->backup = 0;
		b->changed = 0;
	}
	if (nowrite)
		b->rdonly = b->o.readonly = 1;

	/* If first line has CR-LF, assume MS-DOS file */
	if (guesscrlf) {
		p=pdup(b->bof, USTR "bload");
		b->o.crlf = 0;
		for(x=0;x!=1024;++x) {
			int c = pgetc(p);
			if(c == '\r') {
				b->o.crlf = 1;
				break;
				}
			if(c == '\n') {
				b->o.crlf = 0;
				break;
				}
			if(c == NO_MORE_DATA)
				break;
		}
		prm(p);
	}

	/* Search backwards through file: if first indented line
	   is indented with a tab, assume indentc is tab */
	if (guessindent) {
		int i, x, y;
		int guessed_step = 0;
		int hist[20];
		int hist_val[20];
		int nhist = 0;
		int old_max;
		int max;
		int maxi;
		found_space = 0;
		found_tab = 0;
		p=pdup(b->eof, USTR "bload");
		/* Create histogram of indentation values */
		for (y = 0; y != 50; ++y) {
			p_goto_bol(p);
			if ((i = pisindentg(p))) {
				for (x = 0; x != nhist; ++x)
					if (hist_val[x] == i)
						break;
				if (x == nhist && nhist != 20) {
					hist[nhist] = 1;
					hist_val[nhist] = i;
					++nhist;
				} else if (x != nhist) {
					++hist[x];
				}
			}
			if (prgetc(p)==NO_MORE_DATA)
				break;
		}
		/* Find GCM of top 3 most popular indentation values */
		old_max = 0;
		for (y = 0; y != 3; ++y) {
			max = 0;
			for (x = 0; x != nhist; ++x)
				if (hist[x] > max) {
					max = hist[x];
					maxi = x;
				}
			if (max) {
				if (!old_max)
					old_max = max;
				if (guessed_step)
					guessed_step = euclid(guessed_step, hist_val[maxi]);
				else
					guessed_step = hist_val[maxi];
				hist[maxi] = 0;
			}
		}
		/* If guessed value is large, scale it down some */
		while (!(guessed_step & 1) && guessed_step > 8)
			guessed_step >>= 1;

		if (found_tab && !found_space) {
			b->o.indentc = '\t';
			b->o.istep = 1;
		} else if (found_space) {
			b->o.indentc = ' ';
			if (guessed_step)
				b->o.istep = guessed_step;
		}
		prm(p);
	}

	b->er = berror;
	return b;
}

/* Find already loaded buffer or load file into new buffer */
B *bfind(unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		berror = -1;
		b = bmk(NULL);
		setopt(b,USTR "");
		b->rdonly = b->o.readonly;
		b->internal = 0;
		b->er = berror;
		return b;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !zcmp(s, b->name)) {
			if (!b->orphan)
				++b->count; /* Assumes caller is going to put this in a window! */
			else
				b->orphan = 0;
			berror = 0;
			b->internal = 0;
			return b;
		}
	b = bload(s); /* Returns count==1 */
	b->internal = 0;
	return b;
}

/* Find already loaded buffer or load file into new buffer */
B *bfind_scratch(unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		berror = -1;
		b = bmk(NULL);
		setopt(b,USTR "");
		b->rdonly = b->o.readonly;
		b->internal = 0;
		b->er = berror;
		return b;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !zcmp(s, b->name)) {
			if (!b->orphan)
				++b->count;
			else
				b->orphan = 0;
			berror = 0;
			b->internal = 0;
			return b;
		}
	b = bmk(NULL);
	berror = -1;
	setopt(b,s);
	b->internal = 0;
	b->rdonly = b->o.readonly;
	b->er = berror;
	b->name = zdup(s);
	b->scratch = 1;
	return b;
}

B *bfind_reload(unsigned char *s)
{
	B *b;
	b = bload(s);
	b->internal = 0;
	return b;
}

B *bcheck_loaded(unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		return NULL;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !zcmp(s, b->name)) {
			return b;
		}

	return NULL;
}

unsigned char **getbufs(void)
{
	unsigned char **s = vamk(16);
	B *b;

	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name)
			s = vaadd(s, vsncpy(NULL, 0, sz(b->name)));
	return s;
}

/* Find an orphaned buffer: b->count of returned buffer should be 1. */
B *borphan(void)
{
	B *b;

	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->orphan && !b->scratch) {
			b->orphan = 0;
			return b;
		}
	return NULL;
}

/* Write 'size' bytes from file beginning at 'p' to open file 'fd'.
 * Returns error.
 * error is set to -5 for write error or 0 for success.
 * Don't attempt to write past the end of the file
 */
int bsavefd(P *p, int fd, off_t size)
{
	P *np = pdup(p, USTR "bsavefd");
	int amnt;

	while (size > (amnt = GSIZE(np->hdr) - np->ofst)) {
		if (np->ofst < np->hdr->hole) {
			if (joe_write(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
				goto err;
			if (joe_write(fd, np->ptr + np->hdr->ehole, SEGSIZ - np->hdr->ehole) < 0)
				goto err;
		} else if (joe_write(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), amnt) < 0)
			goto err;
		size -= amnt;
		pnext(np);
	}
	if (size) {
		if (np->ofst < np->hdr->hole) {
			if (size > np->hdr->hole - np->ofst) {
				if (joe_write(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
					goto err;
				if (joe_write(fd, np->ptr + np->hdr->ehole, (int) size - np->hdr->hole + np->ofst) < 0)
					goto err;
			} else {
				if (joe_write(fd, np->ptr + np->ofst, (int) size) < 0)
					goto err;
			}
		} else {
			if (joe_write(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), (int) size) < 0)
				goto err;
		}
	}
	prm(np);
	return berror = 0;
err:
	prm(np);
	return berror = -5;
}

/* Save 'size' bytes beginning at 'p' in file 's' */

/* If flag is set, update original time of file if it makes
 * sense to do so (it's a normal file, we're saving with
 * same name as buffer or is about to get this name).
 *
 * If flag is set to 2, we update original time even if file
 * name changed (i.e., we're renaming the file).
 */

int break_links; /* Set to break hard links on writes */
int break_symlinks; /* Set to break symbolic links and hard links on writes */

int bsave(P *p, unsigned char *s, off_t size, int flag)
{
	struct stat sbuf;
	int have_stat = 0;
	FILE *f;
	off_t skip, amnt;
	int norm = 0;

	s = parsens(s, &skip, &amnt);

	if (amnt < size)
		size = amnt;

#ifndef __MSDOS__
	if (s[0] == '!') {
		nescape(maint->t);
		ttclsn();
		f = popen((char *)dequote(s + 1), "w");
	} else
#endif
	if (s[0] == '>' && s[1] == '>')
		f = fopen((char *)dequote(s + 2), "a");
	else if (!zcmp(s, USTR "-")) {
		nescape(maint->t);
		ttclsn();
		f = stdout;
	} else if (skip || amnt != MAXLONG)
		f = fopen((char *)dequote(s), "r+");
	else {
		have_stat = !stat((char *)dequote(s), &sbuf);
		if (!have_stat)
			sbuf.st_mode = 0666;
		/* Normal file save */
		if (break_links || break_symlinks) {
			struct stat lsbuf;

			/* Try to copy permissions */
			if (!lstat((char *)dequote(s),&lsbuf)) {
				int g;
				if (!break_symlinks && S_ISLNK(lsbuf.st_mode))
					goto nobreak;
#ifdef WITH_SELINUX
				security_context_t se;
				if (selinux_enabled == -1)
					selinux_enabled = (is_selinux_enabled() > 0);
				
				if (selinux_enabled) {
					if (getfilecon((char *)dequote(s), &se) < 0) {
						berror = -4;
						goto opnerr;
					}
				}
#endif
				unlink((char *)dequote(s));
				g = creat((char *)dequote(s), sbuf.st_mode & ~(S_ISUID | S_ISGID));
#ifdef WITH_SELINUX
				if (selinux_enabled) {
					setfilecon((char *)dequote(s), &se);
					freecon(se);
				}
#endif
				close(g);
				nobreak:;
			} else {
				unlink((char *)dequote(s));
			}
		}

		f = fopen((char *)dequote(s), "w");
		norm = 1;
	}
	joesep(s);

	if (!f) {
		berror = -4;
		goto opnerr;
	}
	fflush(f);

	if (skip && lseek(fileno(f), skip, 0) < 0) {
		berror = -3;
		goto err;
	}

	bsavefd(p, fileno(f), size);

	if (!berror && force && size && !skip && amnt == MAXLONG) {
		P *q = pdup(p, USTR "bsave");
		unsigned char nl = '\n';

		pfwrd(q, size - 1);
		if (brc(q) != '\n' && joe_write(fileno(f), &nl, 1) < 0)
			berror = -5;
		prm(q);
	}

	/* Restore setuid bit */
	if (!berror && have_stat) {
		fchmod(fileno(f), sbuf.st_mode);
	}

err:
#ifndef __MSDOS__
	if (s[0] == '!')
		pclose(f);
	else
#endif
	if (zcmp(s, USTR "-"))
		fclose(f);
	else
		fflush(f);

	/* Update orignal date of file */
	/* If it's not named, it's about to be */
	if (!berror && norm && flag && (!p->b->name || flag == 2 || !zcmp(s,p->b->name))) {
		if (!stat((char *)dequote(s),&sbuf))
			p->b->mod_time = sbuf.st_mtime;
	}

opnerr:
	if (s[0] == '!' || !zcmp(s,USTR "-")) {
		ttopnn();
		nreturn(maint->t);
	}
	return berror;
}

/* Return byte at p */

int brc(P *p)
{
	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	return GCHAR(p);
}

/* Return character at p */

int brch(P *p)
{
	if (p->b->o.charmap->type) {
		P *q = pdup(p, USTR "brch");
		int c = pgetc(q);
		prm(q);
		return c;
	} else {
		return brc(p);
	}
}

unsigned char *brmem(P *p, unsigned char *blk, int size)
{
	unsigned char *bk = blk;
	P *np;
	int amnt;

	np = pdup(p, USTR "brmem");
	while (size > (amnt = GSIZE(np->hdr) - np->ofst)) {
		grmem(np->hdr, np->ptr, np->ofst, bk, amnt);
		bk += amnt;
		size -= amnt;
		pnext(np);
	}
	if (size)
		grmem(np->hdr, np->ptr, np->ofst, bk, size);
	prm(np);
	return blk;
}

unsigned char *brs(P *p, int size)
{
	unsigned char *s = (unsigned char *) joe_malloc(size + 1);

	s[size] = 0;
	return brmem(p, s, size);
}

unsigned char *brvs(unsigned char *s,P *p, int size)
{
	s = vstrunc(s, size);

	return brmem(p, s, size);
}

unsigned char *brlinevs(unsigned char *buf, P *p)
{
	P *q=pdup(p, USTR "brlinevs");
	size_t size;
	p_goto_eol(q);

	size = q->byte - p->byte;

	prm(q);
	buf = vsensure(buf, size);
	brmem(p,buf,size);
	buf[size]=0;
	obj_len(buf) = size;
	return buf;
}

/* Save edit buffers when editor dies */

FILE *ttsig_f = 0;

RETSIGTYPE ttsig(int sig)
{
	time_t tim = time(NULL);
	B *b;
	int tmpfd;
	struct stat sbuf;

	/* Do not allow double-fault */
	if (ttsig_f)
		_exit(1);

	if ((tmpfd = open("DEADJOE", O_RDWR | O_EXCL | O_CREAT, 0600)) < 0) {
		if (lstat("DEADJOE", &sbuf) < 0)
			_exit(1);
		if (!S_ISREG(sbuf.st_mode) || sbuf.st_uid != geteuid())
			_exit(1);
		/*
		   A race condition still exists between the lstat() and the open()
		   systemcall, which leads to a possible denial-of-service attack
		   by setting the file access mode to 600 for every file the
		   user executing joe has permissions to.
		   This can't be fixed w/o breacking the behavior of the orig. joe!
		 */
		if ((tmpfd = open("DEADJOE", O_RDWR | O_APPEND)) < 0)
			_exit(1);
		if (fchmod(tmpfd, S_IRUSR | S_IWUSR) < 0)
			_exit(1);
	}
	if ((ttsig_f = fdopen(tmpfd, "a")) == NULL)
		_exit(1);

	/* Do not use joe_gettext() here or you might get an infinite loop */
	fprintf(ttsig_f, "\n*** These modified files were found in JOE when it aborted on %s", ctime(&tim));
	if (sig == -2)
		fprintf(ttsig_f, "*** JOE was aborted due to swap file I/O error\n");
	else if (sig == -1)
		fprintf(ttsig_f, "*** JOE was aborted due to malloc returning NULL\n");
	else if (sig)
		fprintf(ttsig_f, "*** JOE was aborted by UNIX signal %d\n", sig);
	else
		fprintf(ttsig_f, "*** JOE was aborted because the terminal closed\n");
	fflush(ttsig_f);
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->changed) {
			if (b->name)
				fprintf(ttsig_f, "\n*** File \'%s\'\n", b->name);
			else
				fprintf(ttsig_f, "\n*** File \'(Unnamed)\'\n");
			fflush(ttsig_f);
			bsavefd(b->bof, fileno(ttsig_f), b->eof->byte);
		}
	if (sig)
		ttclsn();
	if (sig == -2)
		fprintf(stderr,"\n*** JOE was aborted due to swap file I/O error\n");
	else if (sig == -1)
		fprintf(stderr,"\n*** JOE was aborted due to malloc returning NULL.  Buffers saved in DEADJOE\n");
	else if (sig)
		fprintf(stderr,"\n*** JOE was aborted by UNIX signal %d.  Buffers saved in DEADJOE\n", sig);
	_exit(1);
}


/* Create lock for a file
   Return 0 for success or -1 for failure
*/

int lock_it(unsigned char *qpath,unsigned char *bf)
{
        unsigned char *path = dequote(qpath);
	unsigned char *lock_name=dirprt(path);
	unsigned char *name=namprt(path);
	unsigned char *buf;
	unsigned char *user = (unsigned char *)getenv("USER");
	unsigned char *host = (unsigned char *)getenv("HOSTNAME");
	int len;
	if (!user) user=USTR "me";
	if (!host) host=USTR "here";
	lock_name=vscat(lock_name,sc(".#"));
	lock_name=vscat(lock_name,sv(name));
	buf=vsfmt(NULL,0,USTR "%s@@%s.%d",user,host,getpid());
	/* Fail only if there was an existing lock */
	if (!symlink((char *)buf,(char *)lock_name) || errno != EEXIST) {
		obj_free(lock_name);
		return 0;
	}
	if (bf) {
		len = readlink((char *)lock_name,(char *)bf,255);
		if (len<0) len = 0;
		bf[len] = 0;
	}
	obj_free(lock_name);
	return -1;
}

void unlock_it(unsigned char *qpath)
{
        unsigned char *path = dequote(qpath);
	unsigned char *lock_name=dirprt(path);
	unsigned char *name=namprt(path);
	lock_name=vscat(lock_name,sc(".#"));
	lock_name=vscat(lock_name,sv(name));
	unlink((char *)lock_name);
	obj_free(lock_name);
}

/* True if file is regular */

int plain_file(B *b)
{
	if (b->name && zcmp(b->name,USTR "-") && b->name[0]!='!' && b->name[0]!='>' &&
	    !b->scratch)
		return 1;
	else
		return 0;
}

/* True if file changed under us */

int check_mod(B *b)
{
	struct stat sbuf;
	if (!plain_file(b))
		return 0;
	if (!stat((char *)b->name,&sbuf)) {
		if (sbuf.st_mtime>b->mod_time) {
			return 1;
		}
	}
	return 0;
}

/* True if file exists */

int file_exists(unsigned char *path)
{
	struct stat sbuf;
	if (!path) return 0;
	return !stat((char *)path, &sbuf);
}
@


1.101
log
@Fix more compiler warnings.  Update builtins.c
@
text
@d815 1
a815 1
/* move p n characters forward */
d945 1
a945 1
/* move p n characters backwards */
@


1.100
log
@Apply quoting to SELINUX stuff too.
@
text
@d2518 1
a2518 1
			if (i = pisindentg(p)) {
@


1.99
log
@Fix case of \,
@
text
@d2786 1
a2786 1
					if (getfilecon((char *)s, &se) < 0) {
@


1.98
log
@quoting fixes
@
text
@d2188 1
a2188 1
		if (n[x] == ',') {
d2212 1
a2212 1
				if (n[x] == ',') {
@


1.97
log
@Smarter -guessindent
@
text
@d2324 14
d2374 1
a2374 1
		fi = popen((char *)(n + 1), "r");
d2395 1
a2395 1
		fi = fopen((char *)n, "r+");
d2400 1
a2400 1
		fi = fopen((char *)n, "r");
d2756 1
a2756 1
		f = popen((char *)(s + 1), "w");
d2760 1
a2760 1
		f = fopen((char *)(s + 2), "a");
d2766 1
a2766 1
		f = fopen((char *)s, "r+");
d2768 1
a2768 1
		have_stat = !stat((char *)s, &sbuf);
d2776 1
a2776 1
			if (!lstat((char *)s,&lsbuf)) {
d2792 2
a2793 2
				unlink((char *)s);
				g = creat((char *)s, sbuf.st_mode & ~(S_ISUID | S_ISGID));
d2796 1
a2796 1
					setfilecon((char *)s, &se);
d2803 1
a2803 1
				unlink((char *)s);
d2807 1
a2807 1
		f = fopen((char *)s, "w");
d2854 1
a2854 1
		if (!stat((char *)s,&sbuf))
d3010 1
a3010 1
int lock_it(unsigned char *path,unsigned char *bf)
d3012 1
d3038 1
a3038 1
void unlock_it(unsigned char *path)
d3040 1
@


1.96
log
@vfile I/O error message fix
@
text
@d2281 43
d2490 10
d2501 2
a2502 1
		for (x=0; x!=20; ++x) {
d2504 10
a2513 7
			if (pisindent(p)) {
				if (brc(p)=='\t') {
					b->o.indentc = '\t';
					b->o.istep = 1;
				} else {
					b->o.indentc = ' ';
					/* b->o.istep = 2; */
a2514 1
				break;
d2519 31
@


1.95
log
@Improve fault handling
@
text
@d2855 1
a2855 1
			_exit(-1);
d2857 1
a2857 1
			_exit(-1);
d2866 1
a2866 1
			_exit(-1);
d2868 1
a2868 1
			_exit(-1);
d2871 1
a2871 1
		_exit(-1);
d2896 1
a2896 1
		fprintf(ttsig_f, "*** JOE was aborted due to swap file I/O error\n");
d2898 1
a2898 1
		printf("\n*** JOE was aborted due to malloc returning NULL.  Buffers saved in DEADJOE\n");
d2900 1
a2900 1
		printf("\n*** JOE was aborted by UNIX signal %d.  Buffers saved in DEADJOE\n", sig);
@


1.94
log
@Abort cleanly when malloc returns NULL
@
text
@d2840 2
a2845 1
	FILE *f;
d2849 4
d2870 1
a2870 1
	if ((f = fdopen(tmpfd, "a")) == NULL)
d2874 5
a2878 3
	fprintf(f, "\n*** These modified files were found in JOE when it aborted on %s", ctime(&tim));
	if (sig == -1)
		fprintf(f, "*** JOE was aborted due to malloc returning NULL\n");
d2880 1
a2880 1
		fprintf(f, "*** JOE was aborted by UNIX signal %d\n", sig);
d2882 2
a2883 2
		fprintf(f, "*** JOE was aborted because the terminal closed\n");
	fflush(f);
d2887 1
a2887 1
				fprintf(f, "\n*** File \'%s\'\n", b->name);
d2889 3
a2891 3
				fprintf(f, "\n*** File \'(Unnamed)\'\n");
			fflush(f);
			bsavefd(b->bof, fileno(f), b->eof->byte);
d2895 3
a2897 1
	if (sig == -1)
@


1.93
log
@Add reloadall command.
@
text
@d2868 6
a2873 3
	fprintf(f, (char *)joe_gettext(_("\n*** These modified files were found in JOE when it aborted on %s")), ctime(&tim));
	if (sig)
		fprintf(f, (char *)joe_gettext(_("*** JOE was aborted by UNIX signal %d\n")), sig);
d2875 1
a2875 1
		fprintf(f, (char *)joe_gettext(_("*** JOE was aborted because the terminal closed\n")));
d2880 1
a2880 1
				fprintf(f, (char *)joe_gettext(_("\n*** File \'%s\'\n")), b->name);
d2882 1
a2882 1
				fprintf(f, (char *)joe_gettext(_("\n*** File \'(Unnamed)\'\n")));
d2888 4
@


1.92
log
@Reload command now prompts to lose changes to modified files.  Should call it revert.
@
text
@d139 1
a139 1
static B bufs = { {&bufs, &bufs} };
@


1.91
log
@Add reload command
@
text
@d289 6
a294 4
		hfreechn(b->eof->hdr);
		while (!qempty(P, link, b->bof))
			prm(b->bof->link.next);
		prm(b->bof);
@


1.90
log
@Fix file rename bugs.
@
text
@d307 107
@


1.89
log
@Preserve setuid bit
@
text
@d2521 3
d2643 1
a2643 1
	if (!berror && norm && flag && (!p->b->name || !zcmp(s,p->b->name))) {
@


1.88
log
@Change break_links to not break symbolic links.
Add break_symlinks.
@
text
@d2528 2
a2531 1
	struct stat sbuf;
d2555 3
d2560 1
a2560 1
			struct stat sbuf;
d2563 1
a2563 1
			if (!lstat((char *)s,&sbuf)) {
d2565 1
a2565 1
				if (!break_symlinks && S_ISLNK(sbuf.st_mode))
d2622 5
@


1.87
log
@More fixes:
	guessindent don't write to istep if spaces,
	lmargin limit is 1 not 2,
	add .js file type,
	allow file insert on zero width rectangle blocks,
@
text
@d14 8
d2524 1
d2555 1
a2555 1
		if (break_links) {
d2559 1
a2559 1
			if (!stat((char *)s,&sbuf)) {
d2561 2
d2584 1
@


1.86
log
@Fixed crash when file can't be written to (due to lack of disk space or being over quota), patch by Benjamin Mesing (Debian bug #103820)
@
text
@d2339 1
a2339 1
					b->o.istep = 2;
@


1.85
log
@semiautomatic variables
@
text
@d2505 1
a2505 1
	return berror = 5;
@


1.84
log
@UC -> USTR
@
text
@d1 1
a1 1
/*
a20 2
unsigned char stdbuf[stdsiz];

d153 1
a153 1
	unsigned char buf[1024];
d163 1
a163 1
			joe_snprintf_1(buf, sizeof(buf), "Buffer %s\n", b->name);
d165 1
a165 1
			joe_snprintf_1(buf, sizeof(buf), "Buffer 0x%p\n", (void *)b);
d169 1
a169 1
			joe_snprintf_1(buf, sizeof(buf), "  Pointer created by %s\n", p->tracker);
d603 1
a603 1
		int wid = 0;
d2068 1
a2068 1
	x = sLEN(n) - 1;
d2070 1
a2070 1
		for (x = sLEN(n) - 1; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
d2073 1
a2073 2

#if SIZEOF_LONG_LONG && SIZEOF_OFF_T == SIZEOF_LONG_LONG
d2098 2
a2099 1
#if SIZEOF_LONG_LONG && SIZEOF_OFF_T == SIZEOF_LONG_LONG
d2143 1
a2143 2
				z = vsncpy(z, sLEN(z), sz(n + x));
				vsrm(n);
d2152 1
a2152 2
					unsigned char *z = vsncpy(NULL, 0,
							 sz((unsigned char *)(passwd->pw_dir)));
d2154 1
a2154 2
					z = vsncpy(z, sLEN(z), sz(n + x));
					vsrm(n);
a2348 3
	/* Eliminate parsed name */
	vsrm(n);

d2682 1
a2682 1
unsigned char *brvs(P *p, int size)
d2684 1
a2684 1
	unsigned char *s = vstrunc(NULL, size);
d2686 1
a2686 1
	return brmem(p, (unsigned char *)s, size);
d2689 1
a2689 1
unsigned char *brzs(P *p, unsigned char *buf, int size)
d2691 2
a2692 1
	P *q=pdup(p, USTR "brzs");
d2695 1
a2695 2
	if(q->byte-p->byte<size)
		size = q->byte - p->byte;
d2698 1
d2701 1
d2764 1
a2764 1
	unsigned char buf[1024];
d2770 3
a2772 3
	lock_name=vsncpy(sv(lock_name),sc(".#"));
	lock_name=vsncpy(sv(lock_name),sv(name));
	joe_snprintf_3(buf,sizeof(buf),"%s@@%s.%d",user,host,getpid());
d2775 1
a2775 2
		vsrm(lock_name);
		vsrm(name);
d2783 1
a2783 2
	vsrm(lock_name);
	vsrm(name);
d2791 2
a2792 2
	lock_name=vsncpy(sv(lock_name),sc(".#"));
	lock_name=vsncpy(sv(lock_name),sv(name));
d2794 1
a2794 2
	vsrm(lock_name);
	vsrm(name);
@


1.83
log
@change US to UC
@
text
@d31 7
a37 7
	UC _("No error"),
	UC _("New File"),
	UC _("Error reading file"),
	UC _("Error seeking file"),
	UC _("Error opening file"),
	UC _("Error writing file"),
	UC _("File on disk is newer")
d160 1
a160 1
	binss(bw->cursor, UC "Buffers and pointers (the number of pointers per buffer should not grow, except for 20 from markpos):\n\n");
d245 2
a246 2
	b->bof->tracker = UC "bmkchn";
	b->eof = pdup(b->bof, UC "bmkchn");
d431 1
a431 1
			P *q = pdup(p, UC "piseol");
d458 1
a458 1
	P *q = pdup(p, UC "pisbow");
d472 1
a472 1
	P *q = pdup(p, UC "piseow");
d486 1
a486 1
	P *q = pdup(p, UC "pisblank");
d503 1
a503 1
	P *q = pdup(p, UC "piseolblank");
d519 1
a519 1
	P *q = pdup(p, UC "pisindent");
d534 1
a534 1
	P *q = pdup(p, UC "pispure");
d768 1
a768 1
			P *q = pdup(p, UC "prgetc");
d771 1
a771 1
			r = pdup(q, UC "prgetc");
d1142 1
a1142 1
	P *q = pdup(p, UC "pbackws");
d1274 1
a1274 1
	P *q = pdup(p, UC "pfind");
d1289 1
a1289 1
	P *q = pdup(p, UC "pifind");
d1435 1
a1435 1
	P *q = pdup(p, UC "prfind");
d1450 1
a1450 1
	P *q = pdup(p, UC "prifind");
d1472 1
a1472 1
	q = pdup(from, UC "bcpy");
d1932 1
a1932 1
		P *q = pdup(p, UC "binsb");
d1954 1
a1954 1
	q = pdup(p, UC "binsm");
d1979 1
a1979 1
		return binsm(p, UC "\r\n", 2);
d1994 1
a1994 1
			return binsm(p, UC "\r\n", 2);
d2192 1
a2192 1
		setopt(b,UC "");
d2208 1
a2208 1
	if (!zcmp(n, UC "-")) {
d2286 1
a2286 1
	if (zcmp(n, UC "-"))
d2302 1
a2302 1
	} else if (!zcmp(n, UC "-")) {
d2314 1
a2314 1
		p=pdup(b->bof, UC "bload");
d2335 1
a2335 1
		p=pdup(b->eof, UC "bload");
d2369 1
a2369 1
		setopt(b,UC "");
d2398 1
a2398 1
		setopt(b,UC "");
d2479 1
a2479 1
	P *np = pdup(p, UC "bsavefd");
d2546 1
a2546 1
	else if (!zcmp(s, UC "-")) {
d2605 1
a2605 1
		P *q = pdup(p, UC "bsave");
d2620 1
a2620 1
	if (zcmp(s, UC "-"))
d2633 1
a2633 1
	if (s[0] == '!' || !zcmp(s,UC "-")) {
d2654 1
a2654 1
		P *q = pdup(p, UC "brch");
d2669 1
a2669 1
	np = pdup(p, UC "brmem");
d2699 1
a2699 1
	P *q=pdup(p, UC "brzs");
d2774 2
a2775 2
	if (!user) user=UC "me";
	if (!host) host=UC "here";
d2810 1
a2810 1
	if (b->name && zcmp(b->name,UC "-") && b->name[0]!='!' && b->name[0]!='>' &&
@


1.82
log
@compiler warns
@
text
@d31 7
a37 7
	US _("No error"),
	US _("New File"),
	US _("Error reading file"),
	US _("Error seeking file"),
	US _("Error opening file"),
	US _("Error writing file"),
	US _("File on disk is newer")
d160 1
a160 1
	binss(bw->cursor, US "Buffers and pointers (the number of pointers per buffer should not grow, except for 20 from markpos):\n\n");
d245 2
a246 2
	b->bof->tracker = US "bmkchn";
	b->eof = pdup(b->bof, US "bmkchn");
d431 1
a431 1
			P *q = pdup(p, US "piseol");
d458 1
a458 1
	P *q = pdup(p, US "pisbow");
d472 1
a472 1
	P *q = pdup(p, US "piseow");
d486 1
a486 1
	P *q = pdup(p, US "pisblank");
d503 1
a503 1
	P *q = pdup(p, US "piseolblank");
d519 1
a519 1
	P *q = pdup(p, US "pisindent");
d534 1
a534 1
	P *q = pdup(p, US "pispure");
d768 1
a768 1
			P *q = pdup(p, US "prgetc");
d771 1
a771 1
			r = pdup(q, US "prgetc");
d1142 1
a1142 1
	P *q = pdup(p, US "pbackws");
d1274 1
a1274 1
	P *q = pdup(p, US "pfind");
d1289 1
a1289 1
	P *q = pdup(p, US "pifind");
d1435 1
a1435 1
	P *q = pdup(p, US "prfind");
d1450 1
a1450 1
	P *q = pdup(p, US "prifind");
d1472 1
a1472 1
	q = pdup(from, US "bcpy");
d1932 1
a1932 1
		P *q = pdup(p, US "binsb");
d1954 1
a1954 1
	q = pdup(p, US "binsm");
d1979 1
a1979 1
		return binsm(p, US "\r\n", 2);
d1994 1
a1994 1
			return binsm(p, US "\r\n", 2);
d2192 1
a2192 1
		setopt(b,US "");
d2208 1
a2208 1
	if (!zcmp(n, US "-")) {
d2286 1
a2286 1
	if (zcmp(n, US "-"))
d2302 1
a2302 1
	} else if (!zcmp(n, US "-")) {
d2314 1
a2314 1
		p=pdup(b->bof, US "bload");
d2335 1
a2335 1
		p=pdup(b->eof, US "bload");
d2369 1
a2369 1
		setopt(b,US "");
d2398 1
a2398 1
		setopt(b,US "");
d2479 1
a2479 1
	P *np = pdup(p, US "bsavefd");
d2546 1
a2546 1
	else if (!zcmp(s, US "-")) {
d2605 1
a2605 1
		P *q = pdup(p, US "bsave");
d2620 1
a2620 1
	if (zcmp(s, US "-"))
d2633 1
a2633 1
	if (s[0] == '!' || !zcmp(s,US "-")) {
d2654 1
a2654 1
		P *q = pdup(p, US "brch");
d2669 1
a2669 1
	np = pdup(p, US "brmem");
d2699 1
a2699 1
	P *q=pdup(p, US "brzs");
d2774 2
a2775 2
	if (!user) user=US "me";
	if (!host) host=US "here";
d2810 1
a2810 1
	if (b->name && zcmp(b->name,US "-") && b->name[0]!='!' && b->name[0]!='>' &&
@


1.81
log
@fix long long warnings
@
text
@d605 1
a605 1
		int wid;
@


1.80
log
@allow ,start,size only if correct
@
text
@d2076 19
a2094 19
			if (sizeof(off_t) > 4) {
				if (n[x + 1] == 'x' || n[x + 1] == 'X')
					sscanf((char *)(n + x + 2), "%llx", skip);
				else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
					sscanf((char *)(n + x + 3), "%llx", skip);
				else if (n[x + 1] == '0')
					sscanf((char *)(n + x + 1), "%llo", skip);
				else
					sscanf((char *)(n + x + 1), "%lld", skip);
			} else {
				if (n[x + 1] == 'x' || n[x + 1] == 'X')
					sscanf((char *)(n + x + 2), "%lx", skip);
				else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
					sscanf((char *)(n + x + 3), "%lx", skip);
				else if (n[x + 1] == '0')
					sscanf((char *)(n + x + 1), "%lo", skip);
				else
					sscanf((char *)(n + x + 1), "%ld", skip);
			}
d2101 19
a2119 19
					if (sizeof(off_t) > 4) {
						if (n[x + 1] == 'x' || n[x + 1] == 'X')
							sscanf((char *)(n + x + 2), "%llx", skip);
						else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
							sscanf((char *)(n + x + 3), "%llx", skip);
						else if (n[x + 1] == '0')
							sscanf((char *)(n + x + 1), "%llo", skip);
						else
							sscanf((char *)(n + x + 1), "%lld", skip);
					} else {
						if (n[x + 1] == 'x' || n[x + 1] == 'X')
							sscanf((char *)(n + x + 2), "%lx", skip);
						else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
							sscanf((char *)(n + x + 3), "%lx", skip);
						else if (n[x + 1] == '0')
							sscanf((char *)(n + x + 1), "%lo", skip);
						else
							sscanf((char *)(n + x + 1), "%ld", skip);
					}
@


1.79
log
@Add builtins.  Fix syntax error in python.jsf.in
@
text
@d2070 3
a2072 25
	for (x = sLEN(n) - 1; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
	if (n[x] == ',') {
		n[x] = 0;

		if (sizeof(off_t) > 4) {
			if (n[x + 1] == 'x' || n[x + 1] == 'X')
				sscanf((char *)(n + x + 2), "%llx", skip);
			else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				sscanf((char *)(n + x + 3), "%llx", skip);
			else if (n[x + 1] == '0')
				sscanf((char *)(n + x + 1), "%llo", skip);
			else
				sscanf((char *)(n + x + 1), "%lld", skip);
		} else {
			if (n[x + 1] == 'x' || n[x + 1] == 'X')
				sscanf((char *)(n + x + 2), "%lx", skip);
			else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				sscanf((char *)(n + x + 3), "%lx", skip);
			else if (n[x + 1] == '0')
				sscanf((char *)(n + x + 1), "%lo", skip);
			else
				sscanf((char *)(n + x + 1), "%ld", skip);
		}

		for (--x; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
d2075 1
a2075 1
			*amnt = *skip;
d2095 27
@


1.78
log
@large file patch, makefile fix, tty.c fix.
@
text
@d2073 2
a2074 12
		if (n[x + 1] == 'x' || n[x + 1] == 'X')
			sscanf((char *)(n + x + 2), "%llx", skip);
		else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
			sscanf((char *)(n + x + 3), "%llx", skip);
		else if (n[x + 1] == '0')
			sscanf((char *)(n + x + 1), "%llo", skip);
		else
			sscanf((char *)(n + x + 1), "%lld", skip);
		for (--x; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
		if (n[x] == ',') {
			n[x] = 0;
			*amnt = *skip;
d2083 34
@


1.77
log
@transpose menus
@
text
@d2063 1
a2063 1
unsigned char *parsens(unsigned char *s, long int *skip, long int *amnt)
d2074 1
a2074 1
			sscanf((char *)(n + x + 2), "%lx", (unsigned long *)skip);
d2076 1
a2076 1
			sscanf((char *)(n + x + 3), "%lx", (unsigned long *)skip);
d2078 1
a2078 1
			sscanf((char *)(n + x + 1), "%lo", (unsigned long *)skip);
d2080 1
a2080 1
			sscanf((char *)(n + x + 1), "%ld", skip);
d2086 1
a2086 1
				sscanf((char *)(n + x + 2), "%lx", (unsigned long *)skip);
d2088 1
a2088 1
				sscanf((char *)(n + x + 3), "%lx", (unsigned long *)skip);
d2090 1
a2090 1
				sscanf((char *)(n + x + 1), "%lo", (unsigned long *)skip);
d2092 1
a2092 1
				sscanf((char *)(n + x + 1), "%ld", skip);
d2152 1
a2152 1
	long skip, amnt;
d2448 1
a2448 1
int bsavefd(P *p, int fd, long int size)
d2496 1
a2496 1
int bsave(P *p, unsigned char *s, long int size, int flag)
d2499 1
a2499 1
	long skip, amnt;
@


1.76
log
@Less annoying lock messages.
@
text
@d136 8
@


1.75
log
@gettext()
@
text
@d215 1
d2742 2
a2743 1
	if (!symlink((char *)buf,(char *)lock_name)) {
@


1.74
log
@Better grep-find
@
text
@d31 7
a37 7
	US "No error",
	US "New File",
	US "Error reading file",
	US "Error seeking file",
	US "Error opening file",
	US "Error writing file",
	US "File on disk is newer"
d157 1
a157 1
			joe_snprintf_1((char *)buf, sizeof(buf), "Buffer %s\n", b->name);
d159 1
a159 1
			joe_snprintf_1((char *)buf, sizeof(buf), "Buffer 0x%p\n", (void *)b);
d163 1
a163 1
			joe_snprintf_1((char *)buf, sizeof(buf), "  Pointer created by %s\n", p->tracker);
d2703 1
a2703 1
	fprintf(f, "\n*** Modified files in JOE when it aborted on %s", ctime(&tim));
d2705 1
a2705 1
		fprintf(f, "*** JOE was aborted by signal %d\n", sig);
d2707 1
a2707 1
		fprintf(f, "*** JOE was aborted because the terminal closed\n");
d2712 1
a2712 1
				fprintf(f, "\n*** File \'%s\'\n", b->name);
d2714 1
a2714 1
				fprintf(f, "\n*** File \'(Unnamed)\'\n");
d2740 1
a2740 1
	joe_snprintf_3((char *)buf,sizeof(buf),"%s@@%s.%d",user,host,getpid());
@


1.73
log
@e option for s&r
@
text
@d249 1
@


1.72
log
@A option for search
Restore cursor to old position
@
text
@d136 3
d2339 1
a2339 1
				++b->count;
d2346 1
a2346 1
	b = bload(s);
d2420 1
a2420 1
/* Find an orphaned buffer */
@


1.71
log
@Add rexx.  Take advantage of highlighter subroutines.
@
text
@d136 6
d2423 1
a2423 1
		if (b->orphan) {
@


1.70
log
@fix compiler warnings
@
text
@d159 1
@


1.69
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d582 1
a582 1
		int c, oc;
d584 1
a584 1
		int n, m;
d589 1
a589 1
		oc = c;
d617 1
a617 1
		m = n;
@


1.68
log
@fix input redirection
@
text
@a7 1
#include "config.h"
a9 5
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
d13 2
a14 5
#include <errno.h>
#include <stdlib.h>
#ifdef HAVE_TIME_H
#include <time.h>
#endif
a20 18

#include "b.h"
#include "blocks.h"
#include "main.h"
#include "path.h"
#include "queue.h"
#include "rc.h"
#include "scrn.h"
#include "uerror.h"
#include "undo.h"
#include "utils.h"
#include "va.h"
#include "vfile.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"

a22 1
extern int errno;
d26 1
a26 1
int error;
a137 1
	int x;
d150 1
a150 1
			joe_snprintf_1((char *)buf, sizeof(buf), "Buffer 0x%x\n", b);
d159 1
a250 3

extern B *errbuf;

d1929 1
a1929 1
	int hdramnt;
d1995 1
a1995 1
		error = 0;
d2000 1
a2000 1
		error = -2;
d2002 1
a2002 1
		error = 0;
d2016 2
a2017 2
	error = 0;
	while (seg = vlock(vmem, (l = halloc())->seg), !error && (amnt = bkread(fi, seg, max >= SEGSIZ ? SEGSIZ : (int) max))) {
d2054 1
a2054 1
			sscanf((char *)(n + x + 2), "%lx", skip);
d2056 1
a2056 1
			sscanf((char *)(n + x + 3), "%lx", skip);
d2058 1
a2058 1
			sscanf((char *)(n + x + 1), "%lo", skip);
d2066 1
a2066 1
				sscanf((char *)(n + x + 2), "%lx", skip);
d2068 1
a2068 1
				sscanf((char *)(n + x + 3), "%lx", skip);
d2070 1
a2070 1
				sscanf((char *)(n + x + 1), "%lo", skip);
d2130 2
a2131 2
	FILE *fi;
	B *b;
d2141 1
a2141 1
		error = -1;
d2145 1
a2145 1
		b->er = error;
d2195 1
a2195 1
			error = -1;
d2197 1
a2197 1
			error = -4;
d2210 2
a2211 2
			if (r != SEGSIZ || error) {
				error = -3;
d2217 2
a2218 2
		if (skip || error) {
			error = -3;
d2250 1
a2250 1
	if (error || s[0] == '!' || skip || amnt != MAXLONG) {
d2308 1
a2308 1
	b->er = error;
d2318 1
a2318 1
		error = -1;
d2323 1
a2323 1
		b->er = error;
d2332 1
a2332 1
			error = 0;
d2347 1
a2347 1
		error = -1;
d2352 1
a2352 1
		b->er = error;
d2361 1
a2361 1
			error = 0;
d2366 1
a2366 1
	error = -1;
d2370 1
a2370 1
	b->er = error;
d2461 1
a2461 1
	return error = 0;
d2464 1
a2464 1
	return error = 5;
a2510 1
				int en=0;
d2518 1
a2518 1
						error = -4;
d2543 1
a2543 1
		error = -4;
d2549 1
a2549 1
		error = -3;
d2555 1
a2555 1
	if (!error && force && size && !skip && amnt == MAXLONG) {
d2561 1
a2561 1
			error = -5;
d2578 1
a2578 1
	if (!error && norm && flag && (!p->b->name || !zcmp(s,p->b->name))) {
d2588 1
a2588 1
	return error;
@


1.67
log
@joe - fix was not working over X
@
text
@d2191 1
d2203 4
@


1.66
log
@remove debug message
@
text
@d2192 1
a2192 1
		struct stat x, y;
d2195 4
a2198 1
		if (stat("/dev/tty", &x) || fstat(fileno(f), &y) || (x.st_dev == y.st_dev && x.st_ino == y.st_ino)) {
@


1.65
log
@Better handling of 'joe -'
@
text
@a2029 1
	printf("Done\n");
@


1.64
log
@New line attribute cache.
@
text
@d1 1
a1 1
 /*
d2030 1
d2191 3
a2193 1
	if (!zcmp(n, US "-"))
d2195 6
a2200 1
	else {
d2249 1
@


1.63
log
@add joe_debug
@
text
@d266 1
d300 2
d1616 1
d1740 2
d1906 1
d1912 4
@


1.62
log
@Some more highlighting cache fixes.
@
text
@d164 26
d254 2
a255 1
	b->eof = pdup(b->bof);
d345 1
a345 1
P *pdup(P *p)
d352 1
d357 1
a357 1
P *pdupown(P *p, P **o)
d364 1
d439 1
a439 1
			P *q = pdup(p);
d466 1
a466 1
	P *q = pdup(p);
d480 1
a480 1
	P *q = pdup(p);
d494 1
a494 1
	P *q = pdup(p);
d511 1
a511 1
	P *q = pdup(p);
d527 1
a527 1
	P *q = pdup(p);
d542 1
a542 1
	P *q = pdup(p);
d776 1
a776 1
			P *q = pdup(p);
d779 1
a779 1
			r = pdup(q);
d1150 1
a1150 1
	P *q = pdup(p);
d1282 1
a1282 1
	P *q = pdup(p);
d1297 1
a1297 1
	P *q = pdup(p);
d1443 1
a1443 1
	P *q = pdup(p);
d1458 1
a1458 1
	P *q = pdup(p);
d1480 1
a1480 1
	q = pdup(from);
d1925 1
d1932 1
a1932 1
		P *q = pdup(p);
d1954 1
a1954 1
	q = pdup(p);
d2269 1
a2269 1
		p=pdup(b->bof);
d2290 1
a2290 1
		p=pdup(b->eof);
d2434 1
a2434 1
	P *np = pdup(p);
d2561 1
a2561 1
		P *q = pdup(p);
d2610 1
a2610 1
		P *q = pdup(p);
d2625 1
a2625 1
	np = pdup(p);
d2655 1
a2655 1
	P *q=pdup(p);
@


1.61
log
@Improve highlighting performance.
@
text
@a241 1
	b->db = mk_lattr_db();
a272 1
		rm_lattr_db(b->db);
@


1.60
log
@fix gcc-4.0.0 warnings
@
text
@d242 1
d274 1
d962 1
a962 1
	if (line < labs(p->line - line))
d964 2
a965 1
	if (labs(p->b->eof->line - line) < labs(p->line - line))
d967 1
d1709 1
a1709 1
	if (nlines && !pisbol(from)) {
d1874 1
a1874 1
	if (nlines && !pisbol(p))
@


1.59
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@a20 1
#include <string.h>
d1971 1
a1971 1
	return binsm(p, s, strlen((char *)s));
d2147 1
a2147 1
	if (!strcmp(n, "-"))
d2209 1
a2209 1
	if (strcmp(n, "-"))
d2219 1
a2219 1
	b->name = joesep(joe_strdup(s));
d2225 1
a2225 1
	} else if (!strcmp(n, "-")) {
d2299 1
a2299 1
		if (b->name && !strcmp(s, b->name)) {
d2328 1
a2328 1
		if (b->name && !strcmp(s, b->name)) {
d2343 1
a2343 1
	b->name = joe_strdup(s);
d2364 1
a2364 1
		if (b->name && !strcmp(s, b->name)) {
d2469 1
a2469 1
	else if (!strcmp(s, "-")) {
d2544 1
a2544 1
	if (strcmp(s, "-"))
d2551 1
a2551 1
	if (!error && norm && flag && (!p->b->name || !strcmp((char *)s,p->b->name))) {
d2557 1
a2557 1
	if (s[0] == '!' || !strcmp(s, "-")) {
d2733 1
a2733 1
	if (b->name && strcmp(b->name,"-") && b->name[0]!='!' && b->name[0]!='>' &&
@


1.58
log
@fix locks bug, jmacs improvements
@
text
@d2696 2
a2697 2
	unsigned char *user = getenv("USER");
	unsigned char *host = getenv("HOSTNAME");
d2699 2
a2700 2
	if (!user) user="me";
	if (!host) host="here";
d2703 2
a2704 2
	joe_snprintf_3(buf,sizeof(buf),"%s@@%s.%d",user,host,getpid());
	if (!symlink(buf,lock_name)) {
d2710 1
a2710 1
		len = readlink(lock_name,bf,255);
d2725 1
a2725 1
	unlink(lock_name);
d2734 2
a2735 1
	if (b->name && strcmp(b->name,"-") && b->name[0]!='!' && b->name[0]!='>')
@


1.57
log
@prefer bash over sh for cygwin
@
text
@d277 6
@


1.56
log
@Fix ~ expansion insanity
@
text
@d2748 9
@


1.55
log
@File changed check.
@
text
@d2058 10
d2069 2
@


1.54
log
@Add -break_links option.
@
text
@d215 2
d2721 15
@


1.53
log
@Perforce macro and support for it.
@
text
@d26 6
d2427 2
d2457 34
@


1.52
log
@make locking optional
@
text
@d204 1
@


1.51
log
@file locking.
@
text
@d252 1
a252 1
		if (b->locked && !b->ignored_lock && b->name && b->name[0]!='!' && b->name[0]!='>') {
a253 1
		}
d2666 10
@


1.50
log
@Fix -pedantic warnings.
@
text
@d202 2
d252 3
d2623 44
@


1.49
log
@Added diff.jsf.in.
Added improved xml.jsf.in
@
text
@d2189 1
a2189 1
	b->name = joesep((unsigned char *)strdup(s));
d2313 1
a2313 1
	b->name = (unsigned char *)strdup((char *)s);
@


1.48
log
@Fix lockup problem: do not allow querysave in
prompt windows.
@
text
@d54 1
a54 1
	US "No error1",
@


1.47
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d54 1
a54 1
	US "No error",
@


1.46
log
@Compile now uses shell window (so you can hit ^C during the
compile).

Shell window termination code fix: now all of the output always
makes it to the window.

Added query save loop to save all modified files before build.

Added scratch buffers: they are ignored during ^K X, ^C and
querysave.

^X ^C in jmacs is now much more like emacs.
@
text
@d227 2
d2410 6
d2483 3
a2485 1
	if (!error && norm && flag && p->b->name && !strcmp((char *)s,p->b->name)) {
@


1.45
log
@^K E prompts to load original file from disk.
@
text
@d1 1
a1 1
/*
d200 1
d2281 35
@


1.44
log
@Update file date on save.
@
text
@d2280 23
@


1.43
log
@Warn if file changed on save.
@
text
@d2354 1
a2376 5
		if (flag && p->b->name && !strcmp((char *)s,p->b->name)) {
			stat((char *)s,&sbuf);
			if (sbuf.st_mtime>p->b->mod_time)
				return -6;
		}
d2378 1
d2416 5
@


1.42
log
@New status line escape sequence: %x shows current context (function
cursor is in).

More globs in *rc.in files.

csh.jsf lisp.jsf
@
text
@d54 5
d60 1
a60 4
	US "Error opening file",
	US "Error seeking file",
	US "Error reading file",
	US "New File"
d2092 2
d2125 4
d2165 1
d2349 1
a2349 1
int bsave(P *p, unsigned char *s, long int size)
d2353 1
d2375 6
a2380 1
	else
d2382 1
@


1.41
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d2468 14
@


1.40
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d419 1
a419 1
	if (isalnum_(p->b->o.utf8,p->b->o.charmap,c) && (!isalnum_(p->b->o.utf8,p->b->o.charmap,d) || pisbof(p)))
d433 1
a433 1
	if (isalnum_(p->b->o.utf8,p->b->o.charmap,c) && (!isalnum_(p->b->o.utf8,p->b->o.charmap,d) || piseof(p)))
d445 1
a445 1
	while (joe_isblank(brc(q)))
d461 1
a461 1
	while (joe_isblank(brc(q)))
d479 1
a479 1
	while (joe_isblank(brc(q)))
d556 1
a556 1
	if (p->b->o.utf8) {
d719 1
a719 1
	if (p->b->o.utf8) {
d855 1
a855 1
	if (p->b->o.crlf || p->b->o.utf8)
d960 1
a960 1
	if(p->b->o.utf8) {
d1032 1
a1032 1
	if (p->b->o.utf8) {
d1185 1
a1185 1
		if ((c = joe_toupper(map,frgetc(p))) != s[--x]) {
d1344 1
a1344 1
		if ((c = joe_toupper(map,fpgetc(p))) != s[x++]) {
d1932 1
a1932 1
	if (c>127 && p->b->o.utf8) {
d2424 1
a2424 1
	if (p->b->o.utf8) {
@


1.39
log
@Fix highlighter when there are utf-8 characters in file.

No longer depend on wctype.h (working towards not depending on
iconv()).
@
text
@a20 1
#include <ctype.h>
d40 1
d419 1
a419 1
	if (isalnum_(p->b->o.utf8,c) && (!isalnum_(p->b->o.utf8,d) || pisbof(p)))
d433 1
a433 1
	if (isalnum_(p->b->o.utf8,c) && (!isalnum_(p->b->o.utf8,d) || piseof(p)))
d1170 1
d1185 1
a1185 1
		if ((c = toupper(frgetc(p))) != s[--x]) {
d1328 1
d1344 1
a1344 1
		if ((c = toupper(fpgetc(p))) != s[x++]) {
@


1.38
log
@Better handling of iconv() conversion errors.

Better handling of error UTF-8 sequences.
@
text
@d611 1
a611 1
				wid = mk_wcwidth(1,c);
d775 1
a775 1
			p->col -= mk_wcwidth(1,d);
d979 1
a979 1
				wid = mk_wcwidth(1,c);
@


1.37
log
@Prepare for release
@
text
@d589 1
d598 1
a598 1
				if((d&0xC0)!=0x80)
d611 1
a611 1
				wid = mk_wcwidth(c);
d720 19
d775 1
a775 1
			p->col -= mk_wcwidth(d);
d779 1
d979 1
a979 1
				wid = mk_wcwidth(c);
@


1.36
log
@Added -purify option.
@
text
@d46 2
d2170 35
a2204 8
	p=pdup(b->bof);
	/* FIXME: this should be an option */
	b->o.crlf = 0;
	for(x=0;x!=1024;++x) {
		int c = pgetc(p);
		if(c == '\r') {
			b->o.crlf = 1;
			break;
d2206 4
a2209 6
		if(c == '\n') {
			b->o.crlf = 0;
			break;
			}
		if(c == NO_MORE_DATA)
			break;
a2210 2
	prm(p);
	
@


1.35
log
@*** empty log message ***
@
text
@d819 10
d1053 2
a1054 3
	piscol(p);
	if (usetabs)
		while (p->col < to)
d1063 2
a1064 2
		while (p->col < to) {
			binsc(p, ' ');
@


1.34
log
@Fixed bug where '-syntax' on command line had
no effect.

Now if terminal is UTF-8, the default file type
is assumed to be UTF-8.
@
text
@d484 15
@


1.33
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d541 1
a541 1
		int c;
d543 1
a543 1
		int n;
d548 1
d568 3
a570 1
		} else { /* 0-191, 254, 255: ASCII or control character */
d572 1
d575 2
d587 3
d591 2
a592 2
			}
			if (val)
d731 1
a731 1
			} else { /* Invalid (0xFE or 0xFF found) */
d2145 2
a2146 1
	/* FIXME: this is broken if -crlf flag was already set */
@


1.32
log
@Input of UTF-8 is now working.  For example, you
can cut and paste in an xterm.

Placed UTF-8 encoder and decoder in separate file.
@
text
@d417 1
a417 1
	if (isalnum_(c) && (!isalnum_(d) || pisbof(p)))
d431 1
a431 1
	if (isalnum_(c) && (!isalnum_(d) || piseof(p)))
d443 17
a459 1
	while (isblank(brc(q)))
d477 1
a477 1
	while (isblank(brc(q)))
d1863 1
a1863 1
P *binsc(P *p, unsigned char c)
d1872 1
a1872 1
P *bins_utf8(P *p, int c)
d1874 11
a1884 3
	unsigned char buf[8];
	int len = utf8_encode(buf,c);
	return binsm(p,buf,len);
@


1.31
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d40 1
d1846 1
a1846 1
/* insert char 'c' at 'p' */
d1855 8
@


1.30
log
@Fix lockup bug in UTF-8: hit down arrow on last line.  Bug was in pcol().

Start replacement of 'char *' with 'unsigned char *'.  I want to be able to
assign characters to integers and not get -1 (this finishes the conversion
to NO_MORE_DATA from MAXINT).
@
text
@d42 1
a42 1
char stdbuf[stdsiz];
d50 6
a55 6
char *msgs[] = {
	"Error writing file",
	"Error opening file",
	"Error seeking file",
	"Error reading file",
	"New File"
d527 1
d535 1
a535 3
		if ((c&0x80)==0x00) { /* One byte */
			n = 0;
		} else if ((c&0xE0)==0xC0) { /* Two bytes */
d550 2
a551 2
		} else { /* Error */
			c = '?';
d554 16
a569 11
		while(n) {
			d = brc(p);
			if((d&0xC0)!=0x80)
				break;
			pgetb(p);
			c = ((c<<6)|(d&0x3F));
			--n;
		}

		if(n) { /* There was an error (FIXME: this needs more thought) */
			c = '?';
d572 1
a572 1
		if(val) {
a577 2
			else if (c<32)
				p->col++;
d579 1
a579 1
				p->col += mk_wcwidth(c);
d1849 1
a1849 1
		return binsm(p, "\r\n", 2);
d1857 1
a1857 1
	return binsm(p, s, strlen(s));
d1917 1
a1917 1
char *parsens(char *s, long int *skip, long int *amnt)
d1919 1
a1919 1
	char *n = vsncpy(NULL, 0, sz(s));
d1928 1
a1928 1
			sscanf(n + x + 2, "%lx", skip);
d1930 1
a1930 1
			sscanf(n + x + 3, "%lx", skip);
d1932 1
a1932 1
			sscanf(n + x + 1, "%lo", skip);
d1934 1
a1934 1
			sscanf(n + x + 1, "%ld", skip);
d1940 1
a1940 1
				sscanf(n + x + 2, "%lx", skip);
d1942 1
a1942 1
				sscanf(n + x + 3, "%lx", skip);
d1944 1
a1944 1
				sscanf(n + x + 1, "%lo", skip);
d1946 1
a1946 1
				sscanf(n + x + 1, "%ld", skip);
d1954 1
a1954 1
				char *z;
d1956 1
a1956 1
				s = getenv("HOME");
d1965 1
a1965 1
				passwd = getpwnam(n + 1);
d1968 2
a1969 2
					char *z = vsncpy(NULL, 0,
							 sz(passwd->pw_dir));
d1989 1
a1989 1
B *bload(char *s)
d1995 1
a1995 1
	char *n;
d2003 1
a2003 1
		setopt(b,"");
d2016 1
a2016 1
		fi = popen(n + 1, "r");
d2022 1
a2022 1
		fi = fopen(n, "r+");
d2027 1
a2027 1
		fi = fopen(n, "r");
d2086 1
a2086 1
	b->name = joesep(strdup(s));
d2128 1
a2128 1
B *bfind(char *s)
d2135 1
a2135 1
		setopt(b,"");
d2156 1
a2156 1
char **getbufs(void)
d2158 1
a2158 1
	char **s = vamk(16);
d2225 1
a2225 1
int bsave(P *p, char *s, long int size)
d2239 1
a2239 1
		f = popen(s + 1, "w");
d2243 1
a2243 1
		f = fopen(s + 2, "a");
d2249 1
a2249 1
		f = fopen(s, "r+");
d2251 1
a2251 1
		f = fopen(s, "w");
d2346 1
a2346 1
char *brvs(P *p, int size)
d2348 1
a2348 1
	char *s = vstrunc(NULL, size);
@


1.29
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d69 1
a69 1
static void gstgap(H *hdr, char *ptr, int ofst)
d83 1
a83 1
static void ginsm(H *hdr, char *ptr, int ofst, char *blk, int size)
d93 1
a93 1
static void grmem(H *hdr, char *ptr, int ofst, char *blk, int size)
d399 1
a399 1
	char c;
d806 1
a806 1
	char c;
d830 1
a830 1
	char c;
d891 3
d1032 1
a1032 1
static char frgetc(P *p)
d1194 1
a1194 1
	char c;
d1343 1
a1343 1
	char *ptr;
d1410 1
a1410 1
		char *ptr = vlock(vmem, hdr->seg);
d1432 1
a1432 1
		char *ptr = vlock(vmem, hdr->seg);
d1476 1
a1476 1
	char *ptr;
d1662 1
a1662 1
		char *ptr;
d1699 1
a1699 1
static H *bldchn(char *blk, int size, long *nlines)
d1706 1
a1706 1
		char *ptr;
d1813 1
a1813 1
P *binsm(P *p, char *blk, int amnt)
d1844 1
a1844 1
P *binsc(P *p, char c)
d1853 1
a1853 1
P *binss(P *p, char *s)
d1862 1
a1862 1
static int bkread(int fi, char *buff, int size)
d1885 1
a1885 1
	char *seg;
d1989 1
a1989 1
	char buffer[SEGSIZ];
d2267 1
a2267 1
		char nl = '\n';
d2317 1
a2317 1
char *brmem(P *p, char *blk, int size)
d2319 1
a2319 1
	char *bk = blk;
d2336 1
a2336 1
char *brs(P *p, int size)
d2338 1
a2338 1
	char *s = (char *) joe_malloc(size + 1);
d2348 1
a2348 1
	return brmem(p, s, size);
@


1.28
log
@Fix screen update bug introduced with Apr 7th change.

Option settings now can be based on file contents as well as
file name.

Added syntax indicator for status line.
@
text
@d387 1
a387 1
			if (pgetc(q) == '\n') {
d403 2
a404 2
	c = prgetc(p);
	pgetc(p);
d443 1
a443 1
		pgetc(q);
d493 2
a494 2
/* return current character and move p to the next character */
int pgetc(P *p)
a503 1

d510 1
a510 1
			return pgetc(p);
d512 1
a512 1
			++p->col;
d514 1
a514 4
		if (c == '\t')
			p->col += (p->b->o.tab) - (p->col) % (p->b->o.tab);
		else
			++(p->col);
d519 91
d637 2
a638 1
static int prgetc1(P *p)
d648 2
a649 1
	if (c == '\n') {
a650 6
		p->valcol = 0;
	} else {
		if (c == '\t')
			p->valcol = 0;
		--p->col;
	}
d654 2
a655 2
/* move p to the previous character */
int prgetc(P *p)
d657 1
a657 1
	int c = prgetc1(p);
d660 1
a660 1
		c = prgetc1(p);
d664 1
a664 1
			pgetc(p);
d670 50
d758 1
a758 2
	H *hdr = p->hdr;
	int ofst = p->ofst;
d761 1
a761 1
	while (p->ofst != ofst || p->hdr != hdr)
d770 1
a770 1
		pgetc(p);
d779 1
a779 1
	if (p->b->o.crlf)
d846 1
a846 1
		int k = prgetc1(p);
d849 1
a849 1
			pgetc(p);
d880 1
d884 27
a910 3
	do {
		unsigned char c;
		int wid;
d912 19
a930 18
		if (p->ofst == GSIZE(p->hdr))
			break;
		c = GCHAR(p);
		if (c == '\n')
			break;
		if (p->b->o.crlf && c == '\r' && piseol(p))
			break;
		if (c == '\t')
			wid = p->b->o.tab - p->col % p->b->o.tab;
		else
			wid = 1;
		if (p->col + wid > goalcol)
			break;
		if (++p->ofst == GSIZE(p->hdr))
			pnext(p);
		++p->byte;
		p->col += wid;
	} while (p->col != goalcol);
d934 1
a934 1
/* move p into given given 'goalcol' column (even within whitespaces) */
d948 2
a949 1
/* FIXME: whats the differnce between pcol() and pcoli() ??? */
d953 28
a980 2
	while (p->col < goalcol) {
		unsigned char c;
d982 8
a989 16
		if (p->ofst == GSIZE(p->hdr))
			break;
		c = GCHAR(p);
		if (c == '\n')
			break;
#ifdef __MSDOS
		if (c == '\r' && piseol(p))
			break;
#endif
		else if (c == '\t')
			p->col += p->b->o.tab - p->col % p->b->o.tab;
		else
			++p->col;
		if (++p->ofst == GSIZE(p->hdr))
			pnext(p);
		++p->byte;
d2098 1
d2291 2
d2300 14
@


1.27
log
@Automatically detect MS-DOS files
@
text
@d1821 1
a1821 1
		setopt(&b->o, "");
d1858 1
a1858 1
		setopt(&b->o, n);
d1884 1
a1884 1
	setopt(&b->o, n);
d1952 1
a1952 1
		setopt(&b->o, "");
@


1.26
log
@change type of variables holding string to unsigned char *
@
text
@d1815 2
d1920 17
@


1.25
log
@change type of variables holding time values to time_t
@
text
@d970 1
a970 1
P *pfind(P *p, char *s, int len)
d985 1
a985 1
P *pifind(P *p, char *s, int len)
d1130 1
a1130 1
P *prfind(P *p, char *s, int len)
d1145 1
a1145 1
P *prifind(P *p, char *s, int len)
@


1.24
log
@fix segafults in isalpha()-like functions
@
text
@a2136 2
extern char *ctime(const time_t *);

d2139 1
a2139 1
	long tim = time(0);
@


1.23
log
@pisbow() should match the beginning of file and piseow() should match the end of file
@
text
@d499 1
a499 1
		return MAXINT;
d556 1
a556 1
			return MAXINT;
d580 1
a580 1
		if (c != MAXINT)
d716 1
a716 1
		if (k != '\r' && k != MAXINT)
d785 1
a785 1
	if (c != MAXINT)
d846 1
a846 1
	if (c != MAXINT)
d1017 1
a1017 1
		return MAXINT;
d2097 1
a2097 1
		return MAXINT;
@


1.22
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d416 1
a416 1
	if (isalnum_(c) && !isalnum_(d))
d430 1
a430 1
	if (isalnum_(c) && !isalnum_(d))
@


1.21
log
@change aELEMENT #define to typedef
@
text
@d71 7
a77 4
	if (ofst > hdr->hole)
		mmove(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole), vchanged(ptr);
	else if (ofst < hdr->hole)
		mmove(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst), vchanged(ptr);
d96 4
a99 3
		if (size > hdr->hole - ofst)
			mmove(blk, ptr + ofst, hdr->hole - ofst), mmove(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
		else
@


1.20
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d71 4
a74 7
	if (ofst > hdr->hole) {
		mmove(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole);
		vchanged(ptr);
	} else if (ofst < hdr->hole) {
		mmove(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst);
		vchanged(ptr);
	}
d93 3
a95 4
		if (size > hdr->hole - ofst) {
			mmove(blk, ptr + ofst, hdr->hole - ofst);
			mmove(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
		} else
d1782 2
a1783 1
					char *z = vsncpy(NULL, 0, sz(passwd->pw_dir));
@


1.19
log
@use GCHAR macro - clean up the source
@
text
@d71 7
a77 4
	if (ofst > hdr->hole)
		mmove(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole), vchanged(ptr);
	else if (ofst < hdr->hole)
		mmove(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst), vchanged(ptr);
d96 4
a99 3
		if (size > hdr->hole - ofst)
			mmove(blk, ptr + ofst, hdr->hole - ofst), mmove(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
		else
d1786 1
a1786 2
					char *z = vsncpy(NULL, 0,
							 sz(passwd->pw_dir));
@


1.18
log
@change 0 to NULL when used as pointer
@
text
@d64 4
d496 1
a496 4
	if (p->ofst >= p->hdr->hole)
		c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
		c = p->ptr[p->ofst];
d536 1
a536 4
		if (p->ofst >= p->hdr->hole) {
			if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
				++p->line;
		} else if (p->ptr[p->ofst] == '\n')
d554 1
a554 4
	if (p->ofst >= p->hdr->hole)
		c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
		c = p->ptr[p->ofst];
d602 1
a602 4
		if (p->ofst >= p->hdr->hole) {
			if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
				--p->line;
		} else if (p->ptr[p->ofst] == '\n')
d650 1
a650 4
			if (p->ofst >= p->hdr->hole)
				c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
			else
				c = p->ptr[p->ofst];
d679 1
a679 4
		if (p->ofst >= p->hdr->hole)
			c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		else
			c = p->ptr[p->ofst];
d706 1
a706 4
		if (p->ofst >= p->hdr->hole)
			c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		else
			c = p->ptr[p->ofst];
d753 1
a753 4
		if (p->ofst >= p->hdr->hole)
			c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		else
			c = p->ptr[p->ofst];
d795 1
a795 4
		if (p->ofst >= p->hdr->hole)
			c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		else
			c = p->ptr[p->ofst];
d853 1
a853 4
	if (p->ofst >= p->hdr->hole)
		return p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
		return p->ptr[p->ofst];
d950 1
a950 4
		if (p->ofst >= p->hdr->hole) {
			if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
				++p->line;
		} else if (p->ptr[p->ofst] == '\n')
d1014 1
a1014 4
	if (p->ofst >= p->hdr->hole)
		c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
		c = p->ptr[p->ofst];
d1119 1
a1119 4
		if (p->ofst >= p->hdr->hole) {
			if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
				--p->line;
		} else if (p->ptr[p->ofst] == '\n')
d2094 1
a2094 4
	if (p->ofst >= p->hdr->hole)
		return p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
		return p->ptr[p->ofst];
@


1.17
log
@change "expr, expr" to "expr; expr"
@
text
@d183 2
a184 2
	b->oldcur = 0;
	b->oldtop = 0;
d189 1
a189 1
	b->name = 0;
d195 1
a195 1
	b->bof->owner = 0;
d235 1
a235 1
			errbuf = 0;
d252 1
a252 1
		p->ptr = 0;
d289 2
a290 2
	n->ptr = 0;
	n->owner = 0;
d300 1
a300 1
	n->ptr = 0;
d315 1
a315 1
		*p->owner = 0;
d533 1
a533 1
					return 0;
d603 1
a603 1
					return 0;
d688 1
a688 1
					return 0;
d716 1
a716 1
					return 0;
d901 1
a901 1
		return 0;
d924 1
a924 1
				return 0;
d940 1
a940 1
		return 0;
d963 1
a963 1
				return 0;
d1005 1
a1005 1
		return 0;
d1020 1
a1020 1
		return 0;
d1062 1
a1062 1
			return 0;
d1085 1
a1085 1
				return 0;
d1104 1
a1104 1
			return 0;
d1127 1
a1127 1
				return 0;
d1171 1
a1171 1
		return 0;
d1186 1
a1186 1
		return 0;
d1335 1
a1335 1
		return 0;	/* ...nothing to delete */
d1387 1
a1387 1
			h = 0;
d1667 1
a1667 1
	H *h = 0;
d1817 2
a1818 1
					char *z = vsncpy(NULL, 0, sz(passwd->pw_dir));
d2006 1
a2006 1
	return 0;
@


1.16
log
@add comments - explain what is the function doing
@
text
@d527 5
a531 2
				if (!p->ofst)
					p->byte += GSIZE(p->hdr), n -= GSIZE(p->hdr), p->line += p->hdr->nlines;
d561 4
a564 3
	if (c == '\n')
		--p->line, p->valcol = 0;
	else {
d597 5
a601 2
				if (p->ofst)
					p->byte -= p->ofst, n -= p->ofst, p->line -= p->hdr->nlines;
d842 7
a848 4
			if (p->col + p->b->o.tab - p->col % p->b->o.tab <= to)
				binsc(p, '\t'), pgetc(p);
			else
				binsc(p, ' '), pgetc(p);
d850 4
a853 2
		while (p->col < to)
			binsc(p, ' '), pgetc(p);
d913 10
a922 6
			if (table[c] == 255)
				ffwrd(p, len + 1), amnt -= x + 1;
			else if (x <= table[c])
				ffwrd(p, len - x + 1), --amnt;
			else
				ffwrd(p, len - table[c]), amnt -= x - table[c];
d952 10
a961 6
			if (table[c] == 255)
				ffwrd(p, len + 1), amnt -= x + 1;
			else if (x <= table[c])
				ffwrd(p, len - x + 1), --amnt;
			else
				ffwrd(p, len - table[c]), amnt -= x - table[c];
d986 2
a987 1
			p->byte += GSIZE(p->hdr), p->line += p->hdr->nlines;
d1074 10
a1083 6
			if (table[c] == 255)
				fbkwd(p, len + 1), amnt -= len - x + 1;
			else if (len - table[c] <= x)
				fbkwd(p, x + 1), --amnt;
			else
				fbkwd(p, len - table[c]), amnt -= len - table[c] - x;
d1116 10
a1125 6
			if (table[c] == 255)
				fbkwd(p, len + 1), amnt -= len - x + 1;
			else if (len - table[c] <= x)
				fbkwd(p, x + 1), --amnt;
			else
				fbkwd(p, len - table[c]), amnt -= len - table[c] - x;
d1143 4
a1146 2
				if (p->ofst)
					p->byte -= p->ofst, p->line -= p->hdr->nlines;
d1385 3
a1387 2
			/* ..unless from needs to be deleted too */
			a = from->hdr->link.prev, h = 0;
d1817 1
a1817 2
					char *z = vsncpy(NULL, 0,
							 sz(passwd->pw_dir));
d1916 1
a1916 1
      err:;
d1925 5
a1929 3
      opnerr:;
	if (s[0] == '!')
		ttopnn(), nreturn(maint->t);
d1935 10
a1944 6
	if (error || s[0] == '!' || skip || amnt != MAXLONG)
		b->backup = 1, b->changed = 0;
	else if (!strcmp(n, "-"))
		b->backup = 1, b->changed = 1;
	else
		b->backup = 0, b->changed = 0;
d2047 1
a2047 1
      err:;
d2105 1
a2105 1
      err:;
d2116 5
a2120 3
      opnerr:;
	if (s[0] == '!' || !strcmp(s, "-"))
		ttopnn(), nreturn(maint->t);
@


1.15
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d59 1
a59 2

#define GGAPSZ(hdr) ((hdr)->ehole-(hdr)->hole)
d62 1
a62 2

#define GSIZE(hdr) (SEGSIZ-GGAPSZ(hdr))
a64 1

a75 1

a85 1

a96 1
/* Header allocation */
d101 1
a127 1
/* Pointer allocation */
d131 1
a142 1

a170 1

a219 1

a224 1
/* Eliminate a buffer */
d228 1
d352 1
d358 1
d364 1
d388 1
d400 1
d414 1
d428 1
d445 1
d485 1
d518 1
d568 1
d584 1
d609 1
d619 1
d631 1
d641 1
d671 1
d698 1
d728 1
d753 1
d785 1
d799 1
d829 1
d844 1
d881 1
d916 1
d951 2
d973 1
d988 1
d1031 1
d1069 1
d1107 2
d1129 1
d1144 1
d1159 1
a1225 1

a1456 1

a1476 1

d1517 1
a1517 3
/* Make a chain out of a block of memory */
/* The block must not be empty */

d1548 1
a1548 3
/* Insert a chain into a buffer */
/* This does not update pointers */

d1615 1
a1615 3
/* Insert a buffer at pointer position */
/* The buffer goes away */

d1631 1
d1662 1
d1671 1
a1680 1

a1698 1

a1733 1

a1805 1

a1918 1

a1958 1

a1975 1

a2015 1

@


1.14
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d251 1
a251 1
			free(b->name);
d2101 1
a2101 1
	char *s = (char *) malloc(size + 1);
@


1.13
log
@move jread() / jwrite() into utils.c
@
text
@d68 1
a68 1
static void gstgap(H * hdr, char *ptr, int ofst)
d80 1
a80 1
static void ginsm(H * hdr, char *ptr, int ofst, char *blk, int size)
d91 1
a91 1
static void grmem(H * hdr, char *ptr, int ofst, char *blk, int size)
d123 1
a123 1
static void hfree(H * h)
d128 1
a128 1
static void hfreechn(H * h)
d142 1
a142 1
static void pfree(P * p)
d178 1
a178 1
static B *bmkchn(H * chn, B * prop, long amnt, long nlines)
d228 1
a228 1
B *bmk(B * prop)
d237 1
a237 1
void brm(B * b)
d256 1
a256 1
P *poffline(P * p)
d265 1
a265 1
P *ponline(P * p)
d272 1
a272 1
B *boffline(B * b)
d282 1
a282 1
B *bonline(B * b)
d292 1
a292 1
P *pdup(P * p)
d303 1
a303 1
P *pdupown(P * p, P ** o)
d318 1
a318 1
void prm(P * p)
d329 1
a329 1
P *pset(P * n, P * p)
d350 1
a350 1
P *p_goto_bof(P * p)
d355 1
a355 1
P *p_goto_eof(P * p)
d360 1
a360 1
int pisbof(P * p)
d365 1
a365 1
int piseof(P * p)
d370 1
a370 1
int piseol(P * p)
d393 1
a393 1
int pisbol(P * p)
d404 1
a404 1
int pisbow(P * p)
d417 1
a417 1
int piseow(P * p)
d430 1
a430 1
int pisblank(P * p)
d446 1
a446 1
long pisindent(P * p)
d459 1
a459 1
int pnext(P * p)
d472 1
a472 1
int pprev(P * p)
d485 1
a485 1
int pgetc(P * p)
d517 1
a517 1
P *pfwrd(P * p, long n)
d566 1
a566 1
int prgetc(P * p)
d581 1
a581 1
P *pbkwd(P * p, long n)
d605 1
a605 1
P *pgoto(P * p, long loc)
d614 1
a614 1
P *pfcol(P * p)
d625 1
a625 1
P *p_goto_bol(P * p)
d634 1
a634 1
P *p_goto_eol(P * p)
d663 1
a663 1
P *pnextl(P * p)
d689 1
a689 1
P *pprevl(P * p)
d718 1
a718 1
P *pline(P * p, long line)
d742 1
a742 1
P *pcol(P * p, long goalcol)
d773 1
a773 1
P *pcolwse(P * p, long goalcol)
d786 1
a786 1
P *pcoli(P * p, long goalcol)
d815 1
a815 1
void pfill(P * p, long to, int usetabs)
d829 1
a829 1
void pbackws(P * p)
d843 1
a843 1
static char frgetc(P * p)
d854 1
a854 1
static void ffwrd(P * p, int n)
d865 1
a865 1
static P *ffind(P * p, unsigned char *s, int len)
d899 1
a899 1
static P *fifind(P * p, unsigned char *s, int len)
d933 1
a933 1
static P *getto(P * p, P * q)
d953 1
a953 1
P *pfind(P * p, char *s, int len)
d967 1
a967 1
P *pifind(P * p, char *s, int len)
d981 1
a981 1
static void fbkwd(P * p, int n)
d994 1
a994 1
static int fpgetc(P * p)
d1009 1
a1009 1
static P *frfind(P * p, unsigned char *s, int len)
d1046 1
a1046 1
static P *frifind(P * p, unsigned char *s, int len)
d1083 1
a1083 1
static P *rgetto(P * p, P * q)
d1103 1
a1103 1
P *prfind(P * p, char *s, int len)
d1117 1
a1117 1
P *prifind(P * p, char *s, int len)
d1131 1
a1131 1
B *bcpy(P * from, P * to)
d1198 1
a1198 1
void pcoalesce(P * p)
d1264 1
a1264 1
static B *bcut(P * from, P * to)
d1433 1
a1433 1
void bdel(P * from, P * to)
d1451 1
a1451 1
static void bsplit(P * p)
d1527 1
a1527 1
static void inschn(P * p, H * a)
d1563 1
a1563 1
static void fixupins(P * p, long amnt, long nlines, H * hdr, int hdramnt)
d1596 1
a1596 1
P *binsb(P * p, B * b)
d1611 1
a1611 1
P *binsm(P * p, char *blk, int amnt)
@


1.12
log
@change indentation of do {} while() cycles
@
text
@a33 1
#include "tty.h"
d1667 1
a1667 1
	for (a = b = 0; (a < size) && ((b = jread(fi, buff + a, size - a)) > 0); a += b) ;
d1967 1
a1967 1
			if (jwrite(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
d1969 1
a1969 1
			if (jwrite(fd, np->ptr + np->hdr->ehole, SEGSIZ - np->hdr->ehole) < 0)
d1971 1
a1971 1
		} else if (jwrite(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), amnt) < 0)
d1979 1
a1979 1
				if (jwrite(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
d1981 1
a1981 1
				if (jwrite(fd, np->ptr + np->hdr->ehole, (int) size - np->hdr->hole + np->ofst) < 0)
d1984 1
a1984 1
				if (jwrite(fd, np->ptr + np->ofst, (int) size) < 0)
d1988 1
a1988 1
			if (jwrite(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), (int) size) < 0)
d2048 1
a2048 1
		if (brc(q) != '\n' && jwrite(fileno(f), &nl, 1) < 0)
@


1.11
log
@include only headers which are needed
@
text
@d161 1
a161 2
	}
	while (b->internal);
d173 1
a173 2
	}
	while (b->internal);
d277 1
a277 1
	do
d279 1
a279 1
	while ((p = p->link.next) != b->bof);
d287 1
a287 1
	do
d289 1
a289 1
	while ((p = p->link.next) != b->bof);
d530 1
a530 2
			}
			while (n > GSIZE(p->hdr));
d538 1
a538 2
	}
	while (--n);
d594 1
a594 2
			}
			while (n > GSIZE(p->hdr));
d602 1
a602 2
	}
	while (--n);
d674 1
a674 2
			}
			while (!p->hdr->nlines);
d681 1
a681 2
	}
	while (c != '\n');
d701 1
a701 2
			}
			while (!p->hdr->nlines);
d708 1
a708 2
	}
	while (c != '\n');
d770 1
a770 2
	}
	while (p->col != goalcol);
d779 1
a779 1
	do
d781 1
a781 1
	while (c == ' ' || c == '\t');
d835 1
a835 1
	do
d837 1
a837 1
	while (c == ' ' || c == '\t');
d883 1
a883 1
	do
d896 1
a896 1
	while (x) ;
d917 1
a917 1
	do
d930 1
a930 1
	while (x) ;
d1029 1
a1029 1
	do
d1042 1
a1042 1
	while (x != len) ;
d1066 1
a1066 1
	do
d1079 1
a1079 1
	while (x != len) ;
d1092 1
a1092 2
			}
			while (p->hdr != q->hdr);
d1519 1
a1519 2
	}
	while (size);
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@d27 1
a27 1
#include "bw.h"
d29 7
d37 3
a40 3
#include "va.h"
#include "utils.h"
#include "path.h"
a41 6
#include "tty.h"
#include "scrn.h"
#include "main.h"
#include "uerror.h"

#include "b.h"
@


1.9
log
@use mfwrd() and mbkwd() only as internal functions to mmove()
@
text
@d2 6
a7 7
	Editor engine
	Copyright
		(C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/

d9 1
@


1.8
log
@version 2.9.7-pre3
@
text
@d71 1
a71 1
		mfwrd(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole), vchanged(ptr);
d73 1
a73 1
		mbkwd(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst), vchanged(ptr);
d84 1
a84 1
	mcpy(ptr + hdr->hole, blk, size);
d95 1
a95 1
			mcpy(blk, ptr + ofst, hdr->hole - ofst), mcpy(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
d97 1
a97 1
			mcpy(blk, ptr + ofst, size);
d99 1
a99 1
		mcpy(blk, ptr + ofst + hdr->ehole - hdr->hole, size);
d1161 1
a1161 1
		mcpy(ptr, q->ptr + q->hdr->ehole, l->hole);
d1171 1
a1171 1
		mcpy(ptr, q->ptr + q->hdr->ehole, l->hole);
d1180 2
a1181 2
			mcpy(ptr, q->ptr, q->hdr->hole);
			mcpy(ptr + q->hdr->hole, q->ptr + q->hdr->ehole, SEGSIZ - q->hdr->ehole);
d1194 1
a1194 1
			mcpy(ptr, to->ptr, l->hole = to->ofst);
a1266 1
 *  mcpy	- to copy deleted text
d1300 1
a1300 1
		mcpy(ptr, from->ptr + from->hdr->ehole, (int) amnt);
d1324 1
a1324 1
			mcpy(ptr, to->ptr, to->hdr->hole);
d1351 1
a1351 1
			mcpy(ptr, from->ptr + from->hdr->ehole, SEGSIZ - from->hdr->ehole);
d1475 1
a1475 1
		mcpy(ptr, p->ptr + p->hdr->ehole, SEGSIZ - p->hdr->ehole);
d1521 1
a1521 1
		mcpy(ptr, blk, amnt);
@


1.7
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d27 1
a37 1
#include "bw.h"
d547 1
a547 1
int prgetc1(P * p)
d1411 1
a1411 1
		delerr(from->b->name, from->line, nlines, 0);
d1414 1
a1414 1
		delerr(from->b->name, from->line, nlines, 1);
d1585 1
a1585 1
	inserr(p->b->name, p->line, nlines);
d1655 1
a1655 3
P *binsc(p, c)
P *p;
char c;
d1663 1
a1663 3
P *binss(p, s)
P *p;
char *s;
d1673 1
a1673 2
static int bkread(fi, buff, size)
char *buff;
d1692 1
a1692 2
B *bread(fi, max)
long max;
d1728 1
a1728 3
char *parsens(s, skip, amnt)
char *s;
long *skip, *amnt;
d1801 1
a1801 2
B *bload(s)
char *s;
d1915 1
a1915 2
B *bfind(s)
char *s;
d1943 1
a1943 1
char **getbufs()
d1956 1
a1956 1
B *borphan()
d1974 1
a1974 3
int bsavefd(p, fd, size)
P *p;
long size;
d2015 1
a2015 4
int bsave(p, s, size)
P *p;
char *s;
long size;
d2084 1
a2084 2
int brc(p)
P *p;
d2094 1
a2094 4
char *brmem(p, blk, size)
P *p;
char *blk;
int size;
d2113 1
a2113 3
char *brs(p, size)
P *p;
int size;
d2121 1
a2121 3
char *brvs(p, size)
P *p;
int size;
d2130 1
a2130 1
extern char *ctime();
@


1.6
log
@changed as of joe-2.9.6
@
text
@d9 2
a11 1

d16 1
a16 1
#ifndef __MSDOS__
d23 3
a26 1
#include "config.h"
d68 2
a69 1
static void gstgap (H *hdr, char *ptr, int ofst) {
d71 1
a71 2
		mfwrd (ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole),
			vchanged (ptr);
d73 1
a73 2
		mbkwd (ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst,
		       hdr->hole - ofst), vchanged (ptr);
d80 2
a81 1
static void ginsm (H *hdr, char *ptr, int ofst, char *blk, int size) {
d83 2
a84 2
		gstgap (hdr, ptr, ofst);
	mcpy (ptr + hdr->hole, blk, size);
d86 1
a86 1
	vchanged (ptr);
d91 2
a92 1
static void grmem (H *hdr, char *ptr, int ofst, char *blk, int size) {
d95 1
a95 4
			mcpy (blk, ptr + ofst, hdr->hole - ofst),
				mcpy (blk + hdr->hole - ofst,
				      ptr + hdr->ehole,
				      size - (hdr->hole - ofst));
d97 1
a97 1
			mcpy (blk, ptr + ofst, size);
d99 1
a99 1
		mcpy (blk, ptr + ofst + hdr->ehole - hdr->hole, size);
d107 2
a108 1
static H *halloc (void) {
d110 6
a115 7
	if (qempty (H, link, &ohdrs))
	  {
		  h = (H *) alitem (&nhdrs, sizeof (H));
		  h->seg = my_valloc (vmem, (long) SEGSIZ);
	  }
	else
		h = deque (H, link, ohdrs.link.next);
d119 1
a119 1
	izque (H, link, h);
d123 3
a125 2
static void hfree (H *h) {
	enquef (H, link, &ohdrs, h);
d128 3
a130 2
static void hfreechn (H *h) {
	splicef (H, link, &ohdrs, h);
d137 3
a139 2
static P *palloc (void) {
	return alitem (&frptrs, sizeof (P));
d142 3
a144 2
static void pfree (P *p) {
	enquef (P, link, &frptrs, p);
d152 2
a153 1
B *bnext (void) {
d155 6
a160 6
	do
	  {
		  b = bufs.link.prev;
		  deque (B, link, &bufs);
		  enqueb (B, link, b, &bufs);
	  }
d165 2
a166 1
B *bprev (void) {
d168 6
a173 6
	do
	  {
		  b = bufs.link.next;
		  deque (B, link, &bufs);
		  enquef (B, link, b, &bufs);
	  }
d180 5
a184 3
static B *bmkchn (H *chn, B *prop, long amnt, long nlines) {
	B *b = alitem (&frebufs, sizeof (B));
	b->undo = undomk (b);
d189 1
a189 1
	mset (b->marks, 0, sizeof (b->marks));
d200 2
a201 2
	b->bof = palloc ();
	izque (P, link, b->bof);
d206 1
a206 1
	b->bof->ptr = vlock (vmem, b->bof->hdr->seg);
d213 1
a213 1
	b->eof = pdup (b->bof);
d215 1
a215 1
	vunlock (b->eof->ptr);
d217 2
a218 2
	b->eof->ptr = vlock (vmem, b->eof->hdr->seg);
	b->eof->ofst = GSIZE (b->eof->hdr);
d222 3
a224 3
	enquef (B, link, &bufs, b);
	pcoalesce (b->bof);
	pcoalesce (b->eof);
d230 3
a232 2
B *bmk (B *prop) {
	return bmkchn (halloc (), prop, 0L, 0L);
d239 17
a255 17
void brm (B *b) {
	if (b && !--b->count)
	  {
		  if (b->changed)
			  abrerr (b->name);
		  if (b == errbuf)
			  errbuf = 0;
		  if (b->undo)
			  undorm (b->undo);
		  hfreechn (b->eof->hdr);
		  while (!qempty (P, link, b->bof))
			  prm (b->bof->link.next);
		  prm (b->bof);
		  if (b->name)
			  free (b->name);
		  demote (B, link, &frebufs, b);
	  }
d258 6
a263 6
P *poffline (P *p) {
	if (p->ptr)
	  {
		  vunlock (p->ptr);
		  p->ptr = 0;
	  }
d267 2
a268 1
P *ponline (P *p) {
d270 1
a270 1
		p->ptr = vlock (vmem, p->hdr->seg);
d274 2
a275 1
B *boffline (B *b) {
d277 1
d279 1
a279 1
		poffline (p);
d284 2
a285 1
B *bonline (B *b) {
d287 1
d289 1
a289 1
		ponline (p);
d294 4
a297 2
P *pdup (P *p) {
	P *n = palloc ();
d301 2
a302 2
	enquef (P, link, p, n);
	return pset (n, p);
d305 4
a308 2
P *pdupown (P *p, P **o) {
	P *n = palloc ();
d312 2
a313 2
	enquef (P, link, p, n);
	pset (n, p);
d315 1
a315 1
		prm (*o);
d320 2
a321 1
void prm (P *p) {
d327 2
a328 2
		vunlock (p->ptr);
	pfree (deque (P, link, p));
d331 18
a348 20
P *pset (P *n, P *p) {
	if (n != p)
	  {
		  n->b = p->b;
		  n->ofst = p->ofst;
		  n->hdr = p->hdr;
		  if (n->ptr)
			  vunlock (n->ptr);
		  if (p->ptr)
		    {
			    n->ptr = p->ptr;
			    vupcount (n->ptr);
		    }
		  else
			  n->ptr = vlock (vmem, n->hdr->seg);
		  n->byte = p->byte;
		  n->line = p->line;
		  n->col = p->col;
		  n->valcol = p->valcol;
	  }
d352 3
a354 2
P *p_goto_bof (P *p) {
	return pset (p, p->b->bof);
d357 3
a359 2
P *p_goto_eof (P *p) {
	return pset (p, p->b->eof);
d362 2
a363 1
int pisbof (P *p) {
d367 3
a369 2
int piseof (P *p) {
	return p->ofst == GSIZE (p->hdr);
d372 2
a373 1
int piseol (P *p) {
d375 2
a376 1
	if (piseof (p))
d378 1
a378 1
	c = brc (p);
d382 10
a391 12
		if (c == '\r')
		  {
			  P *q = pdup (p);
			  pfwrd (q, 1L);
			  if (pgetc (q) == '\n')
			    {
				    prm (q);
				    return 1;
			    }
			  else
				  prm (q);
		  }
d395 2
a396 1
int pisbol (P *p) {
d398 2
a399 1
	if (pisbof (p))
d401 2
a402 2
	c = prgetc (p);
	pgetc (p);
d406 8
a413 6
int pisbow (P *p) {
	P *q = pdup (p);
	int c = brc (p);
	int d = prgetc (q);
	prm (q);
	if (isalnum_ (c) && !isalnum_ (d))
d419 8
a426 6
int piseow (P *p) {
	P *q = pdup (p);
	int d = brc (q);
	int c = prgetc (q);
	prm (q);
	if (isalnum_ (c) && !isalnum_ (d))
d432 3
a434 2
int pisblank (P *p) {
	P *q = pdup (p);
d436 5
a440 6
	p_goto_bol (q);
	while (isblank (brc (q))) {
		pgetc (q);
	}
	if (piseol (q)) {
		prm (q);
d443 1
a443 1
		prm (q);
d448 3
a450 2
long pisindent (P *p) {
	P *q = pdup (p);
d452 4
a455 3
	p_goto_bol (q);
	while (isblank (brc (q)))
		pgetc (q);
d457 1
a457 1
	prm (q);
d461 6
a466 6
int pnext (P *p) {
	if (p->hdr == p->b->eof->hdr)
	  {
		  p->ofst = GSIZE (p->hdr);
		  return 0;
	  }
d469 2
a470 2
	vunlock (p->ptr);
	p->ptr = vlock (vmem, p->hdr->seg);
d474 6
a479 6
int pprev (P *p) {
	if (p->hdr == p->b->bof->hdr)
	  {
		  p->ofst = 0;
		  return 0;
	  }
d481 3
a483 3
	p->ofst = GSIZE (p->hdr);
	vunlock (p->ptr);
	p->ptr = vlock (vmem, p->hdr->seg);
d487 2
a488 1
int pgetc (P *p) {
d491 1
a491 1
	if (p->ofst == GSIZE (p->hdr))
d497 2
a498 2
	if (++p->ofst == GSIZE (p->hdr))
		pnext (p);
d506 2
a507 2
		if (brc (p) == '\n')
			return pgetc (p);
d519 2
a520 1
P *pfwrd (P *p, long n) {
d524 17
a540 25
	do
	  {
		  if (p->ofst == GSIZE (p->hdr))
			  do
			    {
				    if (!p->ofst)
					    p->byte += GSIZE (p->hdr), n -=
						    GSIZE (p->hdr), p->line +=
						    p->hdr->nlines;
				    if (!pnext (p))
					    return 0;
			    }
			  while (n > GSIZE (p->hdr));
		  if (p->ofst >= p->hdr->hole)
		    {
			    if (p->
				ptr[p->ofst + p->hdr->ehole - p->hdr->hole] ==
				'\n')
				    ++p->line;
		    }
		  else if (p->ptr[p->ofst] == '\n')
			  ++p->line;
		  ++p->byte;
		  ++p->ofst;
	  }
d542 2
a543 2
	if (p->ofst == GSIZE (p->hdr))
		pnext (p);
d547 2
a548 1
int prgetc1 (P *p) {
d550 1
d552 1
a552 1
		if (!pprev (p))
d562 5
a566 6
	else
	  {
		  if (c == '\t')
			  p->valcol = 0;
		  --p->col;
	  }
d570 12
a581 11
int prgetc (P *p) {
	int c = prgetc1 (p);
	if (p->b->o.crlf && c == '\n')
	  {
		  c = prgetc1 (p);
		  if (c == '\r')
			  return '\n';
		  if (c != MAXINT)
			  pgetc (p);
		  c = '\n';
	  }
d585 2
a586 1
P *pbkwd (P *p, long n) {
d590 17
a606 25
	do
	  {
		  if (!p->ofst)
			  do
			    {
				    if (p->ofst)
					    p->byte -= p->ofst, n -=
						    p->ofst, p->line -=
						    p->hdr->nlines;
				    if (!pprev (p))
					    return 0;
			    }
			  while (n > GSIZE (p->hdr));
		  --p->ofst;
		  --p->byte;
		  if (p->ofst >= p->hdr->hole)
		    {
			    if (p->
				ptr[p->ofst + p->hdr->ehole - p->hdr->hole] ==
				'\n')
				    --p->line;
		    }
		  else if (p->ptr[p->ofst] == '\n')
			  --p->line;
	  }
d611 2
a612 1
P *pgoto (P *p, long loc) {
d614 1
a614 1
		pfwrd (p, loc - p->byte);
d616 1
a616 1
		pbkwd (p, p->byte - loc);
d620 2
a621 1
P *pfcol (P *p) {
d624 2
a625 1
	p_goto_bol (p);
d627 1
a627 1
		pgetc (p);
d631 4
a634 3
P *p_goto_bol (P *p) {
	if (pprevl (p))
		pgetc (p);
d640 2
a641 1
P *p_goto_eol (P *p) {
d643 2
a644 2
		while (!piseol (p))
			pgetc (p);
d646 20
a665 25
		while (p->ofst != GSIZE (p->hdr))
		  {
			  unsigned char c;
			  if (p->ofst >= p->hdr->hole)
				  c =
					  p->ptr[p->ofst + p->hdr->ehole -
						 p->hdr->hole];
			  else
				  c = p->ptr[p->ofst];
			  if (c == '\n')
				  break;
			  else
			    {
				    ++p->byte;
				    ++p->ofst;
				    if (c == '\t')
					    p->col +=
						    p->b->o.tab -
						    p->col % p->b->o.tab;
				    else
					    ++p->col;
				    if (p->ofst == GSIZE (p->hdr))
					    pnext (p);
			    }
		  }
d669 2
a670 1
P *pnextl (P *p) {
d672 16
a687 17
	do
	  {
		  if (p->ofst == GSIZE (p->hdr))
			  do
			    {
				    p->byte += GSIZE (p->hdr) - p->ofst;
				    if (!pnext (p))
					    return 0;
			    }
			  while (!p->hdr->nlines);
		  if (p->ofst >= p->hdr->hole)
			  c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		  else
			  c = p->ptr[p->ofst];
		  ++p->byte;
		  ++p->ofst;
	  }
d692 2
a693 2
	if (p->ofst == GSIZE (p->hdr))
		pnext (p);
d697 2
a698 1
P *pprevl (P *p) {
d700 1
d702 15
a716 17
	do
	  {
		  if (!p->ofst)
			  do
			    {
				    p->byte -= p->ofst;
				    if (!pprev (p))
					    return 0;
			    }
			  while (!p->hdr->nlines);
		  --p->ofst;
		  --p->byte;
		  if (p->ofst >= p->hdr->hole)
			  c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		  else
			  c = p->ptr[p->ofst];
	  }
d719 6
a724 6
	if (p->b->o.crlf && c == '\n')
	  {
		  int k = prgetc1 (p);
		  if (k != '\r' && k != MAXINT)
			  pgetc (p);
	  }
d728 14
a741 15
P *pline (P *p, long line) {
	if (line > p->b->eof->line)
	  {
		  pset (p, p->b->eof);
		  return p;
	  }
	if (line < labs (p->line - line))
		pset (p, p->b->bof);
	if (labs (p->b->eof->line - line) < labs (p->line - line))
		pset (p, p->b->eof);
	if (p->line == line)
	  {
		  p_goto_bol (p);
		  return p;
	  }
d743 6
a748 7
		pnextl (p);
	if (line < p->line)
	  {
		  while (line < p->line)
			  pprevl (p);
		  p_goto_bol (p);
	  }
d752 28
a779 27
P *pcol (P *p, long goalcol) {
	p_goto_bol (p);
	do
	  {
		  unsigned char c;
		  int wid;
		  if (p->ofst == GSIZE (p->hdr))
			  break;
		  if (p->ofst >= p->hdr->hole)
			  c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		  else
			  c = p->ptr[p->ofst];
		  if (c == '\n')
			  break;
		  if (p->b->o.crlf && c == '\r' && piseol (p))
			  break;
		  if (c == '\t')
			  wid = p->b->o.tab - p->col % p->b->o.tab;
		  else
			  wid = 1;
		  if (p->col + wid > goalcol)
			  break;
		  if (++p->ofst == GSIZE (p->hdr))
			  pnext (p);
		  ++p->byte;
		  p->col += wid;
	  }
d784 2
a785 1
P *pcolwse (P *p, long goalcol) {
d787 2
a788 1
	pcol (p, goalcol);
d790 1
a790 1
		c = prgetc (p);
d793 1
a793 1
		pgetc (p);
d797 14
a810 13
P *pcoli (P *p, long goalcol) {
	p_goto_bol (p);
	while (p->col < goalcol)
	  {
		  unsigned char c;
		  if (p->ofst == GSIZE (p->hdr))
			  break;
		  if (p->ofst >= p->hdr->hole)
			  c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
		  else
			  c = p->ptr[p->ofst];
		  if (c == '\n')
			  break;
d812 2
a813 2
		  if (c == '\r' && piseol (p))
			  break;
d815 8
a822 8
		  else if (c == '\t')
			  p->col += p->b->o.tab - p->col % p->b->o.tab;
		  else
			  ++p->col;
		  if (++p->ofst == GSIZE (p->hdr))
			  pnext (p);
		  ++p->byte;
	  }
d826 3
a828 2
void pfill (P *p, long to, int usetabs) {
	piscol (p);
d832 1
a832 1
				binsc (p, '\t'), pgetc (p);
d834 1
a834 1
				binsc (p, ' '), pgetc (p);
d837 1
a837 1
			binsc (p, ' '), pgetc (p);
d840 2
a841 1
void pbackws (P *p) {
d843 2
a844 1
	P *q = pdup (p);
d846 1
a846 1
		c = prgetc (q);
d849 3
a851 3
		pgetc (q);
	bdel (q, p);
	prm (q);
d854 2
a855 1
static char frgetc (P *p) {
d857 1
a857 1
		pprev (p);
d865 9
a873 9
static void ffwrd (P *p, int n) {
	while (n > GSIZE (p->hdr) - p->ofst)
	  {
		  n -= GSIZE (p->hdr) - p->ofst;
		  if (!pnext (p))
			  return;
	  }
	if ((p->ofst += n) == GSIZE (p->hdr))
		pnext (p);
d876 2
a877 1
static P *ffind (P *p, unsigned char *s, int len) {
d881 1
d887 1
a887 1
	mset (table, 255, 256);
d890 1
a890 1
	ffwrd (p, len);
d894 13
a906 15
		if ((c = frgetc (p)) != s[--x])
		  {
			  if (table[c] == 255)
				  ffwrd (p, len + 1), amnt -= x + 1;
			  else if (x <= table[c])
				  ffwrd (p, len - x + 1), --amnt;
			  else
				  ffwrd (p, len - table[c]), amnt -=
					  x - table[c];
			  if (amnt < 0)
				  return 0;
			  else
				  x = len;
		  }
	while (x);
d910 2
a911 1
static P *fifind (P *p, unsigned char *s, int len) {
d915 1
d921 1
a921 1
	mset (table, 255, 256);
d924 1
a924 1
	ffwrd (p, len);
d928 71
a998 81
		if ((c = toupper (frgetc (p))) != s[--x])
		  {
			  if (table[c] == 255)
				  ffwrd (p, len + 1), amnt -= x + 1;
			  else if (x <= table[c])
				  ffwrd (p, len - x + 1), --amnt;
			  else
				  ffwrd (p, len - table[c]), amnt -=
					  x - table[c];
			  if (amnt < 0)
				  return 0;
			  else
				  x = len;
		  }
	while (x);
	return p;
}

static P *getto (P *p, P *q) {
	while (p->hdr != q->hdr || p->ofst != q->ofst)
	  {
		  if (p->ofst >= p->hdr->hole)
		    {
			    if (p->
				ptr[p->ofst + p->hdr->ehole - p->hdr->hole] ==
				'\n')
				    ++p->line;
		    }
		  else if (p->ptr[p->ofst] == '\n')
			  ++p->line;
		  ++p->byte;
		  ++p->ofst;
		  if (p->ofst == GSIZE (p->hdr))
			  pnext (p);
		  while (!p->ofst && p->hdr != q->hdr)
		    {
			    p->byte += GSIZE (p->hdr), p->line +=
				    p->hdr->nlines;
			    pnext (p);
		    }
	  }
	return p;
}

P *pfind (P *p, char *s, int len) {
	P *q = pdup (p);
	if (ffind (q, s, len))
	  {
		  getto (p, q);
		  prm (q);
		  return p;
	  }
	else
	  {
		  prm (q);
		  return 0;
	  }
}

P *pifind (P *p, char *s, int len) {
	P *q = pdup (p);
	if (fifind (q, s, len))
	  {
		  getto (p, q);
		  prm (q);
		  return p;
	  }
	else
	  {
		  prm (q);
		  return 0;
	  }
}

static void fbkwd (P *p, int n) {
	while (n > p->ofst)
	  {
		  n -= p->ofst;
		  if (!pprev (p))
			  return;
	  }
d1005 2
a1006 1
static int fpgetc (P *p) {
d1008 2
a1009 1
	if (p->ofst == GSIZE (p->hdr))
d1015 2
a1016 2
	if (++p->ofst == GSIZE (p->hdr))
		pnext (p);
d1020 2
a1021 1
static P *frfind (P *p, unsigned char *s, int len) {
d1025 8
a1032 8
	if (len > p->b->eof->byte - p->byte)
	  {
		  x = len - (p->b->eof->byte - p->byte);
		  if (amnt < x)
			  return 0;
		  amnt -= x;
		  fbkwd (p, x);
	  }
d1036 2
a1037 2
	mset (table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1);
d1040 14
a1053 16
		if ((c = fpgetc (p)) != s[x++])
		  {
			  if (table[c] == 255)
				  fbkwd (p, len + 1), amnt -= len - x + 1;
			  else if (len - table[c] <= x)
				  fbkwd (p, x + 1), --amnt;
			  else
				  fbkwd (p, len - table[c]), amnt -=
					  len - table[c] - x;
			  if (amnt < 0)
				  return 0;
			  else
				  x = 0;
		  }
	while (x != len);
	fbkwd (p, len);
d1057 2
a1058 1
static P *frifind (P *p, unsigned char *s, int len) {
d1062 8
a1069 8
	if (len > p->b->eof->byte - p->byte)
	  {
		  x = len - (p->b->eof->byte - p->byte);
		  if (amnt < x)
			  return 0;
		  amnt -= x;
		  fbkwd (p, x);
	  }
d1073 2
a1074 2
	mset (table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1);
d1077 36
a1112 74
		if ((c = toupper (fpgetc (p))) != s[x++])
		  {
			  if (table[c] == 255)
				  fbkwd (p, len + 1), amnt -= len - x + 1;
			  else if (len - table[c] <= x)
				  fbkwd (p, x + 1), --amnt;
			  else
				  fbkwd (p, len - table[c]), amnt -=
					  len - table[c] - x;
			  if (amnt < 0)
				  return 0;
			  else
				  x = 0;
		  }
	while (x != len);
	fbkwd (p, len);
	return p;
}

static P *rgetto (P *p, P *q) {
	while (p->hdr != q->hdr || p->ofst != q->ofst)
	  {
		  if (!p->ofst)
			  do
			    {
				    if (p->ofst)
					    p->byte -= p->ofst, p->line -=
						    p->hdr->nlines;
				    pprev (p);
			    }
			  while (p->hdr != q->hdr);
		  --p->ofst;
		  --p->byte;
		  if (p->ofst >= p->hdr->hole)
		    {
			    if (p->
				ptr[p->ofst + p->hdr->ehole - p->hdr->hole] ==
				'\n')
				    --p->line;
		    }
		  else if (p->ptr[p->ofst] == '\n')
			  --p->line;
	  }
	return p;
}

P *prfind (P *p, char *s, int len) {
	P *q = pdup (p);
	if (frfind (q, s, len))
	  {
		  rgetto (p, q);
		  prm (q);
		  return p;
	  }
	else
	  {
		  prm (q);
		  return 0;
	  }
}

P *prifind (P *p, char *s, int len) {
	P *q = pdup (p);
	if (frifind (q, s, len))
	  {
		  rgetto (p, q);
		  prm (q);
		  return p;
	  }
	else
	  {
		  prm (q);
		  return 0;
	  }
d1115 30
a1144 1
B *bcpy (P *from,P *to) {
d1150 1
a1150 1
		return bmk (from->b);
d1152 2
a1153 2
	q = pdup (from);
	izque (H, link, &anchor);
d1155 45
a1199 53
	if (q->hdr == to->hdr)
	  {
		  l = halloc ();
		  ptr = vlock (vmem, l->seg);
		  if (q->ofst != q->hdr->hole)
			  gstgap (q->hdr, q->ptr, q->ofst);
		  l->nlines = mcnt (q->ptr + q->hdr->ehole, '\n', l->hole =
				    to->ofst - q->ofst);
		  mcpy (ptr, q->ptr + q->hdr->ehole, l->hole);
		  vchanged (ptr);
		  vunlock (ptr);
		  enqueb (H, link, &anchor, l);
	  }
	else
	  {
		  l = halloc ();
		  ptr = vlock (vmem, l->seg);
		  if (q->ofst != q->hdr->hole)
			  gstgap (q->hdr, q->ptr, q->ofst);
		  l->nlines = mcnt (q->ptr + q->hdr->ehole, '\n', l->hole =
				    SEGSIZ - q->hdr->ehole);
		  mcpy (ptr, q->ptr + q->hdr->ehole, l->hole);
		  vchanged (ptr);
		  vunlock (ptr);
		  enqueb (H, link, &anchor, l);
		  pnext (q);
		  while (q->hdr != to->hdr)
		    {
			    l = halloc ();
			    ptr = vlock (vmem, l->seg);
			    l->nlines = q->hdr->nlines;
			    mcpy (ptr, q->ptr, q->hdr->hole);
			    mcpy (ptr + q->hdr->hole, q->ptr + q->hdr->ehole,
				  SEGSIZ - q->hdr->ehole);
			    l->hole = GSIZE (q->hdr);
			    vchanged (ptr);
			    vunlock (ptr);
			    enqueb (H, link, &anchor, l);
			    pnext (q);
		    }
		  if (to->ofst)
		    {
			    l = halloc ();
			    ptr = vlock (vmem, l->seg);
			    if (to->ofst != to->hdr->hole)
				    gstgap (to->hdr, to->ptr, to->ofst);
			    l->nlines = mcnt (to->ptr, '\n', to->ofst);
			    mcpy (ptr, to->ptr, l->hole = to->ofst);
			    vchanged (ptr);
			    vunlock (ptr);
			    enqueb (H, link, &anchor, l);
		    }
	  }
d1202 2
a1203 2
	deque (H, link, &anchor);
	prm (q);
d1205 1
a1205 2
	return bmkchn (l, from->b, to->byte - from->byte,
		       to->line - from->line);
d1210 45
a1254 52
void pcoalesce (P *p) {
	if (p->hdr != p->b->eof->hdr &&
	    GSIZE (p->hdr) + GSIZE (p->hdr->link.next) <= SEGSIZ - SEGSIZ / 4)
	  {
		  H *hdr = p->hdr->link.next;
		  char *ptr = vlock (vmem, hdr->seg);
		  int osize = GSIZE (p->hdr);
		  int size = GSIZE (hdr);
		  P *q;
		  gstgap (hdr, ptr, size);
		  ginsm (p->hdr, p->ptr, GSIZE (p->hdr), ptr, size);
		  p->hdr->nlines += hdr->nlines;
		  vunlock (ptr);
		  hfree (deque (H, link, hdr));
		  for (q = p->link.next; q != p; q = q->link.next)
			  if (q->hdr == hdr)
			    {
				    q->hdr = p->hdr;
				    if (q->ptr)
				      {
					      vunlock (q->ptr);
					      q->ptr =
						      vlock (vmem,
							     q->hdr->seg);
				      }
				    q->ofst += osize;
			    }
	  }
	if (p->hdr != p->b->bof->hdr &&
	    GSIZE (p->hdr) + GSIZE (p->hdr->link.prev) <= SEGSIZ - SEGSIZ / 4)
	  {
		  H *hdr = p->hdr->link.prev;
		  char *ptr = vlock (vmem, hdr->seg);
		  int size = GSIZE (hdr);
		  P *q;
		  gstgap (hdr, ptr, size);
		  ginsm (p->hdr, p->ptr, 0, ptr, size);
		  p->hdr->nlines += hdr->nlines;
		  vunlock (ptr);
		  hfree (deque (H, link, hdr));
		  p->ofst += size;
		  for (q = p->link.next; q != p; q = q->link.next)
			  if (q->hdr == hdr)
			    {
				    q->hdr = p->hdr;
				    if (q->ptr)
					    vunlock (q->ptr);
				    q->ptr = vlock (vmem, q->hdr->seg);
			    }
			  else if (q->hdr == p->hdr)
				  q->ofst += size;
	  }
d1277 2
a1278 1
static B *bcut (P *from, P *to) {
d1280 1
a1280 1
	 *i;
d1293 92
a1384 108
	if (from->hdr == to->hdr)
	  {			/* Delete is within a single segment */
		  /* Move gap to deletion point */
		  if (from->ofst != from->hdr->hole)
			  gstgap (from->hdr, from->ptr, from->ofst);

		  /* Store the deleted text */
		  h = halloc ();
		  ptr = vlock (vmem, h->seg);
		  mcpy (ptr, from->ptr + from->hdr->ehole, (int) amnt);
		  h->hole = amnt;
		  h->nlines = nlines;
		  vchanged (ptr);
		  vunlock (ptr);

		  /* Delete */
		  from->hdr->ehole += amnt;
		  from->hdr->nlines -= nlines;

		  toamnt = amnt;
	  }
	else
	  {			/* Delete crosses segments */
		  H *a;
		  if (toamnt = to->ofst)
		    {
			    /* Delete beginning of to */
			    /* Move gap to deletion point */
			    /* To could be deleted if it's at the end of the file */
			    if (to->ofst != to->hdr->hole)
				    gstgap (to->hdr, to->ptr, to->ofst);

			    /* Save deleted text */
			    i = halloc ();
			    ptr = vlock (vmem, i->seg);
			    mcpy (ptr, to->ptr, to->hdr->hole);
			    i->hole = to->hdr->hole;
			    i->nlines = mcnt (to->ptr, '\n', to->hdr->hole);
			    vchanged (ptr);
			    vunlock (ptr);

			    /* Delete */
			    to->hdr->nlines -= i->nlines;
			    to->hdr->hole = 0;
		    }
		  else
			  i = 0;

		  /* Delete end of from */
		  if (!from->ofst)
		    {
			    /* ..unless from needs to be deleted too */
			    a = from->hdr->link.prev, h = 0;
			    if (a == from->b->eof->hdr)
				    bofmove = 1;
		    }
		  else
		    {
			    a = from->hdr;
			    /* Move gap to deletion point */
			    if (from->ofst != from->hdr->hole)
				    gstgap (from->hdr, from->ptr, from->ofst);

			    /* Save deleted text */
			    h = halloc ();
			    ptr = vlock (vmem, h->seg);
			    mcpy (ptr, from->ptr + from->hdr->ehole,
				  SEGSIZ - from->hdr->ehole);
			    h->hole = SEGSIZ - from->hdr->ehole;
			    h->nlines = mcnt (ptr, '\n', h->hole);
			    vchanged (ptr);
			    vunlock (ptr);

			    /* Delete */
			    from->hdr->nlines -= h->nlines;
			    from->hdr->ehole = SEGSIZ;
		    }

		  /* Make from point to header/segment of to */
		  from->hdr = to->hdr;
		  vunlock (from->ptr);
		  from->ptr = to->ptr;
		  vupcount (to->ptr);
		  from->ofst = 0;

		  /* Delete headers/segments between a and to->hdr (if there are any) */
		  if (a->link.next != to->hdr)
			  if (!h)
			    {
				    h =
					    snip (H, link, a->link.next,
						  to->hdr->link.prev);
				    if (i)
					    enqueb (H, link, h, i);
			    }
			  else
			    {
				    splicef (H, link, h,
					     snip (H, link, a->link.next,
						   to->hdr->link.prev));
				    if (i)
					    enqueb (H, link, h, i);
			    }
		  else if (!h)
			  h = i;
		  else if (i)
			  enqueb (H, link, h, i);
	  }
d1388 14
a1401 14
	if (!GSIZE (to->hdr) && from->byte)
	  {
		  H *ph = from->hdr->link.prev;
		  hfree (deque (H, link, from->hdr));
		  vunlock (from->ptr);
		  from->hdr = ph;
		  from->ptr = vlock (vmem, from->hdr->seg);
		  from->ofst = GSIZE (ph);
		  vunlock (from->b->eof->ptr);
		  from->b->eof->ptr = from->ptr;
		  vupcount (from->ptr);
		  from->b->eof->hdr = from->hdr;
		  from->b->eof->ofst = from->ofst;
	  }
d1408 8
a1415 18
		pset (from->b->bof, from);
	if (nlines && !pisbol (from))
	  {
		  scrdel (from->b, from->line, nlines, 1);
/* too many arguments so I remove last one
		  delerr (from->b->name, from->line, nlines, 0);
*/
		  delerr (from->b->name, from->line, nlines);
	        }
	else
	  {
		  scrdel (from->b, from->line, nlines, 0);
/* too many arguments so I remove last one
		  delerr (from->b->name, from->line, nlines, 1);
*/
		delerr (from->b->name, from->line, nlines);

	     }
d1422 2
a1423 2
	for (p = from->link.next; p != from; p = p->link.next)
		if (p->byte >= from->byte)
d1426 1
a1426 1
					pset (p, from);
d1428 1
a1428 1
					poffline (pset (p, from));
d1431 4
a1434 4
				  if (p->hdr == to->hdr)
					  p->ofst -= toamnt;
				  p->byte -= amnt;
				  p->line -= nlines;
d1436 2
d1439 1
a1439 1
	pcoalesce (from);
d1443 1
a1443 1
	return bmkchn (h, from->b, amnt, nlines);
d1446 11
a1456 10
void bdel (P *from, P *to) {
	if (to->byte - from->byte)
	  {
		  B *b = bcut (from, to);
		  if (from->b->undo)
			  undodel (from->b->undo, from->byte, b);
		  else
			  brm (b);
		  from->b->changed = 1;
	  }
d1464 38
a1501 40
static void bsplit (P *p) {
	if (p->ofst)
	  {
		  H *hdr;
		  char *ptr;
		  P *pp;

		  hdr = halloc ();
		  ptr = vlock (vmem, hdr->seg);

		  if (p->ofst != p->hdr->hole)
			  gstgap (p->hdr, p->ptr, p->ofst);
		  mcpy (ptr, p->ptr + p->hdr->ehole, SEGSIZ - p->hdr->ehole);
		  hdr->hole = SEGSIZ - p->hdr->ehole;
		  hdr->nlines = mcnt (ptr, '\n', hdr->hole);
		  p->hdr->nlines -= hdr->nlines;
		  vchanged (ptr);
		  p->hdr->ehole = SEGSIZ;

		  enquef (H, link, p->hdr, hdr);

		  vunlock (p->ptr);

		  for (pp = p->link.next; pp != p; pp = pp->link.next)
			  if (pp->hdr == p->hdr && pp->ofst >= p->ofst)
			    {
				    pp->hdr = hdr;
				    if (pp->ptr)
				      {
					      vunlock (pp->ptr);
					      pp->ptr = ptr;
					      vupcount (ptr);
				      }
				    pp->ofst -= p->ofst;
			    }

		  p->ptr = ptr;
		  p->hdr = hdr;
		  p->ofst = 0;
	  }
d1507 2
a1508 1
static H *bldchn (char *blk, int size, long *nlines) {
d1510 1
d1512 20
a1531 20
	izque (H, link, &anchor);
	do
	  {
		  char *ptr;
		  int amnt;
		  ptr = vlock (vmem, (l = halloc ())->seg);
		  if (size > SEGSIZ)
			  amnt = SEGSIZ;
		  else
			  amnt = size;
		  mcpy (ptr, blk, amnt);
		  l->hole = amnt;
		  l->ehole = SEGSIZ;
		  (*nlines) += (l->nlines = mcnt (ptr, '\n', amnt));
		  vchanged (ptr);
		  vunlock (ptr);
		  enqueb (H, link, &anchor, l);
		  blk += amnt;
		  size -= amnt;
	  }
d1534 1
a1534 1
	deque (H, link, &anchor);
d1541 34
a1574 40
static void inschn (P *p, H *a) {
	if (!p->b->eof->byte)
	  {			/* P's buffer is empty: replace the empty segment in p with a */
		  hfree (p->hdr);
		  p->hdr = a;
		  vunlock (p->ptr);
		  p->ptr = vlock (vmem, a->seg);
		  pset (p->b->bof, p);

		  p->b->eof->hdr = a->link.prev;
		  vunlock (p->b->eof->ptr);
		  p->b->eof->ptr = vlock (vmem, p->b->eof->hdr->seg);
		  p->b->eof->ofst = GSIZE (p->b->eof->hdr);
	  }
	else if (piseof (p))
	  {			/* We're at the end of the file: append a to the file */
		  p->b->eof->hdr = a->link.prev;
		  spliceb (H, link, p->b->bof->hdr, a);
		  vunlock (p->b->eof->ptr);
		  p->b->eof->ptr = vlock (vmem, p->b->eof->hdr->seg);
		  p->b->eof->ofst = GSIZE (p->b->eof->hdr);
		  p->hdr = a;
		  vunlock (p->ptr);
		  p->ptr = vlock (vmem, p->hdr->seg);
		  p->ofst = 0;
	  }
	else if (pisbof (p))
	  {			/* We're at the beginning of the file: insert chain and set bof pointer */
		  p->hdr = spliceb (H, link, p->hdr, a);
		  vunlock (p->ptr);
		  p->ptr = vlock (vmem, a->seg);
		  pset (p->b->bof, p);
	  }
	else
	  {			/* We're in the middle of the file: split and insert */
		  bsplit (p);
		  p->hdr = spliceb (H, link, p->hdr, a);
		  vunlock (p->ptr);
		  p->ptr = vlock (vmem, a->seg);
	  }
d1577 2
a1578 1
static void fixupins (P *p, long amnt, long nlines, H *hdr, int hdramnt) {
d1580 3
a1582 2
	if (nlines && !pisbol (p))
		scrins (p->b, p->line, nlines, 1);
d1584 2
a1585 6
		scrins (p->b, p->line, nlines, 0);
/* too few arguments so I added one but because I don't know is last 
	argument so first try is 0 :)
	inserr (p->b->name, p->line, nlines);
*/
	inserr (p->b->name, p->line, nlines, 0);
d1588 1
a1588 2
		if (pp->line == p->line &&
		    (pp->byte > p->byte || pp->end && pp->byte == p->byte))
d1593 1
a1593 1
				pset (pp, p);
d1595 7
a1601 8
				poffline (pset (pp, p));
		else if (pp->byte > p->byte || pp->end && pp->byte == p->byte)
		  {
			  pp->byte += amnt;
			  pp->line += nlines;
			  if (pp->hdr == hdr)
				  pp->ofst += hdramnt;
		  }
d1603 1
a1603 1
		undoins (p->b->undo, p, amnt);
d1610 12
a1621 11
P *binsb (P *p, B *b) {
	if (b->eof->byte)
	  {
		  P *q = pdup (p);
		  inschn (q, b->bof->hdr);
		  b->eof->hdr = halloc ();
		  fixupins (q, b->eof->byte, b->eof->line, NULL, 0);
		  pcoalesce (q);
		  prm (q);
	  }
	brm (b);
d1625 2
a1626 1
P *binsm (P *p, char *blk, int amnt) {
d1631 1
d1634 18
a1651 23
	q = pdup (p);
	if (amnt <= GGAPSZ (q->hdr))
	  {
		  h = q->hdr;
		  hdramnt = amnt;
		  ginsm (q->hdr, q->ptr, q->ofst, blk, amnt);
		  q->hdr->nlines += (nlines = mcnt (blk, '\n', amnt));
	  }
	else if (!q->ofst && q->hdr != q->b->bof->hdr
		 && amnt <= GGAPSZ (q->hdr->link.prev))
	  {
		  pprev (q);
		  ginsm (q->hdr, q->ptr, q->ofst, blk, amnt);
		  q->hdr->nlines += (nlines = mcnt (blk, '\n', amnt));
	  }
	else
	  {
		  H *a = bldchn (blk, amnt, &nlines);
		  inschn (q, a);
	  }
	fixupins (q, (long) amnt, nlines, h, hdramnt);
	pcoalesce (q);
	prm (q);
d1655 3
a1657 3
P *binsc (p, c)
     P *p;
     char c;
d1660 1
a1660 1
		return binsm (p, "\r\n", 2);
d1662 1
a1662 1
		return binsm (p, &c, 1);
d1665 3
a1667 4
P *
binss (p, s)
     P *p;
     char *s;
d1669 1
a1669 1
	return binsm (p, s, strlen (s));
d1677 2
a1678 3
static int
bkread (fi, buff, size)
     char *buff;
d1681 6
a1686 8
	if (!size)
	  {
		  error = 0;
		  return 0;
	  }
	for (a = b = 0;
	     (a < size) && ((b = jread (fi, buff + a, size - a)) > 0);
	     a += b);
d1697 2
a1698 3
B *
bread (fi, max)
     long max;
d1704 2
a1705 1
	izque (H, link, &anchor);
d1707 11
a1717 15
	while (seg = vlock (vmem, (l = halloc ())->seg),
	       !error
	       && (amnt =
		   bkread (fi, seg, max >= SEGSIZ ? SEGSIZ : (int) max)))
	  {
		  total += amnt;
		  max -= amnt;
		  l->hole = amnt;
		  lines += (l->nlines = mcnt (seg, '\n', amnt));
		  vchanged (seg);
		  vunlock (seg);
		  enqueb (H, link, &anchor, l);
	  }
	hfree (l);
	vunlock (seg);
d1719 1
a1719 1
		return bmk (NULL);
d1721 2
a1722 2
	deque (H, link, &anchor);
	return bmkchn (l, NULL, total, lines);
d1734 3
a1736 4
char *
parsens (s, skip, amnt)
     char *s;
     long *skip, *amnt;
d1738 1
a1738 1
	char *n = vsncpy (NULL, 0, sz (s));
d1740 1
d1743 25
a1767 33
	for (x = sLEN (n) - 1;
	     x > 0 && (n[x] >= '0' && n[x] <= '9' || n[x] == 'x'
		       || n[x] == 'X'); --x);
	if (n[x] == ',')
	  {
		  n[x] = 0;
		  if (n[x + 1] == 'x' || n[x + 1] == 'X')
			  sscanf (n + x + 2, "%lx", skip);
		  else if (n[x + 1] == '0'
			   && (n[x + 2] == 'x' || n[x + 2] == 'X'))
			  sscanf (n + x + 3, "%lx", skip);
		  else if (n[x + 1] == '0')
			  sscanf (n + x + 1, "%lo", skip);
		  else
			  sscanf (n + x + 1, "%ld", skip);
		  for (--x;
		       x > 0 && (n[x] >= '0' && n[x] <= '9' || n[x] == 'x'
				 || n[x] == 'X'); --x);
		  if (n[x] == ',')
		    {
			    n[x] = 0;
			    *amnt = *skip;
			    if (n[x + 1] == 'x' || n[x + 1] == 'X')
				    sscanf (n + x + 2, "%lx", skip);
			    else if (n[x + 1] == '0'
				     && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				    sscanf (n + x + 3, "%lx", skip);
			    else if (n[x + 1] == '0')
				    sscanf (n + x + 1, "%lo", skip);
			    else
				    sscanf (n + x + 1, "%ld", skip);
		    }
	  }
d1770 1
a1770 1
		for (x = 1; n[x] && n[x] != '/'; ++x);
d1774 5
a1778 4
				s = getenv ("HOME");
				z = vsncpy (NULL, 0, sz (s));
				z = vsncpy (z, sLEN (z), sz (n + x));
				vsrm (n);
d1782 1
d1784 1
a1784 1
				passwd = getpwnam (n + 1);
d1787 5
a1791 3
					char *z = vsncpy (NULL, 0, sz (passwd->pw_dir));
					z = vsncpy (z, sLEN (z), sz (n + x));
					vsrm (n);
d1809 2
a1810 3
B *
bload (s)
     char *s;
d1819 8
a1826 9
	if (!s || !s[0])
	  {
		  error = -1;
		  b = bmk (NULL);
		  setopt (&b->o, "");
		  b->rdonly = b->o.readonly;
		  b->er = error;
		  return b;
	  }
d1828 1
a1828 1
	n = parsens (s, &skip, &amnt);
a1830 1
	ossep (n);
d1832 5
a1836 7
	if (n[0] == '!')
	  {
		  nescape (maint->t);
		  ttclsn ();
		  fi = popen (n + 1, "r");
	  }
	else
d1838 1
a1838 1
	if (!strcmp (n, "-"))
d1840 11
a1850 12
	else
	  {
		  fi = fopen (n, "r+");
		  if (!fi)
			  nowrite = 1;
		  else
			  fclose (fi);
		  fi = fopen (n, "r");
		  if (!fi)
			  nowrite = 0;
	  }
	joesep (n);
d1853 10
a1862 11
	if (!fi)
	  {
		  if (errno == ENOENT)
			  error = -1;
		  else
			  error = -4;
		  b = bmk (NULL);
		  setopt (&b->o, n);
		  b->rdonly = b->o.readonly;
		  goto opnerr;
	  }
d1865 17
a1881 20
	if (skip && lseek (fileno (fi), skip, 0) < 0)
	  {
		  int r;
		  while (skip > SEGSIZ)
		    {
			    r = bkread (fileno (fi), buffer, SEGSIZ);
			    if (r != SEGSIZ || error)
			      {
				      error = -3;
				      goto err;
			      }
			    skip -= SEGSIZ;
		    }
		  skip -= bkread (fileno (fi), buffer, (int) skip);
		  if (skip || error)
		    {
			    error = -3;
			    goto err;
		    }
	  }
d1884 2
a1885 2
	b = bread (fileno (fi), amnt);
	setopt (&b->o, n);
d1892 1
a1892 1
		pclose (fi);
d1895 2
a1896 2
	if (strcmp (n, "-"))
		fclose (fi);
d1900 1
a1900 1
		ttopnn (), nreturn (maint->t);
d1903 1
a1903 1
	b->name = joesep (strdup (s));
d1908 1
a1908 1
	else if (!strcmp (n, "-"))
d1916 1
a1916 1
	vsrm (n);
d1924 2
a1925 3
B *
bfind (s)
     char *s;
d1928 10
a1937 10
	if (!s || !s[0])
	  {
		  error = -1;
		  b = bmk (NULL);
		  setopt (&b->o, "");
		  b->rdonly = b->o.readonly;
		  b->internal = 0;
		  b->er = error;
		  return b;
	  }
d1939 10
a1948 11
		if (b->name && !strcmp (s, b->name))
		  {
			  if (!b->orphan)
				  ++b->count;
			  else
				  b->orphan = 0;
			  error = 0;
			  b->internal = 0;
			  return b;
		  }
	b = bload (s);
d1953 1
a1953 2
char **
getbufs ()
d1955 1
a1955 1
	char **s = vamk (16);
d1957 1
d1960 1
a1960 1
			s = vaadd (s, vsncpy (NULL, 0, sz (b->name)));
d1966 1
a1966 2
B *
borphan ()
d1969 1
d1971 4
a1974 5
		if (b->orphan)
		  {
			  b->orphan = 0;
			  return b;
		  }
d1984 3
a1986 4
int
bsavefd (p, fd, size)
     P *p;
     long size;
d1988 1
a1988 1
	P *np = pdup (p);
d1990 13
a2002 22
	while (size > (amnt = GSIZE (np->hdr) - np->ofst))
	  {
		  if (np->ofst < np->hdr->hole)
		    {
			    if (jwrite
				(fd, np->ptr + np->ofst,
				 np->hdr->hole - np->ofst) < 0)
				    goto err;
			    if (jwrite
				(fd, np->ptr + np->hdr->ehole,
				 SEGSIZ - np->hdr->ehole) < 0)
				    goto err;
		    }
		  else
			  if (jwrite
			      (fd, np->ptr + np->ofst + GGAPSZ (np->hdr),
			       amnt) < 0)
			  goto err;
		  size -= amnt;
		  pnext (np);
	  }
	if (size)
d2005 4
a2008 9
				if (jwrite
				      (fd, np->ptr + np->ofst,
				       np->hdr->hole - np->ofst) < 0)
					  goto err;
				if (jwrite
				      (fd, np->ptr + np->hdr->ehole,
				       (int) size - np->hdr->hole +
				       np->ofst) < 0)
					  goto err;
d2010 2
a2011 4
				if (jwrite
				     (fd, np->ptr + np->ofst,
				       (int) size) < 0)
					  goto err;
d2014 2
a2015 4
			if (jwrite
			    (fd, np->ptr + np->ofst + GGAPSZ (np->hdr),
			     (int) size) < 0)
			goto err;
d2017 2
a2018 1
	prm (np);
d2021 1
a2021 1
	prm (np);
d2027 4
a2030 5
int
bsave (p, s, size)
     P *p;
     char *s;
     long size;
d2035 1
a2035 1
	s = parsens (s, &skip, &amnt);
a2039 1
	ossep (s);
d2041 5
a2045 7
	if (s[0] == '!')
	  {
		  nescape (maint->t);
		  ttclsn ();
		  f = popen (s + 1, "w");
	  }
	else
d2048 33
a2080 37
		f = fopen (s + 2, "a");
	else if (!strcmp (s, "-"))
	  {
		  nescape (maint->t);
		  ttclsn ();
		  f = stdout;
	  }
	else if (skip || amnt != MAXLONG)
		f = fopen (s, "r+");
	else
		f = fopen (s, "w");
	joesep (s);

	if (!f)
	  {
		  error = -4;
		  goto opnerr;
	  }
	fflush (f);

	if (skip && lseek (fileno (f), skip, 0) < 0)
	  {
		  error = -3;
		  goto err;
	  }

	bsavefd (p, fileno (f), size);

	if (!error && force && size && !skip && amnt == MAXLONG)
	  {
		  P *q = pdup (p);
		  char nl = '\n';
		  pfwrd (q, size - 1);
		  if (brc (q) != '\n' && jwrite (fileno (f), &nl, 1) < 0)
			  error = -5;
		  prm (q);
	  }
d2085 1
a2085 1
		pclose (f);
d2088 2
a2089 2
	if (strcmp (s, "-"))
		fclose (f);
d2091 1
a2091 1
		fflush (f);
d2094 2
a2095 2
	if (s[0] == '!' || !strcmp (s, "-"))
		ttopnn (), nreturn (maint->t);
d2099 2
a2100 3
int
brc (p)
     P *p;
d2102 1
a2102 1
	if (p->ofst == GSIZE (p->hdr))
d2110 4
a2113 5
char *
brmem (p, blk, size)
     P *p;
     char *blk;
     int size;
d2118 8
a2125 8
	np = pdup (p);
	while (size > (amnt = GSIZE (np->hdr) - np->ofst))
	  {
		  grmem (np->hdr, np->ptr, np->ofst, bk, amnt);
		  bk += amnt;
		  size -= amnt;
		  pnext (np);
	  }
d2127 2
a2128 2
		grmem (np->hdr, np->ptr, np->ofst, bk, size);
	prm (np);
d2132 3
a2134 4
char *
brs (p, size)
     P *p;
     int size;
d2136 2
a2137 1
	char *s = (char *) malloc (size + 1);
d2139 1
a2139 1
	return brmem (p, s, size);
d2142 3
a2144 4
char *
brvs (p, size)
     P *p;
     int size;
d2146 3
a2148 2
	char *s = vstrunc (NULL, size);
	return brmem (p, s, size);
d2153 1
a2153 1
extern char *ctime ();
d2155 1
a2155 2
void
ttsig (sig)
d2157 1
a2157 1
	long tim = time (0);
d2163 19
a2181 20
	if ((tmpfd = open ("DEADJOE", O_RDWR | O_EXCL | O_CREAT, 0600)) < 0)
	  {
		  if (lstat ("DEADJOE", &sbuf) < 0)
			  _exit (-1);
		  if (!S_ISREG (sbuf.st_mode) || sbuf.st_uid != geteuid ())
			  _exit (-1);
		  /*
		     A race condition still exists between the lstat() and the open()
		     systemcall, which leads to a possible denial-of-service attack
		     by setting the file access mode to 600 for every file the
		     user executing joe has permissions to.
		     This can't be fixed w/o breacking the behavior of the orig. joe!
		   */
		  if ((tmpfd = open ("DEADJOE", O_RDWR | O_APPEND)) < 0)
			  _exit (-1);
		  if (fchmod (tmpfd, S_IRUSR | S_IWUSR) < 0)
			  _exit (-1);
	  }
	if ((f = fdopen (tmpfd, "a")) == NULL)
		_exit (-1);
d2183 1
a2183 2
	fprintf (f, "\n*** Modified files in JOE when it aborted on %s",
		 ctime (&tim));
d2185 1
a2185 1
		fprintf (f, "*** JOE was aborted by signal %d\n", sig);
d2187 2
a2188 3
		fprintf (f,
			 "*** JOE was aborted because the terminal closed\n");
	fflush (f);
d2190 8
a2197 9
		if (b->changed)
		  {
			  if (b->name)
				  fprintf (f, "\n*** File \'%s\'\n", b->name);
			  else
				  fprintf (f, "\n*** File \'(Unnamed)\'\n");
			  fflush (f);
			  bsavefd (b->bof, fileno (f), b->eof->byte);
		  }
d2199 2
a2200 2
		ttclsn ();
	_exit (1);
@


1.5
log
@changed as of joe-2.9.5
@
text
@a6 3
/*
	DEADJOE tmp race condition security fix by thomas@@suse.de
		at 1999-07-23
d9 2
d48 5
a52 5
  "Error writing file",
  "Error opening file",
  "Error seeking file",
  "Error reading file",
  "New File"
d65 9
a73 14
static void
gstgap (hdr, ptr, ofst)
     H *hdr;
     char *ptr;
     int ofst;
{
  if (ofst > hdr->hole)
    mfwrd (ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole),
      vchanged (ptr);
  else if (ofst < hdr->hole)
    mbkwd (ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst,
	   hdr->hole - ofst), vchanged (ptr);
  hdr->ehole = ofst + hdr->ehole - hdr->hole;
  hdr->hole = ofst;
d78 6
a83 13
static void
ginsm (hdr, ptr, ofst, blk, size)
     H *hdr;
     char *ptr;
     int ofst;
     char *blk;
     int size;
{
  if (ofst != hdr->hole)
    gstgap (hdr, ptr, ofst);
  mcpy (ptr + hdr->hole, blk, size);
  hdr->hole += size;
  vchanged (ptr);
d88 11
a98 17
static void
grmem (hdr, ptr, ofst, blk, size)
     H *hdr;
     char *ptr;
     int ofst;
     char *blk;
     int size;
{
  if (ofst < hdr->hole)
    if (size > hdr->hole - ofst)
      mcpy (blk, ptr + ofst, hdr->hole - ofst),
	mcpy (blk + hdr->hole - ofst, ptr + hdr->ehole,
	      size - (hdr->hole - ofst));
    else
      mcpy (blk, ptr + ofst, size);
  else
    mcpy (blk, ptr + ofst + hdr->ehole - hdr->hole, size);
d106 18
a123 23
static H *
halloc ()
{
  H *h;
  if (qempty (H, link, &ohdrs))
    {
      h = (H *) alitem (&nhdrs, sizeof (H));
      h->seg = my_valloc (vmem, (long) SEGSIZ);
    }
  else
    h = deque (H, link, ohdrs.link.next);
  h->hole = 0;
  h->ehole = SEGSIZ;
  h->nlines = 0;
  izque (H, link, h);
  return h;
}

static void
hfree (h)
     H *h;
{
  enquef (H, link, &ohdrs, h);
d126 2
a127 5
static void
hfreechn (h)
     H *h;
{
  splicef (H, link, &ohdrs, h);
d134 2
a135 4
static P *
palloc ()
{
  return alitem (&frptrs, sizeof (P));
d138 2
a139 5
static void
pfree (p)
     P *p;
{
  enquef (P, link, &frptrs, p);
d147 10
a156 12
B *
bnext ()
{
  B *b;
  do
    {
      b = bufs.link.prev;
      deque (B, link, &bufs);
      enqueb (B, link, b, &bufs);
    }
  while (b->internal);
  return b;
d159 10
a168 12
B *
bprev ()
{
  B *b;
  do
    {
      b = bufs.link.next;
      deque (B, link, &bufs);
      enquef (B, link, b, &bufs);
    }
  while (b->internal);
  return b;
d173 44
a216 49
static B *
bmkchn (chn, prop, amnt, nlines)
     H *chn;
     B *prop;
     long amnt, nlines;
{
  B *b = alitem (&frebufs, sizeof (B));
  b->undo = undomk (b);
  if (prop)
    b->o = prop->o;
  else
    b->o = pdefault;
  mset (b->marks, 0, sizeof (b->marks));
  b->rdonly = 0;
  b->orphan = 0;
  b->oldcur = 0;
  b->oldtop = 0;
  b->backup = 1;
  b->internal = 1;
  b->changed = 0;
  b->count = 1;
  b->name = 0;
  b->er = -3;
  b->bof = palloc ();
  izque (P, link, b->bof);
  b->bof->end = 0;
  b->bof->b = b;
  b->bof->owner = 0;
  b->bof->hdr = chn;
  b->bof->ptr = vlock (vmem, b->bof->hdr->seg);
  b->bof->ofst = 0;
  b->bof->byte = 0;
  b->bof->line = 0;
  b->bof->col = 0;
  b->bof->xcol = 0;
  b->bof->valcol = 1;
  b->eof = pdup (b->bof);
  b->eof->end = 1;
  vunlock (b->eof->ptr);
  b->eof->hdr = chn->link.prev;
  b->eof->ptr = vlock (vmem, b->eof->hdr->seg);
  b->eof->ofst = GSIZE (b->eof->hdr);
  b->eof->byte = amnt;
  b->eof->line = nlines;
  b->eof->valcol = 0;
  enquef (B, link, &bufs, b);
  pcoalesce (b->bof);
  pcoalesce (b->eof);
  return b;
d221 2
a222 5
B *
bmk (prop)
     B *prop;
{
  return bmkchn (halloc (), prop, 0L, 0L);
d229 17
a245 20
void
brm (b)
     B *b;
{
  if (b && !--b->count)
    {
      if (b->changed)
	abrerr (b->name);
      if (b == errbuf)
	errbuf = 0;
      if (b->undo)
	undorm (b->undo);
      hfreechn (b->eof->hdr);
      while (!qempty (P, link, b->bof))
	prm (b->bof->link.next);
      prm (b->bof);
      if (b->name)
	free (b->name);
      demote (B, link, &frebufs, b);
    }
d248 7
a254 10
P *
poffline (p)
     P *p;
{
  if (p->ptr)
    {
      vunlock (p->ptr);
      p->ptr = 0;
    }
  return p;
d257 4
a260 7
P *
ponline (p)
     P *p;
{
  if (!p->ptr)
    p->ptr = vlock (vmem, p->hdr->seg);
  return p;
d263 6
a268 9
B *
boffline (b)
     B *b;
{
  P *p = b->bof;
  do
    poffline (p);
  while ((p = p->link.next) != b->bof);
  return b;
d271 6
a276 9
B *
bonline (b)
     B *b;
{
  P *p = b->bof;
  do
    ponline (p);
  while ((p = p->link.next) != b->bof);
  return b;
d279 30
a308 10
P *
pdup (p)
     P *p;
{
  P *n = palloc ();
  n->end = 0;
  n->ptr = 0;
  n->owner = 0;
  enquef (P, link, p, n);
  return pset (n, p);
d311 21
a331 15
P *
pdupown (p, o)
     P *p;
     P **o;
{
  P *n = palloc ();
  n->end = 0;
  n->ptr = 0;
  n->owner = o;
  enquef (P, link, p, n);
  pset (n, p);
  if (*o)
    prm (*o);
  *o = n;
  return n;
d334 2
a335 11
void
prm (p)
     P *p;
{
  if (!p)
    return;
  if (p->owner)
    *p->owner = 0;
  if (p->ptr)
    vunlock (p->ptr);
  pfree (deque (P, link, p));
d338 2
a339 24
P *
pset (n, p)
     P *n, *p;
{
  if (n != p)
    {
      n->b = p->b;
      n->ofst = p->ofst;
      n->hdr = p->hdr;
      if (n->ptr)
	vunlock (n->ptr);
      if (p->ptr)
	{
	  n->ptr = p->ptr;
	  vupcount (n->ptr);
	}
      else
	n->ptr = vlock (vmem, n->hdr->seg);
      n->byte = p->byte;
      n->line = p->line;
      n->col = p->col;
      n->valcol = p->valcol;
    }
  return n;
d342 2
a343 5
P *
pbof (p)
     P *p;
{
  return pset (p, p->b->bof);
d346 2
a347 5
P *
peof (p)
     P *p;
{
  return pset (p, p->b->eof);
d350 21
a370 5
int
pisbof (p)
     P *p;
{
  return p->hdr == p->b->bof->hdr && !p->ofst;
d373 7
a379 5
int
piseof (p)
     P *p;
{
  return p->ofst == GSIZE (p->hdr);
d382 1
a382 13
int
piseol (p)
     P *p;
{
  int c;
  if (piseof (p))
    return 1;
  c = brc (p);
  if (c == '\n')
    return 1;
  if (p->b->o.crlf)
    if (c == '\r')
      {
d384 5
a388 6
	pfwrd (q, 1L);
	if (pgetc (q) == '\n')
	  {
	    prm (q);
	    return 1;
	  }
d390 1
a390 3
	  prm (q);
      }
  return 0;
d393 9
a401 10
int
pisbol (p)
     P *p;
{
  char c;
  if (pisbof (p))
    return 1;
  c = prgetc (p);
  pgetc (p);
  return c == '\n';
d404 2
a405 13
int
pisbow (p)
     P *p;
{
  P *q = pdup (p);
  int c = brc (p);
  int d = prgetc (q);
  prm (q);
  if (isalnum_ (c) && !isalnum_ (d))
    return 1;
  else
    return 0;
}
d407 11
a417 12
int
piseow (p)
     P *p;
{
  P *q = pdup (p);
  int d = brc (q);
  int c = prgetc (q);
  prm (q);
  if (isalnum_ (c) && !isalnum_ (d))
    return 1;
  else
    return 0;
d420 9
a428 18
int
pisblank (p)
     P *p;
{
  P *q = pdup (p);
  pbol (q);
  while (isblank (brc (q)))
    pgetc (q);
  if (piseol (q))
    {
      prm (q);
      return 1;
    }
  else
    {
      prm (q);
      return 0;
    }
d431 11
a441 12
long
pisindent (p)
     P *p;
{
  P *q = pdup (p);
  long col;
  pbol (q);
  while (isblank (brc (q)))
    pgetc (q);
  col = q->col;
  prm (q);
  return col;
d444 11
a454 14
int
pnext (p)
     P *p;
{
  if (p->hdr == p->b->eof->hdr)
    {
      p->ofst = GSIZE (p->hdr);
      return 0;
    }
  p->hdr = p->hdr->link.next;
  p->ofst = 0;
  vunlock (p->ptr);
  p->ptr = vlock (vmem, p->hdr->seg);
  return 1;
d457 2
a458 15
int
pprev (p)
     P *p;
{
  if (p->hdr == p->b->bof->hdr)
    {
      p->ofst = 0;
      return 0;
    }
  p->hdr = p->hdr->link.prev;
  p->ofst = GSIZE (p->hdr);
  vunlock (p->ptr);
  p->ptr = vlock (vmem, p->hdr->seg);
  return 1;
}
d460 26
a485 31
int
pgetc (p)
     P *p;
{
  char c;
  if (p->ofst == GSIZE (p->hdr))
    return MAXINT;
  if (p->ofst >= p->hdr->hole)
    c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
  else
    c = p->ptr[p->ofst];
  if (++p->ofst == GSIZE (p->hdr))
    pnext (p);
  ++p->byte;
  if (c == '\n')
    ++p->line, p->col = 0, p->valcol = 1;
  else if (p->b->o.crlf && c == '\r')
    {
      if (brc (p) == '\n')
	return pgetc (p);
      else
	++p->col;
    }
  else
    {
      if (c == '\t')
	p->col += p->b->o.tab - p->col % p->b->o.tab;
      else
	++p->col;
    }
  return c;
d488 4
a491 11
P *
pfwrd (p, n)
     P *p;
     long n;
{
  if (!n)
    return p;
  p->valcol = 0;
  do
    {
      if (p->ofst == GSIZE (p->hdr))
d494 27
a520 21
	    if (!p->ofst)
	      p->byte += GSIZE (p->hdr), n -= GSIZE (p->hdr), p->line +=
		p->hdr->nlines;
	    if (!pnext (p))
	      return 0;
	  }
	while (n > GSIZE (p->hdr));
      if (p->ofst >= p->hdr->hole)
	{
	  if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
	    ++p->line;
	}
      else if (p->ptr[p->ofst] == '\n')
	++p->line;
      ++p->byte;
      ++p->ofst;
    }
  while (--n);
  if (p->ofst == GSIZE (p->hdr))
    pnext (p);
  return p;
d523 20
a542 23
int
prgetc1 (p)
     P *p;
{
  unsigned char c;
  if (!p->ofst)
    if (!pprev (p))
      return MAXINT;
  --p->ofst;
  if (p->ofst >= p->hdr->hole)
    c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
  else
    c = p->ptr[p->ofst];
  --p->byte;
  if (c == '\n')
    --p->line, p->valcol = 0;
  else
    {
      if (c == '\t')
	p->valcol = 0;
      --p->col;
    }
  return c;
d545 12
a556 15
int
prgetc (p)
     P *p;
{
  int c = prgetc1 (p);
  if (p->b->o.crlf && c == '\n')
    {
      c = prgetc1 (p);
      if (c == '\r')
	return '\n';
      if (c != MAXINT)
	pgetc (p);
      c = '\n';
    }
  return c;
d559 4
a562 11
P *
pbkwd (p, n)
     P *p;
     long n;
{
  if (!n)
    return p;
  p->valcol = 0;
  do
    {
      if (!p->ofst)
d565 25
a589 18
	    if (p->ofst)
	      p->byte -= p->ofst, n -= p->ofst, p->line -= p->hdr->nlines;
	    if (!pprev (p))
	      return 0;
	  }
	while (n > GSIZE (p->hdr));
      --p->ofst;
      --p->byte;
      if (p->ofst >= p->hdr->hole)
	{
	  if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
	    --p->line;
	}
      else if (p->ptr[p->ofst] == '\n')
	--p->line;
    }
  while (--n);
  return p;
d592 56
a647 10
P *
pgoto (p, loc)
     P *p;
     long loc;
{
  if (loc > p->byte)
    pfwrd (p, loc - p->byte);
  else if (loc < p->byte)
    pbkwd (p, p->byte - loc);
  return p;
d650 26
a675 10
P *
pfcol (p)
     P *p;
{
  H *hdr = p->hdr;
  int ofst = p->ofst;
  pbol (p);
  while (p->ofst != ofst || p->hdr != hdr)
    pgetc (p);
  return p;
d678 29
a706 9
P *
pbol (p)
     P *p;
{
  if (pprevl (p))
    pgetc (p);
  p->col = 0;
  p->valcol = 1;
  return p;
d709 18
a726 18
P *
peol (p)
     P *p;
{
  if (p->b->o.crlf)
    while (!piseol (p))
      pgetc (p);
  else
    while (p->ofst != GSIZE (p->hdr))
      {
	unsigned char c;
	if (p->ofst >= p->hdr->hole)
	  c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
	else
	  c = p->ptr[p->ofst];
	if (c == '\n')
	  break;
	else
d728 3
a730 8
	    ++p->byte;
	    ++p->ofst;
	    if (c == '\t')
	      p->col += p->b->o.tab - p->col % p->b->o.tab;
	    else
	      ++p->col;
	    if (p->ofst == GSIZE (p->hdr))
	      pnext (p);
d732 1
a732 2
      }
  return p;
d735 2
a736 8
P *
pnextl (p)
     P *p;
{
  char c;
  do
    {
      if (p->ofst == GSIZE (p->hdr))
d739 25
a763 19
	    p->byte += GSIZE (p->hdr) - p->ofst;
	    if (!pnext (p))
	      return 0;
	  }
	while (!p->hdr->nlines);
      if (p->ofst >= p->hdr->hole)
	c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
      else
	c = p->ptr[p->ofst];
      ++p->byte;
      ++p->ofst;
    }
  while (c != '\n');
  ++p->line;
  p->col = 0;
  p->valcol = 1;
  if (p->ofst == GSIZE (p->hdr))
    pnext (p);
  return p;
d766 3
a768 9
P *
pprevl (p)
     P *p;
{
  char c;
  p->valcol = 0;
  do
    {
      if (!p->ofst)
d770 5
a774 22
	  {
	    p->byte -= p->ofst;
	    if (!pprev (p))
	      return 0;
	  }
	while (!p->hdr->nlines);
      --p->ofst;
      --p->byte;
      if (p->ofst >= p->hdr->hole)
	c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
      else
	c = p->ptr[p->ofst];
    }
  while (c != '\n');
  --p->line;
  if (p->b->o.crlf && c == '\n')
    {
      int k = prgetc1 (p);
      if (k != '\r' && k != MAXINT)
	pgetc (p);
    }
  return p;
d777 26
a802 28
P *
pline (p, line)
     P *p;
     long line;
{
  if (line > p->b->eof->line)
    {
      pset (p, p->b->eof);
      return p;
    }
  if (line < labs (p->line - line))
    pset (p, p->b->bof);
  if (labs (p->b->eof->line - line) < labs (p->line - line))
    pset (p, p->b->eof);
  if (p->line == line)
    {
      pbol (p);
      return p;
    }
  while (line > p->line)
    pnextl (p);
  if (line < p->line)
    {
      while (line < p->line)
	pprevl (p);
      pbol (p);
    }
  return p;
d805 11
a815 33
P *
pcol (p, goalcol)
     P *p;
     long goalcol;
{
  pbol (p);
  do
    {
      unsigned char c;
      int wid;
      if (p->ofst == GSIZE (p->hdr))
	break;
      if (p->ofst >= p->hdr->hole)
	c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
      else
	c = p->ptr[p->ofst];
      if (c == '\n')
	break;
      if (p->b->o.crlf && c == '\r' && piseol (p))
	break;
      if (c == '\t')
	wid = p->b->o.tab - p->col % p->b->o.tab;
      else
	wid = 1;
      if (p->col + wid > goalcol)
	break;
      if (++p->ofst == GSIZE (p->hdr))
	pnext (p);
      ++p->byte;
      p->col += wid;
    }
  while (p->col != goalcol);
  return p;
d818 10
a827 13
P *
pcolwse (p, goalcol)
     P *p;
     long goalcol;
{
  int c;
  pcol (p, goalcol);
  do
    c = prgetc (p);
  while (c == ' ' || c == '\t');
  if (c != MAXINT)
    pgetc (p);
  return p;
d830 8
a837 30
P *
pcoli (p, goalcol)
     P *p;
     long goalcol;
{
  pbol (p);
  while (p->col < goalcol)
    {
      unsigned char c;
      if (p->ofst == GSIZE (p->hdr))
	break;
      if (p->ofst >= p->hdr->hole)
	c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
      else
	c = p->ptr[p->ofst];
      if (c == '\n')
	break;
#ifdef __MSDOS
      if (c == '\r' && piseol (p))
	break;
#endif
      else if (c == '\t')
	p->col += p->b->o.tab - p->col % p->b->o.tab;
      else
	++p->col;
      if (++p->ofst == GSIZE (p->hdr))
	pnext (p);
      ++p->byte;
    }
  return p;
d840 9
a848 15
void
pfill (p, to, usetabs)
     P *p;
     long to;
{
  piscol (p);
  if (usetabs)
    while (p->col < to)
      if (p->col + p->b->o.tab - p->col % p->b->o.tab <= to)
	binsc (p, '\t'), pgetc (p);
      else
	binsc (p, ' '), pgetc (p);
  else
    while (p->col < to)
      binsc (p, ' '), pgetc (p);
d851 66
a916 13
void
pbackws (p)
     P *p;
{
  int c;
  P *q = pdup (p);
  do
    c = prgetc (q);
  while (c == ' ' || c == '\t');
  if (c != MAXINT)
    pgetc (q);
  bdel (q, p);
  prm (q);
d919 24
a942 11
static char
frgetc (p)
     P *p;
{
  if (!p->ofst)
    pprev (p);
  --p->ofst;
  if (p->ofst >= p->hdr->hole)
    return p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
  else
    return p->ptr[p->ofst];
d945 13
a957 12
static void
ffwrd (p, n)
     P *p;
{
  while (n > GSIZE (p->hdr) - p->ofst)
    {
      n -= GSIZE (p->hdr) - p->ofst;
      if (!pnext (p))
	return;
    }
  if ((p->ofst += n) == GSIZE (p->hdr))
    pnext (p);
d960 13
a972 35
static P *
ffind (p, s, len)
     P *p;
     unsigned char *s;
{
  long amnt = p->b->eof->byte - p->byte;
  int x;
  unsigned char table[256], c;
  if (len > amnt)
    return 0;
  if (!len)
    return p;
  p->valcol = 0;
  mset (table, 255, 256);
  for (x = 0; x != len - 1; ++x)
    table[s[x]] = x;
  ffwrd (p, len);
  amnt -= len;
  x = len;
  do
    if ((c = frgetc (p)) != s[--x])
      {
	if (table[c] == 255)
	  ffwrd (p, len + 1), amnt -= x + 1;
	else if (x <= table[c])
	  ffwrd (p, len - x + 1), --amnt;
	else
	  ffwrd (p, len - table[c]), amnt -= x - table[c];
	if (amnt < 0)
	  return 0;
	else
	  x = len;
      }
  while (x);
  return p;
d975 11
a985 61
static P *
fifind (p, s, len)
     P *p;
     unsigned char *s;
{
  long amnt = p->b->eof->byte - p->byte;
  int x;
  unsigned char table[256], c;
  if (len > amnt)
    return 0;
  if (!len)
    return p;
  p->valcol = 0;
  mset (table, 255, 256);
  for (x = 0; x != len - 1; ++x)
    table[s[x]] = x;
  ffwrd (p, len);
  amnt -= len;
  x = len;
  do
    if ((c = toupper (frgetc (p))) != s[--x])
      {
	if (table[c] == 255)
	  ffwrd (p, len + 1), amnt -= x + 1;
	else if (x <= table[c])
	  ffwrd (p, len - x + 1), --amnt;
	else
	  ffwrd (p, len - table[c]), amnt -= x - table[c];
	if (amnt < 0)
	  return 0;
	else
	  x = len;
      }
  while (x);
  return p;
}

static P *
getto (p, q)
     P *p, *q;
{
  while (p->hdr != q->hdr || p->ofst != q->ofst)
    {
      if (p->ofst >= p->hdr->hole)
	{
	  if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
	    ++p->line;
	}
      else if (p->ptr[p->ofst] == '\n')
	++p->line;
      ++p->byte;
      ++p->ofst;
      if (p->ofst == GSIZE (p->hdr))
	pnext (p);
      while (!p->ofst && p->hdr != q->hdr)
	{
	  p->byte += GSIZE (p->hdr), p->line += p->hdr->nlines;
	  pnext (p);
	}
    }
  return p;
d988 11
a998 17
P *
pfind (p, s, len)
     P *p;
     char *s;
{
  P *q = pdup (p);
  if (ffind (q, s, len))
    {
      getto (p, q);
      prm (q);
      return p;
    }
  else
    {
      prm (q);
      return 0;
    }
d1001 74
a1074 17
P *
pifind (p, s, len)
     P *p;
     char *s;
{
  P *q = pdup (p);
  if (fifind (q, s, len))
    {
      getto (p, q);
      prm (q);
      return p;
    }
  else
    {
      prm (q);
      return 0;
    }
d1077 25
a1101 14
static void
fbkwd (p, n)
     P *p;
{
  while (n > p->ofst)
    {
      n -= p->ofst;
      if (!pprev (p))
	return;
    }
  if (p->ofst >= n)
    p->ofst -= n;
  else
    p->ofst = 0;
d1104 13
a1116 14
static int
fpgetc (p)
     P *p;
{
  char c;
  if (p->ofst == GSIZE (p->hdr))
    return MAXINT;
  if (p->ofst >= p->hdr->hole)
    c = p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
  else
    c = p->ptr[p->ofst];
  if (++p->ofst == GSIZE (p->hdr))
    pnext (p);
  return c;
d1119 13
a1131 39
static P *
frfind (p, s, len)
     P *p;
     unsigned char *s;
{
  long amnt = p->byte;
  int x;
  unsigned char table[256], c;
  if (len > p->b->eof->byte - p->byte)
    {
      x = len - (p->b->eof->byte - p->byte);
      if (amnt < x)
	return 0;
      amnt -= x;
      fbkwd (p, x);
    }
  if (!len)
    return p;
  p->valcol = 0;
  mset (table, 255, 256);
  for (x = len; --x; table[s[x]] = len - x - 1);
  x = 0;
  do
    if ((c = fpgetc (p)) != s[x++])
      {
	if (table[c] == 255)
	  fbkwd (p, len + 1), amnt -= len - x + 1;
	else if (len - table[c] <= x)
	  fbkwd (p, x + 1), --amnt;
	else
	  fbkwd (p, len - table[c]), amnt -= len - table[c] - x;
	if (amnt < 0)
	  return 0;
	else
	  x = 0;
      }
  while (x != len);
  fbkwd (p, len);
  return p;
d1134 4
a1137 67
static P *
frifind (p, s, len)
     P *p;
     unsigned char *s;
{
  long amnt = p->byte;
  int x;
  unsigned char table[256], c;
  if (len > p->b->eof->byte - p->byte)
    {
      x = len - (p->b->eof->byte - p->byte);
      if (amnt < x)
	return 0;
      amnt -= x;
      fbkwd (p, x);
    }
  if (!len)
    return p;
  p->valcol = 0;
  mset (table, 255, 256);
  for (x = len; --x; table[s[x]] = len - x - 1);
  x = 0;
  do
    if ((c = toupper (fpgetc (p))) != s[x++])
      {
	if (table[c] == 255)
	  fbkwd (p, len + 1), amnt -= len - x + 1;
	else if (len - table[c] <= x)
	  fbkwd (p, x + 1), --amnt;
	else
	  fbkwd (p, len - table[c]), amnt -= len - table[c] - x;
	if (amnt < 0)
	  return 0;
	else
	  x = 0;
      }
  while (x != len);
  fbkwd (p, len);
  return p;
}

static P *
rgetto (p, q)
     P *p, *q;
{
  while (p->hdr != q->hdr || p->ofst != q->ofst)
    {
      if (!p->ofst)
	do
	  {
	    if (p->ofst)
	      p->byte -= p->ofst, p->line -= p->hdr->nlines;
	    pprev (p);
	  }
	while (p->hdr != q->hdr);
      --p->ofst;
      --p->byte;
      if (p->ofst >= p->hdr->hole)
	{
	  if (p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole] == '\n')
	    --p->line;
	}
      else if (p->ptr[p->ofst] == '\n')
	--p->line;
    }
  return p;
}
d1139 2
a1140 18
P *
prfind (p, s, len)
     P *p;
     char *s;
{
  P *q = pdup (p);
  if (frfind (q, s, len))
    {
      rgetto (p, q);
      prm (q);
      return p;
    }
  else
    {
      prm (q);
      return 0;
    }
}
d1142 2
a1143 18
P *
prifind (p, s, len)
     P *p;
     char *s;
{
  P *q = pdup (p);
  if (frifind (q, s, len))
    {
      rgetto (p, q);
      prm (q);
      return p;
    }
  else
    {
      prm (q);
      return 0;
    }
}
d1145 53
a1197 67
B *
bcpy (from, to)
     P *from, *to;
{
  H anchor, *l;
  char *ptr;
  P *q;

  if (from->byte >= to->byte)
    return bmk (from->b);

  q = pdup (from);
  izque (H, link, &anchor);

  if (q->hdr == to->hdr)
    {
      l = halloc ();
      ptr = vlock (vmem, l->seg);
      if (q->ofst != q->hdr->hole)
	gstgap (q->hdr, q->ptr, q->ofst);
      l->nlines = mcnt (q->ptr + q->hdr->ehole, '\n', l->hole =
			to->ofst - q->ofst);
      mcpy (ptr, q->ptr + q->hdr->ehole, l->hole);
      vchanged (ptr);
      vunlock (ptr);
      enqueb (H, link, &anchor, l);
    }
  else
    {
      l = halloc ();
      ptr = vlock (vmem, l->seg);
      if (q->ofst != q->hdr->hole)
	gstgap (q->hdr, q->ptr, q->ofst);
      l->nlines = mcnt (q->ptr + q->hdr->ehole, '\n', l->hole =
			SEGSIZ - q->hdr->ehole);
      mcpy (ptr, q->ptr + q->hdr->ehole, l->hole);
      vchanged (ptr);
      vunlock (ptr);
      enqueb (H, link, &anchor, l);
      pnext (q);
      while (q->hdr != to->hdr)
	{
	  l = halloc ();
	  ptr = vlock (vmem, l->seg);
	  l->nlines = q->hdr->nlines;
	  mcpy (ptr, q->ptr, q->hdr->hole);
	  mcpy (ptr + q->hdr->hole, q->ptr + q->hdr->ehole,
		SEGSIZ - q->hdr->ehole);
	  l->hole = GSIZE (q->hdr);
	  vchanged (ptr);
	  vunlock (ptr);
	  enqueb (H, link, &anchor, l);
	  pnext (q);
	}
      if (to->ofst)
	{
	  l = halloc ();
	  ptr = vlock (vmem, l->seg);
	  if (to->ofst != to->hdr->hole)
	    gstgap (to->hdr, to->ptr, to->ofst);
	  l->nlines = mcnt (to->ptr, '\n', to->ofst);
	  mcpy (ptr, to->ptr, l->hole = to->ofst);
	  vchanged (ptr);
	  vunlock (ptr);
	  enqueb (H, link, &anchor, l);
	}
    }
d1199 3
a1201 3
  l = anchor.link.next;
  deque (H, link, &anchor);
  prm (q);
d1203 2
a1204 1
  return bmkchn (l, from->b, to->byte - from->byte, to->line - from->line);
d1209 52
a1260 53
void
pcoalesce (p)
     P *p;
{
  if (p->hdr != p->b->eof->hdr &&
      GSIZE (p->hdr) + GSIZE (p->hdr->link.next) <= SEGSIZ - SEGSIZ / 4)
    {
      H *hdr = p->hdr->link.next;
      char *ptr = vlock (vmem, hdr->seg);
      int osize = GSIZE (p->hdr);
      int size = GSIZE (hdr);
      P *q;
      gstgap (hdr, ptr, size);
      ginsm (p->hdr, p->ptr, GSIZE (p->hdr), ptr, size);
      p->hdr->nlines += hdr->nlines;
      vunlock (ptr);
      hfree (deque (H, link, hdr));
      for (q = p->link.next; q != p; q = q->link.next)
	if (q->hdr == hdr)
	  {
	    q->hdr = p->hdr;
	    if (q->ptr)
	      {
		vunlock (q->ptr);
		q->ptr = vlock (vmem, q->hdr->seg);
	      }
	    q->ofst += osize;
	  }
    }
  if (p->hdr != p->b->bof->hdr &&
      GSIZE (p->hdr) + GSIZE (p->hdr->link.prev) <= SEGSIZ - SEGSIZ / 4)
    {
      H *hdr = p->hdr->link.prev;
      char *ptr = vlock (vmem, hdr->seg);
      int size = GSIZE (hdr);
      P *q;
      gstgap (hdr, ptr, size);
      ginsm (p->hdr, p->ptr, 0, ptr, size);
      p->hdr->nlines += hdr->nlines;
      vunlock (ptr);
      hfree (deque (H, link, hdr));
      p->ofst += size;
      for (q = p->link.next; q != p; q = q->link.next)
	if (q->hdr == hdr)
	  {
	    q->hdr = p->hdr;
	    if (q->ptr)
	      vunlock (q->ptr);
	    q->ptr = vlock (vmem, q->hdr->seg);
	  }
	else if (q->hdr == p->hdr)
	  q->ofst += size;
    }
d1283 142
a1424 65
static B *
bcut (from, to)
     P *from, *to;
{
  H *h,				/* The deleted text */
   *i;
  char *ptr;
  P *p;
  long nlines;			/* No. EOLs to delete */
  long amnt;			/* No. bytes to delete */
  int toamnt;			/* Amount to delete from segment in 'to' */
  int bofmove = 0;		/* Set if bof got deleted */

  if (!(amnt = to->byte - from->byte))
    return 0;			/* ...nothing to delete */

  nlines = to->line - from->line;

  if (from->hdr == to->hdr)
    {				/* Delete is within a single segment */
      /* Move gap to deletion point */
      if (from->ofst != from->hdr->hole)
	gstgap (from->hdr, from->ptr, from->ofst);

      /* Store the deleted text */
      h = halloc ();
      ptr = vlock (vmem, h->seg);
      mcpy (ptr, from->ptr + from->hdr->ehole, (int) amnt);
      h->hole = amnt;
      h->nlines = nlines;
      vchanged (ptr);
      vunlock (ptr);

      /* Delete */
      from->hdr->ehole += amnt;
      from->hdr->nlines -= nlines;

      toamnt = amnt;
    }
  else
    {				/* Delete crosses segments */
      H *a;
      if (toamnt = to->ofst)
	{
	  /* Delete beginning of to */
	  /* Move gap to deletion point */
	  /* To could be deleted if it's at the end of the file */
	  if (to->ofst != to->hdr->hole)
	    gstgap (to->hdr, to->ptr, to->ofst);

	  /* Save deleted text */
	  i = halloc ();
	  ptr = vlock (vmem, i->seg);
	  mcpy (ptr, to->ptr, to->hdr->hole);
	  i->hole = to->hdr->hole;
	  i->nlines = mcnt (to->ptr, '\n', to->hdr->hole);
	  vchanged (ptr);
	  vunlock (ptr);

	  /* Delete */
	  to->hdr->nlines -= i->nlines;
	  to->hdr->hole = 0;
	}
      else
	i = 0;
d1426 1
a1426 28
      /* Delete end of from */
      if (!from->ofst)
	{
	  /* ..unless from needs to be deleted too */
	  a = from->hdr->link.prev, h = 0;
	  if (a == from->b->eof->hdr)
	    bofmove = 1;
	}
      else
	{
	  a = from->hdr;
	  /* Move gap to deletion point */
	  if (from->ofst != from->hdr->hole)
	    gstgap (from->hdr, from->ptr, from->ofst);

	  /* Save deleted text */
	  h = halloc ();
	  ptr = vlock (vmem, h->seg);
	  mcpy (ptr, from->ptr + from->hdr->ehole, SEGSIZ - from->hdr->ehole);
	  h->hole = SEGSIZ - from->hdr->ehole;
	  h->nlines = mcnt (ptr, '\n', h->hole);
	  vchanged (ptr);
	  vunlock (ptr);

	  /* Delete */
	  from->hdr->nlines -= h->nlines;
	  from->hdr->ehole = SEGSIZ;
	}
d1428 10
a1437 72
      /* Make from point to header/segment of to */
      from->hdr = to->hdr;
      vunlock (from->ptr);
      from->ptr = to->ptr;
      vupcount (to->ptr);
      from->ofst = 0;

      /* Delete headers/segments between a and to->hdr (if there are any) */
      if (a->link.next != to->hdr)
	if (!h)
	  {
	    h = snip (H, link, a->link.next, to->hdr->link.prev);
	    if (i)
	      enqueb (H, link, h, i);
	  }
	else
	  {
	    splicef (H, link, h,
		     snip (H, link, a->link.next, to->hdr->link.prev));
	    if (i)
	      enqueb (H, link, h, i);
	  }
      else if (!h)
	h = i;
      else if (i)
	enqueb (H, link, h, i);
    }

  /* If to is empty, then it must have been at the end of the file.  If
     the file did not become empty, delete to */
  if (!GSIZE (to->hdr) && from->byte)
    {
      H *ph = from->hdr->link.prev;
      hfree (deque (H, link, from->hdr));
      vunlock (from->ptr);
      from->hdr = ph;
      from->ptr = vlock (vmem, from->hdr->seg);
      from->ofst = GSIZE (ph);
      vunlock (from->b->eof->ptr);
      from->b->eof->ptr = from->ptr;
      vupcount (from->ptr);
      from->b->eof->hdr = from->hdr;
      from->b->eof->ofst = from->ofst;
    }

  /* The deletion is now done */

  /* Scroll if necessary */

  if (bofmove)
    pset (from->b->bof, from);
  if (nlines && !pisbol (from))
    {
      scrdel (from->b, from->line, nlines, 1);
      delerr (from->b->name, from->line, nlines, 0);
    }
  else
    {
      scrdel (from->b, from->line, nlines, 0);
      delerr (from->b->name, from->line, nlines, 1);
    }

  /* Fix pointers */

  for (p = from->link.next; p != from; p = p->link.next)
    if (p->line == from->line && p->byte > from->byte)
      p->valcol = 0;
  for (p = from->link.next; p != from; p = p->link.next)
    if (p->byte >= from->byte)
      if (p->byte <= from->byte + amnt)
	if (p->ptr)
	  pset (p, from);
d1439 10
a1448 8
	  poffline (pset (p, from));
      else
	{
	  if (p->hdr == to->hdr)
	    p->ofst -= toamnt;
	  p->byte -= amnt;
	  p->line -= nlines;
	}
d1450 19
a1468 1
  pcoalesce (from);
d1470 1
a1470 1
  /* Make buffer out of deleted text and return it */
d1472 1
a1472 1
  return bmkchn (h, from->b, amnt, nlines);
d1475 10
a1484 9
void bdel (P * from, P * to) {
	if (to->byte - from->byte) {
		B *b = bcut (from, to);
		if (from->b->undo)
			undodel (from->b->undo, from->byte, b);
		else
			brm (b);
		from->b->changed = 1;
	}
d1492 40
a1531 43
static void
bsplit (p)
     P *p;
{
  if (p->ofst)
    {
      H *hdr;
      char *ptr;
      P *pp;

      hdr = halloc ();
      ptr = vlock (vmem, hdr->seg);

      if (p->ofst != p->hdr->hole)
	gstgap (p->hdr, p->ptr, p->ofst);
      mcpy (ptr, p->ptr + p->hdr->ehole, SEGSIZ - p->hdr->ehole);
      hdr->hole = SEGSIZ - p->hdr->ehole;
      hdr->nlines = mcnt (ptr, '\n', hdr->hole);
      p->hdr->nlines -= hdr->nlines;
      vchanged (ptr);
      p->hdr->ehole = SEGSIZ;

      enquef (H, link, p->hdr, hdr);

      vunlock (p->ptr);

      for (pp = p->link.next; pp != p; pp = pp->link.next)
	if (pp->hdr == p->hdr && pp->ofst >= p->ofst)
	  {
	    pp->hdr = hdr;
	    if (pp->ptr)
	      {
		vunlock (pp->ptr);
		pp->ptr = ptr;
		vupcount (ptr);
	      }
	    pp->ofst -= p->ofst;
	  }

      p->ptr = ptr;
      p->hdr = hdr;
      p->ofst = 0;
    }
d1537 27
a1563 32
static H *
bldchn (blk, size, nlines)
     char *blk;
     int size;
     long *nlines;
{
  H anchor, *l;
  *nlines = 0;
  izque (H, link, &anchor);
  do
    {
      char *ptr;
      int amnt;
      ptr = vlock (vmem, (l = halloc ())->seg);
      if (size > SEGSIZ)
	amnt = SEGSIZ;
      else
	amnt = size;
      mcpy (ptr, blk, amnt);
      l->hole = amnt;
      l->ehole = SEGSIZ;
      (*nlines) += (l->nlines = mcnt (ptr, '\n', amnt));
      vchanged (ptr);
      vunlock (ptr);
      enqueb (H, link, &anchor, l);
      blk += amnt;
      size -= amnt;
    }
  while (size);
  l = anchor.link.next;
  deque (H, link, &anchor);
  return l;
d1569 40
a1608 44
static void
inschn (p, a)
     P *p;
     H *a;
{
  if (!p->b->eof->byte)
    {				/* P's buffer is empty: replace the empty segment in p with a */
      hfree (p->hdr);
      p->hdr = a;
      vunlock (p->ptr);
      p->ptr = vlock (vmem, a->seg);
      pset (p->b->bof, p);

      p->b->eof->hdr = a->link.prev;
      vunlock (p->b->eof->ptr);
      p->b->eof->ptr = vlock (vmem, p->b->eof->hdr->seg);
      p->b->eof->ofst = GSIZE (p->b->eof->hdr);
    }
  else if (piseof (p))
    {				/* We're at the end of the file: append a to the file */
      p->b->eof->hdr = a->link.prev;
      spliceb (H, link, p->b->bof->hdr, a);
      vunlock (p->b->eof->ptr);
      p->b->eof->ptr = vlock (vmem, p->b->eof->hdr->seg);
      p->b->eof->ofst = GSIZE (p->b->eof->hdr);
      p->hdr = a;
      vunlock (p->ptr);
      p->ptr = vlock (vmem, p->hdr->seg);
      p->ofst = 0;
    }
  else if (pisbof (p))
    {				/* We're at the beginning of the file: insert chain and set bof pointer */
      p->hdr = spliceb (H, link, p->hdr, a);
      vunlock (p->ptr);
      p->ptr = vlock (vmem, a->seg);
      pset (p->b->bof, p);
    }
  else
    {				/* We're in the middle of the file: split and insert */
      bsplit (p);
      p->hdr = spliceb (H, link, p->hdr, a);
      vunlock (p->ptr);
      p->ptr = vlock (vmem, a->seg);
    }
d1611 32
a1642 35
static void
fixupins (p, amnt, nlines, hdr, hdramnt)
     P *p;
     long amnt;
     long nlines;
     H *hdr;
     int hdramnt;
{
  P *pp;
  if (nlines && !pisbol (p))
    scrins (p->b, p->line, nlines, 1);
  else
    scrins (p->b, p->line, nlines, 0);
  inserr (p->b->name, p->line, nlines);

  for (pp = p->link.next; pp != p; pp = pp->link.next)
    if (pp->line == p->line &&
	(pp->byte > p->byte || pp->end
	 && pp->byte == p->byte)) pp->valcol = 0;
  for (pp = p->link.next; pp != p; pp = pp->link.next)
    if (pp->byte == p->byte && !pp->end)
      if (pp->ptr)
	pset (pp, p);
      else
	poffline (pset (pp, p));
    else if (pp->byte > p->byte || pp->end && pp->byte == p->byte)
      {
	pp->byte += amnt;
	pp->line += nlines;
	if (pp->hdr == hdr)
	  pp->ofst += hdramnt;
      }
  if (p->b->undo)
    undoins (p->b->undo, p, amnt);
  p->b->changed = 1;
d1648 12
a1659 16
P *
binsb (p, b)
     P *p;
     B *b;
{
  if (b->eof->byte)
    {
      P *q = pdup (p);
      inschn (q, b->bof->hdr);
      b->eof->hdr = halloc ();
      fixupins (q, b->eof->byte, b->eof->line, NULL, 0);
      pcoalesce (q);
      prm (q);
    }
  brm (b);
  return p;
d1662 31
a1692 36
P *
binsm (p, blk, amnt)
     P *p;
     char *blk;
     int amnt;
{
  long nlines;
  H *h = 0;
  int hdramnt;
  P *q;
  if (!amnt)
    return p;
  q = pdup (p);
  if (amnt <= GGAPSZ (q->hdr))
    {
      h = q->hdr;
      hdramnt = amnt;
      ginsm (q->hdr, q->ptr, q->ofst, blk, amnt);
      q->hdr->nlines += (nlines = mcnt (blk, '\n', amnt));
    }
  else if (!q->ofst && q->hdr != q->b->bof->hdr
	   && amnt <= GGAPSZ (q->hdr->link.prev))
    {
      pprev (q);
      ginsm (q->hdr, q->ptr, q->ofst, blk, amnt);
      q->hdr->nlines += (nlines = mcnt (blk, '\n', amnt));
    }
  else
    {
      H *a = bldchn (blk, amnt, &nlines);
      inschn (q, a);
    }
  fixupins (q, (long) amnt, nlines, h, hdramnt);
  pcoalesce (q);
  prm (q);
  return p;
d1695 1
a1695 2
P *
binsc (p, c)
d1699 4
a1702 4
  if (p->b->o.crlf && c == '\n')
    return binsm (p, "\r\n", 2);
  else
    return binsm (p, &c, 1);
d1710 1
a1710 1
  return binsm (p, s, strlen (s));
d1722 14
a1735 13
  int a, b;
  if (!size)
    {
      error = 0;
      return 0;
    }
  for (a = b = 0; (a < size) && ((b = jread (fi, buff + a, size - a)) > 0);
       a += b);
  if (b < 0)
    error = -2;
  else
    error = 0;
  return a;
d1745 26
a1770 25
  H anchor, *l;
  long lines = 0, total = 0;
  int amnt;
  char *seg;
  izque (H, link, &anchor);
  error = 0;
  while (seg = vlock (vmem, (l = halloc ())->seg),
	 !error
	 && (amnt = bkread (fi, seg, max >= SEGSIZ ? SEGSIZ : (int) max)))
    {
      total += amnt;
      max -= amnt;
      l->hole = amnt;
      lines += (l->nlines = mcnt (seg, '\n', amnt));
      vchanged (seg);
      vunlock (seg);
      enqueb (H, link, &anchor, l);
    }
  hfree (l);
  vunlock (seg);
  if (!total)
    return bmk (NULL);
  l = anchor.link.next;
  deque (H, link, &anchor);
  return bmkchn (l, NULL, total, lines);
d1787 8
a1794 50
  char *n = vsncpy (NULL, 0, sz (s));
  int x;
  *skip = 0;
  *amnt = MAXLONG;
  for (x = sLEN (n) - 1;
       x > 0 && (n[x] >= '0' && n[x] <= '9' || n[x] == 'x' || n[x] == 'X');
       --x);
  if (n[x] == ',')
    {
      n[x] = 0;
      if (n[x + 1] == 'x' || n[x + 1] == 'X')
	sscanf (n + x + 2, "%lx", skip);
      else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
	sscanf (n + x + 3, "%lx", skip);
      else if (n[x + 1] == '0')
	sscanf (n + x + 1, "%lo", skip);
      else
	sscanf (n + x + 1, "%ld", skip);
      for (--x;
	   x > 0 && (n[x] >= '0' && n[x] <= '9' || n[x] == 'x'
		     || n[x] == 'X'); --x);
      if (n[x] == ',')
	{
	  n[x] = 0;
	  *amnt = *skip;
	  if (n[x + 1] == 'x' || n[x + 1] == 'X')
	    sscanf (n + x + 2, "%lx", skip);
	  else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
	    sscanf (n + x + 3, "%lx", skip);
	  else if (n[x + 1] == '0')
	    sscanf (n + x + 1, "%lo", skip);
	  else
	    sscanf (n + x + 1, "%ld", skip);
	}
    }
#ifndef __MSDOS__
  if (n[0] == '~')
    {
      for (x = 1; n[x] && n[x] != '/'; ++x);
      if (n[x] == '/')
	if (x == 1)
	  {
	    char *z;
	    s = getenv ("HOME");
	    z = vsncpy (NULL, 0, sz (s));
	    z = vsncpy (z, sLEN (z), sz (n + x));
	    vsrm (n);
	    n = z;
	  }
	else
d1796 27
a1822 11
	    struct passwd *passwd;
	    n[x] = 0;
	    passwd = getpwnam (n + 1);
	    n[x] = '/';
	    if (passwd)
	      {
		char *z = vsncpy (NULL, 0, sz (passwd->pw_dir));
		z = vsncpy (z, sLEN (z), sz (n + x));
		vsrm (n);
		n = z;
	      }
d1824 25
a1848 1
    }
d1850 1
a1850 1
  return n;
d1865 6
a1870 16
  char buffer[SEGSIZ];
  FILE *fi;
  B *b;
  long skip, amnt;
  char *n;
  int nowrite = 0;

  if (!s || !s[0])
    {
      error = -1;
      b = bmk (NULL);
      setopt (&b->o, "");
      b->rdonly = b->o.readonly;
      b->er = error;
      return b;
    }
d1872 9
a1880 1
  n = parsens (s, &skip, &amnt);
d1882 4
a1885 2
  /* Open file or stream */
  ossep (n);
d1887 7
a1893 7
  if (n[0] == '!')
    {
      nescape (maint->t);
      ttclsn ();
      fi = popen (n + 1, "r");
    }
  else
d1895 49
a1943 49
  if (!strcmp (n, "-"))
    fi = stdin;
  else
    {
      fi = fopen (n, "r+");
      if (!fi)
	nowrite = 1;
      else
	fclose (fi);
      fi = fopen (n, "r");
      if (!fi)
	nowrite = 0;
    }
  joesep (n);

  /* Abort if couldn't open */
  if (!fi)
    {
      if (errno == ENOENT)
	error = -1;
      else
	error = -4;
      b = bmk (NULL);
      setopt (&b->o, n);
      b->rdonly = b->o.readonly;
      goto opnerr;
    }

  /* Skip data if we need to */
  if (skip && lseek (fileno (fi), skip, 0) < 0)
    {
      int r;
      while (skip > SEGSIZ)
	{
	  r = bkread (fileno (fi), buffer, SEGSIZ);
	  if (r != SEGSIZ || error)
	    {
	      error = -3;
	      goto err;
	    }
	  skip -= SEGSIZ;
	}
      skip -= bkread (fileno (fi), buffer, (int) skip);
      if (skip || error)
	{
	  error = -3;
	  goto err;
	}
    }
d1945 4
a1948 4
  /* Read from stream into new buffer */
  b = bread (fileno (fi), amnt);
  setopt (&b->o, n);
  b->rdonly = b->o.readonly;
d1950 2
a1951 2
  /* Close stream */
err:;
d1953 3
a1955 3
  if (s[0] == '!')
    pclose (fi);
  else
d1957 2
a1958 2
  if (strcmp (n, "-"))
    fclose (fi);
d1960 16
a1975 16
opnerr:;
  if (s[0] == '!')
    ttopnn (), nreturn (maint->t);

  /* Set name */
  b->name = joesep (strdup (s));

  /* Set flags */
  if (error || s[0] == '!' || skip || amnt != MAXLONG)
    b->backup = 1, b->changed = 0;
  else if (!strcmp (n, "-"))
    b->backup = 1, b->changed = 1;
  else
    b->backup = 0, b->changed = 0;
  if (nowrite)
    b->rdonly = b->o.readonly = 1;
d1977 2
a1978 2
  /* Eliminate parsed name */
  vsrm (n);
d1980 2
a1981 2
  b->er = error;
  return b;
d1990 23
a2012 19
  B *b;
  if (!s || !s[0])
    {
      error = -1;
      b = bmk (NULL);
      setopt (&b->o, "");
      b->rdonly = b->o.readonly;
      b->internal = 0;
      b->er = error;
      return b;
    }
  for (b = bufs.link.next; b != &bufs; b = b->link.next)
    if (b->name && !strcmp (s, b->name))
      {
	if (!b->orphan)
	  ++b->count;
	else
	  b->orphan = 0;
	error = 0;
a2014 4
      }
  b = bload (s);
  b->internal = 0;
  return b;
d2020 6
a2025 6
  char **s = vamk (16);
  B *b;
  for (b = bufs.link.next; b != &bufs; b = b->link.next)
    if (b->name)
      s = vaadd (s, vsncpy (NULL, 0, sz (b->name)));
  return s;
d2033 8
a2040 8
  B *b;
  for (b = bufs.link.next; b != &bufs; b = b->link.next)
    if (b->orphan)
      {
	b->orphan = 0;
	return b;
      }
  return 0;
d2054 52
a2105 41
  P *np = pdup (p);
  int amnt;
  while (size > (amnt = GSIZE (np->hdr) - np->ofst))
    {
      if (np->ofst < np->hdr->hole)
	{
	  if (jwrite (fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
	    goto err;
	  if (jwrite (fd, np->ptr + np->hdr->ehole, SEGSIZ - np->hdr->ehole) <
	      0)
	    goto err;
	}
      else if (jwrite (fd, np->ptr + np->ofst + GGAPSZ (np->hdr), amnt) < 0)
	goto err;
      size -= amnt;
      pnext (np);
    }
  if (size)
    if (np->ofst < np->hdr->hole)
      if (size > np->hdr->hole - np->ofst)
	{
	  if (jwrite (fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
	    goto err;
	  if (jwrite
	      (fd, np->ptr + np->hdr->ehole,
	       (int) size - np->hdr->hole + np->ofst) < 0)
	    goto err;
	}
      else
	{
	  if (jwrite (fd, np->ptr + np->ofst, (int) size) < 0)
	    goto err;
	}
    else if (jwrite (fd, np->ptr + np->ofst + GGAPSZ (np->hdr), (int) size) <
	     0)
      goto err;
  prm (np);
  return error = 0;
err:;
  prm (np);
  return error = 5;
d2116 2
a2117 2
  FILE *f;
  long skip, amnt;
d2119 1
a2119 1
  s = parsens (s, &skip, &amnt);
d2121 2
a2122 2
  if (amnt < size)
    size = amnt;
d2124 1
a2124 1
  ossep (s);
d2126 7
a2132 7
  if (s[0] == '!')
    {
      nescape (maint->t);
      ttclsn ();
      f = popen (s + 1, "w");
    }
  else
d2134 26
a2159 38
  if (s[0] == '>' && s[1] == '>')
    f = fopen (s + 2, "a");
  else if (!strcmp (s, "-"))
    {
      nescape (maint->t);
      ttclsn ();
      f = stdout;
    }
  else if (skip || amnt != MAXLONG)
    f = fopen (s, "r+");
  else
    f = fopen (s, "w");
  joesep (s);

  if (!f)
    {
      error = -4;
      goto opnerr;
    }
  fflush (f);

  if (skip && lseek (fileno (f), skip, 0) < 0)
    {
      error = -3;
      goto err;
    }

  bsavefd (p, fileno (f), size);

  if (!error && force && size && !skip && amnt == MAXLONG)
    {
      P *q = pdup (p);
      char nl = '\n';
      pfwrd (q, size - 1);
      if (brc (q) != '\n' && jwrite (fileno (f), &nl, 1) < 0)
	error = -5;
      prm (q);
    }
d2161 13
a2173 1
err:;
d2175 3
a2177 3
  if (s[0] == '!')
    pclose (f);
  else
d2179 9
a2187 9
  if (strcmp (s, "-"))
    fclose (f);
  else
    fflush (f);

opnerr:;
  if (s[0] == '!' || !strcmp (s, "-"))
    ttopnn (), nreturn (maint->t);
  return error;
d2194 6
a2199 6
  if (p->ofst == GSIZE (p->hdr))
    return MAXINT;
  if (p->ofst >= p->hdr->hole)
    return p->ptr[p->ofst + p->hdr->ehole - p->hdr->hole];
  else
    return p->ptr[p->ofst];
d2208 15
a2222 15
  char *bk = blk;
  P *np;
  int amnt;
  np = pdup (p);
  while (size > (amnt = GSIZE (np->hdr) - np->ofst))
    {
      grmem (np->hdr, np->ptr, np->ofst, bk, amnt);
      bk += amnt;
      size -= amnt;
      pnext (np);
    }
  if (size)
    grmem (np->hdr, np->ptr, np->ofst, bk, size);
  prm (np);
  return blk;
d2230 3
a2232 3
  char *s = (char *) malloc (size + 1);
  s[size] = 0;
  return brmem (p, s, size);
d2240 2
a2241 2
  char *s = vstrunc (NULL, size);
  return brmem (p, s, size);
d2251 31
a2281 39
  long tim = time (0);
  B *b;
  FILE *f;
  int tmpfd;
  struct stat sbuf;

  if ((tmpfd = open ("DEADJOE", O_RDWR | O_EXCL | O_CREAT, 0600)) < 0)
    {
      if (lstat ("DEADJOE", &sbuf) < 0)
	_exit (-1);
      if (!S_ISREG (sbuf.st_mode) || sbuf.st_uid != geteuid ())
	_exit (-1);
      /*
         A race condition still exists between the lstat() and the open()
         systemcall, which leads to a possible denial-of-service attack
         by setting the file access mode to 600 for every file the
         user executing joe has permissions to.
         This can't be fixed w/o breacking the behavior of the orig. joe!
       */
      if ((tmpfd = open ("DEADJOE", O_RDWR | O_APPEND)) < 0)
	_exit (-1);
      if (fchmod (tmpfd, S_IRUSR | S_IWUSR) < 0)
	_exit (-1);
    }
  if ((f = fdopen (tmpfd, "a")) == NULL)
    _exit (-1);

  fprintf (f, "\n*** Modified files in JOE when it aborted on %s",
	   ctime (&tim));
  if (sig)
    fprintf (f, "*** JOE was aborted by signal %d\n", sig);
  else
    fprintf (f, "*** JOE was aborted because the terminal closed\n");
  fflush (f);
  for (b = bufs.link.next; b != &bufs; b = b->link.next)
    if (b->changed)
      {
	if (b->name)
	  fprintf (f, "\n*** File \'%s\'\n", b->name);
d2283 2
a2284 1
	  fprintf (f, "\n*** File \'(Unnamed)\'\n");
d2286 13
a2298 5
	bsavefd (b->bof, fileno (f), b->eof->byte);
      }
  if (sig)
    ttclsn ();
  _exit (1);
@


1.4
log
@changed as of joe-2.9.4
@
text
@d29 1
a29 1
#include "zstr.h"
@


1.3
log
@changed as of joe-2.9.2
@
text
@d1 4
a4 4
/* Editor engine
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)
d6 1
a6 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d8 2
a9 2
DEADJOE tmp race condition security fix by thomas@@suse.de
at 1999-07-23
d45 1
a45 1
int force=0;
d48 7
a54 8
char *msgs[]=
 { 
 "Error writing file",
 "Error opening file",
 "Error seeking file",
 "Error reading file",
 "New File"
 };
d66 15
a80 12
static void gstgap(hdr,ptr,ofst)
H *hdr;
char *ptr;
int ofst;
 {
 if(ofst>hdr->hole)
  mfwrd(ptr+hdr->hole,ptr+hdr->ehole,ofst-hdr->hole), vchanged(ptr);
 else if(ofst<hdr->hole)
  mbkwd(ptr+hdr->ehole-(hdr->hole-ofst),ptr+ofst,hdr->hole-ofst), vchanged(ptr);
 hdr->ehole=ofst+hdr->ehole-hdr->hole;
 hdr->hole=ofst;
 }
d84 14
a97 12
static void ginsm(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
 {
 if(ofst!=hdr->hole) gstgap(hdr,ptr,ofst);
 mcpy(ptr+hdr->hole,blk,size);
 hdr->hole+=size;
 vchanged(ptr);
 }
d101 18
a118 14
static void grmem(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
 {
 if(ofst<hdr->hole)
  if(size>hdr->hole-ofst)
   mcpy(blk,ptr+ofst,hdr->hole-ofst),
   mcpy(blk+hdr->hole-ofst,ptr+hdr->ehole,size-(hdr->hole-ofst));
  else mcpy(blk,ptr+ofst,size);
 else mcpy(blk,ptr+ofst+hdr->ehole-hdr->hole,size);
 }
d122 2
a123 2
static H nhdrs={{&nhdrs,&nhdrs}};
static H ohdrs={{&ohdrs,&ohdrs}};
d125 31
a155 27
static H *halloc()
 {
 H *h;
 if(qempty(H,link,&ohdrs))
  {
  h=(H *)alitem(&nhdrs,sizeof(H));
  h->seg=my_valloc(vmem,(long)SEGSIZ);
  }
 else h=deque(H,link,ohdrs.link.next);
 h->hole=0;
 h->ehole=SEGSIZ;
 h->nlines=0;
 izque(H,link,h);
 return h;
 }

static void hfree(h)
H *h;
 {
 enquef(H,link,&ohdrs,h);
 }

static void hfreechn(h)
H *h;
 {
 splicef(H,link,&ohdrs,h);
 }
d159 1
a159 1
static P frptrs={{&frptrs,&frptrs}};
d161 12
a172 10
static P *palloc()
 {
 return alitem(&frptrs,sizeof(P));
 }

static void pfree(p)
P *p;
 {
 enquef(P,link,&frptrs,p);
 }
d176 2
a177 2
static B bufs={{&bufs,&bufs}};
static B frebufs={{&frebufs,&frebufs}};
d179 27
a205 25
B *bnext()
 {
 B *b;
 do
  {
  b=bufs.link.prev;
  deque(B,link,&bufs);
  enqueb(B,link,b,&bufs);
  }
  while(b->internal);
 return b;
 }

B *bprev()
 {
 B *b;
 do
  {
  b=bufs.link.next;
  deque(B,link,&bufs);
  enquef(B,link,b,&bufs);
  }
  while(b->internal);
 return b;
 }
d209 50
a258 46
static B *bmkchn(chn,prop,amnt,nlines)
H *chn;
B *prop;
long amnt, nlines;
 {
 B *b=alitem(&frebufs,sizeof(B));
 b->undo=undomk(b);
 if(prop) b->o=prop->o;
 else b->o=pdefault;
 mset(b->marks,0,sizeof(b->marks));
 b->rdonly=0;
 b->orphan=0;
 b->oldcur=0;
 b->oldtop=0;
 b->backup=1;
 b->internal=1;
 b->changed=0;
 b->count=1;
 b->name=0;
 b->er= -3;
 b->bof=palloc(); izque(P,link,b->bof);
 b->bof->end=0;
 b->bof->b=b;
 b->bof->owner=0;
 b->bof->hdr=chn;
 b->bof->ptr=vlock(vmem,b->bof->hdr->seg);
 b->bof->ofst=0;
 b->bof->byte=0;
 b->bof->line=0;
 b->bof->col=0;
 b->bof->xcol=0;
 b->bof->valcol=1;
 b->eof=pdup(b->bof);
 b->eof->end=1;
 vunlock(b->eof->ptr);
 b->eof->hdr=chn->link.prev;
 b->eof->ptr=vlock(vmem,b->eof->hdr->seg);
 b->eof->ofst=GSIZE(b->eof->hdr);
 b->eof->byte=amnt;
 b->eof->line=nlines;
 b->eof->valcol=0;
 enquef(B,link,&bufs,b);
 pcoalesce(b->bof);
 pcoalesce(b->eof);
 return b;
 }
d262 6
a267 5
B *bmk(prop)
B *prop;
 {
 return bmkchn(halloc(),prop,0L,0L);
 }
d273 27
a299 141
void brm(b)
B *b;
 {
 if(b && !--b->count)
  {
  if(b->changed) abrerr(b->name);
  if(b==errbuf) errbuf=0;
  if(b->undo) undorm(b->undo);
  hfreechn(b->eof->hdr);
  while(!qempty(P,link,b->bof)) prm(b->bof->link.next);
  prm(b->bof);
  if(b->name) free(b->name);
  demote(B,link,&frebufs,b);
  }
 }

P *poffline(p)
P *p;
 {
 if(p->ptr)
  {
  vunlock(p->ptr);
  p->ptr=0;
  }
 return p;
 }

P *ponline(p)
P *p;
 {
 if(!p->ptr) p->ptr=vlock(vmem,p->hdr->seg);
 return p;
 }

B *boffline(b)
B *b;
 {
 P *p=b->bof;
 do poffline(p); while((p=p->link.next)!=b->bof);
 return b;
 }

B *bonline(b)
B *b;
 {
 P *p=b->bof;
 do ponline(p); while((p=p->link.next)!=b->bof);
 return b;
 }

P *pdup(p)
P *p;
 {
 P *n=palloc();
 n->end=0;
 n->ptr=0;
 n->owner=0;
 enquef(P,link,p,n);
 return pset(n,p);
 }

P *pdupown(p,o)
P *p;
P **o;
 {
 P *n=palloc();
 n->end=0;
 n->ptr=0;
 n->owner=o;
 enquef(P,link,p,n);
 pset(n,p);
 if(*o) prm(*o);
 *o=n;
 return n;
 }

void prm(p)
P *p;
 {
 if(!p) return;
 if(p->owner) *p->owner=0;
 if(p->ptr) vunlock(p->ptr);
 pfree(deque(P,link,p));
 }

P *pset(n,p)
P *n, *p;
 {
 if(n!=p)
  {
  n->b=p->b;
  n->ofst=p->ofst;
  n->hdr=p->hdr;
  if(n->ptr) vunlock(n->ptr);
  if(p->ptr) { n->ptr=p->ptr; vupcount(n->ptr); }
  else n->ptr=vlock(vmem,n->hdr->seg);
  n->byte=p->byte;
  n->line=p->line;
  n->col=p->col;
  n->valcol=p->valcol;
  }
 return n;
 }

P *pbof(p)
P *p;
 {
 return pset(p,p->b->bof);
 }

P *peof(p)
P *p;
 {
 return pset(p,p->b->eof);
 }

int pisbof(p)
P *p;
 {
 return p->hdr==p->b->bof->hdr && !p->ofst;
 }

int piseof(p)
P *p;
 {
 return p->ofst==GSIZE(p->hdr);
 }

int piseol(p)
P *p;
 {
 int c;
 if(piseof(p)) return 1;
 c=brc(p);
 if(c=='\n') return 1;
 if(p->b->o.crlf)
  if(c=='\r')
   {
   P *q=pdup(p);
   pfwrd(q,1L);
   if(pgetc(q)=='\n')
d301 180
a480 1
    prm(q);
d482 30
d513 50
a562 45
   else prm(q);
   }
 return 0;
 }

int pisbol(p)
P *p;
 {
 char c;
 if(pisbof(p)) return 1;
 c=prgetc(p); pgetc(p);
 return c=='\n';
 }

int pisbow(p)
P *p;
 {
 P *q=pdup(p);
 int c=brc(p);
 int d=prgetc(q);
 prm(q);
 if(crest(c) && !crest(d)) return 1;
 else return 0;
 }

int piseow(p)
P *p;
 {
 P *q=pdup(p);
 int d=brc(q);
 int c=prgetc(q);
 prm(q);
 if(crest(c) && !crest(d)) return 1;
 else return 0;
 }

int pisblank(p)
P *p;
 {
 P *q=pdup(p);
 pbol(q);
 while(isblank(brc(q))) pgetc(q);
 if(piseol(q))
  {
  prm(q);
d564 34
a597 7
  }
 else
  {
  prm(q);
  return 0;
  }
 }
d599 40
a638 272
long pisindent(p)
P *p;
 {
 P *q=pdup(p);
 long col;
 pbol(q);
 while(isblank(brc(q))) pgetc(q);
 col=q->col;
 prm(q);
 return col;
 }

int pnext(p)
P *p;
 {
 if(p->hdr==p->b->eof->hdr)
  {
  p->ofst=GSIZE(p->hdr);
  return 0;
  }
 p->hdr=p->hdr->link.next; p->ofst=0;
 vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg);
 return 1;
 }

int pprev(p)
P *p;
 {
 if(p->hdr==p->b->bof->hdr)
  {
  p->ofst=0;
  return 0;
  }
 p->hdr=p->hdr->link.prev;
 p->ofst=GSIZE(p->hdr);
 vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg);
 return 1;
 }

int pgetc(p)
P *p;
 {
 char c;
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
 ++p->byte;
 if(c=='\n') ++p->line, p->col=0, p->valcol=1;
 else if(p->b->o.crlf && c=='\r')
  {
  if(brc(p)=='\n') return pgetc(p);
  else ++p->col;
  }
 else
  {
  if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
  else ++p->col;
  }
 return c;
 }

P *pfwrd(p,n)
P *p;
long n;
 {
 if(!n) return p;
 p->valcol=0;
 do
  {
  if(p->ofst==GSIZE(p->hdr))
   do
    {
    if(!p->ofst)
     p->byte+=GSIZE(p->hdr), n-=GSIZE(p->hdr), p->line+=p->hdr->nlines;
    if(!pnext(p)) return 0;
    }
    while(n>GSIZE(p->hdr));
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') ++p->line; }
  else if(p->ptr[p->ofst]=='\n') ++p->line;
  ++p->byte; ++p->ofst;
  }
  while(--n);
 if(p->ofst==GSIZE(p->hdr)) pnext(p);
 return p;
 }

int prgetc1(p)
P *p;
 {
 unsigned char c;
 if(!p->ofst) if(!pprev(p)) return MAXINT;
 --p->ofst;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 --p->byte;
 if(c=='\n') --p->line, p->valcol=0;
 else
  {
  if(c=='\t') p->valcol=0;
  --p->col;
  }
 return c;
 }

int prgetc(p)
P *p;
 {
 int c=prgetc1(p);
 if(p->b->o.crlf && c=='\n')
  {
  c=prgetc1(p);
  if(c=='\r') return '\n';
  if(c!=MAXINT) pgetc(p);
  c='\n';
  }
 return c;
 }

P *pbkwd(p,n)
P *p;
long n;
 {
 if(!n) return p;
 p->valcol=0;
 do
  {
  if(!p->ofst)
   do
    {
    if(p->ofst)
     p->byte-=p->ofst, n-=p->ofst, p->line-=p->hdr->nlines;
    if(!pprev(p)) return 0;
    }
    while(n>GSIZE(p->hdr));
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') --p->line; }
  else if(p->ptr[p->ofst]=='\n') --p->line;
  }
  while(--n);
 return p;
 }

P *pgoto(p,loc)
P *p;
long loc;
 {
 if(loc>p->byte) pfwrd(p,loc-p->byte);
 else if(loc<p->byte) pbkwd(p,p->byte-loc);
 return p;
 }

P *pfcol(p)
P *p;
 {
 H *hdr=p->hdr;
 int ofst=p->ofst;
 pbol(p);
 while(p->ofst!=ofst || p->hdr!=hdr) pgetc(p);
 return p;
 }

P *pbol(p)
P *p;
 {
 if(pprevl(p)) pgetc(p);
 p->col=0; p->valcol=1;
 return p;
 }

P *peol(p)
P *p;
 {
 if(p->b->o.crlf)
  while(!piseol(p)) pgetc(p);
 else
  while(p->ofst!=GSIZE(p->hdr))
   {
   unsigned char c;
   if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
   else c=p->ptr[p->ofst];
   if(c=='\n') break;
   else
    {
    ++p->byte;
    ++p->ofst;
    if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
    else ++p->col;
    if(p->ofst==GSIZE(p->hdr)) pnext(p); 
    }
   }
 return p;
 }

P *pnextl(p)
P *p;
 {
 char c;
 do
  {
  if(p->ofst==GSIZE(p->hdr))
   do
    {
    p->byte+=GSIZE(p->hdr)-p->ofst;
    if(!pnext(p)) return 0;
    }
    while(!p->hdr->nlines);
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  ++p->byte; ++p->ofst;
  }
  while(c!='\n');
 ++p->line;
 p->col=0; p->valcol=1;
 if(p->ofst==GSIZE(p->hdr)) pnext(p);
 return p;
 }

P *pprevl(p)
P *p;
 {
 char c;
 p->valcol=0;
 do
  {
  if(!p->ofst)
   do
    {
    p->byte-=p->ofst;
    if(!pprev(p)) return 0;
    }
    while(!p->hdr->nlines);
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  }
  while(c!='\n');
 --p->line;
 if(p->b->o.crlf && c=='\n')
  {
  int k=prgetc1(p);
  if(k!='\r' && k!=MAXINT) pgetc(p);
  }
 return p;
 }

P *pline(p,line)
P *p;
long line;
 {
 if(line>p->b->eof->line) { pset(p,p->b->eof); return p; }
 if(line<labs(p->line-line)) pset(p,p->b->bof);
 if(labs(p->b->eof->line-line)<labs(p->line-line)) pset(p,p->b->eof);
 if(p->line==line) { pbol(p); return p; }
 while(line>p->line) pnextl(p);
 if(line<p->line)
  {
  while(line<p->line) pprevl(p);
  pbol(p);
  }
 return p;
 }

P *pcol(p,goalcol)
P *p;
long goalcol;
 {
 pbol(p);
 do
  {
d640 299
a938 38
  int wid;
  if(p->ofst==GSIZE(p->hdr)) break;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  if(c=='\n') break;
  if(p->b->o.crlf && c=='\r' && piseol(p)) break;
  if(c=='\t') wid=p->b->o.tab-p->col%p->b->o.tab;
  else wid=1;
  if(p->col+wid>goalcol) break;
  if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
  ++p->byte; p->col+=wid;
  } while(p->col!=goalcol);
 return p;
 }

P *pcolwse(p,goalcol)
P *p;
long goalcol;
 {
 int c;
 pcol(p,goalcol);
 do c=prgetc(p); while(c==' ' || c=='\t');
 if(c!=MAXINT) pgetc(p);
 return p;
 }

P *pcoli(p,goalcol)
P *p;
long goalcol;
 {
 pbol(p);
 while(p->col<goalcol)
  {
  unsigned char c;
  if(p->ofst==GSIZE(p->hdr)) break;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  if(c=='\n') break;
d940 2
a941 1
  if(c=='\r' && piseol(p)) break;
d943 458
a1400 315
  else if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
  else ++p->col;
  if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
  ++p->byte;
  }
 return p;
 }

void pfill(p,to,usetabs)
P *p;
long to;
 {
 piscol(p);
 if(usetabs)
  while(p->col<to)
   if(p->col+p->b->o.tab-p->col%p->b->o.tab<=to) binsc(p,'\t'), pgetc(p);
   else binsc(p,' '), pgetc(p);
 else while(p->col<to) binsc(p,' '), pgetc(p);
 }

void pbackws(p)
P *p;
 {
 int c;
 P *q=pdup(p);
 do c=prgetc(q); while(c==' ' || c=='\t');
 if(c!=MAXINT) pgetc(q);
 bdel(q,p);
 prm(q);
 }

static char frgetc(p)
P *p;
 {
 if(!p->ofst) pprev(p);
 --p->ofst;
 if(p->ofst>=p->hdr->hole) return p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else return p->ptr[p->ofst];
 }

static void ffwrd(p,n)
P *p;
 {
 while(n>GSIZE(p->hdr)-p->ofst)
  {
  n-=GSIZE(p->hdr)-p->ofst;
  if(!pnext(p)) return;
  }
 if((p->ofst+=n)==GSIZE(p->hdr)) pnext(p);
 }

static P *ffind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->b->eof->byte-p->byte;
 int x;
 unsigned char table[256], c;
 if(len>amnt) return 0;
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=0;x!=len-1;++x) table[s[x]]=x;
 ffwrd(p,len); amnt-=len; x=len; do
  if((c=frgetc(p))!=s[--x])
   {
   if(table[c]==255) ffwrd(p,len+1), amnt-=x+1;
   else if(x<=table[c]) ffwrd(p,len-x+1), --amnt;
   else ffwrd(p,len-table[c]), amnt-=x-table[c];
   if(amnt<0) return 0;
   else x=len;
   }
  while(x);
 return p;
 }

static P *fifind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->b->eof->byte-p->byte;
 int x;
 unsigned char table[256], c;
 if(len>amnt) return 0;
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=0;x!=len-1;++x) table[s[x]]=x;
 ffwrd(p,len); amnt-=len; x=len; do
  if((c=toupper(frgetc(p)))!=s[--x])
   {
   if(table[c]==255) ffwrd(p,len+1), amnt-=x+1;
   else if(x<=table[c]) ffwrd(p,len-x+1), --amnt;
   else ffwrd(p,len-table[c]), amnt-=x-table[c];
   if(amnt<0) return 0;
   else x=len;
   }
  while(x);
 return p;
 }

static P *getto(p,q)
P *p, *q;
 {
 while(p->hdr!=q->hdr || p->ofst!=q->ofst)
  {
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') ++p->line; }
  else if(p->ptr[p->ofst]=='\n') ++p->line;
  ++p->byte; ++p->ofst;
  if(p->ofst==GSIZE(p->hdr)) pnext(p);
  while(!p->ofst && p->hdr!=q->hdr)
   {
   p->byte+=GSIZE(p->hdr), p->line+=p->hdr->nlines;
   pnext(p);
   }
  }
 return p;
 }

P *pfind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(ffind(q,s,len)) { getto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

P *pifind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(fifind(q,s,len)) { getto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

static void fbkwd(p,n)
P *p;
 {
 while(n>p->ofst)
  {
  n-=p->ofst;
  if(!pprev(p)) return;
  }
 if(p->ofst>=n) p->ofst-=n;
 else p->ofst=0;
 }

static int fpgetc(p)
P *p;
 {
 char c;
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 if(++p->ofst==GSIZE(p->hdr)) pnext(p);
 return c;
 }

static P *frfind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->byte;
 int x;
 unsigned char table[256], c;
 if(len>p->b->eof->byte-p->byte)
  {
  x=len-(p->b->eof->byte-p->byte);
  if(amnt<x) return 0;
  amnt-=x;
  fbkwd(p,x);
  }
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=len;--x;table[s[x]]=len-x-1);
 x=0; do
  if((c=fpgetc(p))!=s[x++])
   {
   if(table[c]==255) fbkwd(p,len+1), amnt-=len-x+1;
   else if(len-table[c]<=x) fbkwd(p,x+1), --amnt;
   else fbkwd(p,len-table[c]), amnt-=len-table[c]-x;
   if(amnt<0) return 0;
   else x=0;
   }
  while(x!=len);
 fbkwd(p,len);
 return p;
 }

static P *frifind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->byte;
 int x;
 unsigned char table[256], c;
 if(len>p->b->eof->byte-p->byte)
  {
  x=len-(p->b->eof->byte-p->byte);
  if(amnt<x) return 0;
  amnt-=x;
  fbkwd(p,x);
  }
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=len;--x;table[s[x]]=len-x-1);
 x=0; do
  if((c=toupper(fpgetc(p)))!=s[x++])
   {
   if(table[c]==255) fbkwd(p,len+1), amnt-=len-x+1;
   else if(len-table[c]<=x) fbkwd(p,x+1), --amnt;
   else fbkwd(p,len-table[c]), amnt-=len-table[c]-x;
   if(amnt<0) return 0;
   else x=0;
   }
  while(x!=len);
 fbkwd(p,len);
 return p;
 }

static P *rgetto(p,q)
P *p, *q;
 {
 while(p->hdr!=q->hdr || p->ofst!=q->ofst)
  {
  if(!p->ofst)
   do
    {
    if(p->ofst)
     p->byte-=p->ofst, p->line-=p->hdr->nlines;
    pprev(p);
    }
    while(p->hdr!=q->hdr);
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') --p->line; }
  else if(p->ptr[p->ofst]=='\n') --p->line;
  }
 return p;
 }

P *prfind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(frfind(q,s,len)) { rgetto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

P *prifind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(frifind(q,s,len)) { rgetto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

B *bcpy(from,to)
P *from, *to;
 {
 H anchor, *l;
 char *ptr;
 P *q;

 if(from->byte>=to->byte) return bmk(from->b);

 q=pdup(from);
 izque(H,link,&anchor);

 if(q->hdr==to->hdr)
  {
  l=halloc(); ptr=vlock(vmem,l->seg);
  if(q->ofst!=q->hdr->hole) gstgap(q->hdr,q->ptr,q->ofst);
  l->nlines=mcnt(q->ptr+q->hdr->ehole,'\n',l->hole=to->ofst-q->ofst);
  mcpy(ptr,q->ptr+q->hdr->ehole,l->hole);
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  }
 else
  {
  l=halloc(); ptr=vlock(vmem,l->seg);
  if(q->ofst!=q->hdr->hole) gstgap(q->hdr,q->ptr,q->ofst);
  l->nlines=mcnt(q->ptr+q->hdr->ehole,'\n',l->hole=SEGSIZ-q->hdr->ehole);
  mcpy(ptr,q->ptr+q->hdr->ehole,l->hole);
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  pnext(q);
  while(q->hdr!=to->hdr)
   {
   l=halloc(); ptr=vlock(vmem,l->seg);
   l->nlines=q->hdr->nlines;
   mcpy(ptr,q->ptr,q->hdr->hole);
   mcpy(ptr+q->hdr->hole,q->ptr+q->hdr->ehole,SEGSIZ-q->hdr->ehole);
   l->hole=GSIZE(q->hdr);
   vchanged(ptr); vunlock(ptr);
   enqueb(H,link,&anchor,l);
   pnext(q);
   }
  if(to->ofst)
   {
   l=halloc(); ptr=vlock(vmem,l->seg);
   if(to->ofst!=to->hdr->hole) gstgap(to->hdr,to->ptr,to->ofst);
   l->nlines=mcnt(to->ptr,'\n',to->ofst);
   mcpy(ptr,to->ptr,l->hole=to->ofst);
   vchanged(ptr); vunlock(ptr);
   enqueb(H,link,&anchor,l);
   }
  }

 l=anchor.link.next;
 deque(H,link,&anchor);
 prm(q);
d1402 2
a1403 2
 return bmkchn(l,from->b,to->byte-from->byte,to->line-from->line);
 }
d1407 54
a1460 46
void pcoalesce(p)
P *p;
 {
 if(p->hdr!=p->b->eof->hdr &&
    GSIZE(p->hdr)+GSIZE(p->hdr->link.next)<=SEGSIZ-SEGSIZ/4)
  {
  H *hdr=p->hdr->link.next;
  char *ptr=vlock(vmem,hdr->seg);
  int osize=GSIZE(p->hdr);
  int size=GSIZE(hdr);
  P *q;
  gstgap(hdr,ptr,size);
  ginsm(p->hdr,p->ptr,GSIZE(p->hdr),ptr,size);
  p->hdr->nlines+=hdr->nlines;
  vunlock(ptr);
  hfree(deque(H,link,hdr));
  for(q=p->link.next;q!=p;q=q->link.next)
   if(q->hdr==hdr)
    {
    q->hdr=p->hdr;
    if(q->ptr) { vunlock(q->ptr); q->ptr=vlock(vmem,q->hdr->seg); }
    q->ofst+=osize;
    }
  }
 if(p->hdr!=p->b->bof->hdr &&
    GSIZE(p->hdr)+GSIZE(p->hdr->link.prev)<=SEGSIZ-SEGSIZ/4)
  {
  H *hdr=p->hdr->link.prev;
  char *ptr=vlock(vmem,hdr->seg);
  int size=GSIZE(hdr);
  P *q;
  gstgap(hdr,ptr,size);
  ginsm(p->hdr,p->ptr,0,ptr,size);
  p->hdr->nlines+=hdr->nlines;
  vunlock(ptr);
  hfree(deque(H,link,hdr));
  p->ofst+=size;
  for(q=p->link.next;q!=p;q=q->link.next)
   if(q->hdr==hdr)
    {
    q->hdr=p->hdr;
    if(q->ptr) vunlock(q->ptr); q->ptr=vlock(vmem,q->hdr->seg);
    }
   else if(q->hdr==p->hdr) q->ofst+=size;
  }
 }
d1482 5
a1486 4
static B *bcut(from,to)
P *from, *to;
 {
 H *h,				/* The deleted text */
d1488 116
a1603 105
 char *ptr;
 P *p;
 long nlines;			/* No. EOLs to delete */
 long amnt;			/* No. bytes to delete */
 int toamnt;			/* Amount to delete from segment in 'to' */
 int bofmove=0;		/* Set if bof got deleted */
 
 if(!(amnt=to->byte-from->byte))
  return 0;			/* ...nothing to delete */
 
 nlines=to->line-from->line;
 
 if(from->hdr==to->hdr)
  { /* Delete is within a single segment */
  /* Move gap to deletion point */
  if(from->ofst!=from->hdr->hole)
   gstgap(from->hdr,from->ptr,from->ofst);
 
  /* Store the deleted text */
  h=halloc();
  ptr=vlock(vmem,h->seg);
  mcpy(ptr,from->ptr+from->hdr->ehole,(int)amnt);
  h->hole=amnt;
  h->nlines=nlines;
  vchanged(ptr); vunlock(ptr);
 
  /* Delete */
  from->hdr->ehole+=amnt;
  from->hdr->nlines-=nlines;
 
  toamnt=amnt;
  }
 else
  { /* Delete crosses segments */
  H *a;
  if(toamnt=to->ofst)
   {
   /* Delete beginning of to */
   /* Move gap to deletion point */
   /* To could be deleted if it's at the end of the file */
   if(to->ofst!=to->hdr->hole)
    gstgap(to->hdr,to->ptr,to->ofst);
  
   /* Save deleted text */
   i=halloc();
   ptr=vlock(vmem,i->seg);
   mcpy(ptr,to->ptr,to->hdr->hole);
   i->hole=to->hdr->hole;
   i->nlines=mcnt(to->ptr,'\n',to->hdr->hole);
   vchanged(ptr); vunlock(ptr);
 
   /* Delete */
   to->hdr->nlines-=i->nlines;
   to->hdr->hole=0;
   }
  else i=0;
 
  /* Delete end of from */
  if(!from->ofst)
   {
   /* ..unless from needs to be deleted too */
   a=from->hdr->link.prev, h=0;
   if(a==from->b->eof->hdr) bofmove=1;
   }
  else
   {
   a=from->hdr;
   /* Move gap to deletion point */
   if(from->ofst!=from->hdr->hole)
    gstgap(from->hdr,from->ptr,from->ofst);
 
   /* Save deleted text */
   h=halloc();
   ptr=vlock(vmem,h->seg);
   mcpy(ptr,from->ptr+from->hdr->ehole,SEGSIZ-from->hdr->ehole);
   h->hole=SEGSIZ-from->hdr->ehole;
   h->nlines=mcnt(ptr,'\n',h->hole);
   vchanged(ptr); vunlock(ptr);
 
   /* Delete */
   from->hdr->nlines-=h->nlines;
   from->hdr->ehole=SEGSIZ;
   }
 
  /* Make from point to header/segment of to */
  from->hdr=to->hdr;
  vunlock(from->ptr); from->ptr=to->ptr; vupcount(to->ptr);
  from->ofst=0;
 
  /* Delete headers/segments between a and to->hdr (if there are any) */
  if(a->link.next!=to->hdr)
   if(!h)
    {
    h=snip(H,link,a->link.next,to->hdr->link.prev);
    if(i) enqueb(H,link,h,i);
    }
   else
    {
    splicef(H,link,h,snip(H,link,a->link.next,to->hdr->link.prev));
    if(i) enqueb(H,link,h,i);
    }
  else
   if(!h) h=i;
   else if(i) enqueb(H,link,h,i);
  }
d1607 69
a1675 64
  if(!GSIZE(to->hdr) && from->byte)
   {
   H *ph=from->hdr->link.prev;
   hfree(deque(H,link,from->hdr)); vunlock(from->ptr);
   from->hdr=ph;
   from->ptr=vlock(vmem,from->hdr->seg);
   from->ofst=GSIZE(ph);
   vunlock(from->b->eof->ptr);
   from->b->eof->ptr=from->ptr;
   vupcount(from->ptr);
   from->b->eof->hdr=from->hdr;
   from->b->eof->ofst=from->ofst;
   }
 
 /* The deletion is now done */
 
 /* Scroll if necessary */
 
 if(bofmove) pset(from->b->bof,from);
 if(nlines && !pisbol(from))
  {
  scrdel(from->b,from->line,nlines,1);
  delerr(from->b->name,from->line,nlines,0);
  }
 else
  {
  scrdel(from->b,from->line,nlines,0);
  delerr(from->b->name,from->line,nlines,1);
  }
 
 /* Fix pointers */

 for(p=from->link.next;p!=from;p=p->link.next)
  if(p->line==from->line && p->byte>from->byte) p->valcol=0; 
 for(p=from->link.next;p!=from;p=p->link.next)
  if(p->byte>=from->byte)
   if(p->byte<=from->byte+amnt)
    if(p->ptr) pset(p,from);
    else poffline(pset(p,from));
   else
    {
    if(p->hdr==to->hdr) p->ofst-=toamnt;
    p->byte-=amnt;
    p->line-=nlines;
    }

 pcoalesce(from);

 /* Make buffer out of deleted text and return it */
 
 return bmkchn(h,from->b,amnt,nlines);
 }

void bdel(from,to)
P *from, *to;
 {
 if(to->byte-from->byte)
  {
  B *b=bcut(from,to);
  if(from->b->undo) undodel(from->b->undo,from->byte,b);
  else brm(b);
  from->b->changed=1;
  }
 }
d1682 44
a1725 37
static void bsplit(p)
P *p;
 {
 if(p->ofst)
  {
  H *hdr;
  char *ptr;
  P *pp;

  hdr=halloc();
  ptr=vlock(vmem,hdr->seg);

  if(p->ofst!=p->hdr->hole) gstgap(p->hdr,p->ptr,p->ofst);
  mcpy(ptr,p->ptr+p->hdr->ehole,SEGSIZ-p->hdr->ehole);
  hdr->hole=SEGSIZ-p->hdr->ehole;
  hdr->nlines=mcnt(ptr,'\n',hdr->hole);
  p->hdr->nlines-=hdr->nlines;
  vchanged(ptr);
  p->hdr->ehole=SEGSIZ;

  enquef(H,link,p->hdr,hdr);

  vunlock(p->ptr);

  for(pp=p->link.next;pp!=p;pp=pp->link.next)
   if(pp->hdr==p->hdr && pp->ofst>=p->ofst)
    {
    pp->hdr=hdr;
    if(pp->ptr) { vunlock(pp->ptr); pp->ptr=ptr; vupcount(ptr); }
    pp->ofst-=p->ofst;
    }

  p->ptr=ptr;
  p->hdr=hdr;
  p->ofst=0;
  }
 }
d1730 33
a1762 26
static H *bldchn(blk,size,nlines)
char *blk;
int size;
long *nlines;
 {
 H anchor, *l;
 *nlines=0;
 izque(H,link,&anchor);
 do
  {
  char *ptr;
  int amnt;
  ptr=vlock(vmem,(l=halloc())->seg);
  if(size>SEGSIZ) amnt=SEGSIZ;
  else amnt=size;
  mcpy(ptr,blk,amnt);
  l->hole=amnt; l->ehole=SEGSIZ; (*nlines)+=(l->nlines=mcnt(ptr,'\n',amnt));
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  blk+=amnt; size-=amnt;
  }
  while(size);
 l=anchor.link.next;
 deque(H,link,&anchor);
 return l;
 }
d1767 82
a1848 65
static void inschn(p,a)
P *p;
H *a;
 {
 if(!p->b->eof->byte)
  { /* P's buffer is empty: replace the empty segment in p with a */
  hfree(p->hdr); p->hdr=a;
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  pset(p->b->bof,p);

  p->b->eof->hdr=a->link.prev;
  vunlock(p->b->eof->ptr); p->b->eof->ptr=vlock(vmem,p->b->eof->hdr->seg);
  p->b->eof->ofst=GSIZE(p->b->eof->hdr);
  }
 else if(piseof(p))
  { /* We're at the end of the file: append a to the file */
  p->b->eof->hdr=a->link.prev;
  spliceb(H,link,p->b->bof->hdr,a);
  vunlock(p->b->eof->ptr); p->b->eof->ptr=vlock(vmem,p->b->eof->hdr->seg);
  p->b->eof->ofst=GSIZE(p->b->eof->hdr);
  p->hdr=a;
  vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg); p->ofst=0;
  }
 else if(pisbof(p))
  { /* We're at the beginning of the file: insert chain and set bof pointer */
  p->hdr=spliceb(H,link,p->hdr,a);
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  pset(p->b->bof,p);
  }
 else
  { /* We're in the middle of the file: split and insert */
  bsplit(p);
  p->hdr=spliceb(H,link,p->hdr,a);
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  }
 }

static void fixupins(p,amnt,nlines,hdr,hdramnt)
P *p;
long amnt;
long nlines;
H *hdr;
int hdramnt;
 {
 P *pp;
 if(nlines && !pisbol(p)) scrins(p->b,p->line,nlines,1);
 else scrins(p->b,p->line,nlines,0);
 inserr(p->b->name,p->line,nlines);

 for(pp=p->link.next;pp!=p;pp=pp->link.next)
  if(pp->line==p->line &&
     (pp->byte>p->byte || pp->end && pp->byte==p->byte)) pp->valcol=0;
 for(pp=p->link.next;pp!=p;pp=pp->link.next)
  if(pp->byte==p->byte && !pp->end)
   if(pp->ptr) pset(pp,p);
   else poffline(pset(pp,p));
  else if(pp->byte>p->byte || pp->end && pp->byte==p->byte)
   {
   pp->byte+=amnt;
   pp->line+=nlines;
   if(pp->hdr==hdr) pp->ofst+=hdramnt;
   }
 if(p->b->undo) undoins(p->b->undo,p,amnt);
 p->b->changed=1;
 }
d1853 74
a1926 66
P *binsb(p,b)
P *p;
B *b;
 {
 if(b->eof->byte)
  {
  P *q=pdup(p);
  inschn(q,b->bof->hdr);
  b->eof->hdr=halloc();
  fixupins(q,b->eof->byte,b->eof->line,NULL,0);
  pcoalesce(q);
  prm(q);
  }
 brm(b);
 return p;
 }

P *binsm(p,blk,amnt)
P *p;
char *blk;
int amnt;
 {
 long nlines;
 H *h=0;
 int hdramnt;
 P *q;
 if(!amnt) return p;
 q=pdup(p);
 if(amnt<=GGAPSZ(q->hdr))
  {
  h=q->hdr;
  hdramnt=amnt;
  ginsm(q->hdr,q->ptr,q->ofst,blk,amnt);
  q->hdr->nlines+=(nlines=mcnt(blk,'\n',amnt));
  }
 else if(!q->ofst && q->hdr!=q->b->bof->hdr && amnt<=GGAPSZ(q->hdr->link.prev))
  {
  pprev(q); 
  ginsm(q->hdr,q->ptr,q->ofst,blk,amnt);
  q->hdr->nlines+=(nlines=mcnt(blk,'\n',amnt));
  }
 else
  {
  H *a=bldchn(blk,amnt,&nlines);
  inschn(q,a);
  }
 fixupins(q,(long)amnt,nlines,h,hdramnt);
 pcoalesce(q);
 prm(q);
 return p;
 }

P *binsc(p,c)
P *p;
char c;
 {
 if(p->b->o.crlf && c=='\n') return binsm(p,"\r\n",2);
 else return binsm(p,&c,1);
 }

P *binss(p,s)
P *p;
char *s;
 {
 return binsm(p,s,strlen(s));
 }
d1933 18
a1950 10
static int bkread(fi,buff,size)
char *buff;
 {
 int a,b;
 if(!size) { error=0; return 0; }
 for(a=b=0;(a<size) && ((b=jread(fi,buff+a,size-a))>0);a+=b);
 if(b<0) error= -2;
 else error=0;
 return a;
 }
d1955 30
a1984 25
B *bread(fi,max)
long max;
 {
 H anchor, *l;
 long lines=0, total=0;
 int amnt;
 char *seg;
 izque(H,link,&anchor);
 error=0;
 while(seg=vlock(vmem,(l=halloc())->seg),
       !error && (amnt=bkread(fi,seg,max>=SEGSIZ?SEGSIZ:(int)max)))
  {
  total+=amnt;
  max-=amnt;
  l->hole=amnt;
  lines+=(l->nlines=mcnt(seg,'\n',amnt));
  vchanged(seg); vunlock(seg);
  enqueb(H,link,&anchor,l);
  }
 hfree(l); vunlock(seg);
 if(!total) return bmk(NULL);
 l=anchor.link.next;
 deque(H,link,&anchor);
 return bmkchn(l,NULL,total,lines);
 }
d1995 40
a2034 27
char *parsens(s,skip,amnt)
char *s;
long *skip, *amnt;
 {
 char *n=vsncpy(NULL,0,sz(s));
 int x;
 *skip=0;
 *amnt= MAXLONG;
 for(x=sLEN(n)-1;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
 if(n[x]==',')
  {
  n[x]=0;
  if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
  else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
  else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
  else sscanf(n+x+1,"%ld",skip);
  for(--x;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
  if(n[x]==',')
   {
   n[x]=0;
   *amnt= *skip;
   if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
   else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
   else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
   else sscanf(n+x+1,"%ld",skip);
   }
  }
d2036 27
a2062 26
 if(n[0]=='~')
  {
  for(x=1;n[x] && n[x]!='/';++x);
  if(n[x]=='/')
   if(x==1)
    {
    char *z;
    s=getenv("HOME");
    z=vsncpy(NULL,0,sz(s));
    z=vsncpy(z,sLEN(z),sz(n+x));
    vsrm(n);
    n=z;
    }
   else
    {
    struct passwd *passwd;
    n[x]=0;
    passwd=getpwnam(n+1);
    n[x]='/';
    if(passwd)
     {
     char *z=vsncpy(NULL,0,sz(passwd->pw_dir));
     z=vsncpy(z,sLEN(z),sz(n+x));
     vsrm(n);
     n=z;
     }
a2063 1
  }
d2065 2
a2066 2
 return n;
 }
d2076 20
a2095 19
B *bload(s)
char *s;
 {
 char buffer[SEGSIZ];
 FILE *fi;
 B *b;
 long skip,amnt;
 char *n;
 int nowrite=0;

 if(!s || !s[0])
  {
  error= -1; 
  b=bmk(NULL);
  setopt(&b->o,"");
  b->rdonly=b->o.readonly;
  b->er=error;
  return b;
  }
d2097 1
a2097 1
 n=parsens(s,&skip,&amnt);
d2099 2
a2100 2
 /* Open file or stream */
 ossep(n);
d2102 7
a2108 7
 if(n[0]=='!')
  {
  nescape(maint->t);
  ttclsn();
  fi=popen(n+1,"r");
  }
 else
d2110 49
a2158 40
 if(!strcmp(n,"-")) fi=stdin;
 else
  {
  fi=fopen(n,"r+");
  if(!fi) nowrite=1;
  else fclose(fi);
  fi=fopen(n,"r");
  if(!fi) nowrite=0;
  }
 joesep(n);

 /* Abort if couldn't open */
 if(!fi)
  {
  if(errno==ENOENT) error= -1;
  else error= -4;
  b=bmk(NULL);
  setopt(&b->o,n);
  b->rdonly=b->o.readonly;
  goto opnerr;
  }

 /* Skip data if we need to */
 if(skip && lseek(fileno(fi),skip,0)<0)
  {
  int r;
  while(skip>SEGSIZ)
   {
   r=bkread(fileno(fi),buffer,SEGSIZ);
   if(r!=SEGSIZ || error) { error= -3; goto err; }
   skip-=SEGSIZ;
   }
  skip-=bkread(fileno(fi),buffer,(int)skip);
  if(skip || error) { error= -3; goto err; }
  }

 /* Read from stream into new buffer */
 b=bread(fileno(fi),amnt);
 setopt(&b->o,n);
 b->rdonly=b->o.readonly;
d2160 7
a2166 2
 /* Close stream */
 err:;
d2168 3
a2170 2
 if(s[0]=='!') pclose(fi);
 else
d2172 2
a2173 1
 if(strcmp(n,"-")) fclose(fi);
d2175 16
a2190 2
 opnerr:;
 if(s[0]=='!') ttopnn(), nreturn(maint->t);
d2192 2
a2193 2
 /* Set name */
 b->name=joesep(strdup(s));
d2195 3
a2197 12
 /* Set flags */
 if(error || s[0]=='!' || skip || amnt!=MAXLONG) b->backup=1, b->changed=0;
 else if(!strcmp(n,"-")) b->backup=1, b->changed=1;
 else b->backup=0, b->changed=0;
 if(nowrite) b->rdonly=b->o.readonly=1;

 /* Eliminate parsed name */
 vsrm(n);

 b->er=error;
 return b;
 }
d2201 28
a2228 12
B *bfind(s)
char *s;
 {
 B *b;
 if(!s || !s[0])
  {
  error= -1; 
  b=bmk(NULL);
  setopt(&b->o,"");
  b->rdonly=b->o.readonly;
  b->internal=0;
  b->er=error;
d2230 12
a2241 23
  }
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->name && !strcmp(s,b->name))
   {
   if(!b->orphan) ++b->count;
   else b->orphan=0;
   error=0;
   b->internal=0;
   return b;
   }
 b=bload(s);
 b->internal=0;
 return b;
 }

char **getbufs()
 {
 char **s=vamk(16);
 B *b;
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->name) s=vaadd(s,vsncpy(NULL,0,sz(b->name)));
 return s;
 }
d2245 12
a2256 11
B *borphan()
 {
 B *b;
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->orphan)
   {
   b->orphan=0;
   return b;
   }
 return 0;
 }
d2264 47
a2310 43
int bsavefd(p,fd,size)
P *p;
long size;
 {
 P *np=pdup(p);
 int amnt;
 while(size>(amnt=GSIZE(np->hdr)-np->ofst))
  {
  if(np->ofst<np->hdr->hole)
   {
   if(jwrite(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0)
    goto err;
   if(jwrite(fd,np->ptr+np->hdr->ehole,SEGSIZ-np->hdr->ehole)<0)
    goto err;
   }
  else
   if(jwrite(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),amnt)<0)
    goto err;
  size-=amnt;
  pnext(np);
  }
 if(size)
  if(np->ofst<np->hdr->hole)
   if(size>np->hdr->hole-np->ofst)
    {
    if(jwrite(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0)
     goto err;
    if(jwrite(fd,np->ptr+np->hdr->ehole,(int)size-np->hdr->hole+np->ofst)<0)
     goto err;
    }
   else
    {
    if(jwrite(fd,np->ptr+np->ofst,(int)size)<0)
     goto err;
    }
  else if(jwrite(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),(int)size)<0)
   goto err;
 prm(np);
 return error=0;
 err:;
 prm(np);
 return error=5;
 }
d2314 8
a2321 7
int bsave(p,s,size)
P *p;
char *s;
long size;
 {
 FILE *f;
 long skip,amnt;
d2323 1
a2323 1
 s=parsens(s,&skip,&amnt);
d2325 2
a2326 1
 if(amnt<size) size=amnt;
d2328 1
a2328 1
 ossep(s);
d2330 7
a2336 7
 if(s[0]=='!')
  {
  nescape(maint->t);
  ttclsn();
  f=popen(s+1,"w");
  }
 else
d2338 26
a2363 31
 if(s[0]=='>' && s[1]=='>') f=fopen(s+2,"a");
 else if(!strcmp(s,"-"))
  {
  nescape(maint->t);
  ttclsn();
  f=stdout;
  }
 else
  if(skip || amnt!=MAXLONG) f=fopen(s,"r+");
  else f=fopen(s,"w");
 joesep(s);

 if(!f)
  {
  error= -4;
  goto opnerr;
  }
 fflush(f);

 if(skip && lseek(fileno(f),skip,0)<0) { error= -3; goto err; }

 bsavefd(p,fileno(f),size);

 if(!error && force && size && !skip && amnt==MAXLONG)
  {
  P *q=pdup(p);
  char nl='\n';
  pfwrd(q,size-1);
  if(brc(q)!='\n' && jwrite(fileno(f),&nl,1)<0) error= -5;
  prm(q);
  }
d2365 13
a2377 1
 err:;
d2379 3
a2381 2
 if(s[0]=='!') pclose(f);
 else
d2383 22
a2404 2
 if(strcmp(s,"-")) fclose(f);
 else fflush(f);
d2406 41
a2446 50
 opnerr:;
 if(s[0]=='!' || !strcmp(s,"-")) ttopnn(), nreturn(maint->t);
 return error;
 }

int brc(p)
P *p;
 {
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) return p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else return p->ptr[p->ofst];
 }

char *brmem(p,blk,size)
P *p;
char *blk;
int size;
 {
 char *bk=blk;
 P *np;
 int amnt;
 np=pdup(p);
 while(size>(amnt=GSIZE(np->hdr)-np->ofst))
  {
  grmem(np->hdr,np->ptr,np->ofst,bk,amnt);
  bk+=amnt;
  size-=amnt;
  pnext(np);
  }
 if(size) grmem(np->hdr,np->ptr,np->ofst,bk,size);
 prm(np);
 return blk;
 }

char *brs(p,size)
P *p;
int size;
 {
 char *s=(char *)malloc(size+1);
 s[size]=0;
 return brmem(p,s,size);
 }

char *brvs(p,size)
P *p;
int size;
 {
 char *s=vstrunc(NULL,size);
 return brmem(p,s,size);
 }
d2450 10
a2459 1
extern char *ctime();
d2461 42
a2502 43
void ttsig(sig)
 {
 long tim=time(0);
 B *b;
 FILE *f;
 int tmpfd;
 struct stat sbuf;

 if((tmpfd = open("DEADJOE", O_RDWR|O_EXCL|O_CREAT, 0600)) < 0) {
    if(lstat("DEADJOE", &sbuf) < 0)
      _exit(-1);
    if(!S_ISREG(sbuf.st_mode) || sbuf.st_uid != geteuid())
      _exit(-1);
    /*
       A race condition still exists between the lstat() and the open()
       systemcall, which leads to a possible denial-of-service attack
       by setting the file access mode to 600 for every file the
       user executing joe has permissions to.
       This can't be fixed w/o breacking the behavior of the orig. joe!
    */
    if((tmpfd = open("DEADJOE", O_RDWR|O_APPEND)) < 0)
      _exit(-1);
    if(fchmod(tmpfd,  S_IRUSR|S_IWUSR) < 0)
      _exit(-1);
 }
 if((f = fdopen(tmpfd, "a")) == NULL)
   _exit(-1);
 
 fprintf(f,"\n*** Modified files in JOE when it aborted on %s",ctime(&tim));
 if(sig) fprintf(f,"*** JOE was aborted by signal %d\n",sig);
 else fprintf(f,"*** JOE was aborted because the terminal closed\n");
 fflush(f);
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->changed)
   {
   if(b->name) fprintf(f,"\n*** File \'%s\'\n",b->name);
   else fprintf(f,"\n*** File \'(Unnamed)\'\n");
   fflush(f);
   bsavefd(b->bof,fileno(f),b->eof->byte);
   }
 if(sig) ttclsn();
 _exit(1);
 }
@


1.2
log
@changes for joe-2.9.1
@
text
@d33 1
d449 1
a449 1
 while(cwhite(brc(q))) pgetc(q);
d468 1
a468 1
 while(cwhite(brc(q))) pgetc(q);
d1551 1
a1551 1
 return binsm(p,s,zlen(s));
d1709 1
a1709 1
 if(!zcmp(n,"-")) fi=stdin;
d1756 1
a1756 1
 if(zcmp(n,"-")) fclose(fi);
d1762 1
a1762 1
 b->name=joesep(zdup(s));
d1766 1
a1766 1
 else if(!zcmp(n,"-")) b->backup=1, b->changed=1;
d1794 1
a1794 1
  if(b->name && !zcmp(s,b->name))
d1905 1
a1905 1
 else if(!zcmp(s,"-"))
d1941 1
a1941 1
 if(zcmp(s,"-")) fclose(f);
d1945 1
a1945 1
 if(s[0]=='!' || !zcmp(s,"-")) ttopnn(), nreturn(maint->t);
@


1.1
log
@Initial revision
@
text
@d18 4
d24 3
d31 2
d133 1
a133 1
  h->seg=valloc(vmem,(long)SEGSIZ);
d714 2
a715 2
 if(line<Labs(p->line-line)) pset(p,p->b->bof);
 if(Labs(p->b->eof->line-line)<Labs(p->line-line)) pset(p,p->b->eof);
d862 1
a862 1
  if((c=toup(frgetc(p)))!=s[--x])
d983 1
a983 1
  if((c=toup(fpgetc(p)))!=s[x++])
d2002 24
a2025 1
 FILE *f=fopen("DEADJOE","a");
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
