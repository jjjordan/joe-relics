head	1.112;
access;
symbols
	joe_3_5:1.99
	joe-3_4:1.97
	help:1.97
	joe_3_1:1.58
	joe_3_0:1.46
	joe_2_9_8:1.22
	joe_2_9_8_pre1:1.19
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.7
	joe_2_9_7_pre2:1.6
	joe_2_9_6:1.5
	joe_2_9_5:1.4
	joe_2_9_4:1.3
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.112
date	2008.11.23.21.25.29;	author jhallen;	state Exp;
branches;
next	1.111;

1.111
date	2008.11.23.20.51.02;	author jhallen;	state Exp;
branches;
next	1.110;

1.110
date	2008.10.26.18.05.46;	author jhallen;	state Exp;
branches;
next	1.109;

1.109
date	2008.10.25.01.44.44;	author jhallen;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.23.18.47.37;	author jhallen;	state Exp;
branches;
next	1.107;

1.107
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.105;

1.105
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.104;

1.104
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.103;

1.103
date	2007.01.21.04.57.23;	author jhallen;	state Exp;
branches;
next	1.102;

1.102
date	2006.07.26.22.05.29;	author jhallen;	state Exp;
branches;
next	1.101;

1.101
date	2006.07.26.03.59.18;	author jhallen;	state Exp;
branches;
next	1.100;

1.100
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.99;

1.99
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.98;

1.98
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.02.15.41.50;	author jhallen;	state Exp;
branches;
next	1.93;

1.93
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.92;

1.92
date	2006.03.05.04.56.18;	author jhallen;	state Exp;
branches;
next	1.91;

1.91
date	2006.03.01.15.23.23;	author jhallen;	state Exp;
branches;
next	1.90;

1.90
date	2006.02.23.18.48.26;	author jhallen;	state Exp;
branches;
next	1.89;

1.89
date	2006.02.23.18.24.12;	author jhallen;	state Exp;
branches;
next	1.88;

1.88
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.87;

1.87
date	2005.04.17.16.35.23;	author jhallen;	state Exp;
branches;
next	1.86;

1.86
date	2005.04.06.16.37.31;	author jhallen;	state Exp;
branches;
next	1.85;

1.85
date	2005.03.30.04.40.48;	author jhallen;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.29.06.26.59;	author jhallen;	state Exp;
branches;
next	1.83;

1.83
date	2005.03.28.15.13.16;	author jhallen;	state Exp;
branches;
next	1.82;

1.82
date	2005.03.28.06.17.08;	author jhallen;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.21.18.16.50;	author jhallen;	state Exp;
branches;
next	1.80;

1.80
date	2005.03.21.04.47.00;	author jhallen;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.21.03.41.36;	author jhallen;	state Exp;
branches;
next	1.78;

1.78
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.18.21.52.33;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.16.23.19.29;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.16.21.37.36;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.05.03.53.17;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.05.03.09.49;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2005.03.04.20.49.06;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2005.03.04.20.44.11;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2005.03.04.20.00.34;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2005.03.03.03.12.24;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2005.03.02.06.02.23;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2005.03.02.03.31.35;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2005.03.01.17.59.42;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2005.03.01.03.33.33;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.01.03.26.39;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.01.02.56.25;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.28.00.30.07;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.26.05.14.42;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.25.20.04.44;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.21.03.19.16;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.24.20.57.26;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.14.04.23.09;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.12.02.06.37;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.06.13.51.39;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.03.22.55.52;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.03.12.28.48;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.30.21.49.55;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.26.20.14.53;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.26.19.38.48;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.25.15.52.36;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.23.17.56.40;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.23.02.14.08;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.22.04.51.58;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.22.04.24.04;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.22.04.11.30;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.22.03.40.21;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.22.01.07.12;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.22.00.57.12;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.21.19.46.39;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.20.22.10.07;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.20.14.45.53;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.18.04.36.12;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.15.19.40.04;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.15.14.29.08;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.12.20.11.16;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.30.05.10.15;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.24.22.57.09;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.18.04.05.09;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.16.14.06.42;	author vsamel;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.09.48.12;	author vsamel;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.04.17.39.22;	author vsamel;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.10.13.57.21;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.04.13.20.52;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.22.09.17.59;	author marx_sk;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.20.12.59.50;	author marx_sk;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.12.15.58.25;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.53.40;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.13;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.112
log
@Smart backspace fix.
@
text
@/*
 *	Basic user edit functions
 *	Copyright
 * 		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/***************/
/* Global options */
int pgamnt = -1;		/* No. of PgUp/PgDn lines to keep */

/* 
 * Move cursor to beginning of line
 */
int u_goto_bol(BW *bw)
{
	if (bw->o.hex) {
		pbkwd(bw->cursor,bw->cursor->byte%16);
	} else {
		p_goto_bol(bw->cursor);
	}
	return 0;
}

/*
 * Move cursor to first non-whitespace character, unless it is
 * already there, in which case move it to beginning of line
 */
int uhome(BW *bw)
{
	P *p;

	if (bw->o.hex) {
		return u_goto_bol(bw);
	}

	p = pdup(bw->cursor, USTR "uhome");

	if (bw->o.indentfirst) {
		if ((bw->o.smarthome) && (piscol(p) > pisindent(p))) { 
			p_goto_bol(p);
			while (joe_isblank(p->b->o.charmap,brc(p)))
				pgetc(p);
		} else
			p_goto_bol(p);
	} else {
		if (bw->o.smarthome && piscol(p)==0 && pisindent(p)) {
			while (joe_isblank(p->b->o.charmap,brc(p)))
				pgetc(p);
		} else
			p_goto_bol(p);
	}

	pset(bw->cursor, p);
	prm(p);
	return 0;
}

/*
 * Move cursor to end of line
 */
int u_goto_eol(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte + 15 - bw->cursor->byte%16 > bw->b->eof->byte)
			pset(bw->cursor,bw->b->eof);
		else
			pfwrd(bw->cursor, 15 - bw->cursor->byte%16);
	} else
		p_goto_eol(bw->cursor);
	return 0;
}

/*
 * Move cursor to beginning of file
 */
int u_goto_bof(BW *bw)
{
	p_goto_bof(bw->cursor);
	return 0;
}

/*
 * Move cursor to end of file
 */
int u_goto_eof(BW *bw)
{
	p_goto_eof(bw->cursor);
	return 0;
}

/*
 * Move cursor left
 */
int u_goto_left(BW *bw)
{
	if (bw->o.hex) {
		if (prgetb(bw->cursor) != NO_MORE_DATA) {
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->o.picture) {
		if (bw->cursor->xcol) {
			--bw->cursor->xcol;
			pcol(bw->cursor,bw->cursor->xcol);
			return 0;
		} else
			return -1;
	} else {
		/* Have to do ECHKXCOL here because of picture mode */
		if (bw->cursor->xcol != piscol(bw->cursor)) {
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else if (prgetc(bw->cursor) != NO_MORE_DATA) {
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else {
			return -1;
		}
	}
}

/*
 * Move cursor right
 */
int u_goto_right(BW *bw)
{
	if (bw->o.hex) {
		if (pgetb(bw->cursor) != NO_MORE_DATA) {
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->o.picture) {
		++bw->cursor->xcol;
		pcol(bw->cursor,bw->cursor->xcol);
		return 0;
	} else {
		int rtn;
		if (pgetc(bw->cursor) != NO_MORE_DATA) {
			bw->cursor->xcol = piscol(bw->cursor);
			rtn = 0;
		} else {
			rtn = -1;
		}
		/* Have to do EFIXXCOL here because of picture mode */
		if (bw->cursor->xcol != piscol(bw->cursor))
			bw->cursor->xcol = piscol(bw->cursor);
		return rtn;
	}
}

/*
 * Move cursor to beginning of previous word or if there isn't 
 * previous word then go to beginning of the file
 *
 * WORD is a sequence non-white-space characters
 */
int p_goto_prev(P *ptr)
{
	P *p = pdup(ptr, USTR "p_goto_prev");
	struct charmap *map=ptr->b->o.charmap;
	int c = prgetc(p);

	if (joe_isalnum_(map,c)) {
		while (joe_isalnum_(map,(c=prgetc(p))))
			/* Do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(p);
	} else if (joe_isspace(map,c) || joe_ispunct(map,c)) {
		while ((c=prgetc(p)), (joe_isspace(map,c) || joe_ispunct(map,c)))
			/* Do nothing */;
		while(joe_isalnum_(map,(c=prgetc(p))))
			/* Do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(p);
	}
	pset(ptr, p);
	prm(p);
	return 0;
}

int u_goto_prev(BW *bw)
{
	return p_goto_prev(bw->cursor);
}

/*
 * Move cursor to end of next word or if there isn't 
 * next word then go to end of the file
 *
 * WORD is a sequence non-white-space characters
 */
int p_goto_next(P *ptr)
{
	P *p = pdup(ptr, USTR "p_goto_next");
	struct charmap *map=ptr->b->o.charmap;
	int c = brch(p);
	int rtn = -1;

	if (joe_isalnum_(map,c)) {
		rtn = 0;
		while (joe_isalnum_(map,(c = brch(p))))
			pgetc(p);
	} else if (joe_isspace(map,c) || joe_ispunct(map,c)) {
		while (joe_isspace(map, (c = brch(p))) || joe_ispunct(map,c))
			pgetc(p);
		while (joe_isalnum_(map,(c = brch(p)))) {
			rtn = 0;
			pgetc(p);
		}
	} else
		pgetc(p);
	pset(ptr, p);
	prm(p);
	return rtn;
}

int u_goto_next(BW *bw)
{
	return p_goto_next(bw->cursor);
}

static P *pboi(P *p)
{
	p_goto_bol(p);
	while (joe_isblank(p->b->o.charmap,brch(p)))
		pgetc(p);
	return p;
}

static int pisedge(P *p)
{
	P *q;
	int c;

	if (pisbol(p))
		return -1;
	if (piseol(p))
		return 1;
	q = pdup(p, USTR "pisedge");
	pboi(q);
	if (q->byte == p->byte)
		goto left;
	if (joe_isblank(p->b->o.charmap,(c = brch(p)))) {
		pset(q, p);
		if (joe_isblank(p->b->o.charmap,prgetc(q)))
			goto no;
		if (c == '\t')
			goto right;
		pset(q, p);
		pgetc(q);
		if (pgetc(q) == ' ')
			goto right;
		goto no;
	} else {
		pset(q, p);
		c = prgetc(q);
		if (c == '\t')
			goto left;
		if (c != ' ')
			goto no;
		if (prgetc(q) == ' ')
			goto left;
		goto no;
	}

      right:prm(q);
	return 1;
      left:prm(q);
	return -1;
      no:prm(q);
	return 0;
}

int upedge(BW *bw)
{
	if (prgetc(bw->cursor) == NO_MORE_DATA)
		return -1;
	while (pisedge(bw->cursor) != -1)
		prgetc(bw->cursor);
	return 0;
}

int unedge(BW *bw)
{
	if (pgetc(bw->cursor) == NO_MORE_DATA)
		return -1;
	while (pisedge(bw->cursor) != 1)
		pgetc(bw->cursor);
	return 0;
}

/* Move cursor to matching delimiter */
/*
 * begin end
 *
 * module endmodule
 *
 * function endfunction
 * 
 * <word </word
 *
 * if elif else fi
 *
 * do done
 *
 * case esac, endcase
 *
 * #if #ifdef #ifndef #elseif #else #endif
 *
 * `ifdef  `ifndef  `else `endif
 *
 */

/* A delimiter set list is a : separated list of delimiter sets.
   A delimiter set is two or more groups of matching delimiters.
   A group is a list of equivalent delimiters separated with |.

   For example, here is a delimiter set list, with three sets:
   	"case|casex|casez=endcase:begin=end:if=elif=else=fi:

   In the first delimiter set: "case," "casex" and "casez" all match with
   "endcase." In the third set: "if" matches with "elif," which matches with
   "else," which finally matches with "fi".

   The search goes forward if the delimiter matches any words of any group
   but the last of the set.  If the delimiter matches a word in the last
   group, the search goes backward to the first delimiter.
*/

/* Return pointer to first matching set in delimiter set list.  Returns NULL
   if no matches were found. */

unsigned char *next_set(unsigned char *set)
{
	while (*set && *set!=':')
		++set;
	if (*set==':')
		++set;
	return set;
}

unsigned char *next_group(unsigned char *group)
{
	while (*group && *group!='=' && *group!=':')
		++group;
	if (*group=='=')
		++group;
	return group;
}

unsigned char *next_word(unsigned char *word)
{
	while (*word && *word!='|' && *word!='=' && *word!=':')
		++word;
	if (*word=='|')
		++word;
	return word;
}

int match_word(unsigned char *word,unsigned char *s)
{
	while (*word==*s && *s && *word) {
		++word;
		++s;
	}
	if (!*s && (!*word || *word=='|' || *word=='=' || *word==':'))
		return 1;
	else
		return 0;
}

int is_in_group(unsigned char *group,unsigned char *s)
{
	while (*group && *group!='=' && *group!=':') {
		if (match_word(group, s))
			return 1;
		else
			group = next_word(group);
	}
	return 0;
}

int is_in_any_group(unsigned char *group,unsigned char *s)
{
	while (*group && *group!=':') {
		if (match_word(group, s))
			return 1;
		else {
			group = next_word(group);
			if (*group == '=')
				++group;
		}
	}
	return 0;
}

unsigned char *find_last_group(unsigned char *group)
{
	unsigned char *s;
	for (s = group; *s && *s!=':'; s=next_group(s))
		group = s;
	return group;
}

#define MAX_WORD_SIZE 255

int tomatch_word(BW *bw,unsigned char *set,unsigned char *group)
{
	if (!*group || *group==':') {
		/* Backward search */
		unsigned char *last_of_set = find_last_group(set);
		P *p=pdup(bw->cursor, USTR "tomatch_word");
		int c;
		unsigned char buf[MAX_WORD_SIZE+1];
		int len;
		int cnt = 1;
		p_goto_next(p);
		p_goto_prev(p);
		while ((c=prgetc(p)) != NO_MORE_DATA) {
			int peek = prgetc(p);
			if(peek!=NO_MORE_DATA)
				pgetc(p);
			if (peek=='\\') {
			} else if (!bw->o.no_double_quoted && c == '"') {
				while((c = prgetc(p)) != NO_MORE_DATA) {
					if (c == '"') {
						c = prgetc(p);
						if (c != '\\') {
							if (c != NO_MORE_DATA)
								pgetc(p);
							break;
						}
					}
				}
			} else if (bw->o.single_quoted && c == '\'') {
				while((c = prgetc(p)) != NO_MORE_DATA)
					if (c == '\'') {
						c = prgetc(p);
						if (c != '\\') {
							if (c != NO_MORE_DATA)
								pgetc(p);
							break;
						}
					}
			} else if (bw->o.c_comment && c == '/') {
				c = prgetc(p);
				if (c == '*') {
					c = prgetc(p);
					do {
						do {
							if (c == '*') break;
						} while ((c = prgetc(p)) != NO_MORE_DATA);
						c = prgetc(p);
					} while (c != NO_MORE_DATA && c != '/');
				} else if (c != NO_MORE_DATA)
					pgetc(p);
			} else if ((bw->o.cpp_comment || bw->o.pound_comment ||
			            bw->o.semi_comment || bw->o.tex_comment || bw->o.vhdl_comment) && c == '\n') {
				P *q = pdup(p, USTR "tomatch_word");
				int cc;
				p_goto_bol(q);
				while((cc = pgetc(q)) != '\n') {
					if (bw->o.pound_comment && cc == '$' && brch(q)=='#') {
						pgetc(q);
					} else if(!bw->o.no_double_quoted && cc=='"') {
						while ((cc = pgetc(q)) != '\n')
							if (cc == '"') break;
							else if (cc == '\\') pgetc(q);
					} else if (bw->o.cpp_comment && cc == '/') {
						if (brch(q)=='/') {
							prgetc(q);
							pset(p,q);
							break;
						}
					} else if (bw->o.single_quoted && cc == '\'') {
						while((cc = pgetc(q)) != '\n')
							if (cc == '\'') break;
							else if (cc == '\\') pgetc(q);
					} else if (bw->o.vhdl_comment && cc == '-') {
						if (brch(q)=='-') {
							prgetc(q);
							pset(p,q);
							break;
						}
					} else if (bw->o.pound_comment && cc == '#') {
						pset(p,q);
						break;
					} else if (bw->o.semi_comment && cc == ';') {
						pset(p,q);
						break;
					} else if (bw->o.tex_comment && cc == '%') {
						pset(p,q);
						break;
					}
				}
				prm(q);
			} else if ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || (c>='0' && c<='9') || c=='_') {
				int x;
				int flg=0;
				P *q;
				len=0;
				while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || (c>='0' && c<='9')) {
					if(len!=MAX_WORD_SIZE)
						buf[len++]=c;
					c=prgetc(p);
				}
				/* ifdef hack */
				q=pdup(p, USTR "tomatch_word");
				while (c ==' ' || c=='\t')
					c=prgetc(q);
				prm(q);
				/* VHDL hack */
				if ((c=='d' || c=='D') && bw->o.vhdl_comment) {
					c=prgetc(q);
					if(c=='n' || c=='N') {
						c=prgetc(q);
						if(c=='e' || c=='E') {
							c=prgetc(q);
							if(c==' ' || c=='\t' || c=='\n' || c==NO_MORE_DATA)
								flg=1;
						}
					}
				}
				prm(q);
				if (c == set[0])
					buf[len++] = c;
				if(c!=NO_MORE_DATA)
					pgetc(p);
				buf[len]=0;
				for(x=0;x!=len/2;++x) {
					int d = buf[x];
					buf[x] = buf[len-x-1];
					buf[len-x-1] = d;
				}
				if (is_in_group(last_of_set,buf)) {
					++cnt;
				} else if(is_in_group(set,buf) && !flg && !--cnt) {
					pset(bw->cursor,p);
					prm(p);
					return 0;
				}
			}
		}
		prm(p);
		return -1;
	} else {
		/* Forward search */
		unsigned char *last_of_set = find_last_group(group);
		P *p=pdup(bw->cursor, USTR "tomatch_word");
		int c;
		unsigned char buf[MAX_WORD_SIZE+1];
		int len;
		int cnt = 1;
		p_goto_next(p);
		while ((c=pgetc(p)) != NO_MORE_DATA) {
			if (c == '\\') {
				pgetc(p);
			} else if (!bw->o.no_double_quoted && c == '"') {
				while ((c = pgetc(p)) != NO_MORE_DATA)
					if (c == '"') break;
					else if (c == '\\') pgetc(p);
			} else if (c == '$' && brch(p)=='#' && bw->o.pound_comment) {
				pgetc(p);
			} else if ((bw->o.pound_comment && c == '#') ||
				   (bw->o.semi_comment && c == ';') ||
				   (bw->o.tex_comment && c == '%') ||
				   (bw->o.vhdl_comment && c == '-' && brch(p) == '-')) {
				while ((c = pgetc(p)) != NO_MORE_DATA)
					if (c == '\n')
						break;
			} else if (bw->o.single_quoted && c == '\'') {
				while((c = pgetc(p)) != NO_MORE_DATA)
					if (c == '\'') break;
					else if (c == '\\') pgetc(p);
			} else if ((bw->o.c_comment || bw->o.cpp_comment) && c == '/') {
				c = pgetc(p);
				if (bw->o.c_comment && c == '*') {
					c = pgetc(p);
					do {
						do {
							if (c == '*') break;
						} while ((c = pgetc(p)) != NO_MORE_DATA);
						c = pgetc(p);
					} while (c != NO_MORE_DATA && c != '/');
				} else if (bw->o.cpp_comment && c == '/') {
					while ((c = pgetc(p)) != NO_MORE_DATA)
						if (c == '\n')
							break;
				} else if (c != NO_MORE_DATA)
					prgetc(p);
			} else if (c == set[0]) {
				/* ifdef hack */
				while ((c = pgetc(p))!=NO_MORE_DATA) {
					if (c!=' ' && c!='\t')
						break;
				}
				buf[0]=set[0];
				len=1;
				if (c >= 'a' && c <= 'z')
					goto doit;
			} else if ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_') {
				len=0;
				doit:
				while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || (c>='0' && c<='9')) {
					if(len!=MAX_WORD_SIZE)
						buf[len++]=c;
					c=pgetc(p);
				}
				if (c!=NO_MORE_DATA)
					prgetc(p);
				buf[len]=0;
				if (is_in_group(set,buf)) {
					++cnt;
				} else if (cnt==1) {
					if (is_in_any_group(group,buf)) {
						if (!((buf[0]>='a' && buf[0]<='z') || (buf[0]>='A' && buf[0]<='Z')))
							pgoto(p,p->byte-len+1);
						else
							pgoto(p,p->byte-len);
						pset(bw->cursor,p);
						prm(p);
						return 0;
					}
				} else if(is_in_group(last_of_set,buf)) {
					/* VHDL hack */
					if (bw->o.vhdl_comment && (!zcmp(buf,USTR "end") || !zcmp(buf,USTR "END")))
						while((c=pgetc(p))!=NO_MORE_DATA)
							if (c==';' || c=='\n')
								break;
					--cnt;
				}
			}
		}
		prm(p);
		return -1;
	}
}

/* Return true if <foo /> */

int xml_startend(P *p)
{
	int c, d=0;
	p=pdup(p, USTR "xml_startend");
	while((c=pgetc(p)) != NO_MORE_DATA) {
		if(d=='/' && c=='>') {
			prm(p);
			return 1;
		} else if(c=='>')
			break;
		d=c;
	}
	prm(p);
	return 0;
}

int tomatch_xml(BW *bw,unsigned char *word,int dir)
{
	if (dir== -1) {
		/* Backward search */
		P *p=pdup(bw->cursor, USTR "tomatch_xml");
		int c;
		unsigned char buf[MAX_WORD_SIZE+1];
		int len;
		int cnt = 1;
		p_goto_next(p);
		p_goto_prev(p);
		while ((c=prgetc(p)) != NO_MORE_DATA) {
			if ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || (c>='0' && c<='9') || c=='.' || c==':' || c=='-' || c=='_') {
				int x;
				len=0;
				while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || (c>='0' && c<='9') || c=='.' ||
				       c == '-' || c == ':') {
					if(len!=MAX_WORD_SIZE)
						buf[len++]=c;
					c=prgetc(p);
				}
				if(c!=NO_MORE_DATA)
					c = pgetc(p);
				buf[len]=0;
				for(x=0;x!=len/2;++x) {
					int d = buf[x];
					buf[x] = buf[len-x-1];
					buf[len-x-1] = d;
				}
				if (!zcmp(word,buf) && !xml_startend(p)) {
					if (c=='<') {
						if (!--cnt) {
							pset(bw->cursor,p);
							prm(p);
							return 0;
						}
					}
					else if (c=='/') {
						++cnt;
					}
				}
			}
		}
		prm(p);
		return -1;
	} else {
		/* Forward search */
		P *p=pdup(bw->cursor, USTR "tomatch_xml");
		int c;
		unsigned char buf[MAX_WORD_SIZE+1];
		int len;
		int cnt = 1;
		while ((c=pgetc(p)) != NO_MORE_DATA) {
			if (c == '<') {
				int e = 1;
				c = pgetc(p);
				if (c=='/') {
					e = 0;
					c = pgetc(p);
				}
				if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c=='_' || c==':' || c=='-' || c=='.') {
					len=0;
					while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || c==':' || c=='-' || c=='.' ||
					       (c >= '0' && c <= '9')) {
						if(len!=MAX_WORD_SIZE)
							buf[len++]=c;
						c=pgetc(p);
					}
					if (c!=NO_MORE_DATA)
						prgetc(p);
					buf[len]=0;
					if (!zcmp(word,buf) && !xml_startend(p)) {
						if (e) {
							++cnt;
						}
						else if (!--cnt) {
							pgoto(p,p->byte-len);
							pset(bw->cursor,p);
							prm(p);
							return 0;
						}
					}
				} else if (c!=NO_MORE_DATA) {
					prgetc(p);
				}
			}
		}
		prm(p);
		return -1;
	}
}

void get_xml_name(P *p,unsigned char *buf)
{
	int c;
	int len=0;
	p=pdup(p, USTR "get_xml_name");
	c=pgetc(p);
	while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || c==':' || c=='-' || c=='.' ||
	       (c >= '0' && c <= '9')) {
		if(len!=MAX_WORD_SIZE)
			buf[len++]=c;
		c=pgetc(p);
	}
	buf[len]=0;
	prm(p);
}

void get_delim_name(P *q,unsigned char *buf)
{
	int c;
	int len=0;
	P *p=pdup(q, USTR "get_delim_name");
	while ((c=prgetc(p))!=NO_MORE_DATA)
		if (c!=' ' && c!='\t')
			break;
	prm(p);
	/* preprocessor directive hack */
	if (c=='#' || c=='`')
		buf[len++]=c;

	p=pdup(q, USTR "get_delim_name");
	c=pgetc(p);
	while ((c >= 'a' && c <= 'z') || (c>='A' && c<='Z') || c=='_' || (c >= '0' && c <= '9')) {
		if(len!=MAX_WORD_SIZE)
			buf[len++]=c;
		c=pgetc(p);
	}
	buf[len]=0;
	prm(p);
}

int utomatch(BW *bw)
{
	int d;
	int c,			/* Character under cursor */
	 f,			/* Character to find */
	 dir;			/* 1 to search forward, -1 to search backward */

	c = brch(bw->cursor);

	/* Check for word delimiters */
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_') {
		P *p;
		unsigned char buf[MAX_WORD_SIZE+1];
		unsigned char buf1[MAX_WORD_SIZE+1];
		unsigned char *list = bw->b->o.text_delimiters;
		unsigned char *set;
		unsigned char *group;
		unsigned char *word;
		int flg=0;
		p=pdup(bw->cursor, USTR "utomatch");
		p_goto_next(p);
		p_goto_prev(p);
		get_delim_name(p,buf);
		get_xml_name(p,buf1);
		c=prgetc(p);
		if (c=='<')
			flg = 1;
		else if (c=='/') {
			c=prgetc(p);
			if (c=='<')
				flg = -1;
		}
		prm(p);

		if (flg) {
			return tomatch_xml(bw, buf1, flg);
		}

		for (set = list; set && *set; set = next_set(set)) {
			for (group = set; *group && *group!='=' && *group!=':'; group=next_group(group)) {
				for (word = group; *word && *word!='|' && *word!='=' && *word!=':'; word=next_word(word)) {
					if (match_word(word, buf)) {
						return tomatch_word(bw, set, next_group(word));
					}
				}
			}
				
		}

		/* We don't know the word, so start a search */
		return dofirst(bw, 0, 0, buf);
	}

	switch (c) {
	case '/':
		dir = 1;
		pgetc(bw->cursor);
		f = brch(bw->cursor);
		prgetc(bw->cursor);
		if(f=='*') f = '/';
		else {
			dir = -1;
			f = prgetc(bw->cursor);
			if (f!=NO_MORE_DATA)
				pgetc(bw->cursor);
			if(f=='*') f = '/';
			else
				return -1;
		}
		break;
	case '(':
		f = ')';
		dir = 1;
		break;
	case '[':
		f = ']';
		dir = 1;
		break;
	case '{':
		f = '}';
		dir = 1;
		break;
	case '`':
		f = '\'';
		dir = 1;
		break;
	case '<':
		f = '>';
		dir = 1;
		break;
	case ')':
		f = '(';
		dir = -1;
		break;
	case ']':
		f = '[';
		dir = -1;
		break;
	case '}':
		f = '{';
		dir = -1;
		break;
	case '\'':
		f = '`';
		dir = -1;
		break;
	case '>':
		f = '<';
		dir = -1;
		break;
	default:
		return -1;
	}

	/* Search for matching C comment */
	if (f == '/') {
		P *p = pdup(bw->cursor, USTR "utomatch");
		if (dir == 1) {
			d = pgetc(p);
			do {
				do {
					if (d == '*') break;
				} while ((d = pgetc(p)) != NO_MORE_DATA);
				d = pgetc(p);
			} while (d != NO_MORE_DATA && d != '/');
			if (d == '/') {
				pset(bw->cursor,p);
				prgetc(bw->cursor);
			}
		} else {
			d = prgetc(p);
			do {
				do {
					if (d == '*') break;
				} while ((d = prgetc(p)) != NO_MORE_DATA);
				d = prgetc(p);
			} while (d != NO_MORE_DATA && d != '/');
			if (d == '/') {
				pset(bw->cursor,p);
			}
		}
		prm(p);
		if (d == NO_MORE_DATA)
			return -1;
		else
			return 0;
	}

	/* Search for matching delimiter: ignore things in comments or strings */
	/* This really should be language dependent */
	if (dir == 1) {
		P *p = pdup(bw->cursor, USTR "utomatch");
		int cnt = 0;	/* No. levels of delimiters we're in */

		while ((d = pgetc(p)) != NO_MORE_DATA) {
			if (d == '\\') {
				pgetc(p);
			} else if (d == '$' && brch(p)=='#' && bw->o.pound_comment) {
				pgetc(p);
			} else if (!bw->o.no_double_quoted && d == '"') {
				while ((d = pgetc(p)) != NO_MORE_DATA)
					if (d == '"') break;
					else if (d == '\\') pgetc(p);
			} else if (bw->o.single_quoted && d == '\'' && c!='\'' && c!='`') {
				while((d = pgetc(p)) != NO_MORE_DATA)
					if (d == '\'') break;
					else if (d == '\\') pgetc(p);
			} else if ((bw->o.pound_comment && d == '#') ||
				   (bw->o.semi_comment && d == ';') ||
				   (bw->o.tex_comment && d == '%') ||
				   (bw->o.vhdl_comment && d == '-' && brch(p) == '-')) {
				while ((d = pgetc(p)) != NO_MORE_DATA)
					if (d == '\n')
						break;
			} else if ((bw->o.c_comment || bw->o.cpp_comment) && d == '/') {
				d = pgetc(p);
				if (bw->o.c_comment && d == '*') {
					d = pgetc(p);
					do {
						do {
							if (d == '*') break;
						} while ((d = pgetc(p)) != NO_MORE_DATA);
						d = pgetc(p);
					} while (d != NO_MORE_DATA && d != '/');
				} else if (bw->o.cpp_comment && d == '/') {
					while ((d = pgetc(p)) != NO_MORE_DATA)
						if (d == '\n')
							break;
				} else if (d != NO_MORE_DATA)
					prgetc(p);
			} else if (d == c)
				++cnt;
			else if (d == f && !--cnt) {
				prgetc(p);
				pset(bw->cursor, p);
				break;
			}
		}
		prm(p);
	} else {
		P *p = pdup(bw->cursor, USTR "utomatch");
		int cnt = 0;	/* No. levels of delimiters we're in */

		while ((d = prgetc(p)) != NO_MORE_DATA) {
			int peek = prgetc(p);
			int peek1 = 0;
			if(peek != NO_MORE_DATA) {
				peek1 = prgetc(p);
				if (peek1 != NO_MORE_DATA)
					pgetc(p);
				pgetc(p);
			}
			if (peek == '\\' && peek1!='\\') {
			} else if (!bw->o.no_double_quoted && d == '"') {
				while((d = prgetc(p)) != NO_MORE_DATA) {
					if (d == '"') {
						d = prgetc(p);
						if (d != '\\') {
							if (d != NO_MORE_DATA)
								pgetc(p);
							break;
						}
					}
				}
			} else if (bw->o.c_comment && d =='/') {
				d = prgetc(p);
				if (d == '*') {
					d = prgetc(p);
					do {
						do {
							if (d == '*') break;
						} while ((d = prgetc(p)) != NO_MORE_DATA);
						d = prgetc(p);
					} while (d != NO_MORE_DATA && d != '/');
				} else if (d != NO_MORE_DATA)
					pgetc(p);
			} else if ((bw->o.cpp_comment || bw->o.pound_comment ||
			            bw->o.semi_comment || bw->o.tex_comment || bw->o.vhdl_comment) && d == '\n') {
				P *q = pdup(p, USTR "utomatch");
				int cc;
				p_goto_bol(q);
				while((cc = pgetc(q)) != '\n') {
					if (bw->o.pound_comment && cc == '$' && brch(q)=='#') {
						pgetc(q);
					} else if (cc == '\\') {
						if (pgetc(q) == '\n')
							break;
					} else if(!bw->o.no_double_quoted && cc=='"') {
						while ((cc = pgetc(q)) != '\n')
							if (cc == '"') break;
							else if (cc == '\\') pgetc(q);
						if (cc == '\n')
							break;
					} else if (bw->o.cpp_comment && cc == '/') {
						if (brch(q)=='/') {
							prgetc(q);
							pset(p,q);
							break;
						}
					} else if (bw->o.single_quoted && cc == '\'') {
						while((cc = pgetc(q)) != '\n')
							if (cc == '\'') break;
							else if (cc == '\\') pgetc(q);
						if (cc == '\n')
							break;
					} else if (bw->o.vhdl_comment && cc == '-') {
						if (brch(q)=='-') {
							prgetc(q);
							pset(p,q);
							break;
						}
					} else if (bw->o.pound_comment && cc == '#') {
						pset(p,q);
						break;
					} else if (bw->o.semi_comment && cc == ';') {
						pset(p,q);
						break;
					} else if (bw->o.tex_comment && cc == '%') {
						pset(p,q);
						break;
					}
				}
				prm(q);
			} else if (bw->o.single_quoted && d =='\'' && c!='\'' && c!='`') {
				while((d = prgetc(p)) != NO_MORE_DATA)
					if (d == '\'') {
						d = prgetc(p);
						if (d != '\\') {
							if (d != NO_MORE_DATA)
								pgetc(p);
							break;
						}
					}
			} else if (d == c)
				++cnt;
			else if (d == f)
				if (!cnt--) {
					pset(bw->cursor, p);
					break;
				}
		}
		prm(p);
	}
	if (d == NO_MORE_DATA)
		return -1;
	else
		return 0;
}

/* Move cursor up */

int uuparw(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte<16)
			return -1;
		else {
			pbkwd(bw->cursor, 16);
			return 0;
		}
	}
	if (bw->cursor->line) {
		pprevl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else
		return -1;
}

/* Move cursor down */

int udnarw(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte+16 <= bw->b->eof->byte) {
			pfwrd(bw->cursor, 16);
			return 0;
		} else if (bw->cursor->byte != bw->b->eof->byte) {
			pset(bw->cursor, bw->b->eof);
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->cursor->line != bw->b->eof->line) {
		pnextl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else if(bw->o.picture) {
		p_goto_eol(bw->cursor);
		binsc(bw->cursor,'\n');
		pgetc(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else
		return -1;
}

/* Move cursor to top of window */

int utos(BW *bw)
{
	long col = bw->cursor->xcol;

	pset(bw->cursor, bw->top);
	pcol(bw->cursor, col);
	bw->cursor->xcol = col;
	return 0;
}

/* Move cursor to bottom of window */

int ubos(BW *bw)
{
	long col = bw->cursor->xcol;

	pline(bw->cursor, bw->top->line + bw->h - 1);
	pcol(bw->cursor, col);
	bw->cursor->xcol = col;
	return 0;
}

/* Scroll buffer window up n lines
 * If beginning of file is close, scrolls as much as it can
 * If beginning of file is on-screen, cursor jumps to beginning of file
 *
 * If flg is set: cursor stays fixed relative to screen edge
 * If flg is clr: cursor stays fixed on the buffer line
 */

void scrup(BW *bw, int n, int flg)
{
	int scrollamnt = 0;
	int cursoramnt = 0;
	int x;

	/* Decide number of lines we're really going to scroll */

	if (bw->o.hex) {
		if (bw->top->byte/16 >= n)
			scrollamnt = cursoramnt = n;
		else if (bw->top->byte/16)
			scrollamnt = cursoramnt = bw->top->byte/16;
		else if (flg)
			cursoramnt = bw->cursor->byte/16;
		else if (bw->cursor->byte/16 >= n)
			cursoramnt = n;
	} else {
		if (bw->top->line >= n)
			scrollamnt = cursoramnt = n;
		else if (bw->top->line)
			scrollamnt = cursoramnt = bw->top->line;
		else if (flg)
			cursoramnt = bw->cursor->line;
		else if (bw->cursor->line >= n)
			cursoramnt = n;
	}

	if (bw->o.hex) {
		/* Move top-of-window pointer */
		pbkwd(bw->top,scrollamnt*16);
		/* Move cursor */
		pbkwd(bw->cursor,cursoramnt*16);
		/* If window is on the screen, give (buffered) scrolling command */
		if (bw->parent->y != -1)
			nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	} else {
		/* Move top-of-window pointer */
		for (x = 0; x != scrollamnt; ++x)
			pprevl(bw->top);
		p_goto_bol(bw->top);

		/* Move cursor */
		for (x = 0; x != cursoramnt; ++x)
			pprevl(bw->cursor);
		p_goto_bol(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);

		/* If window is on the screen, give (buffered) scrolling command */
		if (bw->parent->y != -1)
			nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	}
}

/* Scroll buffer window down n lines
 * If end of file is close, scrolls as much as possible
 * If end of file is on-screen, cursor jumps to end of file
 *
 * If flg is set: cursor stays fixed relative to screen edge
 * If flg is clr: cursor stays fixed on the buffer line
 */

void scrdn(BW *bw, int n, int flg)
{
	int scrollamnt = 0;
	int cursoramnt = 0;
	int x;

	/* How much we're really going to scroll... */
	if (bw->o.hex) {
		if (bw->top->b->eof->byte/16 < bw->top->byte/16 + bw->h) {
			cursoramnt = bw->top->b->eof->byte/16 - bw->cursor->byte/16;
			if (!flg && cursoramnt > n)
				cursoramnt = n;
		} else if (bw->top->b->eof->byte/16 - (bw->top->byte/16 + bw->h) >= n)
			cursoramnt = scrollamnt = n;
		else
			cursoramnt = scrollamnt = bw->top->b->eof->byte/16 - (bw->top->byte/16 + bw->h) + 1;
	} else {
		if (bw->top->b->eof->line < bw->top->line + bw->h) {
			cursoramnt = bw->top->b->eof->line - bw->cursor->line;
			if (!flg && cursoramnt > n)
				cursoramnt = n;
		} else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
			cursoramnt = scrollamnt = n;
		else
			cursoramnt = scrollamnt = bw->top->b->eof->line - (bw->top->line + bw->h) + 1;
	}

	if (bw->o.hex) {
		/* Move top-of-window pointer */
		pfwrd(bw->top,16*scrollamnt);
		/* Move cursor */
		pfwrd(bw->cursor,16*cursoramnt);
		/* If window is on screen, give (buffered) scrolling command to terminal */
		if (bw->parent->y != -1)
			nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	} else {
		/* Move top-of-window pointer */
		for (x = 0; x != scrollamnt; ++x)
			pnextl(bw->top);

		/* Move cursor */
		for (x = 0; x != cursoramnt; ++x)
			pnextl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);

		/* If window is on screen, give (buffered) scrolling command to terminal */
		if (bw->parent->y != -1)
			nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	}
}

/* Page up */

int upgup(BW *bw)
{
	if (menu_above) {
		if (bw->parent->link.prev->watom==&watommenu) {
			return umpgup(bw->parent->link.prev->object);
		}
	} else {
		if (bw->parent->link.next->watom==&watommenu) {
			return umpgup(bw->parent->link.next->object);
		}
	}
	bw = (BW *) bw->parent->main->object;

	if (bw->o.hex ? bw->cursor->byte < 16 : !bw->cursor->line)
		return -1;
	if (pgamnt < 0)
		scrup(bw, bw->h / 2 + bw->h % 2, 1);
	else if (pgamnt < bw->h)
		scrup(bw, bw->h - pgamnt, 1);
	else
		scrup(bw, 1, 1);
	return 0;
}

/* Page down */

int upgdn(BW *bw)
{
	if (menu_above) {
		if (bw->parent->link.prev->watom==&watommenu) {
			return umpgdn(bw->parent->link.prev->object);
		}
	} else {
		if (bw->parent->link.next->watom==&watommenu) {
			return umpgdn(bw->parent->link.next->object);
		}
	}
	bw = (BW *) bw->parent->main->object;
	if (bw->o.hex ? bw->cursor->byte/16 == bw->b->eof->byte/16 : bw->cursor->line == bw->b->eof->line)
		return -1;
	if (pgamnt < 0)
		scrdn(bw, bw->h / 2 + bw->h % 2, 1);
	else if (pgamnt < bw->h)
		scrdn(bw, bw->h - pgamnt, 1);
	else
		scrdn(bw, 1, 1);
	return 0;
}

/* Scroll by a single line.  The cursor moves with the scroll */

int uupslide(BW *bw)
{
	bw = (BW *) bw->parent->main->object;
	if (bw->o.hex ? bw->top->byte/16 : bw->top->line) {
		if (bw->o.hex ? bw->top->byte/16 + bw->h -1 != bw->cursor->byte/16 : bw->top->line + bw->h - 1 != bw->cursor->line)
			udnarw(bw);
		scrup(bw, 1, 0);
		return 0;
	} else
		/* was return -1; */
		return uuparw(bw);
}

int udnslide(BW *bw)
{
	bw = (BW *) bw->parent->main->object;
	if (bw->o.hex ? bw->top->line/16 + bw->h <= bw->top->b->eof->byte/16 : bw->top->line + bw->h <= bw->top->b->eof->line) {
		if (bw->o.hex ? bw->top->byte/16 != bw->cursor->byte/16 : bw->top->line != bw->cursor->line)
			uuparw(bw);
		scrdn(bw, 1, 0);
		return 0;
	} else
		/* was return -1; */
		return udnarw(bw);
}

/* Move cursor to specified line number */

static B *linehist = NULL;	/* History of previously entered line numbers */

int uline(BW *bw)
{
	long num;
	unsigned char *s;

	s = ask(bw->parent, joe_gettext(_("Go to line (^C to abort): ")), &linehist,
	        NULL, NULL, locale_map, 0, 0, NULL);

	if (!s)
		return -1;

	num = calc(bw, s);

	if (num >= 1 && !merr) {
		int tmp = mid;

		if (num > bw->b->eof->line)
			num = bw->b->eof->line + 1;
		pline(bw->cursor, num - 1), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merr)
			msgnw(bw->parent, merr);
		else
			msgnw(bw->parent, joe_gettext(_("Invalid line number")));
		return -1;
	}
}

/* Move cursor to specified column number */

static B *colhist = NULL;	/* History of previously entered column numbers */

int ucol(BW *bw)
{
	long num;
	unsigned char *s;

	s = ask(bw->parent, joe_gettext(_("Go to column (^C to abort): ")), &colhist,
	        NULL, NULL, locale_map, 0, 0, NULL);

	if (!s)
		return -1;

	num = calc(bw, s);

	if (num >= 1 && !merr) {
		int tmp = mid;

		pcol(bw->cursor, num - 1), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merr)
			msgnw(bw->parent, merr);
		else
			msgnw(bw->parent, joe_gettext(_("Invalid column number")));
		return -1;
	}
}

/* Move cursor to specified byte number */

static B *bytehist = NULL;	/* History of previously entered byte numbers */

int ubyte(BW *bw)
{
	long num;
	unsigned char *s;

	s = ask(bw->parent, joe_gettext(_("Go to byte (^C to abort): ")), &bytehist,
	        NULL, NULL, locale_map, 0, 0, NULL);

	num = calc(bw, s);

	if (num >= 0 && !merr) {
		int tmp = mid;

		pgoto(bw->cursor, num), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merr)
			msgnw(bw->parent, merr);
		else
			msgnw(bw->parent, joe_gettext(_("Invalid byte number")));
		return -1;
	}
}

/* Delete character under cursor
 * or write ^D to process if we're at end of file in a shell window
 */

int udelch(BW *bw)
{
	P *p;

	if (piseof(bw->cursor))
		return -1;
	pgetc(p = pdup(bw->cursor, USTR "udelch"));
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Backspace */

int ubacks(BW *bw, int k)
{
	/* Don't backspace when at beginning of line in prompt windows */
	if (bw->parent->watom->what == TYPETW || !pisbol(bw->cursor)) {
		int c;
		int indent;
		int col;
		int indwid;
		int wid;

		/* Degenerate into ltarw for overtype mode */
		if (bw->o.overtype) {
			return u_goto_left(bw);
		}

		if (pisbof(bw->cursor))
			return -1;

		/* Indentation point of this line */
		indent = pisindent(bw->cursor);

		/* Column position of cursor */
		col = piscol(bw->cursor);

		/* Indentation step in columns */
		if (bw->o.indentc=='\t')
			wid = bw->o.tab;
		else
			wid = 1;

		indwid = (bw->o.istep*wid);

		/* Smart backspace when: cursor is at indentation point, indentation point
		   is a multiple of indentation width, we're not at beginning of line,
		   'smarthome' option is enabled, and indentation is purely made out of
		   indent characters (or purify indents is enabled). */
		
		/* Ignore purify for backspace */
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && bw->o.autoindent) {
			P *p;

			/* Delete all indentation */
			p = pdup(bw->cursor, USTR "ubacks");
			p_goto_bol(p);
			bdel(p,bw->cursor);
			prm(p);

			/* Indent to new position */
			pfill(bw->cursor,col-indwid,bw->o.indentc);
		} else if (col<indent && bw->o.smartbacks && !pisbol(bw->cursor)) {
			/* We're before indent point: delete indwid worth of space but do not
			   cross line boundary.  We could probably replace the above with this. */
			int cw=0;
			P *p = pdup(bw->cursor, USTR "ubacks");
			do {
				c = prgetc(bw->cursor);
				if(c=='\t') cw += bw->o.tab;
				else cw += 1;
				bdel(bw->cursor, p);
			} while(!pisbol(bw->cursor) && cw<indwid);
			prm(p);
		} else {
			/* Regular backspace */
			P *p = pdup(bw->cursor, USTR "ubacks");
			if ((c = prgetc(bw->cursor)) != NO_MORE_DATA)
				if (!bw->o.overtype || c == '\t' || pisbol(p) || piseol(p))
					bdel(bw->cursor, p);
			prm(p);
		}
		return 0;
	} else
		return -1;
}

/* 
 * Delete sequence of characters (alphabetic, numeric) or (white-space)
 *	if cursor is on the white-space it will delete all white-spaces
 *		until alphanumeric character
 *      if cursor is on the alphanumeric it will delete all alphanumeric
 *		characters until character that is not alphanumeric
 */
int u_word_delete(BW *bw)
{
	P *p = pdup(bw->cursor, USTR "u_word_delete");
	struct charmap *map=bw->b->o.charmap;
	int c = brch(p);

	if (joe_isalnum_(map,c))
		while (joe_isalnum_(map,(c = brch(p))))
			pgetc(p);
	else if (joe_isspace(map,c))
		while (joe_isspace(map,(c = brch(p))))
			pgetc(p);
	else
		pgetc(p);

	if (p->byte == bw->cursor->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete from cursor to beginning of word it's in or immediately after,
 * to start of whitespace, or a single character
 */

int ubackw(BW *bw)
{
	P *p = pdup(bw->cursor, USTR "ubackw");
	int c = prgetc(bw->cursor);
	struct charmap *map=bw->b->o.charmap;

	if (joe_isalnum_(map,c)) {
		while (joe_isalnum_(map,(c = prgetc(bw->cursor))))
			/* do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(bw->cursor);
	} else if (joe_isspace(map,c)) {
		while (joe_isspace(map,(c = prgetc(bw->cursor))))
			/* do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(bw->cursor);
	}
	if (bw->cursor->byte == p->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete from cursor to end of line, or if there's nothing to delete,
 * delete the line-break
 */

int udelel(BW *bw)
{
	P *p = p_goto_eol(pdup(bw->cursor, USTR "udelel"));

	if (bw->cursor->byte == p->byte) {
		prm(p);
		return udelch(bw);
	} else
		bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete to beginning of line, or if there's nothing to delete,
 * delete the line-break
 */

int udelbl(BW *bw)
{
	P *p = p_goto_bol(pdup(bw->cursor, USTR "udelbl"));

	if (p->byte == bw->cursor->byte) {
		prm(p);
		return ubacks(bw, 8);	/* The 8 goes to the process if we're at EOF of shell window */
	} else
		bdel(p, bw->cursor);
	prm(p);
	return 0;
}

/* Delete entire line */

int udelln(BW *bw)
{
	P *p = pdup(bw->cursor, USTR "udelln");

	p_goto_bol(bw->cursor);
	pnextl(p);
	if (bw->cursor->byte == p->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Insert a space */

int uinsc(BW *bw)
{
	binsc(bw->cursor, ' ');
	return 0;
}

/* Move p backwards to first non-blank line and return its indentation */

int find_indent(P *p)
{
	int x;
	for (x=0; x != 10; ++x) {
		if (!pprevl(p)) return -1;
		p_goto_bol(p);
		if (!pisblank(p)) break;
	}
	if (x==10)
		return -1;
	else
		return pisindent(p);
}

/* Type a character into the buffer (deal with left margin, overtype mode and
 * word-wrap), if cursor is at end of shell window buffer, just send character
 * to process.
 */

struct utf8_sm utype_utf8_sm;

int utypebw_raw(BW *bw, int k, int no_decode)
{
	struct charmap *map=bw->b->o.charmap;

	/* Send data to shell window */
	if (bw->b->pid && piseof(bw->cursor)) {
		unsigned char c = k;
		joe_write(bw->b->out, &c, 1);
		return 0;
	}

	/* Hex mode overtype is real simple */
	if (bw->o.hex && bw->o.overtype) {
		P *p;
		unsigned char c = k;
		binsm(bw->cursor, &c, 1);
		pgetb(bw->cursor);
		if (piseof(bw->cursor))
			return 0;
		pgetb(p = pdup(bw->cursor, USTR "utypebw_raw"));
		bdel(bw->cursor, p);
		prm(p);
		return 0;
	}

	if (k == '\t' && bw->o.overtype && !piseol(bw->cursor)) { /* TAB in overtype mode is supposed to be just cursor motion */
		int col = bw->cursor->xcol;		/* Current cursor column */
		col = col + bw->o.tab - (col%bw->o.tab);/* Move to next tab stop */
		pcol(bw->cursor,col);			/* Try to position cursor there */
		if (!bw->o.picture && piseol(bw->cursor) && piscol(bw->cursor)<col) {	/* We moved past end of line, insert a tab (unless in picture mode) */
			if (bw->o.spaces)
				pfill(bw->cursor,col,' ');
			else
				pfill(bw->cursor,col,'\t');
		}
		bw->cursor->xcol = col;			/* Put cursor there even if we can't really go there */
	} else if (k == '\t' && bw->o.smartbacks && bw->o.autoindent && pisindent(bw->cursor)>=piscol(bw->cursor)) {
		P *p = pdup(bw->cursor, USTR "utypebw_raw");
		int n = find_indent(p);
		if (n != -1 && pisindent(bw->cursor)==piscol(bw->cursor) && n > pisindent(bw->cursor)) {
			if (!pisbol(bw->cursor))
				udelbl(bw);
			while (joe_isspace(map,(k = pgetc(p))) && k != '\n') {
				binsc(bw->cursor, k);
				pgetc(bw->cursor);
			}
		} else {
			int x;
			for (x=0;x<bw->o.istep;++x) {
				binsc(bw->cursor,bw->o.indentc);
				pgetc(bw->cursor);
			}
		}
		bw->cursor->xcol = piscol(bw->cursor);
		prm (p);
	} else if (k == '\t' && bw->o.spaces) {
		long n;

		if (bw->o.picture)
			n = bw->cursor->xcol;
		else
			n = piscol(bw->cursor);

		utype_utf8_sm.state = 0;
		utype_utf8_sm.ptr = 0;

		n = bw->o.tab - n % bw->o.tab;
		while (n--)
			utypebw(bw, ' ');
	} else {
		int upd;
		int simple;
		int x;

		/* Picture mode */
		if (bw->o.picture && bw->cursor->xcol!=piscol(bw->cursor))
			pfill(bw->cursor,bw->cursor->xcol,' '); /* Why no tabs? */

		/* UTF8 decoder */
		if(locale_map->type && !no_decode) {
			int utf8_char = utf8_decode(&utype_utf8_sm,k);

			if(utf8_char >= 0)
				k = utf8_char;
			else
				return 0;
		}

		upd = bw->parent->t->t->updtab[bw->y + bw->cursor->line - bw->top->line];
		simple = 1;

		if (pisblank(bw->cursor))
			while (piscol(bw->cursor) < bw->o.lmargin) {
				binsc(bw->cursor, ' ');
				pgetc(bw->cursor);
			}

		if (!no_decode) {
			if(locale_map->type && !bw->b->o.charmap->type) {
				unsigned char buf[10];
				utf8_encode(buf,k);
				k = from_utf8(bw->b->o.charmap,buf);
			} else if(!locale_map->type && bw->b->o.charmap->type) {
				unsigned char buf[10];
				to_utf8(locale_map,buf,k);
				k = utf8_decode_string(buf);
			}
		}
		
		binsc(bw->cursor, k);

		/* We need x position before we move cursor */
		x = piscol(bw->cursor) - bw->offset;
		pgetc(bw->cursor);

		/* Tabs are weird here... */
		if (bw->o.overtype && !piseol(bw->cursor) && k != '\t')
			udelch(bw);

		/* Not sure if we're in right position for wordwrap when we're in overtype mode */
		if (bw->o.wordwrap && piscol(bw->cursor) > bw->o.rmargin && !joe_isblank(map,k)) {
			wrapword(bw, bw->cursor, (long) bw->o.lmargin, bw->o.french, 0, NULL);
			simple = 0;
		}

		bw->cursor->xcol = piscol(bw->cursor);
#ifndef __MSDOS__
		if (x < 0 || x >= bw->w)
			simple = 0;
		if (bw->cursor->line < bw->top->line || bw->cursor->line >= bw->top->line + bw->h)
			simple = 0;
		if (simple && bw->parent->t->t->sary[bw->y + bw->cursor->line - bw->top->line])
			simple = 0;
		if (simple && k != '\t' && k != '\n' && !curmacro) {
			int atr;
			SCRN *t = bw->parent->t->t;
			int y = bw->y + bw->cursor->line - bw->top->line;
			int *screen = t->scrn + y * t->co;
			int *attr = t->attr + y * t->co;
			x += bw->x;

			atr = BG_COLOR(bg_text);

			if (!upd && piseol(bw->cursor) && !bw->o.highlight)
				t->updtab[y] = 0;
			if (markb &&
			    markk &&
			    markb->b == bw->b &&
			    markk->b == bw->b &&
			   ((!square && bw->cursor->byte >= markb->byte && bw->cursor->byte < markk->byte) ||
			    ( square && bw->cursor->line >= markb->line && bw->cursor->line <= markk->line && piscol(bw->cursor) >= markb->xcol && piscol(bw->cursor) < markk->xcol)))
				atr |= INVERSE;
			outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, k, atr);
		}
#endif
	}
	return 0;
}

int utypebw(BW *bw, int k)
{
	return utypebw_raw(bw, k, 0);
}

/* Quoting */

static B *unicodehist = NULL;	/* History of previously entered unicode characters */

int quotestate;
int quoteval;

int uquote(BW *bw)
{
	unsigned char buf[40];
	int c;

	quotestate = 0;
	c = query(bw->parent, sz(joe_gettext(_("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"))), QW_STAY);
	if (c == -1)
		return -1;

	again:

	if (c < 0 || c >= 256) {
		nungetc(c);
		return -1;
	}
	switch (quotestate) {
	case 0:
		if (c >= '0' && c <= '9') {
			quoteval = c - '0';
			quotestate = 1;
			joe_snprintf_1(buf, sizeof(buf), "ASCII %c--", c);
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		} else if (c == 'x' || c == 'X') {
			if (bw->b->o.charmap->type) {
				unsigned char *s = ask(bw->parent, joe_gettext(_("Unicode (ISO-10646) character in hex (^C to abort): ")), &unicodehist, NULL, utypebw, locale_map, 0, 0, NULL);
				if (s) {
					int num;
					sscanf((char *)s,"%x",(unsigned *)&num);
					utypebw_raw(bw, num, 1);
					bw->cursor->xcol = piscol(bw->cursor);
					return 0;
				} else
					return -1;
			} else {
				quotestate = 3;
				c = query(bw->parent, sc("ASCII 0x--"), QW_STAY);
				if (c == -1)
					return -1;
				else
					goto again;
			}
		} else if (c == 'o' || c == 'O') {
			quotestate = 5;
			c = query(bw->parent, sc("ASCII 0---"), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		} else {
			if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
				c &= 0x1F;
			if (c == '?')
				c = 127;
			utypebw_raw(bw, c, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	case 1:
		if (c >= '0' && c <= '9') {
			joe_snprintf_2(buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
			quoteval = quoteval * 10 + c - '0';
			quotestate = 2;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		}
		break;
	case 2:
		if (c >= '0' && c <= '9') {
			quoteval = quoteval * 10 + c - '0';
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	case 3:
		if (c >= '0' && c <= '9') {
			joe_snprintf_1(buf, sizeof(buf), "ASCII 0x%c-", c);
			quoteval = c - '0';
			quotestate = 4;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		} else if (c >= 'a' && c <= 'f') {
			joe_snprintf_1(buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
			quoteval = c - 'a' + 10;
			quotestate = 4;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		} else if (c >= 'A' && c <= 'F') {
			joe_snprintf_1(buf, sizeof(buf), "ASCII 0x%c-", c);
			quoteval = c - 'A' + 10;
			quotestate = 4;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		}
		break;
	case 4:
		if (c >= '0' && c <= '9') {
			quoteval = quoteval * 16 + c - '0';
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		} else if (c >= 'a' && c <= 'f') {
			quoteval = quoteval * 16 + c - 'a' + 10;
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		} else if (c >= 'A' && c <= 'F') {
			quoteval = quoteval * 16 + c - 'A' + 10;
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	case 5:
		if (c >= '0' && c <= '7') {
			joe_snprintf_1(buf, sizeof(buf), "ASCII 0%c--", c);
			quoteval = c - '0';
			quotestate = 6;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		}
		break;
	case 6:
		if (c >= '0' && c <= '7') {
			joe_snprintf_2(buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
			quoteval = quoteval * 8 + c - '0';
			quotestate = 7;
			c = query(bw->parent, sz(buf), QW_STAY);
			if (c == -1)
				return -1;
			else
				goto again;
		}
		break;
	case 7:
		if (c >= '0' && c <= '7') {
			quoteval = quoteval * 8 + c - '0';
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	}
	return 0;
}

int uquote8(BW *bw)
{
	int c;
	c = query(bw->parent, sc("Meta-"), QW_STAY);
	if (c == -1)
		return -1;
	if (c == '`') {
		c = query(bw->parent, sc("Meta-Ctrl-"), QW_STAY);
		if (c == -1)
			return -1;
		if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
			c &= 0x1F;
		if (c == '?')
			c = 127;
	}
	c |= 128;
	utypebw_raw(bw, c, 1);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;

}

int uctrl(BW *bw)
{
	int c;
	int org;
	c = query(bw->parent, sz(joe_gettext(_("Quote"))), QW_STAY);
	if (c == -1)
		return -1;
	org = bw->o.overtype;
	bw->o.overtype = 0;
	if (bw->parent->huh == srchstr && c == '\n') {
		utypebw(bw, '\\');
		utypebw(bw, 'n');
	} else
		utypebw_raw(bw, c, 1);
	bw->o.overtype = org;
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

/* User hit Return.  Deal with autoindent.
 */

int rtntw(BW *bw)
{
	if (bw->o.overtype) {
		p_goto_eol(bw->cursor);
		if (piseof(bw->cursor))
			binsc(bw->cursor, '\n');
		pgetc(bw->cursor);
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		P *p = pdup(bw->cursor, USTR "rtntw");
		unsigned char c;

		binsc(bw->cursor, '\n'), pgetc(bw->cursor);
		/* Suppress autoindent if we're on a space or tab... */
		if (bw->o.autoindent /* && (brch(bw->cursor)!=' ' && brch(bw->cursor)!='\t')*/) {
			p_goto_bol(p);
			while (joe_isspace(bw->b->o.charmap,(c = pgetc(p))) && c != '\n') {
				binsc(bw->cursor, c);
				pgetc(bw->cursor);
			}
		}
		prm(p);
		bw->cursor->xcol = piscol(bw->cursor);
	}
	return 0;
}

/* Open a line */

int uopen(BW *bw)
{
	binsc(bw->cursor,'\n');
	if (bw->o.autoindent && (brch(bw->cursor)!=' ' && brch(bw->cursor)!='\t')) {
		P *p = pdup(bw->cursor, USTR "uopen");
		P *q = pdup(p, USTR "uopen");
		int c;
		pgetc(q);
		p_goto_bol(p);
		while (joe_isspace(bw->b->o.charmap,(c = pgetc(p))) && c != '\n') {
			binsc(q, c);
			pgetc(q);
		}
		prm(p); prm(q);
	}
	
	return 0;
}

/* Set book-mark */

int usetmark(BW *bw, int c)
{
	if (c < '0' || c > ':') {
		c = query(bw->parent, sz(joe_gettext(_("Set mark (0-9):"))), QW_STAY);
		if (c == -1)
			return -1;
		if (c < '0' || c > ':') {
			nungetc(c);
			return -1;
		}
	}
	pdupown(bw->cursor, bw->b->marks + c - '0', USTR "dosetmark");
	poffline(bw->b->marks[c - '0']);
	if (c!=':') {
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Mark %d set")), c - '0'));
	}
	return 0;
}

/* Goto book-mark */

int ugomark(BW *bw, int c)
{
	if (c < '0' || c > ':') {
		c = query(bw->parent, sz(joe_gettext(_("Set mark (0-9):"))), QW_STAY);
		if (c == -1)
			return -1;
		if (c < '0' || c > ':') {
			nungetc(c);
			return -1;
		}
	}
	if (bw->b->marks[c - '0']) {
		pset(bw->cursor, bw->b->marks[c - '0']);
		bw->cursor->xcol = piscol(bw->cursor);
		return 0;
	} else {
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Mark %d not set")), c - '0'));
		return -1;
	}
}

/* Goto next instance of character */

int ufwrdc(BW *bw, int k)
{
	int c;
	P *q;
	if (k < 0 || k >= 256) {
		k = query(bw->parent, sz(joe_gettext(_("Forward to char: "))), QW_STAY);
		if (k < 0 || k >= 256) {
			nungetc(k);
			return -1;
		}
	}
	q = pdup(bw->cursor, USTR "dofwrdc");
	while ((c = pgetc(q)) != NO_MORE_DATA)
		if (c == k)
			break;
	if (c == NO_MORE_DATA) {
		msgnw(bw->parent, joe_gettext(_("Not found")));
		prm(q);
		return -1;
	} else {
		pset(bw->cursor, q);
		bw->cursor->xcol = piscol(bw->cursor);
		prm(q);
		return 0;
	}
}

int ubkwdc(BW *bw, int k)
{
	int c;
	P *q;
	if (k < 0 || k >= 256) {
		k = query(bw->parent, sz(joe_gettext(_("Backward to char: "))), QW_STAY);
		if (k < 0 || k >= 256) {
			nungetc(k);
			return -1;
		}
	}
	q = pdup(bw->cursor, USTR "dofwrdc");
	while ((c = prgetc(q)) != NO_MORE_DATA)
		if (c == k)
			break;
	if (c == NO_MORE_DATA) {
		msgnw(bw->parent, joe_gettext(_("Not found")));
		prm(q);
		return -1;
	} else {
		pset(bw->cursor, q);
		bw->cursor->xcol = piscol(bw->cursor);
		prm(q);
		return 0;
	}
}

/* Display a message */

int umsg(BASE *b)
{
	unsigned char *s;
	s = ask(b->parent, joe_gettext(_("Message (^C to abort): ")), NULL,
	        NULL, NULL, locale_map, 0, 0, NULL);

	if (!s)
		return -1;

	msgnw(b->parent, s);
	return 0;
}

/* Insert text */

int utxt(BW *bw)
{
	int x, fill;
	unsigned char *s;

	s = ask(bw->parent, joe_gettext(_("Insert (^C to abort): ")),
	        NULL, NULL, utypebw, bw->b->o.charmap, 0, 0, NULL);

	if (s[0] == '`') {
		unsigned char *str = vsmk(1024);
		fill = ' ';
		str = stagen(str, bw, &s[1], fill);
		if (str) {
			for (x = 0; x != vslen(str); ++x)
				utypebw(bw, str[x]);
		}
	} else {
		for (x = 0; x != vslen(s); ++x)
			utypebw(bw, s[x]);
	}

	return 0;
}

/* Insert current file name */

int uname_joe(BW *bw)
{
	unsigned char *s;
	W *w=bw->parent->main;
	s=((BW *)w->object)->b->name;
	if (!s || !*s)
		return -1;
	while (*s)
		if (utypebw(bw,*s++))
			return -1;
	return 0;
}

/* Insert until non-base64 character received */

int upaste(BW  *bw, int k)
{
	int c;
	int accu = 0;
	int count;
	int tmp_ww = bw->o.wordwrap;
	int tmp_ai = bw->o.autoindent;

	bw->o.wordwrap = 0;
	bw->o.autoindent = 0;
	count = 0;

	/* We have to wait for the second ';' */
	while ((c = ttgetc()) != -1)
		if (c == ';')
			break;
	if (c == -1)
		goto bye;

	while ((c = ttgetc()) != -1) {
		if (c >= 'A' && c <= 'Z')
			c = c - 'A';
		else if (c >= 'a' && c <= 'z')
			c = c - 'a' + 26;
		else if (c >= '0' && c <= '9')
			c = c - '0' + 52;
		else if (c == '+')
			c = 62;
		else if (c == '/')
			c = 63;
		else if (c == '=')
			continue;
		else
			break;

		switch (count) {
			case 0:
				accu = c;
				count = 6;
				break;
			case 2:
				accu = (accu << 6) + c;
				if (accu == 13)
					rtntw(bw);
				else
					utypebw(bw, accu);
				count = 0;
				break;
			case 4:
				accu = (accu << 4) + (c >> 2);
				if (accu == 13)
					rtntw(bw);
				else
					utypebw(bw, accu);
				accu = (c & 0x3);
				count = 2;
				break;
			case 6:
				accu = (accu << 2) + (c >> 4);
				if (accu == 13)
					rtntw(bw);
				else
					utypebw(bw, accu);
				accu = (c & 0xF);
				count = 4;
				break;
		}
	}
	/* Terminator is ESC \ */
	if (c == 033) {
		ttgetc();
	}

	bye:

	bw->o.wordwrap = tmp_ww;
	bw->o.autoindent = tmp_ai;

	return 0;
}
@


1.111
log
@C++ and C comment fixed for co-routine version.
@
text
@d1546 1
a1546 1
		} else if (col<indent && !pisbol(bw->cursor)) {
@


1.110
log
@fix paragraph format when overtype is one
@
text
@d584 1
a584 1
				if (c == '*') {
d592 1
a592 1
				} else if (c == '/') {
d980 1
a980 1
				} else if (d == '/') {
@


1.109
log
@Add -no_double_quoted and -tex_comment
@
text
@d1835 1
a1835 1
			wrapword(bw, bw->cursor, (long) bw->o.lmargin, bw->o.french, NULL);
@


1.108
log
@Fix LUA and infinite loop with ^G
@
text
@d431 1
a431 1
			} else if (c == '"') {
d465 1
a465 1
			            bw->o.semi_comment || bw->o.vhdl_comment) && c == '\n') {
d472 1
a472 1
					} else if(cc=='"') {
d498 3
d565 1
a565 1
			} else if (c == '"') {
d573 1
d955 1
a955 1
			} else if (d == '"') {
d965 1
d1009 1
a1009 1
			} else if (d == '"') {
d1033 1
a1033 1
			            bw->o.semi_comment || bw->o.vhdl_comment) && d == '\n') {
d1043 1
a1043 1
					} else if(cc=='"') {
d1073 3
@


1.107
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d1035 3
d1042 2
d1054 2
@


1.106
log
@More work on coroutine refactoring.
@
text
@d2242 1
a2242 1
	int x;
d2248 12
a2259 2
	for (x = 0; x != vslen(s); ++x)
		utypebw(bw, s[x]);
@


1.105
log
@more refactoring
@
text
@d1870 1
a1870 1
static int doquote(BW *bw, int c, void *object, int *notify)
d1873 8
d1892 2
a1893 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d1896 1
a1896 1
				return 0;
a1902 2
					/* if (notify)
						*notify = 1; */
d1910 2
a1911 1
				if (!mkqwna(bw->parent, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
d1914 1
a1914 1
					return 0;
d1918 2
a1919 1
			if (!mkqwna(bw->parent, sc("ASCII 0---"), doquote, NULL, NULL, notify))
d1922 1
a1922 1
				return 0;
d1937 2
a1938 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d1941 1
a1941 1
				return 0;
d1956 2
a1957 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d1960 1
a1960 1
				return 0;
d1965 2
a1966 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d1969 1
a1969 1
				return 0;
d1974 2
a1975 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d1978 1
a1978 1
				return 0;
d2001 2
a2002 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d2005 1
a2005 1
				return 0;
d2013 2
a2014 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d2017 1
a2017 1
				return 0;
a2027 2
	if (notify)
		*notify = 1;
d2031 1
a2031 1
int uquote(BW *bw)
d2033 3
a2035 4
	quotestate = 0;
	if (mkqwna(bw->parent, sz(joe_gettext(_("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"))), doquote, NULL, NULL, NULL))
		return 0;
	else
a2036 18
}

static int doquote9(BW *bw, int c, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
		c &= 0x1F;
	if (c == '?')
		c = 127;
	c |= 128;
	utypebw_raw(bw, c, 1);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

static int doquote8(BW *bw, int c, void *object, int *notify)
{
d2038 2
a2039 3
		if (mkqwna(bw->parent, sc("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
			return 0;
		else
d2041 4
a2045 2
	if (notify)
		*notify = 1;
d2050 1
d2053 1
a2053 1
int uquote8(BW *bw)
d2055 4
a2058 3
	if (mkqwna(bw->parent, sc("Meta-"), doquote8, NULL, NULL, NULL))
		return 0;
	else
d2060 1
a2060 8
}

static int doctrl(BW *bw, int c, void *object, int *notify)
{
	int org = bw->o.overtype;

	if (notify)
		*notify = 1;
a2071 8
int uctrl(BW *bw)
{
	if (mkqwna(bw->parent, sz(joe_gettext(_("Quote"))), doctrl, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

d2125 1
a2125 1
static int dosetmark(BW *bw, int c, void *object, int *notify)
d2127 7
a2133 7
	if (notify)
		*notify = 1;
	if (c >= '0' && c <= ':') {
		pdupown(bw->cursor, bw->b->marks + c - '0', USTR "dosetmark");
		poffline(bw->b->marks[c - '0']);
		if (c!=':') {
			msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Mark %d set")), c - '0'));
a2134 4
		return 0;
	} else {
		nungetc(c);
		return -1;
d2136 6
a2141 10
}

int usetmark(BW *bw, int c)
{
	if (c >= '0' && c <= ':')
		return dosetmark(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sz(joe_gettext(_("Set mark (0-9):"))), dosetmark, NULL, NULL, NULL))
		return 0;
	else
		return -1;
d2146 1
a2146 1
static int dogomark(BW *bw, int c, void *object, int *notify)
d2148 6
a2153 9
	if (notify)
		*notify = 1;
	if (c >= '0' && c <= ':')
		if (bw->b->marks[c - '0']) {
			pset(bw->cursor, bw->b->marks[c - '0']);
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else {
			msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("Mark %d not set")), c - '0'));
d2155 6
d2162 1
a2162 1
		nungetc(c);
a2166 10
int ugomark(BW *bw, int c)
{
	if (c >= '0' && c <= '9')
		return dogomark(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sz(joe_gettext(_("Goto bookmark (0-9):"))), dogomark, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

d2169 1
a2169 3
static int dobkwdc;

static int dofwrdc(BW *bw, int k, void *object, int *notify)
a2172 3

	if (notify)
		*notify = 1;
d2174 5
a2178 2
		nungetc(k);
		return -1;
d2181 3
a2183 9
	if (dobkwdc) {
		while ((c = prgetc(q)) != NO_MORE_DATA)
			if (c == k)
				break;
	} else {
		while ((c = pgetc(q)) != NO_MORE_DATA)
			if (c == k)
				break;
	}
d2196 1
a2196 1
int ufwrdc(BW *bw, int k)
d2198 16
a2213 6
	dobkwdc = 0;
	if (k >= 0 && k < 256)
		return dofwrdc(bw, k, NULL, NULL);
	else if (mkqw(bw->parent, sz(joe_gettext(_("Forward to char: "))), dofwrdc, NULL, NULL, NULL))
		return 0;
	else
d2215 4
a2218 8
}

int ubkwdc(BW *bw, int k)
{
	dobkwdc = 1;
	if (k >= 0 && k < 256)
		return dofwrdc(bw, k, NULL, NULL);
	else if (mkqw(bw->parent, sz(joe_gettext(_("Backward to char: "))), dofwrdc, NULL, NULL, NULL))
d2220 1
a2220 2
	else
		return -1;
@


1.104
log
@fix tags.
switch more wmkpw to ask
@
text
@d1373 1
a1373 1
	        NULL, NULL, NULL, locale_map, 0, 0, NULL);
d1409 1
a1409 1
	        NULL, NULL, NULL, locale_map, 0, 0, NULL);
d1443 1
a1443 1
	        NULL, NULL, NULL, locale_map, 0, 0, NULL);
d1890 1
a1890 1
				unsigned char *s = ask(bw->parent, joe_gettext(_("Unicode (ISO-10646) character in hex (^C to abort): ")), &unicodehist, NULL, utypebw, NULL, locale_map, 0, 0, NULL);
d2265 1
a2265 1
	        NULL, NULL, NULL, locale_map, 0, 0, NULL);
d2282 1
a2282 1
	        NULL, NULL, utypebw, NULL, bw->b->o.charmap, 0, 0, NULL);
@


1.103
log
@fix obj_stack leak during coroutine switch
@
text
@a1866 11
static int dounicode(BW *bw, unsigned char *s, void *object, int *notify)
{
	int num;
	sscanf((char *)s,"%x",(unsigned  *)&num);
	if (notify)
		*notify = 1;
	utypebw_raw(bw, num, 1);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

d1890 8
a1897 2
				if (!wmkpw(bw->parent, joe_gettext(_("Unicode (ISO-10646) character in hex (^C to abort): ")), &unicodehist, dounicode,
				           NULL, NULL, NULL, NULL, NULL, locale_map, 0))
d1899 1
a1899 1
				else
@


1.102
log
@use ask() more
@
text
@d1373 1
a1373 1
	        NULL, NULL, NULL, locale_map, 0);
d1409 1
a1409 1
	        NULL, NULL, NULL, locale_map, 0);
d1443 1
a1443 1
	        NULL, NULL, NULL, locale_map, 0);
d2270 1
a2270 1
	        NULL, NULL, NULL, locale_map, 0);
d2287 1
a2287 1
	        NULL, NULL, utypebw, NULL, bw->b->o.charmap, 0);
@


1.101
log
@coroutines
@
text
@d1367 1
a1367 1
static int doline(BW *bw, unsigned char *s, void *object, int *notify)
d1369 10
a1378 1
	long num = calc(bw, s);
a1379 2
	if (notify)
		*notify = 1;
a1398 8
int uline(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Go to line (^C to abort): ")), &linehist, doline, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
		return 0;
	else
		return -1;
}

d1403 1
a1403 1
static int docol(BW *bw, unsigned char *s, void *object, int *notify)
d1405 10
a1414 1
	long num = calc(bw, s);
a1415 2
	if (notify)
		*notify = 1;
a1432 8
int ucol(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Go to column (^C to abort): ")), &colhist, docol, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
		return 0;
	else
		return -1;
}

d1437 1
a1437 1
static int dobyte(BW *bw, unsigned char *s, void *object, int *notify)
d1439 7
a1445 1
	long num = calc(bw, s);
a1446 2
	if (notify)
		*notify = 1;
a1463 8
int ubyte(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Go to byte (^C to abort): ")), &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
		return 0;
	else
		return -1;
}

d2266 1
a2266 1
static int domsg(BASE *b, unsigned char *s, void *object, int *notify)
d2268 3
a2270 5
	if (notify)
		*notify = 1;
	msgnw(b->parent, s);
	return 0;
}
d2272 1
a2272 5
int umsg(BASE *b)
{
	if (wmkpw(b->parent, joe_gettext(_("Message (^C to abort): ")), NULL, domsg, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
		return 0;
	else
a2273 1
}
d2275 1
a2275 11
/* Insert text */

/*
static int dotxt(BW *bw, unsigned char *s, void *object, int *notify)
{
	int x;

	if (notify)
		*notify = 1;
	for (x = 0; x != vslen(s); ++x)
		utypebw(bw, s[x]);
d2279 1
a2279 8
int utxt(BW *bw)
{
	if (wmkpw(bw->parent, joe_gettext(_("Insert (^C to abort): ")), NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.charmap, 0))
		return 0;
	else
		return -1;
}
*/
@


1.100
log
@semiautomatic variables
@
text
@d2290 1
d2309 15
@


1.99
log
@UC -> USTR
@
text
@a1372 1
	vsrm(s);
a1409 1
	vsrm(s);
a1444 1
	vsrm(s);
a1878 1
	vsrm(s);
d2162 1
a2162 2
			joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Mark %d set")), c - '0');
			msgnw(bw->parent, msgbuf);
d2193 1
a2193 2
			joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("Mark %d not set")), c - '0');
			msgnw(bw->parent, msgbuf);
d2276 1
a2276 3
	zcpy(msgbuf, s);
	vsrm(s);
	msgnw(b->parent, msgbuf);
d2296 1
a2296 1
	for (x = 0; x != sLEN(s); ++x)
a2297 1
	vsrm(s);
@


1.98
log
@change US to UC
@
text
@d39 1
a39 1
	p = pdup(bw->cursor, UC "uhome");
d166 1
a166 1
	P *p = pdup(ptr, UC "p_goto_prev");
d201 1
a201 1
	P *p = pdup(ptr, UC "p_goto_next");
d246 1
a246 1
	q = pdup(p, UC "pisedge");
d419 1
a419 1
		P *p=pdup(bw->cursor, UC "tomatch_word");
d466 1
a466 1
				P *q = pdup(p, UC "tomatch_word");
d512 1
a512 1
				q=pdup(p, UC "tomatch_word");
d553 1
a553 1
		P *p=pdup(bw->cursor, UC "tomatch_word");
d629 1
a629 1
					if (bw->o.vhdl_comment && (!zcmp(buf,UC "end") || !zcmp(buf,UC "END")))
d647 1
a647 1
	p=pdup(p, UC "xml_startend");
d664 1
a664 1
		P *p=pdup(bw->cursor, UC "tomatch_xml");
d707 1
a707 1
		P *p=pdup(bw->cursor, UC "tomatch_xml");
d756 1
a756 1
	p=pdup(p, UC "get_xml_name");
d772 1
a772 1
	P *p=pdup(q, UC "get_delim_name");
d781 1
a781 1
	p=pdup(q, UC "get_delim_name");
d811 1
a811 1
		p=pdup(bw->cursor, UC "utomatch");
d908 1
a908 1
		P *p = pdup(bw->cursor, UC "utomatch");
d943 1
a943 1
		P *p = pdup(bw->cursor, UC "utomatch");
d991 1
a991 1
		P *p = pdup(bw->cursor, UC "utomatch");
d1029 1
a1029 1
				P *q = pdup(p, UC "utomatch");
d1483 1
a1483 1
	pgetc(p = pdup(bw->cursor, UC "udelch"));
d1533 1
a1533 1
			p = pdup(bw->cursor, UC "ubacks");
d1544 1
a1544 1
			P *p = pdup(bw->cursor, UC "ubacks");
d1554 1
a1554 1
			P *p = pdup(bw->cursor, UC "ubacks");
d1574 1
a1574 1
	P *p = pdup(bw->cursor, UC "u_word_delete");
d1602 1
a1602 1
	P *p = pdup(bw->cursor, UC "ubackw");
d1632 1
a1632 1
	P *p = p_goto_eol(pdup(bw->cursor, UC "udelel"));
d1649 1
a1649 1
	P *p = p_goto_bol(pdup(bw->cursor, UC "udelbl"));
d1664 1
a1664 1
	P *p = pdup(bw->cursor, UC "udelln");
d1727 1
a1727 1
		pgetb(p = pdup(bw->cursor, UC "utypebw_raw"));
d1745 1
a1745 1
		P *p = pdup(bw->cursor, UC "utypebw_raw");
d2117 1
a2117 1
		P *p = pdup(bw->cursor, UC "rtntw");
d2141 2
a2142 2
		P *p = pdup(bw->cursor, UC "uopen");
		P *q = pdup(p, UC "uopen");
d2163 1
a2163 1
		pdupown(bw->cursor, bw->b->marks + c - '0', UC "dosetmark");
d2232 1
a2232 1
	q = pdup(bw->cursor, UC "dofwrdc");
@


1.97
log
@transpose menus
@
text
@d39 1
a39 1
	p = pdup(bw->cursor, US "uhome");
d166 1
a166 1
	P *p = pdup(ptr, US "p_goto_prev");
d201 1
a201 1
	P *p = pdup(ptr, US "p_goto_next");
d246 1
a246 1
	q = pdup(p, US "pisedge");
d419 1
a419 1
		P *p=pdup(bw->cursor, US "tomatch_word");
d466 1
a466 1
				P *q = pdup(p, US "tomatch_word");
d512 1
a512 1
				q=pdup(p, US "tomatch_word");
d553 1
a553 1
		P *p=pdup(bw->cursor, US "tomatch_word");
d629 1
a629 1
					if (bw->o.vhdl_comment && (!zcmp(buf,US "end") || !zcmp(buf,US "END")))
d647 1
a647 1
	p=pdup(p, US "xml_startend");
d664 1
a664 1
		P *p=pdup(bw->cursor, US "tomatch_xml");
d707 1
a707 1
		P *p=pdup(bw->cursor, US "tomatch_xml");
d756 1
a756 1
	p=pdup(p, US "get_xml_name");
d772 1
a772 1
	P *p=pdup(q, US "get_delim_name");
d781 1
a781 1
	p=pdup(q, US "get_delim_name");
d811 1
a811 1
		p=pdup(bw->cursor, US "utomatch");
d908 1
a908 1
		P *p = pdup(bw->cursor, US "utomatch");
d943 1
a943 1
		P *p = pdup(bw->cursor, US "utomatch");
d991 1
a991 1
		P *p = pdup(bw->cursor, US "utomatch");
d1029 1
a1029 1
				P *q = pdup(p, US "utomatch");
d1483 1
a1483 1
	pgetc(p = pdup(bw->cursor, US "udelch"));
d1533 1
a1533 1
			p = pdup(bw->cursor, US "ubacks");
d1544 1
a1544 1
			P *p = pdup(bw->cursor, US "ubacks");
d1554 1
a1554 1
			P *p = pdup(bw->cursor, US "ubacks");
d1574 1
a1574 1
	P *p = pdup(bw->cursor, US "u_word_delete");
d1602 1
a1602 1
	P *p = pdup(bw->cursor, US "ubackw");
d1632 1
a1632 1
	P *p = p_goto_eol(pdup(bw->cursor, US "udelel"));
d1649 1
a1649 1
	P *p = p_goto_bol(pdup(bw->cursor, US "udelbl"));
d1664 1
a1664 1
	P *p = pdup(bw->cursor, US "udelln");
d1727 1
a1727 1
		pgetb(p = pdup(bw->cursor, US "utypebw_raw"));
d1745 1
a1745 1
		P *p = pdup(bw->cursor, US "utypebw_raw");
d2117 1
a2117 1
		P *p = pdup(bw->cursor, US "rtntw");
d2141 2
a2142 2
		P *p = pdup(bw->cursor, US "uopen");
		P *q = pdup(p, US "uopen");
d2163 1
a2163 1
		pdupown(bw->cursor, bw->b->marks + c - '0', US "dosetmark");
d2232 1
a2232 1
	q = pdup(bw->cursor, US "dofwrdc");
@


1.96
log
@gettext()
@
text
@d1829 1
a1829 1
			wrapword(bw->cursor, (long) bw->o.lmargin, bw->o.french, NULL);
@


1.95
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d1388 1
a1388 1
			msgnw(bw->parent, US "Invalid line number");
d1395 1
a1395 1
	if (wmkpw(bw->parent, US "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
d1424 1
a1424 1
			msgnw(bw->parent, US "Invalid column number");
d1431 1
a1431 1
	if (wmkpw(bw->parent, US "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
d1460 1
a1460 1
			msgnw(bw->parent, US "Invalid byte number");
d1467 1
a1467 1
	if (wmkpw(bw->parent, US "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
d1904 1
a1904 1
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII %c--", c);
d1911 1
a1911 1
				if (!wmkpw(bw->parent, US "Unicode (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
d1940 1
a1940 1
			joe_snprintf_2((char *)buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
d1958 1
a1958 1
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
d1966 1
a1966 1
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
d1974 1
a1974 1
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
d2000 1
a2000 1
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0%c--", c);
d2011 1
a2011 1
			joe_snprintf_2((char *)buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
d2036 1
a2036 1
	if (mkqwna(bw->parent, sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"), doquote, NULL, NULL, NULL))
d2099 1
a2099 1
	if (mkqwna(bw->parent, sc("Quote"), doctrl, NULL, NULL, NULL))
d2166 1
a2166 1
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d set", c - '0');
d2180 1
a2180 1
	else if (mkqwna(bw->parent, sc("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
d2198 1
a2198 1
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d not set", c - '0');
d2211 1
a2211 1
	else if (mkqwna(bw->parent, sc("Goto bookmark (0-9):"), dogomark, NULL, NULL, NULL))
d2243 1
a2243 1
		msgnw(bw->parent, US "Not found");
d2259 1
a2259 1
	else if (mkqw(bw->parent, sc("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
d2270 1
a2270 1
	else if (mkqw(bw->parent, sc("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
d2290 1
a2290 1
	if (wmkpw(b->parent, US "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL, locale_map, 0))
d2312 1
a2312 1
	if (wmkpw(bw->parent, US "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.charmap, 0))
@


1.94
log
@Match JOE to working Xterm-212
@
text
@a7 1
#include "config.h"
a9 19
#include <stdio.h>

#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "pw.h"
#include "qw.h"
#include "scrn.h"
#include "ublock.h"
#include "uformat.h"
#include "umath.h"
#include "usearch.h"
#include "utils.h"
#include "vs.h"
#include "utf8.h"
#include "charmap.h"
#include "w.h"

a13 6
extern WATOM watommenu;

/******** i don't like global var ******/

extern int bg_text;

d111 2
a112 1
		}
a422 1
		int state = 0;
d501 1
a501 1
			} else if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c>='0' && c<='9' || c=='_') {
d506 1
a506 1
				while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9') {
a556 1
		int state = 0;
d568 3
a570 3
			} else if (bw->o.pound_comment && c == '#' ||
				   bw->o.semi_comment && c == ';' ||
				   bw->o.vhdl_comment && c == '-' && brch(p) == '-') {
d604 1
a604 1
			} else if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_') {
d607 1
a607 1
				while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9') {
d619 1
a619 1
						if (!(buf[0]>='a' && buf[0]<='z' || buf[0]>='A' && buf[0]<='Z'))
a667 1
		int state = 0;
d672 1
a672 1
			if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c>='0' && c<='9' || c=='.' || c==':' || c=='-' || c=='_') {
d675 1
a675 1
				while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9' || c=='.' ||
a710 1
		int state = 0;
d720 1
a720 1
				if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c=='_' || c==':' || c=='-' || c=='.') {
d722 2
a723 2
					while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c==':' || c=='-' || c=='.' ||
					       c >= '0' && c <= '9') {
d758 2
a759 2
	while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c==':' || c=='-' || c=='.' ||
	       c >= '0' && c <= '9') {
d783 1
a783 1
	while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c >= '0' && c <= '9') {
d802 2
a803 2
	if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_') {
		P *q, *p;
d959 3
a961 3
			} else if (bw->o.pound_comment && d == '#' ||
				   bw->o.semi_comment && d == ';' ||
				   bw->o.vhdl_comment && d == '-' && brch(p) == '-') {
a1285 2
extern int menu_above;

a1494 1
		P *p;
a1499 1
		int pure = 1;
a1530 1
			int x;
d1737 1
a1737 1
		if (!bw->o.picture && piseol(bw->cursor) && piscol(bw->cursor)<col)	/* We moved past end of line, insert a tab (unless in picture mode) */
d1742 1
a1841 1
			int a;
a1842 1
			unsigned char c = k;
d1879 1
a1879 1
	sscanf((char *)s,"%x",&num);
a2079 2
extern unsigned char srchstr[];

d2338 1
a2338 1
	int accu;
@


1.93
log
@add joe_debug
@
text
@d2384 7
d2444 3
@


1.92
log
@Fix pgup/pgdn to work with menu_above
@
text
@d65 1
a65 1
	p = pdup(bw->cursor);
d191 1
a191 1
	P *p = pdup(ptr);
d226 1
a226 1
	P *p = pdup(ptr);
d271 1
a271 1
	q = pdup(p);
d444 1
a444 1
		P *p=pdup(bw->cursor);
d492 1
a492 1
				P *q = pdup(p);
d538 1
a538 1
				q=pdup(p);
d579 1
a579 1
		P *p=pdup(bw->cursor);
d674 1
a674 1
	p=pdup(p);
d691 1
a691 1
		P *p=pdup(bw->cursor);
d735 1
a735 1
		P *p=pdup(bw->cursor);
d785 1
a785 1
	p=pdup(p);
d801 1
a801 1
	P *p=pdup(q);
d810 1
a810 1
	p=pdup(q);
d840 1
a840 1
		p=pdup(bw->cursor);
d937 1
a937 1
		P *p = pdup(bw->cursor);
d972 1
a972 1
		P *p = pdup(bw->cursor);
d1020 1
a1020 1
		P *p = pdup(bw->cursor);
d1058 1
a1058 1
				P *q = pdup(p);
d1514 1
a1514 1
	pgetc(p = pdup(bw->cursor));
d1567 1
a1567 1
			p = pdup(bw->cursor);
d1578 1
a1578 1
			P *p = pdup(bw->cursor);
d1588 1
a1588 1
			P *p = pdup(bw->cursor);
d1608 1
a1608 1
	P *p = pdup(bw->cursor);
d1636 1
a1636 1
	P *p = pdup(bw->cursor);
d1666 1
a1666 1
	P *p = p_goto_eol(pdup(bw->cursor));
d1683 1
a1683 1
	P *p = p_goto_bol(pdup(bw->cursor));
d1698 1
a1698 1
	P *p = pdup(bw->cursor);
d1761 1
a1761 1
		pgetb(p = pdup(bw->cursor));
d1778 1
a1778 1
		P *p = pdup(bw->cursor);
d2154 1
a2154 1
		P *p = pdup(bw->cursor);
d2178 2
a2179 2
		P *p = pdup(bw->cursor);
		P *q = pdup(p);
d2200 1
a2200 1
		pdupown(bw->cursor, bw->b->marks + c - '0');
d2269 1
a2269 1
	q = pdup(bw->cursor);
@


1.91
log
@Match to xterm's base64 patch
@
text
@d1315 2
d1319 8
a1326 2
	if (bw->parent->link.next->watom==&watommenu) {
		return umpgup(bw->parent->link.next->object);
d1345 8
a1352 2
	if (bw->parent->link.next->watom==&watommenu) {
		return umpgdn(bw->parent->link.next->object);
@


1.90
log
@Fix bugs with quoted input
@
text
@d2419 4
@


1.89
log
@Fix unicode entry bug
@
text
@d1728 1
a1728 1
int utypebw_raw(BW *bw, int k, int force_decode)
d1806 1
a1806 1
		if(locale_map->type || force_decode) {
d1824 1
a1824 1
		if (!force_decode) {
a1899 2
	unsigned char buf[8];
	int x;
d1904 1
a1904 3
	utf8_encode(buf,num);
	for(x=0;buf[x];++x)
		utypebw_raw(bw, buf[x], 1);
d1955 1
a1955 1
			utypebw(bw, c);
d1973 1
a1973 1
			utypebw(bw, quoteval);
d2007 1
a2007 1
			utypebw(bw, quoteval);
d2011 1
a2011 1
			utypebw(bw, quoteval);
d2015 1
a2015 1
			utypebw(bw, quoteval);
d2044 1
a2044 1
			utypebw(bw, quoteval);
d2072 1
a2072 1
	utypebw(bw, c);
d2088 1
a2088 1
	utypebw(bw, c);
d2114 1
a2114 1
		utypebw(bw, c);
@


1.88
log
@fix gcc-4.0.0 warnings
@
text
@d1728 1
a1728 1
int utypebw(BW *bw, int k)
d1806 1
a1806 1
		if(locale_map->type) {
d1824 10
a1833 8
		if(locale_map->type && !bw->b->o.charmap->type) {
			unsigned char buf[10];
			utf8_encode(buf,k);
			k = from_utf8(bw->b->o.charmap,buf);
		} else if(!locale_map->type && bw->b->o.charmap->type) {
			unsigned char buf[10];
			to_utf8(locale_map,buf,k);
			k = utf8_decode_string(buf);
d1888 5
d1908 1
a1908 1
		utypebw(bw, buf[x]);
@


1.87
log
@latest updates
@
text
@d656 1
a656 1
					if (bw->o.vhdl_comment && (!strcmp(buf,"end") || !strcmp(buf,"END")))
d717 1
a717 1
				if (!strcmp(word,buf) && !xml_startend(p)) {
d760 1
a760 1
					if (!strcmp(word,buf) && !xml_startend(p)) {
d2302 1
a2302 1
	strcpy((char *)msgbuf, (char *)s);
@


1.86
log
@new base64 encoded xterm-patch
@
text
@d2142 1
a2142 1
		if (bw->o.autoindent && (brch(bw->cursor)!=' ' && brch(bw->cursor)!='\t')) {
@


1.85
log
@fix mouse & hex bugs
@
text
@d2353 1
a2353 1
/* Insert until magic code: "ESC [ 2 0 1 ~" received */
a2356 2
	unsigned char buf[6];
	int buf_len = 0;
d2358 2
d2365 1
d2368 13
a2380 10
		if (buf_len == 6) {
			if (buf[0] == 13)
				rtntw(bw);
			else
				utypebw(bw, buf[0]);
			memmove(buf, buf+1, 5);
			buf[5] = c;
		} else
			buf[buf_len++] = c;
		if (buf_len == 6 && !strncmp((char *)buf, "\033[201~", 6)) {
d2382 32
a2415 1

@


1.84
log
@XTerm hack.
@
text
@d2368 1
a2368 1
			if (buf[0] == 13 && !bw->o.hex)
@


1.83
log
@Background color for screen item
@
text
@d2352 34
@


1.82
log
@Background color
@
text
@d38 1
a38 1
extern int bg_color;
d1868 1
a1868 1
			atr = BG_COLOR(bg_color);
@


1.81
log
@Fix: segfault, xcol for hex, backspace
@
text
@d38 2
d1860 1
a1860 1
			int atr = 0;
d1868 2
d1878 1
a1878 1
				atr = INVERSE;
@


1.80
log
@Blocks to work in hex mode.
Overtype mode for hex.
@
text
@d1518 5
@


1.79
log
@minor fixes for hex mode
@
text
@d1732 14
@


1.78
log
@hex edit mode
@
text
@d1355 2
a1356 2
	if (bw->top->line) {
		if (bw->top->line + bw->h - 1 != bw->cursor->line)
d1361 2
a1362 1
		return -1;
d1368 2
a1369 2
	if (bw->top->line + bw->h <= bw->top->b->eof->line) {
		if (bw->top->line != bw->cursor->line)
d1374 2
a1375 1
		return -1;
@


1.77
log
@Get ` to send control keys to shell
@
text
@d43 5
a47 1
	p_goto_bol(bw->cursor);
d57 7
a63 1
	P *p = pdup(bw->cursor);
d90 7
a96 1
	p_goto_eol(bw->cursor);
d123 7
d155 7
d1121 8
d1141 11
d1206 19
a1224 13
	if (bw->top->line >= n)
		scrollamnt = cursoramnt = n;
	else if (bw->top->line)
		scrollamnt = cursoramnt = bw->top->line;
	else if (flg)
		cursoramnt = bw->cursor->line;
	else if (bw->cursor->line >= n)
		cursoramnt = n;

	/* Move top-of-window pointer */
	for (x = 0; x != scrollamnt; ++x)
		pprevl(bw->top);
	p_goto_bol(bw->top);
d1226 19
a1244 5
	/* Move cursor */
	for (x = 0; x != cursoramnt; ++x)
		pprevl(bw->cursor);
	p_goto_bol(bw->cursor);
	pcol(bw->cursor, bw->cursor->xcol);
d1246 4
a1249 3
	/* If window is on the screen, give (buffered) scrolling command */
	if (bw->parent->y != -1)
		nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d1267 19
a1285 8
	if (bw->top->b->eof->line < bw->top->line + bw->h) {
		cursoramnt = bw->top->b->eof->line - bw->cursor->line;
		if (!flg && cursoramnt > n)
			cursoramnt = n;
	} else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
		cursoramnt = scrollamnt = n;
	else
		cursoramnt = scrollamnt = bw->top->b->eof->line - (bw->top->line + bw->h) + 1;
d1287 17
a1303 3
	/* Move top-of-window pointer */
	for (x = 0; x != scrollamnt; ++x)
		pnextl(bw->top);
d1305 4
a1308 8
	/* Move cursor */
	for (x = 0; x != cursoramnt; ++x)
		pnextl(bw->cursor);
	pcol(bw->cursor, bw->cursor->xcol);

	/* If window is on screen, give (buffered) scrolling command to terminal */
	if (bw->parent->y != -1)
		nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d1319 2
a1320 1
	if (!bw->cursor->line)
d1339 1
a1339 1
	if (bw->cursor->line == bw->b->eof->line)
@


1.76
log
@Get tab completion to work on user names.
@
text
@d1630 8
@


1.75
log
@Fix ~ expansion insanity
@
text
@d2215 1
a2215 1
int uname(BW *bw)
@


1.74
log
@fix autoindent in open, and prevent ^K E in prompts
@
text
@d1316 1
a1316 1
	if (wmkpw(bw->parent, US "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL, locale_map))
d1352 1
a1352 1
	if (wmkpw(bw->parent, US "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL, locale_map))
d1388 1
a1388 1
	if (wmkpw(bw->parent, US "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, locale_map))
d1805 1
a1805 1
				           NULL, NULL, NULL, NULL, NULL, locale_map))
d2185 1
a2185 1
	if (wmkpw(b->parent, US "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL, locale_map))
d2207 1
a2207 1
	if (wmkpw(bw->parent, US "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.charmap))
@


1.73
log
@A few more VHDL hacks.
@
text
@d2035 13
@


1.72
log
@fix vhdl...
@
text
@d511 1
a511 1
				if (c=='d' && bw->o.vhdl_comment) {
d513 1
a513 1
					if(c=='n') {
d515 1
a515 1
						if(c=='e') {
d614 1
a614 1
						if (!(buf[0]>='a' && buf[0]<='z'))
d624 1
a624 1
					if (bw->o.vhdl_comment && !strcmp(buf,"end"))
@


1.71
log
@^G for VHDL
@
text
@d625 3
a627 1
						p_goto_next(p);
@


1.70
log
@Add #if #else #endif matching.
@
text
@d458 2
a459 1
			} else if (bw->o.cpp_comment && c == '\n') {
d464 7
a470 1
					if (cc == '/') {
d476 16
d497 1
d510 13
d535 1
a535 1
				} else if(is_in_group(set,buf) && !--cnt) {
d560 9
a568 1
					else if (c == '\\') pgetc(p); 
d623 3
@


1.69
log
@Ignore <a/>
@
text
@d474 1
d481 7
d544 10
d556 1
d569 4
a572 1
						pgoto(p,p->byte-len);
d715 24
d751 1
a751 1
		unsigned char *buf;
d761 1
a761 3
		q=pdup(p);
		p_goto_next(q);
		buf=brvs(p,q->byte-p->byte);
d771 1
a771 1
		prm(p); prm(q);
d774 1
a774 2
			flg = tomatch_xml(bw, buf1, flg);
			goto done;
d781 1
a781 2
						flg = tomatch_word(bw, set, next_group(word));
						goto done;
d789 1
a789 5
		flg = dofirst(bw, 0, 0, buf);

		done:
		vsrm(buf);
		return flg;
@


1.68
log
@Fix syntax file warnings.
Add -jump_menu
@
text
@d565 18
d613 1
a613 1
				if (!strcmp(word,buf)) {
d656 1
a656 1
					if (!strcmp(word,buf)) {
@


1.67
log
@Fix keymap command.  Add name command.
@
text
@d34 2
d1118 3
d1137 3
@


1.66
log
@Allow :s in xml names.
@
text
@d2085 15
@


1.65
log
@fix xml matching bug
@
text
@d403 1
a403 1
#define MAX_WORD_SIZE 31
d657 16
d686 1
d698 1
d710 1
a710 1
			flg = tomatch_xml(bw, buf, flg);
@


1.64
log
@Ctrl-G matches XML tags
@
text
@d598 1
@


1.63
log
@User defined text delimiters
@
text
@d470 1
a470 1
			} else if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_') {
d563 93
d673 1
a673 1
		int flg;
d680 8
d690 5
@


1.62
log
@Fix lockup problem with ^G
@
text
@d324 1
a324 1
   but the last of in the set.  If the delimiter matches a word in the last
d331 1
a331 1
unsigned char *have_delim(unsigned char *list,unsigned char *delim)
d333 5
a337 2
	unsigned char *start_of_entry;
	return start_of_entry;
d340 1
a340 1
int tomatch_fwrd(BW *bw,unsigned char *begin_delim,unsigned char *end_delim)
d342 48
a389 51
	P *p=pdup(bw->cursor);
	int c;
	unsigned char buf[32];
	int len;
	int state = 0;
	int cnt = 1;
	p_goto_next(p);
	while ((c=pgetc(p)) != NO_MORE_DATA) {
		if (c == '\\') {
			pgetc(p);
		} else if (c == '"') {
			while ((c = pgetc(p)) != NO_MORE_DATA)
				if (c == '"') break;
				else if (c == '\\') pgetc(p); 
		} else if (bw->o.single_quoted && c == '\'') {
			while((c = pgetc(p)) != NO_MORE_DATA)
				if (c == '\'') break;
				else if (c == '\\') pgetc(p);
		} else if ((bw->o.c_comment || bw->o.cpp_comment) && c == '/') {
			c = pgetc(p);
			if (c == '*') {
				c = pgetc(p);
				do {
					do {
						if (c == '*') break;
					} while ((c = pgetc(p)) != NO_MORE_DATA);
					c = pgetc(p);
				} while (c != NO_MORE_DATA && c != '/');
			} else if (c == '/') {
				while ((c = pgetc(p)) != NO_MORE_DATA)
					if (c == '\n')
						break;
			} else if (c != NO_MORE_DATA)
				prgetc(p);
		} else if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_') {
			len=0;
			while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9') {
				if(len!=31)
					buf[len++]=c;
				c=pgetc(p);
			}
			if(c!=NO_MORE_DATA)
				prgetc(p);
			buf[len]=0;
			if (!strcmp((char *)buf,(char *)begin_delim)) {
				++cnt;
			} else if(!strcmp((char *)buf,(char *)end_delim) && !--cnt) {
				pgoto(p,p->byte-len);
				pset(bw->cursor,p);
				return 0;
			}
d392 9
a400 1
	return -1;
d403 3
a405 1
int tomatch_bkwd(BW *bw,unsigned char *begin_delim,unsigned char *end_delim)
d407 25
a431 21
	P *p=pdup(bw->cursor);
	int c;
	unsigned char buf[32];
	int len;
	int state = 0;
	int cnt = 1;
	p_goto_next(p);
	p_goto_prev(p);
	while ((c=prgetc(p)) != NO_MORE_DATA) {
		int peek = prgetc(p);
		if(peek!=NO_MORE_DATA)
			pgetc(p);
		if (peek=='\\') {
		} else if (c == '"') {
			while((c = prgetc(p)) != NO_MORE_DATA) {
				if (c == '"') {
					c = prgetc(p);
					if (c != '\\') {
						if (c != NO_MORE_DATA)
							pgetc(p);
						break;
d434 9
a442 9
			}
		} else if (bw->o.single_quoted && c == '\'') {
			while((c = prgetc(p)) != NO_MORE_DATA)
				if (c == '\'') {
					c = prgetc(p);
					if (c != '\\') {
						if (c != NO_MORE_DATA)
							pgetc(p);
						break;
d444 1
a444 4
				}
		} else if (bw->o.c_comment && c == '/') {
			c = prgetc(p);
			if (c == '*') {
d446 2
a447 1
				do {
d449 18
a466 16
						if (c == '*') break;
					} while ((c = prgetc(p)) != NO_MORE_DATA);
					c = prgetc(p);
				} while (c != NO_MORE_DATA && c != '/');
			} else if (c != NO_MORE_DATA)
				pgetc(p);
		} else if (bw->o.cpp_comment && c == '\n') {
			P *q = pdup(p);
			int cc;
			p_goto_bol(q);
			while((cc = pgetc(q)) != '\n') {
				if (cc == '/') {
					if (brch(q)=='/') {
						prgetc(q);
						pset(p,q);
						break;
d469 24
d494 15
a508 10
			prm(q);
		} else if (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_') {
			int x;
			len=0;
			while (c >= 'a' && c <= 'z' || c>='A' && c<='Z' || c=='_' || c>='0' && c<='9') {
				if(len!=31)
					buf[len++]=c;
				c=prgetc(p);
			}
			if(c!=NO_MORE_DATA)
d510 46
a555 11
			buf[len]=0;
			for(x=0;x!=len/2;++x) {
				int d = buf[x];
				buf[x] = buf[len-x-1];
				buf[len-x-1] = d;
			}
			if (!strcmp((char *)buf,(char *)end_delim)) {
				++cnt;
			} else if(!strcmp((char *)buf,(char *)begin_delim) && !--cnt) {
				pset(bw->cursor,p);
				return 0;
d558 2
a560 1
	return -1;
d576 4
d589 10
a598 33
		if(!strcmp((char *)buf,"begin"))
			flg=tomatch_fwrd(bw,US "begin", US "end");
		else if(!strcmp((char *)buf,"module"))
			flg=tomatch_fwrd(bw,US "module", US "endmodule");
		else if(!strcmp((char *)buf,"function"))
			flg=tomatch_fwrd(bw,US "function", US "endfunction");
		else if(!strcmp((char *)buf,"if"))
			flg=tomatch_fwrd(bw,US "if", US "fi"); // Or endif
		else if(!strcmp((char *)buf,"case"))
			flg=tomatch_fwrd(bw,US "case", US "endcase"); // Or esac
		else if(!strcmp((char *)buf,"do"))
			flg=tomatch_fwrd(bw,US "do", US "done");

		else if(!strcmp((char *)buf,"end"))
			flg=tomatch_bkwd(bw,US "begin", US "end");
		else if(!strcmp((char *)buf,"endmodule"))
			flg=tomatch_bkwd(bw,US "module", US "endmodule");
		else if(!strcmp((char *)buf,"endfunction"))
			flg=tomatch_bkwd(bw,US "function", US "endfunction");
		else if(!strcmp((char *)buf,"fi"))
			flg=tomatch_bkwd(bw,US "if", US "fi");
		else if(!strcmp((char *)buf,"endif"))
			flg=tomatch_bkwd(bw,US "if", US "endif");
		else if(!strcmp((char *)buf,"endcase"))
			flg=tomatch_bkwd(bw,US "case",US "endcase");
		else if(!strcmp((char *)buf,"esac"))
			flg=tomatch_bkwd(bw,US "case",US "esac");
		else if(!strcmp((char *)buf,"done"))
			flg=tomatch_bkwd(bw,US "do",US "done");
		else {
			flg= -1;
			/* We don't know the word, so start a search */
			flg = dofirst(bw, 0, 0, buf);
d600 5
a606 1
		
@


1.61
log
@Apply patches, improve verilog syntax.
@
text
@d705 1
a705 1
				while((d = prgetc(p)) != NO_MORE_DATA)
d714 1
d746 1
a746 1
						while((cc = pgetc(q)) != NO_MORE_DATA)
@


1.60
log
@Ctrl-G starts a search if it doesn't know word under cursor.
@
text
@d311 26
@


1.59
log
@Fix perl highlighter bug, enhance ^G
@
text
@d23 1
d509 1
a509 1
		else
d511 3
@


1.58
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d154 1
a154 1
int u_goto_prev(BW *bw)
d156 2
a157 2
	P *p = pdup(bw->cursor);
	struct charmap *map=bw->b->o.charmap;
d173 1
a173 7
/*
	if (p->byte == bw->cursor->byte) {
		prm(p);
		return -1;
	}
*/
	pset(bw->cursor, p);
d178 5
d189 1
a189 1
int u_goto_next(BW *bw)
d191 2
a192 2
	P *p = pdup(bw->cursor);
	struct charmap *map=bw->b->o.charmap;
d209 1
a209 1
	pset(bw->cursor, p);
d214 5
d290 166
d464 68
a531 1
	switch (c = brch(bw->cursor)) {
d576 36
d617 35
a651 1
			if (d == c)
d665 79
a743 1
			if (d == c)
@


1.57
log
@Smart indent and backspace now work even if cursor
is not right at indentation point.  Also autoindent
does not happen if cursor is on a space or tab character.

Jmacs: ^W (cut) now works if mark is after point.  (Added -autoswap
mode).  Also: preserve mark and point positions during block
operations.
@
text
@d1078 1
a1078 1
			snprintf((char *)buf, sizeof(buf), "ASCII %c--", c);
d1114 1
a1114 1
			snprintf((char *)buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
d1132 1
a1132 1
			snprintf((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
d1140 1
a1140 1
			snprintf((char *)buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
d1148 1
a1148 1
			snprintf((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
d1174 1
a1174 1
			snprintf((char *)buf, sizeof(buf), "ASCII 0%c--", c);
d1185 1
a1185 1
			snprintf((char *)buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
d1329 1
a1329 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d set", c - '0');
d1361 1
a1361 1
			snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d not set", c - '0');
@


1.56
log
@Improve exit messages.

Improve 'lose' which is for jmacs.

Improve ^X for jpico.

Got rid of "end of processs" message in shell windows.

Shell windows can now be orphaned and duplicated (process
is associated with B instead of BW).

Shell window input taken from cmd.c instead of in
actual edit functions.
@
text
@d740 12
d753 1
d921 1
a921 1
	} else if (k == '\t' && bw->o.smartbacks && bw->o.autoindent && pisindent(bw->cursor)==piscol(bw->cursor)) {
d924 1
a924 1
		if (n != -1 && n > pisindent(bw->cursor)) {
d1297 2
a1298 1
		if (bw->o.autoindent) {
@


1.55
log
@Added "upper" and "lower" functions (no longer depend on "tr" command).
Fix jmacs transpose word command.
@
text
@d681 1
a681 5
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte) {
		unsigned char c = 4;
		joe_write(bw->out, &c, 1);	/* Send Ctrl-D to process */
	} else {
		P *p;
d683 5
a687 6
		if (piseof(bw->cursor))
			return -1;
		pgetc(p = pdup(bw->cursor));
		bdel(bw->cursor, p);
		prm(p);
	}
d691 1
a691 2
/* Backspace, or if cursor is at end of file in a shell window, send backspace
 * to shell */
d695 2
a696 5
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte) {
		unsigned char c = k;

		joe_write(bw->out, &c, 1);
	} else if (bw->parent->watom->what == TYPETW || !pisbol(bw->cursor)) {
d747 1
a749 1
	return 0;
d898 1
a898 8
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte) {
		unsigned char c = k;

		utype_utf8_sm.state = 0;
		utype_utf8_sm.ptr = 0;

		joe_write(bw->out, &c, 1);
	} else if (k == '\t' && bw->o.overtype && !piseol(bw->cursor)) { /* TAB in overtype mode is supposed to be just cursor motion */
d1268 1
a1268 2
/* User hit Return.  Deal with autoindent.  If cursor is at end of shell
 * window buffer, send the return to the shell
d1273 1
a1273 3
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte) {
		joe_write(bw->out, "\n", 1);
	} else if (bw->o.overtype) {
@


1.54
log
@Smart tab searches back 10 lines to determine indentation.
@
text
@d173 1
d178 1
d195 1
d197 2
a198 1
	if (joe_isalnum_(map,c))
d201 1
a201 1
	else if (joe_isspace(map,c) || joe_ispunct(map,c)) {
d204 2
a205 1
		while (joe_isalnum_(map,(c = brch(p))))
d207 1
a209 4
	if (p->byte == bw->cursor->byte) {
		prm(p);
		return -1;
	}
d212 1
a212 1
	return 0;
d1330 1
a1330 1
	if (c >= '0' && c <= '9') {
d1333 4
a1336 2
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d set", c - '0');
		msgnw(bw->parent, msgbuf);
d1346 1
a1346 1
	if (c >= '0' && c <= '9')
d1360 1
a1360 1
	if (c >= '0' && c <= '9')
@


1.53
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d879 16
d924 2
a925 1
		if (pprevl(p) && p_goto_bol(p) && pisindent(p)>pisindent(bw->cursor)) {
d940 1
@


1.52
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d26 1
d55 1
a55 1
			while (joe_isblank(brc(p)))
d61 1
a61 1
			while (joe_isblank(brc(p)))
d157 1
d160 2
a161 2
	if (isalnum_(bw->b->o.utf8,p->b->o.charmap,c)) {
		while (isalnum_(bw->b->o.utf8,p->b->o.charmap,(c=prgetc(p))))
d165 2
a166 2
	} else if (joe_isspace(c) || joe_ispunct(bw->b->o.utf8,bw->b->o.charmap,c)) {
		while ((c=prgetc(p)), (joe_isspace(c) || joe_ispunct(bw->b->o.utf8,bw->b->o.charmap,c)))
d168 1
a168 1
		while(isalnum_(bw->b->o.utf8,p->b->o.charmap,(c=prgetc(p))))
d191 1
d194 2
a195 2
	if (isalnum_(bw->b->o.utf8,p->b->o.charmap,c))
		while (isalnum_(bw->b->o.utf8,p->b->o.charmap,(c = brch(p))))
d197 2
a198 2
	else if (joe_isspace(c) || joe_ispunct(bw->b->o.utf8,bw->b->o.charmap,c)) {
		while (joe_isspace(c = brch(p)) || joe_ispunct(bw->b->o.utf8,bw->b->o.charmap,c))
d200 1
a200 1
		while (isalnum_(bw->b->o.utf8,p->b->o.charmap,(c = brch(p))))
d216 1
a216 1
	while (joe_isblank(brch(p)))
d234 1
a234 1
	if (joe_isblank(c = brch(p))) {
d236 1
a236 1
		if (joe_isblank(prgetc(q)))
d595 1
a595 1
	if (wmkpw(bw->parent, US "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL, -1))
d631 1
a631 1
	if (wmkpw(bw->parent, US "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL, -1))
d667 1
a667 1
	if (wmkpw(bw->parent, US "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, -1))
d769 1
d772 2
a773 2
	if (isalnum_(bw->b->o.utf8,p->b->o.charmap,c))
		while (isalnum_(bw->b->o.utf8,p->b->o.charmap,(c = brch(p))))
d775 2
a776 2
	else if (joe_isspace(c))
		while (joe_isspace(c = brch(p)))
d798 1
d800 2
a801 2
	if (isalnum_(bw->b->o.utf8,p->b->o.charmap,c)) {
		while (isalnum_(bw->b->o.utf8,p->b->o.charmap,(c = prgetc(bw->cursor))))
d805 2
a806 2
	} else if (joe_isspace(c)) {
		while (joe_isspace(c = prgetc(bw->cursor)))
a884 1
extern int utf8;
d888 1
d911 1
a911 1
			while (joe_isspace(k = pgetc(p)) && k != '\n') {
d947 1
a947 1
		if(utf8) {
d965 1
a965 1
		if(utf8 && !bw->b->o.utf8) {
d969 1
a969 1
		} else if(!utf8 && bw->b->o.utf8) {
d986 1
a986 1
		if (bw->o.wordwrap && piscol(bw->cursor) > bw->o.rmargin && !joe_isblank(k)) {
d1018 1
a1018 1
			outatr(bw->b->o.utf8, bw->b->o.charmap, t, screen + x, attr + x, x, y, k, atr);
d1067 1
a1067 1
			if (bw->b->o.utf8) {
d1069 1
a1069 1
				           NULL, NULL, NULL, NULL, NULL, -1))
d1285 1
a1285 1
			while (joe_isspace(c = pgetc(p)) && c != '\n') {
d1436 1
a1436 1
	if (wmkpw(b->parent, US "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL, -1))
d1458 1
a1458 1
	if (wmkpw(bw->parent, US "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.utf8))
@


1.51
log
@Elimiante --pedantic warnings.
@
text
@a11 1
#include <ctype.h>
d158 2
a159 2
	if (isalnum_(bw->b->o.utf8,c)) {
		while (isalnum_(bw->b->o.utf8,(c=prgetc(p))))
d163 2
a164 2
	} else if (isspace(c) || ispunct(c)) {
		while ((c=prgetc(p)), (isspace(c) || ispunct(c)))
d166 1
a166 1
		while(isalnum_(bw->b->o.utf8,(c=prgetc(p))))
d191 2
a192 2
	if (isalnum_(bw->b->o.utf8,c))
		while (isalnum_(bw->b->o.utf8,(c = brch(p))))
d194 2
a195 2
	else if (isspace(c) || ispunct(c)) {
		while (isspace(c = brch(p)) || ispunct(c))
d197 1
a197 1
		while (isalnum_(bw->b->o.utf8,(c = brch(p))))
d768 2
a769 2
	if (isalnum_(bw->b->o.utf8,c))
		while (isalnum_(bw->b->o.utf8,(c = brch(p))))
d771 2
a772 2
	else if (isspace(c))
		while (isspace(c = brch(p)))
d795 2
a796 2
	if (isalnum_(bw->b->o.utf8,c)) {
		while (isalnum_(bw->b->o.utf8,(c = prgetc(bw->cursor))))
d800 2
a801 2
	} else if (isspace(c)) {
		while (isspace(c = prgetc(bw->cursor)))
d906 1
a906 1
			while (isspace(k = pgetc(p)) && k != '\n') {
d963 1
a963 1
			k = from_utf8(buf);
d966 1
a966 1
			to_utf8(buf,k);
d1013 1
a1013 1
			outatr(bw->b->o.utf8, t, screen + x, attr + x, x, y, k, atr);
d1280 1
a1280 1
			while (isspace(c = pgetc(p)) && c != '\n') {
@


1.50
log
@Improve Fortran again.

Added '-indentfirst' option to control
how smarthome works.

Now syntax files are loaded as needed.

New version of automake and autoconf

Print UTF-8 (c) if terminal is utf-8.
@
text
@d1030 1
a1030 1
	sscanf(s,"%x",&num);
d1424 1
a1424 1
	strcpy(msgbuf, s);
@


1.49
log
@Smart backspace now always fixes the indentation.

Indent left and right always fixes indentation.
@
text
@d52 14
a65 5
	if (bw->o.smarthome && piscol(p)==0 && pisindent(p)) {
		while (joe_isblank(brc(p)))
			pgetc(p);
	} else
		p_goto_bol(p);
a66 6
/* Old way
	if ((bw->o.smarthome) && (piscol(p) > pisindent(p))) { 
		p_goto_bol(p);
		while (joe_isblank(brc(p)))
			pgetc(p);
*/
@


1.48
log
@Fix rtarw: was not fixing xcol.

TAB key now does smart indenting.

smart home goes to real home first, then indentation point.
@
text
@d730 1
a730 1
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && bw->o.autoindent && pispure(bw->cursor,bw->o.indentc)) {
@


1.47
log
@Better handling of iconv() conversion errors.

Better handling of error UTF-8 sequences.
@
text
@d52 7
d63 1
a63 2
	} else
		p_goto_bol(p);
d131 1
d134 1
a134 1
			return 0;
d136 1
a136 1
			return -1;
d138 4
d730 1
a730 1
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && pispure(bw->cursor,bw->o.indentc)) {
d899 17
@


1.46
log
@Prepare for release
@
text
@a982 11
			if (bw->b->o.utf8) {
				if (k<32 || k>126 && k<160) {
					xlat_utf_ctrl(&a, &c);
					k = c;
					atr ^= a;
					}
			} else {
				xlat(&a, &c);
				k = c;
				atr ^= a;
			}
@


1.45
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@d717 3
a719 1
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && (bw->o.purify || pispure(bw->cursor,bw->o.indentc))) {
@


1.44
log
@TAB now only inserts in overtype mode when cursor is past end of line.
@
text
@d95 18
a112 4
	if (prgetc(bw->cursor) != NO_MORE_DATA)
		return 0;
	else
		return -1;
d120 3
a122 1
	if (pgetc(bw->cursor) != NO_MORE_DATA)
d124 8
a131 2
	else
		return -1;
d376 6
d880 1
a880 1
		if (piseol(bw->cursor) && piscol(bw->cursor)<col)	/* We moved past end of line, insert a tab */
d887 6
a892 1
		long n = piscol(bw->cursor);
d905 4
d1274 1
a1274 5
	P *q = pdup(bw->cursor);

	rtntw(bw);
	pset(bw->cursor, q);
	prm(q);
@


1.43
log
@Fixed wordwrap/overtype interaction bugs.
@
text
@d848 10
@


1.42
log
@Now Enter does not insert newline when in overtype mode.
@
text
@d896 6
d905 2
a906 2
		} else if (bw->o.overtype && !piseol(bw->cursor) && k != '\t')
			udelch(bw);
@


1.41
log
@Added -purify option.
@
text
@d1193 6
@


1.40
log
@Added 'smartbacks' option.
@
text
@d688 2
a689 2
		   indent characters. */
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && pispure(bw->cursor,bw->o.indentc)) {
d700 1
a700 6
			col -= indwid;

			for (x=0; x!=col; x+=wid) {
				binsc(bw->cursor, bw->o.indentc);
				pgetc(bw->cursor);
			}
d1200 1
a1200 1
			while (isspace(c = pgetc(p)) && c != 10) {
@


1.39
log
@*** empty log message ***
@
text
@d689 1
a689 1
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smarthome && pispure(bw->cursor,bw->o.indentc)) {
@


1.38
log
@Fix new bug caused by previous bug fix :-)
@
text
@d52 1
a52 1
	if ((bw->o.smarthome) && (p->col > pisindent(p))) { 
d662 5
d670 43
a712 5
		p = pdup(bw->cursor);
		if ((c = prgetc(bw->cursor)) != NO_MORE_DATA)
			if (!bw->o.overtype || c == '\t' || pisbol(p) || piseol(p))
				bdel(bw->cursor, p);
		prm(p);
@


1.37
log
@Fix bug where double wide characters typed at end of line was
screwing up (was assuming that they were one character wide in
the utypebw optimization logic).
@
text
@d856 1
a856 1
		x = bw->cursor->xcol - bw->offset;
@


1.36
log
@Applied David Phillips' smart home key patch.

Changed  ` u to ` x.
@
text
@d822 1
d855 2
d865 1
a865 1
		if (bw->cursor->xcol - bw->offset - 1 < 0 || bw->cursor->xcol - bw->offset - 1 >= bw->w)
a876 1
			int x = bw->cursor->xcol - bw->offset + bw->x - 1;
d879 1
@


1.35
log
@Added ` u to insert unicode characters in hex.

Fixed typeing of unicode (utypebw() optimization bug).

Fixed editor hang when syntax hightlighter hits unicode character.
@
text
@d45 19
d947 13
a959 5
			quotestate = 3;
			if (!mkqwna(bw->parent, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
a965 6
		} else if (c == 'u' || c == 'U') {
			if (!wmkpw(bw->parent, US "Unicode (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
			           NULL, NULL, NULL, NULL, NULL, -1))
				return 0;
			else
				return -1;
@


1.34
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d850 3
a852 2
			int a = 0;
			unsigned char c = (unsigned char)k;
d867 13
a879 3
				a = INVERSE;
			xlat(&a, &c);
			outatr(bw->b->o.utf8, t, screen + x, attr + x, x, y, c, a);
d888 18
d939 6
@


1.33
log
@First attempt at character set conversion iconv().
Now the file's coding can be different from the terminal's
coding.

Also, applied secure linux patch from RedHat.
@
text
@d532 1
a532 1
	if (wmkpw(bw->parent, US "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL))
d568 1
a568 1
	if (wmkpw(bw->parent, US "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL))
d604 1
a604 1
	if (wmkpw(bw->parent, US "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL))
d1258 1
a1258 1
	if (wmkpw(b->parent, US "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL))
d1278 1
a1278 1
int utxt(BASE *bw)
d1280 1
a1280 1
	if (wmkpw(bw->parent, US "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL))
@


1.32
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d823 10
@


1.31
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d780 1
d805 1
a805 1
		if(bw->b->o.utf8) {
d858 1
a858 1
			outatr(t, screen + x, attr + x, x, y, c, a);
@


1.30
log
@Input of UTF-8 is now working.  For example, you
can cut and paste in an xterm.

Placed UTF-8 encoder and decoder in separate file.
@
text
@d104 2
a105 2
	if (isalnum_(c)) {
		while (isalnum_(c=prgetc(p)))
d112 1
a112 1
		while(isalnum_(c=prgetc(p)))
d135 1
a135 1
	int c = brc(p);
d137 2
a138 2
	if (isalnum_(c))
		while (isalnum_(c = brc(p)))
d141 1
a141 1
		while (isspace(c = brc(p)) || ispunct(c))
d143 1
a143 1
		while (isalnum_(c = brc(p)))
d159 1
a159 1
	while (isblank(brc(p)))
d177 1
a177 1
	if (isblank(c = brc(p))) {
d179 1
a179 1
		if (isblank(prgetc(q)))
d235 1
a235 1
	switch (c = brc(bw->cursor)) {
d666 1
a666 1
	int c = brc(p);
d668 2
a669 2
	if (isalnum_(c))
		while (isalnum_(c = brc(p)))
d672 1
a672 1
		while (isspace(c = brc(p)))
d695 2
a696 2
	if (isalnum_(c)) {
		while (isalnum_(c = prgetc(bw->cursor)))
d822 1
a822 4
		if(bw->b->o.utf8)
			bins_utf8(bw->cursor, k);
		else
			binsc(bw->cursor, k);
d825 1
a825 1
		if (bw->o.wordwrap && piscol(bw->cursor) > bw->o.rmargin && !isblank(k)) {
@


1.29
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d26 1
d779 2
d786 3
d793 3
d800 15
a814 2
		int upd = bw->parent->t->t->updtab[bw->y + bw->cursor->line - bw->top->line];
		int simple = 1;
d821 7
a827 1
		binsc(bw->cursor, k), pgetc(bw->cursor);
@


1.28
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d503 1
a503 1
static int doline(BW *bw, char *s, void *object, int *notify)
d524 1
a524 1
			msgnw(bw->parent, "Invalid line number");
d531 1
a531 1
	if (wmkpw(bw->parent, "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL))
d541 1
a541 1
static int docol(BW *bw, char *s, void *object, int *notify)
d560 1
a560 1
			msgnw(bw->parent, "Invalid column number");
d567 1
a567 1
	if (wmkpw(bw->parent, "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL))
d577 1
a577 1
static int dobyte(BW *bw, char *s, void *object, int *notify)
d596 1
a596 1
			msgnw(bw->parent, "Invalid byte number");
d603 1
a603 1
	if (wmkpw(bw->parent, "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL))
d616 1
a616 1
		char c = 4;
d636 1
a636 1
		char c = k;
d741 1
a741 1
		return ubacks(bw, MAXINT);	/* FIXME: MAXINT overloaded */
d781 1
a781 1
		char c = k;
d846 1
a846 1
	char buf[40];
d857 1
a857 1
			snprintf(buf, sizeof(buf), "ASCII %c--", c);
d885 1
a885 1
			snprintf(buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
d903 1
a903 1
			snprintf(buf, sizeof(buf), "ASCII 0x%c-", c);
d911 1
a911 1
			snprintf(buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
d919 1
a919 1
			snprintf(buf, sizeof(buf), "ASCII 0x%c-", c);
d945 1
a945 1
			snprintf(buf, sizeof(buf), "ASCII 0%c--", c);
d956 1
a956 1
			snprintf(buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
d1025 1
a1025 1
extern char srchstr[];
d1062 1
a1062 1
		char c;
d1099 1
a1099 1
		snprintf(msgbuf, JOE_MSGBUFSIZE, "Mark %d set", c - '0');
d1130 1
a1130 1
			snprintf(msgbuf, JOE_MSGBUFSIZE, "Mark %d not set", c - '0');
d1175 1
a1175 1
		msgnw(bw->parent, "Not found");
d1210 1
a1210 1
static int domsg(BASE *b, char *s, void *object, int *notify)
d1222 1
a1222 1
	if (wmkpw(b->parent, "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL))
d1230 1
a1230 1
static int dotxt(BW *bw, char *s, void *object, int *notify)
d1244 1
a1244 1
	if (wmkpw(bw->parent, "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL))
@


1.27
log
@More changes for syntax highlighting.
@
text
@d820 1
d832 1
a832 1
			outatr(t, screen + x, x, y, c, a);
@


1.26
log
@Fix lockup when ^Z on first word in a file
@
text
@d104 2
a105 3
		while (isalnum_(c=prgetc(p)));
		/* while (isalnum_(c = brc(p)))
			prgetc(p);*/
d109 4
a112 7
		while ((c=prgetc(p)), (isspace(c) || ispunct(c)));
		/*
		while (isspace(c = brc(p)) || ispunct(c))
			prgetc(p); */
		while(isalnum_(c=prgetc(p)));
/*		while (isalnum_(c = brc(p)))
			prgetc(p); */
@


1.25
log
@Fixed ^C and ^D in shell windows.
This will require more work: basically if setsid() doesn't
exist, setpgrp(0,0) should be used instead.  I think the latter
is only for BSD.
@
text
@d104 3
a106 2
		while (isalnum_(c = brc(p)))
			prgetc(p);
d110 2
d113 4
a116 3
			prgetc(p);
		while (isalnum_(c = brc(p)))
			prgetc(p);
d825 1
a825 1
			if (!upd && piseol(bw->cursor))
@


1.24
log
@u_goto_prev()/u_goto_next() fix take two: skip over spaces
@
text
@d617 1
a617 2

		joe_write(bw->pid, &c, 0);	/* FIXME: why would we write zero chars ??? */
@


1.23
log
@fix 'go to previous/next word': behave like 'delete previous/next word'
@
text
@d108 4
a111 2
	} else if (isspace(c)) {
		while (isspace(c = brc(p)))
d139 4
a142 2
	else if (isspace(c))
		while (isspace(c = brc(p)))
d144 1
a144 1
	else
@


1.22
log
@change 0 to NULL where we're talking about pointers
@
text
@d100 2
a101 10
	if (pisbof(bw->cursor)) {
		return -1;	/* cursor is at beginning of file */
	} else if (isspace(prgetc(bw->cursor))) {
		while ((!pisbof(bw->cursor)) && (isspace(prgetc(bw->cursor))))
			/* do nothing */;	/* if cursor is on white-space char then find first non-white-space char */
	}
	if (pisbof(bw->cursor)) {
		return -1;	/* cursor is at beginning of file */
	}
	pgetc(bw->cursor);
d103 14
a116 5
	while (!pisbof(bw->cursor)) {
		if (isspace(prgetc(bw->cursor))) {	/* if previous character is white-space then beginning of word was found */
			pgetc(bw->cursor);
			break;
		}
d118 2
d131 2
a132 10
	if (piseof(bw->cursor)) {
		return -1;	/* cursor is at end of file */
	} else if (isspace(pgetc(bw->cursor))) {
		while ((!piseof(bw->cursor)) && (isspace(pgetc(bw->cursor))))
			/* do nothing */;	/* if cursor is on white-space char then find first non-white-space char */
	}
	if (piseof(bw->cursor)) {
		return -1;	/* cursor is at end of file */
	}
	prgetc(bw->cursor);
d134 11
a144 5
	while (!piseof(bw->cursor)) {
		if (isspace(pgetc(bw->cursor))) {	/* if next character is white-space then end of word was found */
			prgetc(bw->cursor);
			break;
		}
d146 2
@


1.21
log
@fix segafults in isalpha()-like functions
@
text
@d494 1
a494 1
static B *linehist = 0;		/* History of previously entered line numbers */
d532 1
a532 1
static B *colhist = 0;		/* History of previously entered column numbers */
d568 1
a568 1
static B *bytehist = 0;		/* History of previously entered byte numbers */
@


1.20
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d75 1
a75 1
	if (prgetc(bw->cursor) != MAXINT)
d86 1
a86 1
	if (pgetc(bw->cursor) != MAXINT)
d202 1
a202 1
	if (prgetc(bw->cursor) == MAXINT)
d211 1
a211 1
	if (pgetc(bw->cursor) == MAXINT)
d276 1
a276 1
		while (d = pgetc(p), d != MAXINT)
d284 1
d290 1
a290 1
		while (d = prgetc(p), d != MAXINT)
d298 1
d301 1
a301 1
	if (d == MAXINT)
d640 1
a640 1
		if ((c = prgetc(bw->cursor)) != MAXINT)
d691 1
a691 1
		if (c != MAXINT)
d696 1
a696 1
		if (c != MAXINT)
d735 1
a735 1
		return ubacks(bw, MAXINT);
d1159 1
a1159 1
		while ((c = prgetc(q)) != MAXINT)
d1163 1
a1163 1
		while ((c = pgetc(q)) != MAXINT)
d1167 1
a1167 1
	if (c == MAXINT) {
@


1.19
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d639 1
a639 2
			if (!bw->o.overtype || c == '\t' || pisbol(p)
			    || piseol(p))
d660 1
a660 1
		while (c = brc(p), isalnum_(c))
d663 1
a663 1
		while (c = brc(p), isspace(c))
d687 1
a687 1
		while (c = prgetc(bw->cursor), isalnum_(c))
d692 1
a692 1
		while (c = prgetc(bw->cursor), isspace(c))
d787 4
a790 2
			while (piscol(bw->cursor) < bw->o.lmargin)
				binsc(bw->cursor, ' '), pgetc(bw->cursor);
d792 4
a795 4
		if (bw->o.wordwrap && piscol(bw->cursor) > bw->o.rmargin && !isblank(k))
			wrapword(bw->cursor, (long) bw->o.lmargin, bw->o.french, NULL), simple = 0;
		else if (bw->o.overtype && !piseol(bw->cursor)
			 && k != '\t')
d866 1
a866 2
			if ((c >= 0x40 && c <= 0x5F)
			    || (c >= 'a' && c <= 'z'))
d1025 4
a1028 3
	if (bw->parent->huh == srchstr && c == '\n')
		utypebw(bw, '\\'), utypebw(bw, 'n');
	else
d1058 4
a1061 2
			while (isspace(c = pgetc(p)) && c != 10)
				binsc(bw->cursor, c), pgetc(bw->cursor);
@


1.18
log
@change xlat macro into xlat(int *, char *) function
@
text
@d37 1
a37 1
int u_goto_bol(BW * bw)
d46 1
a46 1
int u_goto_eol(BW * bw)
d55 1
a55 1
int u_goto_bof(BW * bw)
d64 1
a64 1
int u_goto_eof(BW * bw)
d73 1
a73 1
int u_goto_left(BW * bw)
d84 1
a84 1
int u_goto_right(BW * bw)
d98 1
a98 1
int u_goto_prev(BW * bw)
d126 1
a126 1
int u_goto_next(BW * bw)
d200 1
a200 1
int upedge(BW * bw)
d209 1
a209 1
int unedge(BW * bw)
d220 1
a220 1
int utomatch(BW * bw)
d307 1
a307 1
int uuparw(BW * bw)
d319 1
a319 1
int udnarw(BW * bw)
d331 1
a331 1
int utos(BW * bw)
d343 1
a343 1
int ubos(BW * bw)
d361 1
a361 1
void scrup(BW * bw, int n, int flg)
d402 1
a402 1
void scrdn(BW * bw, int n, int flg)
d434 1
a434 1
int upgup(BW * bw)
d450 1
a450 1
int upgdn(BW * bw)
d466 1
a466 1
int uupslide(BW * bw)
d478 1
a478 1
int udnslide(BW * bw)
d494 1
a494 1
static int doline(BW * bw, char *s, void *object, int *notify)
d520 1
a520 1
int uline(BW * bw)
d532 1
a532 1
static int docol(BW * bw, char *s, void *object, int *notify)
d556 1
a556 1
int ucol(BW * bw)
d568 1
a568 1
static int dobyte(BW * bw, char *s, void *object, int *notify)
d592 1
a592 1
int ubyte(BW * bw)
d604 1
a604 1
int udelch(BW * bw)
d625 1
a625 1
int ubacks(BW * bw, int k)
d655 1
a655 1
int u_word_delete(BW * bw)
d682 1
a682 1
int ubackw(BW * bw)
d711 1
a711 1
int udelel(BW * bw)
d728 1
a728 1
int udelbl(BW * bw)
d743 1
a743 1
int udelln(BW * bw)
d760 1
a760 1
int uinsc(BW * bw)
d771 1
a771 1
int utypebw(BW * bw, int k)
d834 1
a834 1
static int doquote(BW * bw, int c, void *object, int *notify)
d969 1
a969 1
int uquote(BW * bw)
d978 1
a978 1
static int doquote9(BW * bw, int c, void *object, int *notify)
d992 1
a992 1
static int doquote8(BW * bw, int c, void *object, int *notify)
d1008 1
a1008 1
int uquote8(BW * bw)
d1018 1
a1018 1
static int doctrl(BW * bw, int c, void *object, int *notify)
d1034 1
a1034 1
int uctrl(BW * bw)
d1046 1
a1046 1
int rtntw(BW * bw)
d1068 1
a1068 1
int uopen(BW * bw)
d1080 1
a1080 1
static int dosetmark(BW * bw, int c, void *object, int *notify)
d1096 1
a1096 1
int usetmark(BW * bw, int c)
d1108 1
a1108 1
static int dogomark(BW * bw, int c, void *object, int *notify)
d1127 1
a1127 1
int ugomark(BW * bw, int c)
d1141 1
a1141 1
static int dofwrdc(BW * bw, int k, void *object, int *notify)
d1174 1
a1174 1
int ufwrdc(BW * bw, int k)
d1185 1
a1185 1
int ubkwdc(BW * bw, int k)
d1198 1
a1198 1
static int domsg(BASE * b, char *s, void *object, int *notify)
d1208 1
a1208 1
int umsg(BASE * b)
d1218 1
a1218 1
static int dotxt(BW * bw, char *s, void *object, int *notify)
d1230 1
a1230 1
int utxt(BASE * bw)
@


1.17
log
@move jread() / jwrite() into utils.c
@
text
@d805 2
a806 1
			int c = 0;
d820 3
a822 3
				c = INVERSE;
			xlat(c, k);
			outatr(t, screen + x, x, y, k, c);
@


1.16
log
@change indentation of cases in the switch() statement
@
text
@d609 1
a609 1
		jwrite(bw->pid, &c, 0);	/* FIXME: why would we write zero chars ??? */
d630 1
a630 1
		jwrite(bw->out, &c, 1);
d776 1
a776 1
		jwrite(bw->out, &c, 1);
d1048 1
a1048 1
		jwrite(bw->out, "\n", 1);
@


1.15
log
@change indentation of do {} while() cycles
@
text
@d228 1
a228 1
		case '(':
d232 1
a232 1
		case '[':
d236 1
a236 1
		case '{':
d240 1
a240 1
		case '`':
d244 1
a244 1
		case '<':
d248 1
a248 1
		case ')':
d252 1
a252 1
		case ']':
d256 1
a256 1
		case '}':
d260 1
a260 1
		case '\'':
d264 1
a264 1
		case '>':
d268 1
a268 1
		default:
d842 1
a842 1
		case 0:
d873 1
a873 2

		case 1:
d884 1
a884 2

		case 2:
d891 1
a891 2

		case 3:
d918 1
a918 2

		case 4:
d933 1
a933 2

		case 5:
d944 1
a944 2

		case 6:
d955 1
a955 2

		case 7:
@


1.14
log
@include only headers which are needed
@
text
@d103 2
a104 1
		while ((!pisbof(bw->cursor)) && (isspace(prgetc(bw->cursor)))) ;	/* if cursor is on white-space char then find first non-white-space char */
d131 2
a132 1
		while ((!piseof(bw->cursor)) && (isspace(pgetc(bw->cursor)))) ;	/* if cursor is on white-space char then find first non-white-space char */
d688 2
a689 1
		while (c = prgetc(bw->cursor), isalnum_(c)) ;
d693 2
a694 1
		while (c = prgetc(bw->cursor), isspace(c)) ;
@


1.13
log
@put struct definitions and other goodies into types.h
@
text
@d12 1
a13 3
#include <ctype.h>
#include <string.h>
#include "utils.h"
d16 2
a17 2
#include "scrn.h"
#include "w.h"
d20 4
d26 1
a26 7
#include "uformat.h"
#include "umath.h"
#include "ublock.h"
#include "tw.h"
#include "macro.h"
#include "main.h"
#include "uedit.h"
@


1.12
log
@MSGSBUFSIZE renamed to MSGBUFSIZE (again)
@
text
@d2 8
a9 5
	Basic user edit functions
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a15 2

#include "config.h"
@


1.11
log
@MSGBUFSIZE remaned to JOE_MSGBUFSIZE
@
text
@d1092 1
a1092 1
		snprintf(msgbuf, JOE_MSGSBUFSIZE, "Mark %d set", c - '0');
d1123 1
a1123 1
			snprintf(msgbuf, JOE_MSGSBUFSIZE, "Mark %d not set", c - '0');
@


1.10
log
@correct typo: utype(bw, c) --> utypebw(bw,c)
I'm not 100% sure about this, but "works for me here"(tm)
@
text
@d1092 1
a1092 1
		snprintf(msgbuf, MSGBUFSIZE, "Mark %d set", c - '0');
d1123 1
a1123 1
			snprintf(msgbuf, MSGBUFSIZE, "Mark %d not set", c - '0');
@


1.9
log
@use mkqw(W *, ...) instead of mkqw(BASE *, ...) (ditto. mkqwna() and mkqwnsr())
@
text
@d1033 1
a1033 1
		utype(bw, c);
@


1.8
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d846 1
a846 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d852 1
a852 1
			if (!mkqwna(bw, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
d858 1
a858 1
			if (!mkqwna(bw, sc("ASCII 0---"), doquote, NULL, NULL, notify))
d878 1
a878 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d898 1
a898 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d906 1
a906 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d914 1
a914 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d942 1
a942 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d954 1
a954 1
			if (!mkqwna(bw, sz(buf), doquote, NULL, NULL, notify))
d977 1
a977 1
	if (mkqwna(bw, sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"), doquote, NULL, NULL, NULL))
d1000 1
a1000 1
		if (mkqwna(bw, sc("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
d1015 1
a1015 1
	if (mkqwna(bw, sc("Meta-"), doquote8, NULL, NULL, NULL))
d1041 1
a1041 1
	if (mkqwna(bw, sc("Quote"), doctrl, NULL, NULL, NULL))
d1105 1
a1105 1
	else if (mkqwna(bw, sc("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
d1136 1
a1136 1
	else if (mkqwna(bw, sc("Goto bookmark (0-9):"), dogomark, NULL, NULL, NULL))
d1184 1
a1184 1
	else if (mkqw(bw, sc("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
d1195 1
a1195 1
	else if (mkqw(bw, sc("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
@


1.7
log
@version 2.9.7-pre3
@
text
@d514 1
a514 1
			msgnw(bw, merr);
d516 1
a516 1
			msgnw(bw, "Invalid line number");
d550 1
a550 1
			msgnw(bw, merr);
d552 1
a552 1
			msgnw(bw, "Invalid column number");
d586 1
a586 1
			msgnw(bw, merr);
d588 1
a588 1
			msgnw(bw, "Invalid byte number");
d1093 1
a1093 1
		msgnw(bw, msgbuf);
d1124 1
a1124 1
			msgnw(bw, msgbuf);
d1168 1
a1168 1
		msgnw(bw, "Not found");
d1209 1
a1209 1
	msgnw(b, msgbuf);
@


1.6
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d149 1
a149 1
P *pboi(P * p)
d157 1
a157 1
int pisedge(P * p)
d832 1
a832 1
int doquote(BW * bw, int c, void *object, int *notify)
d846 1
a846 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d852 1
a852 1
			if (!mkqwna(bw->parent, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
d858 1
a858 1
			if (!mkqwna(bw->parent, sc("ASCII 0---"), doquote, NULL, NULL, notify))
d878 1
a878 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d898 1
a898 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d906 1
a906 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d914 1
a914 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d942 1
a942 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d954 1
a954 1
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
d977 1
a977 1
	if (mkqwna(bw->parent, sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"), doquote, NULL, NULL, NULL))
d983 1
a983 1
int doquote9(BW * bw, int c, void *object, int *notify)
d997 1
a997 1
int doquote8(BW * bw, int c, void *object, int *notify)
d1000 1
a1000 1
		if (mkqwna(bw->parent, sc("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
d1015 1
a1015 1
	if (mkqwna(bw->parent, sc("Meta-"), doquote8, NULL, NULL, NULL))
d1023 1
a1023 1
int doctrl(BW * bw, int c, void *object, int *notify)
d1041 1
a1041 1
	if (mkqwna(bw->parent, sc("Quote"), doctrl, NULL, NULL, NULL))
d1085 1
a1085 1
int dosetmark(BW * bw, int c, void *object, int *notify)
d1105 1
a1105 1
	else if (mkqwna(bw->parent, sc("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
d1113 1
a1113 1
int dogomark(BW * bw, int c, void *object, int *notify)
d1136 1
a1136 1
	else if (mkqwna(bw->parent, sc("Goto bookmark (0-9):"), dogomark, NULL, NULL, NULL))
d1146 1
a1146 1
int dofwrdc(BW * bw, int k, void *object, int *notify)
d1184 1
a1184 1
	else if (mkqw(bw->parent, sc("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
d1195 1
a1195 1
	else if (mkqw(bw->parent, sc("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
d1203 1
a1203 1
int domsg(BASE * b, char *s, void *object, int *notify)
d1223 1
a1223 1
int dotxt(BW * bw, char *s, void *object, int *notify)
@


1.5
log
@changed as of joe-2.9.6
@
text
@d31 5
d38 1
a38 1
 * Move cursor to beginning/end of line
d40 3
a42 2
int u_goto_bol (BW *bw) {
	p_goto_bol (bw->cursor);
d46 6
a51 2
int u_goto_eol (BW *bw) {
	p_goto_eol (bw->cursor);
d56 1
a56 1
 * Move cursor to beginning/end of file
d58 3
a60 2
int u_goto_bof (BW *bw) {
	p_goto_bof (bw->cursor);
d64 6
a69 2
int u_goto_eof (BW *bw) {
	p_goto_eof (bw->cursor);
d74 1
a74 1
 * Move cursor left/right
d76 3
a78 3
int u_goto_left (BW *bw) {
	if (!pisbof (bw->cursor)) {
		prgetc (bw->cursor);
d80 1
a80 10
	} else {
		return -1;
	}
}

int u_goto_right (BW *bw) {
	if (!piseof (bw->cursor)) {
		pgetc (bw->cursor);
		return 0;
	} else {
a81 1
	}
d85 1
a85 1
 * Move cursor up/down 
d87 3
a89 4
int u_goto_up (BW *bw) {
	if (bw->cursor->line) {
		pprevl (bw->cursor);
		pcol (bw->cursor, bw->cursor->xcol);
d91 1
a91 1
	} else {
a92 1
	}
a94 11
int u_goto_down (BW *bw) {
	if (bw->cursor->line != bw->b->eof->line) {
		pnextl (bw->cursor);
		pcol (bw->cursor, bw->cursor->xcol);
		return 0;
	} else {
		return -1;
	}
}


d101 15
a115 15
int u_goto_prev (BW *bw) {
	if (pisbof (bw->cursor)) {
		return -1;						/* cursor is at beginning of file */
	} else if (isspace (prgetc (bw->cursor))) {
		while ((!pisbof (bw->cursor)) && 
		       (isspace (prgetc (bw->cursor))));		/* if cursor is on white-space char then find first non-white-space char */
	}
	if (pisbof (bw->cursor)) { 
		return -1;						/* cursor is at beginning of file */
	}
	pgetc (bw->cursor);

	while (!pisbof (bw->cursor)) {
		if (isspace (prgetc (bw->cursor))) {			/* if previous character is white-space then beginning of word was found */
			pgetc (bw->cursor);
d128 15
a142 15
int u_goto_next (BW *bw) {
	if (piseof (bw->cursor)) {
		return -1;						/* cursor is at end of file */
	} else if (isspace (pgetc (bw->cursor))) {
		while ((!piseof (bw->cursor)) && 
		       (isspace (pgetc (bw->cursor))));			/* if cursor is on white-space char then find first non-white-space char */
	}
	if (piseof (bw->cursor)) { 
		return -1;						/* cursor is at end of file */
	}
	prgetc (bw->cursor);

	while (!piseof (bw->cursor)) {
		if (isspace (pgetc (bw->cursor))) {			/* if next character is white-space then end of word was found */
			prgetc (bw->cursor);
d149 10
a158 4
/*
 *	this part is not completed yet
 */
int pisedge (P *p) {
d161 2
a162 1
	if (pisbol (p))
d164 1
a164 1
	if (piseol (p))
d166 2
a167 6
	q = pdup (p);

	p_goto_bol (q);				/* pboi(q) */
	while (isblank (brc (q)))
		pgetc (q);

d170 22
a191 25
	if (isblank (c = brc (p)))
	  {
		  pset (q, p);
		  if (isblank (prgetc (q)))
			  goto no;
		  if (c == '\t')
			  goto right;
		  pset (q, p);
		  pgetc (q);
		  if (pgetc (q) == ' ')
			  goto right;
		  goto no;
	  }
	else
	  {
		  pset (q, p);
		  c = prgetc (q);
		  if (c == '\t')
			  goto left;
		  if (c != ' ')
			  goto no;
		  if (prgetc (q) == ' ')
			  goto left;
		  goto no;
	  }
d193 1
a193 1
      right:prm (q);
d195 1
a195 1
      left:prm (q);
d197 1
a197 1
      no:prm (q);
d201 3
a203 2
int upedge (BW *bw) {
	if (prgetc (bw->cursor) == MAXINT)
d205 2
a206 2
	while (pisedge (bw->cursor) != -1)
		prgetc (bw->cursor);
d210 3
a212 2
int unedge (BW *bw) {
	if (pgetc (bw->cursor) == MAXINT)
d214 2
a215 2
	while (pisedge (bw->cursor) != 1)
		pgetc (bw->cursor);
d221 2
a222 1
int utomatch (BW *bw) {
d225 64
a288 2
	  f,			/* Character to find */
	  dir;			/* 1 to search forward, -1 to search backward */
d290 10
a299 76
	switch (c = brc (bw->cursor))
	  {
	  case '(':
		  f = ')';
		  dir = 1;
		  break;
	  case '[':
		  f = ']';
		  dir = 1;
		  break;
	  case '{':
		  f = '}';
		  dir = 1;
		  break;
	  case '`':
		  f = '\'';
		  dir = 1;
		  break;
	  case '<':
		  f = '>';
		  dir = 1;
		  break;
	  case ')':
		  f = '(';
		  dir = -1;
		  break;
	  case ']':
		  f = '[';
		  dir = -1;
		  break;
	  case '}':
		  f = '{';
		  dir = -1;
		  break;
	  case '\'':
		  f = '`';
		  dir = -1;
		  break;
	  case '>':
		  f = '<';
		  dir = -1;
		  break;
	  default:
		  return -1;
	  }

	if (dir == 1)
	  {
		  P *p = pdup (bw->cursor);
		  int cnt = 0;	/* No. levels of delimiters we're in */
		  while (d = pgetc (p), d != MAXINT)
			  if (d == c)
				  ++cnt;
			  else if (d == f && !--cnt)
			    {
				    prgetc (p);
				    pset (bw->cursor, p);
				    break;
			    }
		  prm (p);
	  }
	else
	  {
		  P *p = pdup (bw->cursor);
		  int cnt = 0;	/* No. levels of delimiters we're in */
		  while (d = prgetc (p), d != MAXINT)
			  if (d == c)
				  ++cnt;
			  else if (d == f)
				  if (!cnt--)
				    {
					    pset (bw->cursor, p);
					    break;
				    }
		  prm (p);
	  }
d306 23
d332 2
a333 1
int utos (BW *bw) {
d335 3
a337 2
	pset (bw->cursor, bw->top);
	pcol (bw->cursor, col);
d344 2
a345 1
int ubos (BW *bw) {
d347 3
a349 2
	pline (bw->cursor, bw->top->line + bw->h - 1);
	pcol (bw->cursor, col);
d362 2
a363 1
void scrup (BW *bw, int n, int flg) {
d381 2
a382 2
		pprevl (bw->top);
	p_goto_bol (bw->top);
d386 3
a388 3
		pprevl (bw->cursor);
	p_goto_bol (bw->cursor);
	pcol (bw->cursor, bw->cursor->xcol);
d392 1
a392 1
		nscrldn (bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d403 2
a404 1
void scrdn (BW *bw, int n, int flg) {
d410 5
a414 7
	if (bw->top->b->eof->line < bw->top->line + bw->h)
	  {
		  cursoramnt = bw->top->b->eof->line - bw->cursor->line;
		  if (!flg && cursoramnt > n)
			  cursoramnt = n;
	  }
	else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
d417 1
a417 2
		cursoramnt = scrollamnt =
			bw->top->b->eof->line - (bw->top->line + bw->h) + 1;
d421 1
a421 1
		pnextl (bw->top);
d425 2
a426 2
		pnextl (bw->cursor);
	pcol (bw->cursor, bw->cursor->xcol);
d430 1
a430 1
		nscrlup (bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
a432 3
/* Global options */
int pgamnt = -1;		/* No. of PgUp/PgDn lines to keep */

d435 2
a436 1
int upgup (BW *bw) {
d441 1
a441 1
		scrup (bw, bw->h / 2 + bw->h % 2, 1);
d443 1
a443 1
		scrup (bw, bw->h - pgamnt, 1);
d445 1
a445 1
		scrup (bw, 1, 1);
d451 2
a452 1
int upgdn (BW *bw) {
d457 1
a457 1
		scrdn (bw, bw->h / 2 + bw->h % 2, 1);
d459 1
a459 1
		scrdn (bw, bw->h - pgamnt, 1);
d461 1
a461 1
		scrdn (bw, 1, 1);
d467 2
a468 1
int uupslide (BW *bw) {
d470 6
a475 8
	if (bw->top->line)
	  {
		  if (bw->top->line + bw->h - 1 != bw->cursor->line)
			  u_goto_down (bw);
		  scrup (bw, 1, 0);
		  return 0;
	  }
	else
d479 2
a480 1
int udnslide (BW *bw) {
d482 6
a487 8
	if (bw->top->line + bw->h <= bw->top->b->eof->line)
	  {
		  if (bw->top->line != bw->cursor->line)
			  u_goto_up (bw);
		  scrdn (bw, 1, 0);
		  return 0;
	  }
	else
d495 4
a498 2
static int doline (BW *bw, char *s, void *object, int *notify) {
	long num = calc (bw, s);
d501 18
a518 21
	vsrm (s);
	if (num >= 1 && !merr)
	  {
		  int tmp = mid;
		  if (num > bw->b->eof->line)
			  num = bw->b->eof->line + 1;
		  pline (bw->cursor, num - 1), bw->cursor->xcol =
			  piscol (bw->cursor);
		  mid = 1;
		  dofollows ();
		  mid = tmp;
		  return 0;
	  }
	else
	  {
		  if (merr)
			  msgnw (bw, merr);
		  else
			  msgnw (bw, "Invalid line number");
		  return -1;
	  }
d521 3
a523 4
int uline (BW *bw) {
	if (wmkpw
	    (bw->parent, "Go to line (^C to abort): ", &linehist, doline, NULL, NULL,
	     NULL, NULL, NULL))
d533 4
a536 2
static int docol (BW *bw, char *s, void *object, int *notify) {
	long num = calc (bw, s);
d539 16
a554 19
	vsrm (s);
	if (num >= 1 && !merr)
	  {
		  int tmp = mid;
		  pcol (bw->cursor, num - 1), bw->cursor->xcol =
			  piscol (bw->cursor);
		  mid = 1;
		  dofollows ();
		  mid = tmp;
		  return 0;
	  }
	else
	  {
		  if (merr)
			  msgnw (bw, merr);
		  else
			  msgnw (bw, "Invalid column number");
		  return -1;
	  }
d557 3
a559 4
int ucol (BW *bw) {
	if (wmkpw
	    (bw->parent, "Go to column (^C to abort): ", &colhist, docol, NULL, NULL,
	     NULL, NULL, NULL))
d569 4
a572 2
static int dobyte (BW *bw, char *s, void *object, int *notify) {
	long num = calc (bw, s);
d575 16
a590 19
	vsrm (s);
	if (num >= 0 && !merr)
	  {
		  int tmp = mid;
		  pgoto (bw->cursor, num), bw->cursor->xcol =
			  piscol (bw->cursor);
		  mid = 1;
		  dofollows ();
		  mid = tmp;
		  return 0;
	  }
	else
	  {
		  if (merr)
			  msgnw (bw, merr);
		  else
			  msgnw (bw, "Invalid byte number");
		  return -1;
	  }
d593 3
a595 4
int ubyte (BW *bw) {
	if (wmkpw
	    (bw->parent, "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL,
	     NULL, NULL, NULL))
d605 15
a619 15
int udelch (BW *bw) {
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
	  {
		  char c = 4;
		  write (bw->pid, &c, 0);
	  }
	else
	  {
		  P *p;
		  if (piseof (bw->cursor))
			  return -1;
		  pgetc (p = pdup (bw->cursor));
		  bdel (bw->cursor, p);
		  prm (p);
	  }
d626 19
a644 20
int ubacks (BW *bw, int k) {
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
	  {
		  char c = k;
		  write (bw->out, &c, 1);
	  }
	else if (bw->parent->watom->what == TYPETW || !pisbol (bw->cursor))
	  {
		  P *p;
		  int c;
		  if (pisbof (bw->cursor))
			  return -1;
		  p = pdup (bw->cursor);
		  if ((c = prgetc (bw->cursor)) != MAXINT)
			  if (!bw->o.overtype || c == '\t' || pisbol (p)
			      || piseol (p))
				  bdel (bw->cursor, p);
		  prm (p);
	  }
	else
d656 11
a666 10
int u_word_delete (BW *bw) {
	P *p = pdup (bw->cursor);
	int c = brc (p);

	if (isalnum_ (c))
		while (c = brc (p), isalnum_ (c))
			pgetc (p);
	else if (isspace (c))
		while (c = brc (p), isspace (c))
			pgetc (p);
d668 1
a668 1
		pgetc (p);
d671 1
a671 1
		prm (p);
d674 2
a675 2
	bdel (bw->cursor, p);
	prm (p);
d683 7
a689 5
int ubackw (BW *bw) {
	P *p = pdup (bw->cursor);
	int c = prgetc (bw->cursor);
	if (isalnum_ (c)) {
		while (c = prgetc (bw->cursor), isalnum_ (c));
d691 3
a693 3
			pgetc (bw->cursor);
	} else if (isspace (c)) {
		while (c = prgetc (bw->cursor), isspace (c));
d695 1
a695 1
			pgetc (bw->cursor);
d698 1
a698 1
		prm (p);
d701 2
a702 2
	bdel (bw->cursor, p);
	prm (p);
d710 4
a713 2
int udelel (BW *bw) {
	P *p = p_goto_eol (pdup (bw->cursor));
d715 2
a716 2
		prm (p);
		return udelch (bw);
d718 2
a719 2
		bdel (bw->cursor, p);
	prm (p);
d727 10
a736 10
int udelbl (BW *bw) {
	P *p = p_goto_bol (pdup (bw->cursor));
	if (p->byte == bw->cursor->byte)
	  {
		  prm (p);
		  return ubacks (bw, MAXINT);
	  }
	else
		bdel (p, bw->cursor);
	prm (p);
d742 12
a753 11
int udelln (BW *bw) {
	P *p = pdup (bw->cursor);
	p_goto_bol (bw->cursor);
	pnextl (p);
	if (bw->cursor->byte == p->byte)
	  {
		  prm (p);
		  return -1;
	  }
	bdel (bw->cursor, p);
	prm (p);
d759 3
a761 2
int uinsc (BW *bw) {
	binsc (bw->cursor, ' ');
d770 26
a795 31
int utypebw (BW *bw, int k) {
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
	  {
		  char c = k;
		  write (bw->out, &c, 1);
	  }
	else if (k == '\t' && bw->o.spaces)
	  {
		  long n = piscol (bw->cursor);
		  n = bw->o.tab - n % bw->o.tab;
		  while (n--)
			  utypebw (bw, ' ');
	  }
	else
	  {
		  int upd =
			  bw->parent->t->t->updtab[bw->y + bw->cursor->line -
						   bw->top->line];
		  int simple = 1;
		  if (pisblank (bw->cursor))
			  while (piscol (bw->cursor) < bw->o.lmargin)
				  binsc (bw->cursor, ' '), pgetc (bw->cursor);
		  binsc (bw->cursor, k), pgetc (bw->cursor);
		  if (bw->o.wordwrap && piscol (bw->cursor) > bw->o.rmargin
		      && !isblank (k))
			  wrapword (bw->cursor, (long) bw->o.lmargin,
				    bw->o.french, NULL), simple = 0;
		  else if (bw->o.overtype && !piseol (bw->cursor)
			   && k != '\t')
			  udelch (bw);
		  bw->cursor->xcol = piscol (bw->cursor);
d797 25
a821 38
		  if (bw->cursor->xcol - bw->offset - 1 < 0
		      || bw->cursor->xcol - bw->offset - 1 >= bw->w)
			  simple = 0;
		  if (bw->cursor->line < bw->top->line ||
		      bw->cursor->line >= bw->top->line + bw->h)
			  simple = 0;
		  if (simple &&
		      bw->parent->t->t->sary[bw->y + bw->cursor->line -
					     bw->top->line]) simple = 0;
		  if (simple && k != '\t' && k != '\n' && !curmacro)
		    {
			    int c = 0;
			    SCRN *t = bw->parent->t->t;
			    int y = bw->y + bw->cursor->line - bw->top->line;
			    int x = bw->cursor->xcol - bw->offset + bw->x - 1;
			    int *screen = t->scrn + y * t->co;
			    if (!upd && piseol (bw->cursor))
				    t->updtab[y] = 0;
			    if (markb && markk && markb->b == bw->b
				&& markk->b == bw->b && (!square
							 && bw->cursor->
							 byte >= markb->byte
							 && bw->cursor->byte <
							 markk->byte || square
							 && bw->cursor->
							 line >= markb->line
							 && bw->cursor->
							 line <= markk->line
							 && piscol (bw->
								    cursor) >=
							 markb->xcol
							 && piscol (bw->
								    cursor) <
							 markk->xcol))
				    c = INVERSE;
			    xlat (c, k);
			    outatr (t, screen + x, x, y, k, c);
		    }
d823 1
a823 1
	  }
d832 2
a833 1
int doquote (BW *bw, int c, void *object, int *notify) {
d835 134
a968 168
	if (c < 0 || c >= 256)
	  {
		  nungetc (c);
		  return -1;
	  }
	switch (quotestate)
	  {
	  case 0:
		  if (c >= '0' && c <= '9')
		    {
			    quoteval = c - '0';
			    quotestate = 1;
			    snprintf (buf, sizeof(buf), "ASCII %c--", c);
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  else if (c == 'x' || c == 'X')
		    {
			    quotestate = 3;
			    if (!mkqwna
				(bw->parent, sc ("ASCII 0x--"), doquote, NULL, NULL,
				 notify))
				    return -1;
			    else
				    return 0;
		    }
		  else if (c == 'o' || c == 'O')
		    {
			    quotestate = 5;
			    if (!mkqwna
				(bw->parent, sc ("ASCII 0---"), doquote, NULL, NULL,
				 notify))
				    return -1;
			    else
				    return 0;
		    }
		  else
		    {
			    if ((c >= 0x40 && c <= 0x5F)
				|| (c >= 'a' && c <= 'z'))
				    c &= 0x1F;
			    if (c == '?')
				    c = 127;
			    utypebw (bw, c);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  break;

	  case 1:
		  if (c >= '0' && c <= '9')
		    {
			    snprintf (buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
			    quoteval = quoteval * 10 + c - '0';
			    quotestate = 2;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  break;

	  case 2:
		  if (c >= '0' && c <= '9')
		    {
			    quoteval = quoteval * 10 + c - '0';
			    utypebw (bw, quoteval);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  break;

	  case 3:
		  if (c >= '0' && c <= '9')
		    {
			    snprintf (buf, sizeof(buf), "ASCII 0x%c-", c);
			    quoteval = c - '0';
			    quotestate = 4;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  else if (c >= 'a' && c <= 'f')
		    {
			    snprintf (buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
			    quoteval = c - 'a' + 10;
			    quotestate = 4;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  else if (c >= 'A' && c <= 'F')
		    {
			    snprintf (buf, sizeof(buf), "ASCII 0x%c-", c);
			    quoteval = c - 'A' + 10;
			    quotestate = 4;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  break;

	  case 4:
		  if (c >= '0' && c <= '9')
		    {
			    quoteval = quoteval * 16 + c - '0';
			    utypebw (bw, quoteval);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  else if (c >= 'a' && c <= 'f')
		    {
			    quoteval = quoteval * 16 + c - 'a' + 10;
			    utypebw (bw, quoteval);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  else if (c >= 'A' && c <= 'F')
		    {
			    quoteval = quoteval * 16 + c - 'A' + 10;
			    utypebw (bw, quoteval);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  break;

	  case 5:
		  if (c >= '0' && c <= '7')
		    {
			    snprintf (buf, sizeof(buf), "ASCII 0%c--", c);
			    quoteval = c - '0';
			    quotestate = 6;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  break;

	  case 6:
		  if (c >= '0' && c <= '7')
		    {
			    snprintf (buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
			    quoteval = quoteval * 8 + c - '0';
			    quotestate = 7;
			    if (!mkqwna
				(bw->parent, sz (buf), doquote, NULL, NULL, notify))
				    return -1;
			    else
				    return 0;
		    }
		  break;

	  case 7:
		  if (c >= '0' && c <= '7')
		    {
			    quoteval = quoteval * 8 + c - '0';
			    utypebw (bw, quoteval);
			    bw->cursor->xcol = piscol (bw->cursor);
		    }
		  break;
	  }
d974 2
a975 1
int uquote (BW *bw) {
d977 1
a977 4
	if (mkqwna (bw->parent,
		    sc
		    ("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"),
		    doquote, NULL, NULL, NULL))
d983 2
a984 1
int doquote9 (BW *bw, int c, void *object, int *notify) {
d992 2
a993 2
	utypebw (bw, c);
	bw->cursor->xcol = piscol (bw->cursor);
d997 8
a1004 9
int doquote8 (BW *bw, int c, void *object, int *notify) {
	if (c == '`')
	  {
		  if (mkqwna
		      (bw->parent, sc ("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
			  return 0;
		  else
			  return -1;
	  }
d1008 2
a1009 2
	utypebw (bw, c);
	bw->cursor->xcol = piscol (bw->cursor);
d1013 3
a1015 2
int uquote8 (BW *bw) {
	if (mkqwna (bw->parent, sc ("Meta-"), doquote8, NULL, NULL, NULL))
d1023 2
a1024 1
int doctrl (BW *bw, int c, void *object, int *notify) {
d1026 1
d1031 1
a1031 1
		utypebw (bw, '\\'), utypebw (bw, 'n');
d1033 1
a1033 1
		utype (bw, c);
d1035 1
a1035 1
	bw->cursor->xcol = piscol (bw->cursor);
d1039 3
a1041 2
int uctrl (BW *bw) {
	if (mkqwna (bw->parent, sc ("Quote"), doctrl, NULL, NULL, NULL))
d1051 17
a1067 19
int rtntw (BW *bw) {
	if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
	  {
		  write (bw->out, "\n", 1);
	  }
	else
	  {
		  P *p = pdup (bw->cursor);
		  char c;
		  binsc (bw->cursor, '\n'), pgetc (bw->cursor);
		  if (bw->o.autoindent)
		    {
			    p_goto_bol (p);
			    while (isblank (c = pgetc (p)))
				    binsc (bw->cursor, c), pgetc (bw->cursor);
		    }
		  prm (p);
		  bw->cursor->xcol = piscol (bw->cursor);
	  }
d1073 7
a1079 5
int uopen (BW *bw) {
	P *q = pdup (bw->cursor);
	rtntw (bw);
	pset (bw->cursor, q);
	prm (q);
d1085 2
a1086 1
int dosetmark (BW *bw, int c, void *object, int *notify) {
d1089 10
a1098 13
	if (c >= '0' && c <= '9')
	  {
		  pdupown (bw->cursor, bw->b->marks + c - '0');
		  poffline (bw->b->marks[c - '0']);
		  snprintf (msgbuf, MSGBUFSIZE, "Mark %d set", c - '0');
		  msgnw (bw, msgbuf);
		  return 0;
	  }
	else
	  {
		  nungetc (c);
		  return -1;
	  }
d1101 2
a1102 1
int usetmark (BW *bw, int c) {
d1104 2
a1105 4
		return dosetmark (bw, c, NULL, NULL);
	else
		if (mkqwna
		    (bw->parent, sc ("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
d1113 2
a1114 1
int dogomark (BW *bw, int c, void *object, int *notify) {
d1118 12
a1129 17
		if (bw->b->marks[c - '0'])
		  {
			  pset (bw->cursor, bw->b->marks[c - '0']);
			  bw->cursor->xcol = piscol (bw->cursor);
			  return 0;
		  }
		else
		  {
			  snprintf (msgbuf, MSGBUFSIZE, "Mark %d not set", c - '0');
			  msgnw (bw, msgbuf);
			  return -1;
		  }
	else
	  {
		  nungetc (c);
		  return -1;
	  }
d1132 2
a1133 1
int ugomark (BW *bw, int c) {
d1135 2
a1136 5
		return dogomark (bw, c, NULL, NULL);
	else
		if (mkqwna
		    (bw->parent, sc ("Goto bookmark (0-9):"), dogomark, NULL, NULL,
		     NULL))
d1146 2
a1147 1
int dofwrdc (BW *bw, int k, void *object, int *notify) {
d1150 1
d1153 24
a1176 31
	if (k < 0 || k >= 256)
	  {
		  nungetc (k);
		  return -1;
	  }
	q = pdup (bw->cursor);
	if (dobkwdc)
	  {
		  while ((c = prgetc (q)) != MAXINT)
			  if (c == k)
				  break;
	  }
	else
	  {
		  while ((c = pgetc (q)) != MAXINT)
			  if (c == k)
				  break;
	  }
	if (c == MAXINT)
	  {
		  msgnw (bw, "Not found");
		  prm (q);
		  return -1;
	  }
	else
	  {
		  pset (bw->cursor, q);
		  bw->cursor->xcol = piscol (bw->cursor);
		  prm (q);
		  return 0;
	  }
d1179 2
a1180 1
int ufwrdc (BW *bw, int k) {
d1183 2
a1184 2
		return dofwrdc (bw, k, NULL, NULL);
	else if (mkqw (bw->parent, sc ("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
d1190 2
a1191 1
int ubkwdc (BW *bw, int k) {
d1194 2
a1195 2
		return dofwrdc (bw, k, NULL, NULL);
	else if (mkqw (bw->parent, sc ("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
d1203 2
a1204 1
int domsg (BASE *b, char *s, void *object, int *notify) {
d1207 3
a1209 3
	strcpy (msgbuf, s);
	vsrm (s);
	msgnw (b, msgbuf);
d1213 2
a1214 1
int umsg (BASE *b) {
d1223 2
a1224 1
int dotxt (BW *bw, char *s, void *object, int *notify) {
d1226 1
d1229 3
a1231 3
	for (x = 0; x != sLEN (s); ++x)
		utypebw (bw, s[x]);
	vsrm (s);
d1235 2
a1236 1
int utxt (BASE *bw) {
d1241 1
a1241 1
}@


1.4
log
@changed as of joe-2.9.5
@
text
@d8 2
d12 2
a30 1
/* Global options */
d32 5
a36 6
int pgamnt = -1;		/* No. of PgUp/PgDn lines to keep */

/* Move cursor to beginning of line */

int ubol (BW *bw) {
	pbol (bw->cursor);
d40 2
a41 4
/* Move cursor to end of line */

int ueol (BW *bw) {
	peol (bw->cursor);
d45 5
a49 4
/* Move cursor to beginning of file */

int ubof (BW *bw) {
	pbof (bw->cursor);
d53 2
a54 4
/* Move cursor to end of file */

int ueof (BW *bw) {
	peof (bw->cursor);
d58 11
a68 1
/* Move cursor left */
d70 3
a72 2
int ultarw (BW *bw) {
	if (prgetc (bw->cursor) != MAXINT)
d74 1
a74 1
	else
d76 1
d79 12
a90 1
/* Move cursor right */
d92 4
a95 2
int urtarw (BW *bw) {
	if (pgetc (bw->cursor) != MAXINT)
d97 1
a97 1
	else
d99 1
a101 2
/* Move cursor to beginning of previous word, previous edge, or beginning
   of line */
d103 26
a128 2
int uprvwrd (BW *bw) {
	int c, d;
d130 17
a146 2
	if (pisbof (bw->cursor))
		return -1;
d148 4
a151 11
	/* Move to end of previous word or edge */
	lp:
	d = ' ';
	while (c = prgetc (bw->cursor), c != MAXINT && !isalnum_ (c) && (!isspace (c) || isspace (d)))
		d = c;
	if (c == ' ') {
		d = prgetc (bw->cursor);
		if (d != MAXINT) pgetc (bw->cursor);
		if (!isspace (d)) {
			pgetc (bw->cursor);
			goto lp;
d154 2
a155 1
	if (c != MAXINT) pgetc (bw->cursor);
d157 49
a205 4
	/* Move to beginning of current word */
	while (isalnum_ (c = prgetc (bw->cursor)));
	if (c != MAXINT)
		pgetc (bw->cursor);
d209 7
a215 1
/* Move cursor to end of next word, next edge, or end of line */
d217 6
a222 105
int
unxtwrd (bw)
     BW *bw;
{
  int c, d;
  if (piseof (bw->cursor))
    return -1;
  /* Move to start of next word or edge */
lp:
  d = ' ';
  while (c = brc (bw->cursor),
	 c != MAXINT && !isalnum_ (c) && (!isspace (c) || isspace (d)))
    d = pgetc (bw->cursor);
  if (c == ' ')
    {
      pgetc (bw->cursor);
      d = brc (bw->cursor);
      prgetc (bw->cursor);
      if (!isspace (d))
	goto lp;
    }
  /* Move to end of current word */
  while (c = brc (bw->cursor), isalnum_ (c))
    pgetc (bw->cursor);
  return 0;
}

P *
pboi (p)
     P *p;
{
  pbol (p);
  while (isblank (brc (p)))
    pgetc (p);
  return p;
}

int
pisedge (p)
     P *p;
{
  P *q;
  int c;
  if (pisbol (p))
    return -1;
  if (piseol (p))
    return 1;
  q = pdup (p);
  pboi (q);
  if (q->byte == p->byte)
    goto left;
  if (isblank (c = brc (p)))
    {
      pset (q, p);
      if (isblank (prgetc (q)))
	goto no;
      if (c == '\t')
	goto right;
      pset (q, p);
      pgetc (q);
      if (pgetc (q) == ' ')
	goto right;
      goto no;
    }
  else
    {
      pset (q, p);
      c = prgetc (q);
      if (c == '\t')
	goto left;
      if (c != ' ')
	goto no;
      if (prgetc (q) == ' ')
	goto left;
      goto no;
    }

right:prm (q);
  return 1;
left:prm (q);
  return -1;
no:prm (q);
  return 0;
}

int
upedge (bw)
     BW *bw;
{
  if (prgetc (bw->cursor) == MAXINT)
    return -1;
  while (pisedge (bw->cursor) != -1)
    prgetc (bw->cursor);
  return 0;
}

int
unedge (bw)
     BW *bw;
{
  if (pgetc (bw->cursor) == MAXINT)
    return -1;
  while (pisedge (bw->cursor) != 1)
    pgetc (bw->cursor);
  return 0;
d227 86
a312 121
int
utomatch (bw)
     BW *bw;
{
  int d;
  int c,			/* Character under cursor */
    f,				/* Character to find */
    dir;			/* 1 to search forward, -1 to search backward */

  switch (c = brc (bw->cursor))
    {
    case '(':
      f = ')';
      dir = 1;
      break;
    case '[':
      f = ']';
      dir = 1;
      break;
    case '{':
      f = '}';
      dir = 1;
      break;
    case '`':
      f = '\'';
      dir = 1;
      break;
    case '<':
      f = '>';
      dir = 1;
      break;
    case ')':
      f = '(';
      dir = -1;
      break;
    case ']':
      f = '[';
      dir = -1;
      break;
    case '}':
      f = '{';
      dir = -1;
      break;
    case '\'':
      f = '`';
      dir = -1;
      break;
    case '>':
      f = '<';
      dir = -1;
      break;
    default:
      return -1;
    }

  if (dir == 1)
    {
      P *p = pdup (bw->cursor);
      int cnt = 0;		/* No. levels of delimiters we're in */
      while (d = pgetc (p), d != MAXINT)
	if (d == c)
	  ++cnt;
	else if (d == f && !--cnt)
	  {
	    prgetc (p);
	    pset (bw->cursor, p);
	    break;
	  }
      prm (p);
    }
  else
    {
      P *p = pdup (bw->cursor);
      int cnt = 0;		/* No. levels of delimiters we're in */
      while (d = prgetc (p), d != MAXINT)
	if (d == c)
	  ++cnt;
	else if (d == f)
	  if (!cnt--)
	    {
	      pset (bw->cursor, p);
	      break;
	    }
      prm (p);
    }
  if (d == MAXINT)
    return -1;
  else
    return 0;
}

/* Move cursor up */

int
uuparw (bw)
     BW *bw;
{
  if (bw->cursor->line)
    {
      pprevl (bw->cursor);
      pcol (bw->cursor, bw->cursor->xcol);
      return 0;
    }
  else
    return -1;
}

/* Move cursor down */

int
udnarw (bw)
     BW *bw;
{
  if (bw->cursor->line != bw->b->eof->line)
    {
      pnextl (bw->cursor);
      pcol (bw->cursor, bw->cursor->xcol);
      return 0;
    }
  else
    return -1;
d315 1
d318 6
a323 9
int
utos (bw)
     BW *bw;
{
  long col = bw->cursor->xcol;
  pset (bw->cursor, bw->top);
  pcol (bw->cursor, col);
  bw->cursor->xcol = col;
  return 0;
d328 6
a333 9
int
ubos (bw)
     BW *bw;
{
  long col = bw->cursor->xcol;
  pline (bw->cursor, bw->top->line + bw->h - 1);
  pcol (bw->cursor, col);
  bw->cursor->xcol = col;
  return 0;
d344 30
a373 33
void
scrup (bw, n, flg)
     BW *bw;
{
  int scrollamnt = 0;
  int cursoramnt = 0;
  int x;

  /* Decide number of lines we're really going to scroll */

  if (bw->top->line >= n)
    scrollamnt = cursoramnt = n;
  else if (bw->top->line)
    scrollamnt = cursoramnt = bw->top->line;
  else if (flg)
    cursoramnt = bw->cursor->line;
  else if (bw->cursor->line >= n)
    cursoramnt = n;

  /* Move top-of-window pointer */
  for (x = 0; x != scrollamnt; ++x)
    pprevl (bw->top);
  pbol (bw->top);

  /* Move cursor */
  for (x = 0; x != cursoramnt; ++x)
    pprevl (bw->cursor);
  pbol (bw->cursor);
  pcol (bw->cursor, bw->cursor->xcol);

  /* If window is on the screen, give (buffered) scrolling command */
  if (bw->parent->y != -1)
    nscrldn (bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d384 30
a413 33
void
scrdn (bw, n, flg)
     BW *bw;
{
  int scrollamnt = 0;
  int cursoramnt = 0;
  int x;

  /* How much we're really going to scroll... */
  if (bw->top->b->eof->line < bw->top->line + bw->h)
    {
      cursoramnt = bw->top->b->eof->line - bw->cursor->line;
      if (!flg && cursoramnt > n)
	cursoramnt = n;
    }
  else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
    cursoramnt = scrollamnt = n;
  else
    cursoramnt = scrollamnt =
      bw->top->b->eof->line - (bw->top->line + bw->h) + 1;

  /* Move top-of-window pointer */
  for (x = 0; x != scrollamnt; ++x)
    pnextl (bw->top);

  /* Move cursor */
  for (x = 0; x != cursoramnt; ++x)
    pnextl (bw->cursor);
  pcol (bw->cursor, bw->cursor->xcol);

  /* If window is on screen, give (buffered) scrolling command to terminal */
  if (bw->parent->y != -1)
    nscrlup (bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d416 3
d421 11
a431 14
int
upgup (bw)
     BW *bw;
{
  bw = (BW *) bw->parent->main->object;
  if (!bw->cursor->line)
    return -1;
  if (pgamnt < 0)
    scrup (bw, bw->h / 2 + bw->h % 2, 1);
  else if (pgamnt < bw->h)
    scrup (bw, bw->h - pgamnt, 1);
  else
    scrup (bw, 1, 1);
  return 0;
d436 11
a446 14
int
upgdn (bw)
     BW *bw;
{
  bw = (BW *) bw->parent->main->object;
  if (bw->cursor->line == bw->b->eof->line)
    return -1;
  if (pgamnt < 0)
    scrdn (bw, bw->h / 2 + bw->h % 2, 1);
  else if (pgamnt < bw->h)
    scrdn (bw, bw->h - pgamnt, 1);
  else
    scrdn (bw, 1, 1);
  return 0;
d451 24
a474 30
int
uupslide (bw)
     BW *bw;
{
  bw = (BW *) bw->parent->main->object;
  if (bw->top->line)
    {
      if (bw->top->line + bw->h - 1 != bw->cursor->line)
	udnarw (bw);
      scrup (bw, 1, 0);
      return 0;
    }
  else
    return -1;
}

int
udnslide (bw)
     BW *bw;
{
  bw = (BW *) bw->parent->main->object;
  if (bw->top->line + bw->h <= bw->top->b->eof->line)
    {
      if (bw->top->line != bw->cursor->line)
	uuparw (bw);
      scrdn (bw, 1, 0);
      return 0;
    }
  else
    return -1;
d481 34
a514 42
static int
doline (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
  long num = calc (bw, s);
  if (notify)
    *notify = 1;
  vsrm (s);
  if (num >= 1 && !merr)
    {
      int tmp = mid;
      if (num > bw->b->eof->line)
	num = bw->b->eof->line + 1;
      pline (bw->cursor, num - 1), bw->cursor->xcol = piscol (bw->cursor);
      mid = 1;
      dofollows ();
      mid = tmp;
      return 0;
    }
  else
    {
      if (merr)
	msgnw (bw, merr);
      else
	msgnw (bw, "Invalid line number");
      return -1;
    }
}

int
uline (bw)
     BW *bw;
{
  if (wmkpw
      (bw, "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL,
       NULL, NULL))
    return 0;
  else
    return -1;
d521 32
a552 40
static int
docol (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
  long num = calc (bw, s);
  if (notify)
    *notify = 1;
  vsrm (s);
  if (num >= 1 && !merr)
    {
      int tmp = mid;
      pcol (bw->cursor, num - 1), bw->cursor->xcol = piscol (bw->cursor);
      mid = 1;
      dofollows ();
      mid = tmp;
      return 0;
    }
  else
    {
      if (merr)
	msgnw (bw, merr);
      else
	msgnw (bw, "Invalid column number");
      return -1;
    }
}

int
ucol (bw)
     BW *bw;
{
  if (wmkpw
      (bw, "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL,
       NULL, NULL))
    return 0;
  else
    return -1;
d559 32
a590 40
static int
dobyte (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
  long num = calc (bw, s);
  if (notify)
    *notify = 1;
  vsrm (s);
  if (num >= 0 && !merr)
    {
      int tmp = mid;
      pgoto (bw->cursor, num), bw->cursor->xcol = piscol (bw->cursor);
      mid = 1;
      dofollows ();
      mid = tmp;
      return 0;
    }
  else
    {
      if (merr)
	msgnw (bw, merr);
      else
	msgnw (bw, "Invalid byte number");
      return -1;
    }
}

int
ubyte (bw)
     BW *bw;
{
  if (wmkpw
      (bw, "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL,
       NULL, NULL))
    return 0;
  else
    return -1;
d597 16
a612 19
int
udelch (bw)
     BW *bw;
{
  if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
    {
      char c = 4;
      write (bw->pid, &c, 0);
    }
  else
    {
      P *p;
      if (piseof (bw->cursor))
	return -1;
      pgetc (p = pdup (bw->cursor));
      bdel (bw->cursor, p);
      prm (p);
    }
  return 0;
d618 22
a639 24
int
ubacks (bw, k)
     BW *bw;
{
  if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
    {
      char c = k;
      write (bw->out, &c, 1);
    }
  else if (bw->parent->watom->what == TYPETW || !pisbol (bw->cursor))
    {
      P *p;
      int c;
      if (pisbof (bw->cursor))
	return -1;
      p = pdup (bw->cursor);
      if ((c = prgetc (bw->cursor)) != MAXINT)
	if (!bw->o.overtype || c == '\t' || pisbol (p) || piseol (p))
	  bdel (bw->cursor, p);
      prm (p);
    }
  else
    return -1;
  return 0;
d648 1
a648 1
 */	
d675 19
a693 26
int
ubackw (bw)
     BW *bw;
{
  P *p = pdup (bw->cursor);
  int c = prgetc (bw->cursor);
  if (isalnum_ (c))
    {
      while (c = prgetc (bw->cursor), isalnum_ (c));
      if (c != MAXINT)
	pgetc (bw->cursor);
    }
  else if (isspace (c))
    {
      while (c = prgetc (bw->cursor), isspace (c));
      if (c != MAXINT)
	pgetc (bw->cursor);
    }
  if (bw->cursor->byte == p->byte)
    {
      prm (p);
      return -1;
    }
  bdel (bw->cursor, p);
  prm (p);
  return 0;
d700 9
a708 14
int
udelel (bw)
     BW *bw;
{
  P *p = peol (pdup (bw->cursor));
  if (bw->cursor->byte == p->byte)
    {
      prm (p);
      return udelch (bw);
    }
  else
    bdel (bw->cursor, p);
  prm (p);
  return 0;
d715 11
a725 14
int
udelbl (bw)
     BW *bw;
{
  P *p = pbol (pdup (bw->cursor));
  if (p->byte == bw->cursor->byte)
    {
      prm (p);
      return ubacks (bw, MAXINT);
    }
  else
    bdel (p, bw->cursor);
  prm (p);
  return 0;
d730 12
a741 15
int
udelln (bw)
     BW *bw;
{
  P *p = pdup (bw->cursor);
  pbol (bw->cursor);
  pnextl (p);
  if (bw->cursor->byte == p->byte)
    {
      prm (p);
      return -1;
    }
  bdel (bw->cursor, p);
  prm (p);
  return 0;
d746 3
a748 6
int
uinsc (bw)
     BW *bw;
{
  binsc (bw->cursor, ' ');
  return 0;
d756 31
a786 33
int
utypebw (bw, k)
     BW *bw;
     int k;
{
  if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
    {
      char c = k;
      write (bw->out, &c, 1);
    }
  else if (k == '\t' && bw->o.spaces)
    {
      long n = piscol (bw->cursor);
      n = bw->o.tab - n % bw->o.tab;
      while (n--)
	utypebw (bw, ' ');
    }
  else
    {
      int upd =
	bw->parent->t->t->updtab[bw->y + bw->cursor->line - bw->top->line];
      int simple = 1;
      if (pisblank (bw->cursor))
	while (piscol (bw->cursor) < bw->o.lmargin)
	  binsc (bw->cursor, ' '), pgetc (bw->cursor);
      binsc (bw->cursor, k), pgetc (bw->cursor);
      if (bw->o.wordwrap && piscol (bw->cursor) > bw->o.rmargin
	  && !isblank (k))
	wrapword (bw->cursor, (long) bw->o.lmargin, bw->o.french, NULL),
	  simple = 0;
      else if (bw->o.overtype && !piseol (bw->cursor) && k != '\t')
	udelch (bw);
      bw->cursor->xcol = piscol (bw->cursor);
d788 38
a825 29
      if (bw->cursor->xcol - bw->offset - 1 < 0
	  || bw->cursor->xcol - bw->offset - 1 >= bw->w)
	simple = 0;
      if (bw->cursor->line < bw->top->line ||
	  bw->cursor->line >= bw->top->line + bw->h)
	simple = 0;
      if (simple &&
	  bw->parent->t->t->sary[bw->y + bw->cursor->line -
				 bw->top->line]) simple = 0;
      if (simple && k != '\t' && k != '\n' && !curmacro)
	{
	  int c = 0;
	  SCRN *t = bw->parent->t->t;
	  int y = bw->y + bw->cursor->line - bw->top->line;
	  int x = bw->cursor->xcol - bw->offset + bw->x - 1;
	  int *screen = t->scrn + y * t->co;
	  if (!upd && piseol (bw->cursor))
	    t->updtab[y] = 0;
	  if (markb && markk && markb->b == bw->b && markk->b == bw->b &&
	      (!square && bw->cursor->byte >= markb->byte
	       && bw->cursor->byte < markk->byte || square
	       && bw->cursor->line >= markb->line
	       && bw->cursor->line <= markk->line
	       && piscol (bw->cursor) >= markb->xcol
	       && piscol (bw->cursor) < markk->xcol))
	    c = INVERSE;
	  xlat (c, k);
	  outatr (t, screen + x, x, y, k, c);
	}
d827 2
a828 2
    }
  return 0;
d836 174
a1009 51
int
doquote (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  char buf[40];
  if (c < 0 || c >= 256)
    {
      nungetc (c);
      return -1;
    }
  switch (quotestate)
    {
    case 0:
      if (c >= '0' && c <= '9')
	{
	  quoteval = c - '0';
	  quotestate = 1;
	  sprintf (buf, "ASCII %c--", c);
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      else if (c == 'x' || c == 'X')
	{
	  quotestate = 3;
	  if (!mkqwna (bw, sc ("ASCII 0x--"), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      else if (c == 'o' || c == 'O')
	{
	  quotestate = 5;
	  if (!mkqwna (bw, sc ("ASCII 0---"), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      else
	{
	  if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
	    c &= 0x1F;
	  if (c == '?')
	    c = 127;
	  utypebw (bw, c);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      break;
d1011 10
a1020 12
    case 1:
      if (c >= '0' && c <= '9')
	{
	  sprintf (buf, "ASCII %c%c-", quoteval + '0', c);
	  quoteval = quoteval * 10 + c - '0';
	  quotestate = 2;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      break;
d1022 12
a1033 8
    case 2:
      if (c >= '0' && c <= '9')
	{
	  quoteval = quoteval * 10 + c - '0';
	  utypebw (bw, quoteval);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      break;
d1035 16
a1050 32
    case 3:
      if (c >= '0' && c <= '9')
	{
	  sprintf (buf, "ASCII 0x%c-", c);
	  quoteval = c - '0';
	  quotestate = 4;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      else if (c >= 'a' && c <= 'f')
	{
	  sprintf (buf, "ASCII 0x%c-", c + 'A' - 'a');
	  quoteval = c - 'a' + 10;
	  quotestate = 4;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      else if (c >= 'A' && c <= 'F')
	{
	  sprintf (buf, "ASCII 0x%c-", c);
	  quoteval = c - 'A' + 10;
	  quotestate = 4;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      break;
d1052 6
a1057 20
    case 4:
      if (c >= '0' && c <= '9')
	{
	  quoteval = quoteval * 16 + c - '0';
	  utypebw (bw, quoteval);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      else if (c >= 'a' && c <= 'f')
	{
	  quoteval = quoteval * 16 + c - 'a' + 10;
	  utypebw (bw, quoteval);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      else if (c >= 'A' && c <= 'F')
	{
	  quoteval = quoteval * 16 + c - 'A' + 10;
	  utypebw (bw, quoteval);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      break;
d1059 1
a1059 12
    case 5:
      if (c >= '0' && c <= '7')
	{
	  sprintf (buf, "ASCII 0%c--", c);
	  quoteval = c - '0';
	  quotestate = 6;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      break;
d1061 11
a1071 67
    case 6:
      if (c >= '0' && c <= '7')
	{
	  sprintf (buf, "ASCII 0%c%c-", quoteval + '0', c);
	  quoteval = quoteval * 8 + c - '0';
	  quotestate = 7;
	  if (!mkqwna (bw, sz (buf), doquote, NULL, NULL, notify))
	    return -1;
	  else
	    return 0;
	}
      break;

    case 7:
      if (c >= '0' && c <= '7')
	{
	  quoteval = quoteval * 8 + c - '0';
	  utypebw (bw, quoteval);
	  bw->cursor->xcol = piscol (bw->cursor);
	}
      break;
    }
  if (notify)
    *notify = 1;
  return 0;
}

int
uquote (bw)
     BW *bw;
{
  quotestate = 0;
  if (mkqwna (bw,
	      sc ("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"),
	      doquote, NULL, NULL, NULL))
    return 0;
  else
    return -1;
}

int
doquote9 (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  if (notify)
    *notify = 1;
  if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
    c &= 0x1F;
  if (c == '?')
    c = 127;
  c |= 128;
  utypebw (bw, c);
  bw->cursor->xcol = piscol (bw->cursor);
  return 0;
}

int
doquote8 (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  if (c == '`')
    {
      if (mkqwna (bw, sc ("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
a1072 19
      else
	return -1;
    }
  if (notify)
    *notify = 1;
  c |= 128;
  utypebw (bw, c);
  bw->cursor->xcol = piscol (bw->cursor);
  return 0;
}

int
uquote8 (bw)
     BW *bw;
{
  if (mkqwna (bw, sc ("Meta-"), doquote8, NULL, NULL, NULL))
    return 0;
  else
    return -1;
d1075 5
a1079 29
extern char srchstr[];

int
doctrl (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  int org = bw->o.overtype;
  if (notify)
    *notify = 1;
  bw->o.overtype = 0;
  if (bw->parent->huh == srchstr && c == '\n')
    utypebw (bw, '\\'), utypebw (bw, 'n');
  else
    utype (bw, c);
  bw->o.overtype = org;
  bw->cursor->xcol = piscol (bw->cursor);
  return 0;
}

int
uctrl (bw)
     BW *bw;
{
  if (mkqwna (bw, sc ("Quote"), doctrl, NULL, NULL, NULL))
    return 0;
  else
    return -1;
d1086 20
a1105 23
int
rtntw (bw)
     BW *bw;
{
  if (bw->pid && bw->cursor->byte == bw->b->eof->byte)
    {
      write (bw->out, "\n", 1);
    }
  else
    {
      P *p = pdup (bw->cursor);
      char c;
      binsc (bw->cursor, '\n'), pgetc (bw->cursor);
      if (bw->o.autoindent)
	{
	  pbol (p);
	  while (isblank (c = pgetc (p)))
	    binsc (bw->cursor, c), pgetc (bw->cursor);
	}
      prm (p);
      bw->cursor->xcol = piscol (bw->cursor);
    }
  return 0;
d1110 6
a1115 9
int
uopen (bw)
     BW *bw;
{
  P *q = pdup (bw->cursor);
  rtntw (bw);
  pset (bw->cursor, q);
  prm (q);
  return 0;
d1120 27
a1146 33
int
dosetmark (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  if (notify)
    *notify = 1;
  if (c >= '0' && c <= '9')
    {
      pdupown (bw->cursor, bw->b->marks + c - '0');
      poffline (bw->b->marks[c - '0']);
      sprintf (msgbuf, "Mark %d set", c - '0');
      msgnw (bw, msgbuf);
      return 0;
    }
  else
    {
      nungetc (c);
      return -1;
    }
}

int
usetmark (bw, c)
     BW *bw;
{
  if (c >= '0' && c <= '9')
    return dosetmark (bw, c, NULL, NULL);
  else if (mkqwna (bw, sc ("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
    return 0;
  else
    return -1;
d1151 33
a1183 39
int
dogomark (bw, c, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  if (notify)
    *notify = 1;
  if (c >= '0' && c <= '9')
    if (bw->b->marks[c - '0'])
      {
	pset (bw->cursor, bw->b->marks[c - '0']);
	bw->cursor->xcol = piscol (bw->cursor);
	return 0;
      }
    else
      {
	sprintf (msgbuf, "Mark %d not set", c - '0');
	msgnw (bw, msgbuf);
	return -1;
      }
  else
    {
      nungetc (c);
      return -1;
    }
}

int
ugomark (bw, c)
     BW *bw;
{
  if (c >= '0' && c <= '9')
    return dogomark (bw, c, NULL, NULL);
  else
    if (mkqwna (bw, sc ("Goto bookmark (0-9):"), dogomark, NULL, NULL, NULL))
      return 0;
  else
    return -1;
d1190 56
a1245 67
int
dofwrdc (bw, k, object, notify)
     BW *bw;
     void *object;
     int *notify;
{
  int c;
  P *q;
  if (notify)
    *notify = 1;
  if (k < 0 || k >= 256)
    {
      nungetc (k);
      return -1;
    }
  q = pdup (bw->cursor);
  if (dobkwdc)
    {
      while ((c = prgetc (q)) != MAXINT)
	if (c == k)
	  break;
    }
  else
    {
      while ((c = pgetc (q)) != MAXINT)
	if (c == k)
	  break;
    }
  if (c == MAXINT)
    {
      msgnw (bw, "Not found");
      prm (q);
      return -1;
    }
  else
    {
      pset (bw->cursor, q);
      bw->cursor->xcol = piscol (bw->cursor);
      prm (q);
      return 0;
    }
}

int
ufwrdc (bw, k)
     BW *bw;
{
  dobkwdc = 0;
  if (k >= 0 && k < 256)
    return dofwrdc (bw, k, NULL, NULL);
  else if (mkqw (bw, sc ("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
    return 0;
  else
    return -1;
}

int
ubkwdc (bw, k)
     BW *bw;
{
  dobkwdc = 1;
  if (k >= 0 && k < 256)
    return dofwrdc (bw, k, NULL, NULL);
  else if (mkqw (bw, sc ("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
    return 0;
  else
    return -1;
d1250 14
a1263 24
int
domsg (b, s, object, notify)
     BASE *b;
     char *s;
     void *object;
     int *notify;
{
  if (notify)
    *notify = 1;
  strcpy (msgbuf, s);
  vsrm (s);
  msgnw (b, msgbuf);
  return 0;
}

int
umsg (b)
     BASE *b;
{
  if (wmkpw
      (b, "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL,
       NULL)) return 0;
  else
    return -1;
d1268 8
a1275 25
int
dotxt (bw, s, object, notify)
     BW *bw;
     char *s;
     void *object;
     int *notify;
{
  int x;
  if (notify)
    *notify = 1;
  for (x = 0; x != sLEN (s); ++x)
    utypebw (bw, s[x]);
  vsrm (s);
  return 0;
}

int
utxt (bw)
     BASE *bw;
{
  if (wmkpw
      (bw, "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL,
       NULL)) return 0;
  else
    return -1;
d1277 7
@


1.3
log
@changed as of joe-2.9.4
@
text
@d17 1
a17 1
#include "zstr.h"
@


1.2
log
@changed as of joe-2.9.2
@
text
@d1 3
a3 2
/* Basic user edit functions
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d29 1
a29 1
int pgamnt= -1;				/* No. of PgUp/PgDn lines to keep */
d33 4
a36 6
int ubol(bw)
BW *bw;
 {
 pbol(bw->cursor);
 return 0;
 }
d40 4
a43 6
int ueol(bw)
BW *bw;
 {
 peol(bw->cursor);
 return 0;
 }
d47 4
a50 6
int ubof(bw)
BW *bw;
 {
 pbof(bw->cursor);
 return 0;
 }
d54 4
a57 6
int ueof(bw)
BW *bw;
 {
 peof(bw->cursor);
 return 0;
 }
d61 6
a66 6
int ultarw(bw)
BW *bw;
 {
 if(prgetc(bw->cursor)!=MAXINT) return 0;
 else return -1;
 }
d70 6
a75 6
int urtarw(bw)
BW *bw;
 {
 if(pgetc(bw->cursor)!=MAXINT) return 0;
 else return -1;
 }
d80 27
a106 22
int uprvwrd(bw)
BW *bw;
 {
 int c, d;
 if(pisbof(bw->cursor)) return -1;
 /* Move to end of previous word or edge */
 lp:
 d=' ';
 while(c=prgetc(bw->cursor),
       c!= MAXINT && !crest(c) && (!isspace(c) || isspace(d)))
  d=c; 
 if(c==' ')
  {
  d=prgetc(bw->cursor); if(d!=MAXINT) pgetc(bw->cursor);
  if(!isspace(d)) { pgetc(bw->cursor); goto lp; }
  }
 if(c!= MAXINT) pgetc(bw->cursor);
 /* Move to beginning of current word */
 while(crest(c=prgetc(bw->cursor)));
 if(c!= MAXINT) pgetc(bw->cursor);
 return 0;
 }
d110 106
a215 76
int unxtwrd(bw)
BW *bw;
 {
 int c, d;
 if(piseof(bw->cursor)) return -1;
 /* Move to start of next word or edge */
 lp:
 d=' ';
 while(c=brc(bw->cursor),
       c!= MAXINT && !crest(c) && (!isspace(c) || isspace(d)))
  d=pgetc(bw->cursor);
 if(c==' ')
  {
  pgetc(bw->cursor); d=brc(bw->cursor); prgetc(bw->cursor);
  if(!isspace(d)) goto lp;
  }
 /* Move to end of current word */
 while(c=brc(bw->cursor), crest(c)) pgetc(bw->cursor);
 return 0;
 }

P *pboi(p)
P *p;
 {
 pbol(p);
 while(isblank(brc(p))) pgetc(p);
 return p;
 }

int pisedge(p)
P *p;
 {
 P *q;
 int c;
 if(pisbol(p)) return -1;
 if(piseol(p)) return  1;
 q=pdup(p);
 pboi(q);
 if(q->byte==p->byte) goto left;
 if(isblank(c=brc(p)))
  {
  pset(q,p); if(isblank(prgetc(q))) goto no;
  if(c=='\t') goto right;
  pset(q,p); pgetc(q);
  if(pgetc(q)==' ') goto right;
  goto no;
  }
 else
  {
  pset(q,p); c=prgetc(q);
  if(c=='\t') goto left;
  if(c!=' ') goto no;
  if(prgetc(q)==' ') goto left;
  goto no;
  }

 right: prm(q); return 1;
 left: prm(q); return -1;
 no: prm(q); return 0;
 }

int upedge(bw)
BW *bw;
 {
 if(prgetc(bw->cursor)==MAXINT) return -1;
 while(pisedge(bw->cursor)!= -1) prgetc(bw->cursor);
 return 0;
 }

int unedge(bw)
BW *bw;
 {
 if(pgetc(bw->cursor)==MAXINT) return -1;
 while(pisedge(bw->cursor)!= 1) pgetc(bw->cursor);
 return 0;
 }
d219 90
a308 44
int utomatch(bw)
BW *bw;
 {
 int d;
 int c,		/* Character under cursor */
     f,		/* Character to find */
     dir;	/* 1 to search forward, -1 to search backward */
 
 switch(c=brc(bw->cursor))
  {
 case '(':  f=')';  dir=1;   break;
 case '[':  f=']';  dir=1;   break;
 case '{':  f='}';  dir=1;   break;
 case '`':  f='\''; dir=1;   break;
 case '<':  f='>';  dir=1;   break;
 case ')':  f='(';  dir= -1; break;
 case ']':  f='[';  dir= -1; break;
 case '}':  f='{';  dir= -1; break;
 case '\'': f='`';  dir= -1; break;
 case '>':  f='<';  dir= -1; break;
 default:   return -1;
  }
 
 if(dir==1)
  {
  P *p=pdup(bw->cursor);
  int cnt=0;	/* No. levels of delimiters we're in */
  while(d=pgetc(p), d!= MAXINT)
   if(d==c) ++cnt;
   else if(d==f && !--cnt) { prgetc(p); pset(bw->cursor,p); break; }
  prm(p);
  }
 else
  {
  P *p=pdup(bw->cursor);
  int cnt=0;	/* No. levels of delimiters we're in */
  while(d=prgetc(p), d!= MAXINT)
   if(d==c) ++cnt;
   else if(d==f) if(!cnt--) { pset(bw->cursor,p); break; }
  prm(p);
  }
 if(d==MAXINT) return -1;
 else return 0;
 }
d312 13
a324 11
int uuparw(bw)
BW *bw;
 {
 if(bw->cursor->line)
  {
  pprevl(bw->cursor);
  pcol(bw->cursor,bw->cursor->xcol);
  return 0;
  }
 else return -1;
 }
d328 13
a340 11
int udnarw(bw)
BW *bw;
 {
 if(bw->cursor->line!=bw->b->eof->line)
  {
  pnextl(bw->cursor);
  pcol(bw->cursor,bw->cursor->xcol);
  return 0;
  }
 else return -1;
 }
d344 10
a353 9
int utos(bw)
BW *bw;
 {
 long col=bw->cursor->xcol;
 pset(bw->cursor,bw->top);
 pcol(bw->cursor,col);
 bw->cursor->xcol=col;
 return 0;
 }
d357 10
a366 9
int ubos(bw)
BW *bw;
 {
 long col=bw->cursor->xcol;
 pline(bw->cursor,bw->top->line+bw->h-1);
 pcol(bw->cursor,col);
 bw->cursor->xcol=col;
 return 0;
 }
d376 34
a409 28
void scrup(bw,n,flg)
BW *bw;
 {
 int scrollamnt=0;
 int cursoramnt=0;
 int x;
 
 /* Decide number of lines we're really going to scroll */
 
 if(bw->top->line>=n) scrollamnt=cursoramnt=n;
 else
  if(bw->top->line) scrollamnt=cursoramnt=bw->top->line;
  else
   if(flg) cursoramnt=bw->cursor->line;
   else if(bw->cursor->line>=n) cursoramnt=n;
 
 /* Move top-of-window pointer */
 for(x=0;x!=scrollamnt;++x) pprevl(bw->top);
 pbol(bw->top);
 
 /* Move cursor */
 for(x=0;x!=cursoramnt;++x) pprevl(bw->cursor);
 pbol(bw->cursor);
 pcol(bw->cursor,bw->cursor->xcol);
 
 /* If window is on the screen, give (buffered) scrolling command */
 if(bw->parent->y!= -1) nscrldn(bw->parent->t->t,bw->y,bw->y+bw->h,scrollamnt);
 }
d419 34
a452 28
void scrdn(bw,n,flg)
BW *bw;
 {
 int scrollamnt=0;
 int cursoramnt=0;
 int x;
 
 /* How much we're really going to scroll... */
 if(bw->top->b->eof->line<bw->top->line+bw->h)
  {
  cursoramnt=bw->top->b->eof->line-bw->cursor->line;
  if(!flg && cursoramnt>n) cursoramnt=n;
  }
 else if(bw->top->b->eof->line-(bw->top->line+bw->h)>=n)
  cursoramnt=scrollamnt=n;
 else
  cursoramnt=scrollamnt=bw->top->b->eof->line-(bw->top->line+bw->h)+1;

 /* Move top-of-window pointer */
 for(x=0;x!=scrollamnt;++x) pnextl(bw->top);
 
 /* Move cursor */
 for(x=0;x!=cursoramnt;++x) pnextl(bw->cursor);
 pcol(bw->cursor,bw->cursor->xcol);
 
 /* If window is on screen, give (buffered) scrolling command to terminal */
 if(bw->parent->y!= -1) nscrlup(bw->parent->t->t,bw->y,bw->y+bw->h,scrollamnt);
 }
d456 15
a470 10
int upgup(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(!bw->cursor->line) return -1;
 if(pgamnt<0) scrup(bw,bw->h/2+bw->h%2,1);
 else if(pgamnt<bw->h) scrup(bw,bw->h-pgamnt,1);
 else scrup(bw,1,1);
 return 0;
 }
d474 15
a488 10
int upgdn(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->cursor->line==bw->b->eof->line) return -1;
 if(pgamnt<0) scrdn(bw,bw->h/2+bw->h%2,1);
 else if(pgamnt<bw->h) scrdn(bw,bw->h-pgamnt,1);
 else scrdn(bw,1,1);
 return 0;
 }
d492 31
a522 25
int uupslide(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->top->line)
  {
  if(bw->top->line+bw->h-1!=bw->cursor->line) udnarw(bw);
  scrup(bw,1,0);
  return 0;
  }
 else return -1;
 }

int udnslide(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->top->line+bw->h<=bw->top->b->eof->line)
  {
  if(bw->top->line!=bw->cursor->line) uuparw(bw);
  scrdn(bw,1,0);
  return 0;
  }
 else return -1;
 }
d526 1
a526 1
static B *linehist=0;	/* History of previously entered line numbers */
d528 43
a570 31
static int doline(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=1 && !merr)
  {
  int tmp=mid;
  if(num>bw->b->eof->line) num=bw->b->eof->line+1;
  pline(bw->cursor,num-1), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid line number");
  return -1;
  }
 }

int uline(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to line (^C to abort): ",&linehist,doline,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d574 1
a574 1
static B *colhist=0;	/* History of previously entered column numbers */
d576 41
a616 30
static int docol(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=1 && !merr)
  {
  int tmp=mid;
  pcol(bw->cursor,num-1), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid column number");
  return -1;
  }
 }

int ucol(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to column (^C to abort): ",&colhist,docol,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d620 1
a620 1
static B *bytehist=0;	/* History of previously entered byte numbers */
d622 41
a662 30
static int dobyte(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=0 && !merr)
  {
  int tmp=mid;
  pgoto(bw->cursor,num), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid byte number");
  return -1;
  }
 }

int ubyte(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to byte (^C to abort): ",&bytehist,dobyte,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d668 20
a687 18
int udelch(bw)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=4;
  write(bw->pid,&c,0);
  }
 else
  {
  P *p;
  if(piseof(bw->cursor)) return -1;
  pgetc(p=pdup(bw->cursor));
  bdel(bw->cursor,p);
  prm(p);
  }
 return 0;
 }
d692 25
a716 27
int ubacks(bw,k)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=k;
  write(bw->out,&c,1);
  }
 else if(bw->parent->watom->what==TYPETW || !pisbol(bw->cursor))
  {
  P *p;
  int c;
  if(pisbof(bw->cursor)) return -1;
  p=pdup(bw->cursor);
  if((c=prgetc(bw->cursor))!= MAXINT)
   if(!bw->o.overtype || c=='\t' || pisbol(p) || piseol(p))
    bdel(bw->cursor,p);
  prm(p);
  }
 else return -1;
 return 0;
 }

/* Delete from cursor to end of word it's on, to beginning of next word if
 * it's on whitespace or a single character if it's on neither a word nor
 * on whitespace
 */
d718 28
a745 15
int udelw(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 int c=brc(p);
 if(crest(c))
  while(c=brc(p), crest(c)) pgetc(p);
 else if(isspace(c) || c=='\r')
  while(c=brc(p), (isspace(c) || c=='\r')) pgetc(p);
 else pgetc(p);
 if(p->byte==bw->cursor->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d751 27
a777 20
int ubackw(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 int c=prgetc(bw->cursor);
 if(crest(c))
  {
  while(c=prgetc(bw->cursor), crest(c));
  if(c!= MAXINT) pgetc(bw->cursor);
  }
 else if(isspace(c))
  {
  while(c=prgetc(bw->cursor), isspace(c));
  if(c!= MAXINT) pgetc(bw->cursor);
  }
 if(bw->cursor->byte==p->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d783 15
a797 9
int udelel(bw)
BW *bw;
 {
 P *p=peol(pdup(bw->cursor));
 if(bw->cursor->byte==p->byte) { prm(p); return udelch(bw); }
 else bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d803 15
a817 9
int udelbl(bw)
BW *bw;
 {
 P *p=pbol(pdup(bw->cursor));
 if(p->byte==bw->cursor->byte) { prm(p); return ubacks(bw,MAXINT); }
 else bdel(p,bw->cursor);
 prm(p);
 return 0;
 }
d821 16
a836 11
int udelln(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 pbol(bw->cursor);
 pnextl(p);
 if(bw->cursor->byte==p->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d840 7
a846 6
int uinsc(bw)
BW *bw;
 {
 binsc(bw->cursor,' ');
 return 0;
 }
d853 33
a885 27
int utypebw(bw,k)
BW *bw;
int k;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=k;
  write(bw->out,&c,1);
  }
 else if(k=='\t' && bw->o.spaces)
  {
  long n=piscol(bw->cursor);
  n=bw->o.tab-n%bw->o.tab;
  while(n--) utypebw(bw,' ');
  }
 else
  {
  int upd=bw->parent->t->t->updtab[bw->y+bw->cursor->line-bw->top->line];
  int simple=1;
  if(pisblank(bw->cursor))
   while(piscol(bw->cursor)<bw->o.lmargin)
    binsc(bw->cursor,' '), pgetc(bw->cursor);
  binsc(bw->cursor,k), pgetc(bw->cursor);
  if(bw->o.wordwrap && piscol(bw->cursor)>bw->o.rmargin && !isblank(k))
   wrapword(bw->cursor,(long)bw->o.lmargin,bw->o.french,NULL), simple=0;
  else if(bw->o.overtype && !piseol(bw->cursor) && k!='\t') udelch(bw);
  bw->cursor->xcol=piscol(bw->cursor);
d887 29
a915 22
  if(bw->cursor->xcol-bw->offset-1<0 || bw->cursor->xcol-bw->offset-1>=bw->w)
   simple=0;
  if(bw->cursor->line<bw->top->line ||
     bw->cursor->line>=bw->top->line+bw->h) simple=0;
  if(simple &&
     bw->parent->t->t->sary[bw->y+bw->cursor->line-bw->top->line]) simple=0;
  if(simple && k!='\t' && k!='\n' && !curmacro)
   {
   int c=0;
   SCRN *t=bw->parent->t->t;
   int y=bw->y+bw->cursor->line-bw->top->line;
   int x=bw->cursor->xcol-bw->offset+bw->x-1;
   int *screen=t->scrn+y*t->co;
   if(!upd && piseol(bw->cursor)) t->updtab[y]=0;
   if(markb && markk && markb->b==bw->b && markk->b==bw->b &&
      (!square && bw->cursor->byte>=markb->byte && bw->cursor->byte<markk->byte ||
       square && bw->cursor->line>=markb->line && bw->cursor->line<=markk->line &&
       piscol(bw->cursor)>=markb->xcol && piscol(bw->cursor)<markk->xcol))
    c=INVERSE;
   xlat(c,k);
   outatr(t,screen+x,x,y,k,c);
   }
d917 3
a919 3
  }
 return 0;
 }
d926 229
a1154 192
int doquote(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 char buf[40];
 if(c<0 || c>=256)
  {
  nungetc(c);
  return -1;
  }
 switch(quotestate)
  {
  case 0:
  if(c>='0' && c<='9')
   {
   quoteval=c-'0';
   quotestate=1;
   sprintf(buf,"ASCII %c--",c);
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c=='x' || c=='X')
   {
   quotestate=3;
   if(!mkqwna(bw,sc("ASCII 0x--"),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c=='o' || c=='O')
   {
   quotestate=5;
   if(!mkqwna(bw,sc("ASCII 0---"),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else
   {
   if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
   if(c=='?') c=127;
   utypebw(bw,c);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 1:
  if(c>='0' && c<='9')
   {
   sprintf(buf,"ASCII %c%c-",quoteval+'0',c);
   quoteval=quoteval*10+c-'0';
   quotestate=2;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 2:
  if(c>='0' && c<='9')
   {
   quoteval=quoteval*10+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 3:
  if(c>='0' && c<='9')
   {
   sprintf(buf,"ASCII 0x%c-",c);
   quoteval=c-'0';
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c>='a' && c<='f')
   {
   sprintf(buf,"ASCII 0x%c-",c+'A'-'a');
   quoteval=c-'a'+10;
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c>='A' && c<='F')
   {
   sprintf(buf,"ASCII 0x%c-",c);
   quoteval=c-'A'+10;
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 4:
  if(c>='0' && c<='9')
   {
   quoteval=quoteval*16+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else if(c>='a' && c<='f')
   {
   quoteval=quoteval*16+c-'a'+10;
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else if(c>='A' && c<='F')
   {
   quoteval=quoteval*16+c-'A'+10;
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 5:
  if(c>='0' && c<='7')
   {
   sprintf(buf,"ASCII 0%c--",c);
   quoteval=c-'0';
   quotestate=6;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 6:
  if(c>='0' && c<='7')
   {
   sprintf(buf,"ASCII 0%c%c-",quoteval+'0',c);
   quoteval=quoteval*8+c-'0';
   quotestate=7;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 7:
  if(c>='0' && c<='7')
   {
   quoteval=quoteval*8+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;
  }
 if(notify) *notify=1;
 return 0;
 }

int uquote(bw)
BW *bw;
 {
 quotestate=0;
 if(mkqwna(bw,
           sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"),doquote,NULL,NULL,NULL)) return 0;
 else return -1;
 }

int doquote9(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
 if(c=='?') c=127;
 c|=128;
 utypebw(bw,c);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int doquote8(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='`')
  {
  if(mkqwna(bw,sc("Meta-Ctrl-"),doquote9,NULL,NULL,notify)) return 0;
  else return -1;
  }
 if(notify) *notify=1;
 c|=128;
 utypebw(bw,c);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int uquote8(bw)
BW *bw;
 {
 if(mkqwna(bw,sc("Meta-"),doquote8,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1158 28
a1185 23
int doctrl(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 int org=bw->o.overtype;
 if(notify) *notify=1;
 bw->o.overtype=0;
 if(bw->parent->huh==srchstr && c=='\n')
   utypebw(bw,'\\'), utypebw(bw,'n');
 else
  utype(bw,c);
 bw->o.overtype=org;
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int uctrl(bw)
BW *bw;
 {
 if(mkqwna(bw,sc("Quote"),doctrl,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1191 24
a1214 23
int rtntw(bw)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  write(bw->out,"\n",1);
  }
 else
  {
  P *p=pdup(bw->cursor);
  char c;
  binsc(bw->cursor,'\n'), pgetc(bw->cursor);
  if(bw->o.autoindent)
   {
   pbol(p);
   while(isblank(c=pgetc(p)))
    binsc(bw->cursor,c), pgetc(bw->cursor);
   }
  prm(p);
  bw->cursor->xcol=piscol(bw->cursor);
  }
 return 0;
 }
d1218 10
a1227 9
int uopen(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 rtntw(bw);
 pset(bw->cursor,q);
 prm(q);
 return 0;
 }
d1231 34
a1264 29
int dosetmark(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c>='0' && c<='9')
  {
  pdupown(bw->cursor,bw->b->marks+c-'0');
  poffline(bw->b->marks[c-'0']);
  sprintf(msgbuf,"Mark %d set",c-'0');
  msgnw(bw,msgbuf);
  return 0;
  }
 else
  {
  nungetc(c);
  return -1;
  }
 }

int usetmark(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return dosetmark(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Set mark (0-9):"),dosetmark,NULL,NULL,NULL)) return 0;
  else return -1;
 }
d1268 40
a1307 34
int dogomark(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c>='0' && c<='9')
  if(bw->b->marks[c-'0'])
   {
   pset(bw->cursor,bw->b->marks[c-'0']);
   bw->cursor->xcol=piscol(bw->cursor);
   return 0;
   }
  else
   {
   sprintf(msgbuf,"Mark %d not set",c-'0');
   msgnw(bw,msgbuf);
   return -1;
   }
 else
  {
  nungetc(c);
  return -1;
  }
 }

int ugomark(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return dogomark(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Goto bookmark (0-9):"),dogomark,NULL,NULL,NULL)) return 0;
  else return -1;
 }
d1313 68
a1380 48
int dofwrdc(bw,k,object,notify)
BW *bw;
void *object;
int *notify;
 {
 int c;
 P *q;
 if(notify) *notify=1;
 if(k<0 || k>=256)
  {
  nungetc(k);
  return -1;
  }
 q=pdup(bw->cursor);
 if(dobkwdc) { while((c=prgetc(q))!=MAXINT) if(c==k) break; }
 else { while((c=pgetc(q))!=MAXINT) if(c==k) break; }
 if(c==MAXINT)
  {
  msgnw(bw,"Not found");
  prm(q);
  return -1;
  }
 else
  {
  pset(bw->cursor,q);
  bw->cursor->xcol=piscol(bw->cursor);
  prm(q);
  return 0;
  }
 }

int ufwrdc(bw,k)
BW *bw;
 {
 dobkwdc=0;
 if(k>=0 && k<256) return dofwrdc(bw,k,NULL,NULL);
 else if(mkqw(bw,sc("Fwrd to char: "),dofwrdc,NULL,NULL,NULL)) return 0;
 else return -1;
 }

int ubkwdc(bw,k)
BW *bw;
 {
 dobkwdc=1;
 if(k>=0 && k<256) return dofwrdc(bw,k,NULL,NULL);
 else if(mkqw(bw,sc("Bkwd to char: "),dofwrdc,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1384 25
a1408 19
int domsg(b,s,object,notify)
BASE *b;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 strcpy(msgbuf,s);
 vsrm(s);
 msgnw(b,msgbuf);
 return 0;
 }

int umsg(b)
BASE *b;
 {
 if(wmkpw(b,"Msg (^C to abort): ",NULL,domsg,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1412 26
a1437 19
int dotxt(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int x;
 if(notify) *notify=1;
 for(x=0;x!=sLEN(s);++x) utypebw(bw,s[x]);
 vsrm(s);
 return 0;
 }

int utxt(bw)
BASE *bw;
 {
 if(wmkpw(bw,"Insert (^C to abort): ",NULL,dotxt,NULL,NULL,utypebw,NULL,NULL)) return 0;
 else return -1;
 }
@


1.1
log
@Initial revision
@
text
@d19 2
d108 1
a108 1
       c!= MAXINT && !crest(c) && (!cwhitel(c) || cwhitel(d)))
d113 1
a113 1
  if(!cwhitel(d)) { pgetc(bw->cursor); goto lp; }
d133 1
a133 1
       c!= MAXINT && !crest(c) && (!cwhitel(c) || cwhitel(d)))
d138 1
a138 1
  if(!cwhitel(d)) goto lp;
d149 1
a149 1
 while(cwhite(brc(p))) pgetc(p);
d163 1
a163 1
 if(cwhite(c=brc(p)))
d165 1
a165 1
  pset(q,p); if(cwhite(prgetc(q))) goto no;
d595 2
a596 2
 else if(cwhitel(c) || c=='\r')
  while(c=brc(p), (cwhitel(c) || c=='\r')) pgetc(p);
d618 1
a618 1
 else if(cwhitel(c))
d620 1
a620 1
  while(c=prgetc(bw->cursor), cwhitel(c));
d708 1
a708 1
  if(bw->o.wordwrap && piscol(bw->cursor)>bw->o.rmargin && !cwhite(k))
d983 1
a983 1
   while(cwhite(c=pgetc(p)))
d1135 1
a1135 1
 zcpy(msgbuf,s);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
