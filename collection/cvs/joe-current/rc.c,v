head	1.133;
access;
symbols
	joe_3_5:1.112
	joe-3_4:1.103
	help:1.103
	joe_3_1:1.54
	joe_3_0:1.39
	joe_2_9_8:1.24
	joe_2_9_8_pre1:1.16
	joe_2_9_7:1.7
	joe_2_9_7_pre3:1.7
	joe_2_9_7_pre2:1.6
	joe_2_9_6:1.5
	joe_2_9_5:1.4
	joe_2_9_4:1.3
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.133
date	2008.11.02.20.20.41;	author jhallen;	state Exp;
branches;
next	1.132;

1.132
date	2008.11.02.16.30.30;	author jhallen;	state Exp;
branches;
next	1.131;

1.131
date	2008.11.02.04.05.09;	author jhallen;	state Exp;
branches;
next	1.130;

1.130
date	2008.11.01.22.19.24;	author jhallen;	state Exp;
branches;
next	1.129;

1.129
date	2008.10.31.15.05.31;	author jhallen;	state Exp;
branches;
next	1.128;

1.128
date	2008.10.30.22.30.03;	author jhallen;	state Exp;
branches;
next	1.127;

1.127
date	2008.10.29.22.58.48;	author jhallen;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.28.02.34.35;	author jhallen;	state Exp;
branches;
next	1.125;

1.125
date	2008.10.26.16.33.59;	author jhallen;	state Exp;
branches;
next	1.124;

1.124
date	2008.10.25.04.08.47;	author jhallen;	state Exp;
branches;
next	1.123;

1.123
date	2008.10.25.03.43.17;	author jhallen;	state Exp;
branches;
next	1.122;

1.122
date	2008.10.25.01.44.44;	author jhallen;	state Exp;
branches;
next	1.121;

1.121
date	2008.10.25.01.13.18;	author jhallen;	state Exp;
branches;
next	1.120;

1.120
date	2008.10.25.01.02.36;	author jhallen;	state Exp;
branches;
next	1.119;

1.119
date	2008.10.23.21.53.49;	author jhallen;	state Exp;
branches;
next	1.118;

1.118
date	2008.10.23.16.04.59;	author jhallen;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.04.01.13.33;	author jhallen;	state Exp;
branches;
next	1.116;

1.116
date	2007.01.29.14.26.23;	author jhallen;	state Exp;
branches;
next	1.115;

1.115
date	2007.01.23.04.16.50;	author jhallen;	state Exp;
branches;
next	1.114;

1.114
date	2006.07.23.14.06.34;	author jhallen;	state Exp;
branches;
next	1.113;

1.113
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.112;

1.112
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.111;

1.111
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.18.23.28.56;	author jhallen;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.18.19.32.08;	author jhallen;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.02.16.54.06;	author jhallen;	state Exp;
branches;
next	1.107;

1.107
date	2006.06.15.18.18.28;	author jhallen;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.03.23.37.01;	author jhallen;	state Exp;
branches;
next	1.105;

1.105
date	2006.06.03.14.06.40;	author jhallen;	state Exp;
branches;
next	1.104;

1.104
date	2006.06.01.17.44.40;	author jhallen;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.30.12.57.13;	author jhallen;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.26.15.37.30;	author jhallen;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.25.18.40.29;	author jhallen;	state Exp;
branches;
next	1.99;

1.99
date	2006.05.24.22.19.00;	author jhallen;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.23.02.40.06;	author jhallen;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.21.01.58.58;	author jhallen;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.16.05.04.20;	author jhallen;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.93;

1.93
date	2006.05.12.02.07.05;	author jhallen;	state Exp;
branches;
next	1.92;

1.92
date	2006.05.05.18.18.45;	author jhallen;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.05.14.46.18;	author jhallen;	state Exp;
branches;
next	1.90;

1.90
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.89;

1.89
date	2006.03.06.04.27.31;	author jhallen;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.05.04.50.00;	author jhallen;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.05.04.17.53;	author jhallen;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.01.00.06.38;	author jhallen;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.24.04.30.50;	author jhallen;	state Exp;
branches;
next	1.84;

1.84
date	2005.04.21.20.40.14;	author jhallen;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.01.04.25.21;	author jhallen;	state Exp;
branches;
next	1.82;

1.82
date	2005.03.29.06.26.57;	author jhallen;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.28.15.13.14;	author jhallen;	state Exp;
branches;
next	1.80;

1.80
date	2005.03.28.06.17.08;	author jhallen;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.28.05.05.35;	author jhallen;	state Exp;
branches;
next	1.78;

1.78
date	2005.03.22.03.22.38;	author jhallen;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.21.00.18.17;	author jhallen;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.20.03.31.26;	author jhallen;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.18.04.25.23;	author jhallen;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.18.03.29.32;	author jhallen;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.17.23.54.47;	author jhallen;	state Exp;
branches;
next	1.72;

1.72
date	2005.03.16.21.37.35;	author jhallen;	state Exp;
branches;
next	1.71;

1.71
date	2005.03.16.16.18.45;	author jhallen;	state Exp;
branches;
next	1.70;

1.70
date	2005.03.16.00.00.56;	author jhallen;	state Exp;
branches;
next	1.69;

1.69
date	2005.03.14.19.29.47;	author jhallen;	state Exp;
branches;
next	1.68;

1.68
date	2005.03.14.03.21.36;	author jhallen;	state Exp;
branches;
next	1.67;

1.67
date	2005.03.14.00.23.09;	author jhallen;	state Exp;
branches;
next	1.66;

1.66
date	2005.03.12.15.00.54;	author jhallen;	state Exp;
branches;
next	1.65;

1.65
date	2005.03.05.04.29.56;	author jhallen;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.05.04.21.57;	author jhallen;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.02.18.55.39;	author jhallen;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.02.06.02.22;	author jhallen;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.02.03.31.35;	author jhallen;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.27.05.29.32;	author jhallen;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.21.03.19.16;	author jhallen;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.19.22.34.04;	author jhallen;	state Exp;
branches;
next	1.57;

1.57
date	2004.08.09.18.13.48;	author jhallen;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.21.14.47.36;	author jhallen;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.28.17.06.35;	author jhallen;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.27.19.45.43;	author jhallen;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.25.03.00.40;	author jhallen;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.24.20.57.26;	author jhallen;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.16.18.54.29;	author jhallen;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.10.20.31.19;	author jhallen;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.07.20.05.46;	author jhallen;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.07.19.43.29;	author jhallen;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.06.19.20.29;	author jhallen;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.06.03.47.29;	author jhallen;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.05.00.09.15;	author jhallen;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.03.22.55.50;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.03.12.28.48;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.30.21.49.55;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.23.17.56.40;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.23.02.14.08;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.22.03.40.21;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.22.01.06.57;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.20.14.45.53;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.17.13.13.16;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.16.21.10.15;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.15.14.29.07;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.13.19.35.05;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.09.18.48.48;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.08.15.20.39;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.07.00.19.20;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.24.19.47.50;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.24.09.18.45;	author vsamel;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.04.17.39.11;	author vsamel;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.20.07.18.19;	author vsamel;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.10.48.15;	author vsamel;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.27.13.31.30;	author vsamel;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.10.12.13.32;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.10.12.09.38;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.10.13.52.28;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.15.55.00;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.00.24;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.39.58;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.39.58;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.133
log
@Fix more compiler warnings.  Update builtins.c
@
text
@/*
 *	*rc file parser
 *	Copyright
 *		(C) 1992 Joseph H. Allen; 
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Commands which just type in variable values */

int ucharset(BW *bw)
{
	unsigned char *s;
	W *w=bw->parent->main;
	s=((BW *)w->object)->o.charmap->name;
	if (!s || !*s)
		return -1;
	while (*s)
		if (utypebw(bw,*s++))
			return -1;
	return 0;
}

int ulanguage(BW *bw)
{
	unsigned char *s;
	W *w=bw->parent->main;
	s=((BW *)w->object)->o.language;
	if (!s || !*s)
		return -1;
	while (*s)
		if (utypebw(bw,*s++))
			return -1;
	return 0;
}

static struct context {
	struct context *next;
	unsigned char *name;
	KMAP *kmap;
} *contexts = NULL;		/* List of named contexts */

/* Find a context of a given name- if not found, one with an empty kmap
 * is created.
 */

KMAP *kmap_getcontext(unsigned char *name)
{
	struct context *c;

	for (c = contexts; c; c = c->next)
		if (!zcmp(c->name, name))
			return c->kmap;
	c = (struct context *) joe_malloc(sizeof(struct context));

	c->next = contexts;
	c->name = zdup(name);
	contexts = c;
	return c->kmap = mkkmap();
}

/* JM - ngetcontext(name) - like getcontext, but return NULL if it
 * doesn't exist, instead of creating a new one.
 */

KMAP *ngetcontext(unsigned char *name)
{
	struct context *c;
	for(c=contexts;c;c=c->next)
		if(!zcmp(c->name,name))
			return c->kmap;
	return 0;
}

/* Validate joerc file */

int validate_rc()
{
	KMAP *k = ngetcontext(USTR "main");
	int x;
	/* Make sure main exists */
	if (!k)
		return -1;
	/* Make sure there is at least one key binding */
	for (x = 0; x != KEYS; ++x)
		if (k->keys[x].value.bind)
			return 0;
	return -1;
}

unsigned char **get_keymap_list()
{
	unsigned char **lst = 0;
	struct context *c;
	for (c=contexts; c; c=c->next)
		lst = vaadd(lst, vsncpy(NULL,0,sz(c->name)));

	return lst;
}

OPTIONS *options = NULL;

/* Set to use ~/.joe_state file */
int joe_state;

/* Default options for prompt windows */

OPTIONS pdefault = {
	NULL,		/* *next */
	NULL,		/* *name_regex */
	NULL,		/* *contents_regex */
	0,		/* overtype */
	0,		/* lmargin */
	76,		/* rmargin */
	0,		/* autoindent */
	0,		/* wordwrap */
	0,		/* nobackup */
	8,		/* tab */
	' ',		/* indent char */
	1,		/* indent step */
	NULL,		/* *context */
	NULL,		/* *lmsg */
	NULL,		/* *rmsg */
	0,		/* line numbers */
	0,		/* read only */
	0,		/* french spacing */
	0,		/* flowed text */
	0,		/* spaces */
#ifdef __MSDOS__
	1,		/* crlf */
#else
	0,		/* crlf */
#endif
	0,		/* Highlight */
	NULL,		/* Syntax name */
	NULL,		/* Syntax */
	NULL,		/* Name of character set */
	NULL,		/* Character set */
	NULL,		/* Language */
	0,		/* Smart home key */
	0,		/* Goto indent first */
	0,		/* Smart backspace key */
	0,		/* Purify indentation */
	0,		/* Picture mode */
	0,		/* single_quoted */
	0,		/* no_double_quoted */
	0,		/* c_comment */
	0,		/* cpp_comment */
	0,		/* pound_comment */
	0,		/* vhdl_comment */
	0,		/* semi_comment */
	0,		/* tex_comment */
	0,		/* hex */
	NULL,		/* text_delimiters */
	NULL,		/* Characters which can indent paragraphs */
	NULL,		/* macro to execute for new files */
	NULL,		/* macro to execute for existing files */
	NULL,		/* macro to execute before saving new files */
	NULL,		/* macro to execute before saving existing files */
	NULL		/* macro to execute on first change */
};

/* Default options for file windows */

OPTIONS fdefault = {
	NULL,		/* *next */
	NULL,		/* *name_regex */
	NULL,		/* *contents_regex */
	0,		/* overtype */
	0,		/* lmargin */
	76,		/* rmargin */
	0,		/* autoindent */
	0,		/* wordwrap */
	0,		/* nobackup */
	8,		/* tab */
	' ',		/* indent char */
	1,		/* indent step */
	USTR "main",		/* *context */
	USTR "\\i%n %m %M",	/* *lmsg */
	USTR " %S Ctrl-K H for help",	/* *rmsg */
	0,		/* line numbers */
	0,		/* read only */
	0,		/* french spacing */
	0,		/* flowed text */
	0,		/* spaces */
#ifdef __MSDOS__
	1,		/* crlf */
#else
	0,		/* crlf */
#endif
	0,		/* Highlight */
	NULL,		/* Syntax name */
	NULL,		/* Syntax */
	NULL,		/* Name of character set */
	NULL,		/* Character set */
	NULL,		/* Language */
	0,		/* Smart home key */
	0,		/* Goto indent first */
	0,		/* Smart backspace key */
	0,		/* Purity indentation */
	0,		/* Picture mode */
	0,		/* single_quoted */
	0,		/* no_double_quoted */
	0,		/* c_comment */
	0,		/* cpp_comment */
	0,		/* pound_comment */
	0,		/* vhdl_comment */
	0,		/* semi_comment */
	0,		/* tex_comment */
	0,		/* hex */
	NULL,		/* text_delimiters */
	USTR ">;!#%/*-",	/* Characters which can indent paragraphs */
	NULL, NULL, NULL, NULL, NULL	/* macros (see above) */
};

/* Update options */

void lazy_opts(B *b, OPTIONS *o)
{
	o->syntax = load_syntax(o->syntax_name);
	if (!o->map_name) {
		/* Guess encoding if it's not explicitly given */
		unsigned char buf[1024];
		int len = 1024;
		if (b->eof->byte < 1024)
			len = b->eof->byte;
		brmem(b->bof, buf, len);
		o->charmap = guess_map(buf, len);
		o->map_name = zdup(o->charmap->name);
	} else {
		o->charmap = find_charmap(o->map_name);
	}
	if (!o->charmap)
		o->charmap = locale_map;
	if (!o->language)
		o->language = zdup(locale_msgs);
	/* Hex not allowed with UTF-8 */
	if (o->hex && o->charmap->type) {
		o->charmap = find_charmap(USTR "c");
	}
}

/* Set local options depending on file name and contents */

void setopt(B *b, unsigned char *parsed_name)
{
	OPTIONS *o;
	int x;
	unsigned char *pieces[26];
	for (x = 0; x!=26; ++x)
		pieces[x] = NULL;

	for (o = options; o; o = o->next)
		if (rmatch(o->name_regex, parsed_name)) {
			if(o->contents_regex) {
				P *p = pdup(b->bof, USTR "setopt");
				if (pmatch(pieces,o->contents_regex,zlen(o->contents_regex),p,0,0)) {
					prm(p);
					b->o = *o;
					lazy_opts(b, &b->o);
					goto done;
				} else {
					prm(p);
				}
			} else {
				b->o = *o;
				lazy_opts(b, &b->o);
				goto done;
			}
		}

	b->o = fdefault;
	lazy_opts(b, &b->o);

	done:
	for (x = 0; x!=26; ++x)
		obj_free(pieces[x]);
}

/* Table of options and how to set them */

/* local means it's in an OPTION structure, global means it's in a global
 * variable */

struct glopts {
	unsigned char *name;		/* Option name */
	int type;		/*      0 for global option flag
				   1 for global option numeric
				   2 for global option string
				   4 for local option flag
				   5 for local option numeric
				   6 for local option string
				   7 for local option numeric+1, with range checking
				 */
	void *set;		/* Address of global option */
	unsigned char *addr;		/* Local options structure member address */
	unsigned char *yes;		/* Message if option was turned on, or prompt string */
	unsigned char *no;		/* Message if option was turned off */
	unsigned char *menu;		/* Menu string */
	int ofst;		/* Local options structure member offset */
	int low;		/* Low limit for numeric options */
	int high;		/* High limit for numeric options */
} glopts[] = {
	{USTR "overwrite",4, NULL, (unsigned char *) &fdefault.overtype, USTR _("Overtype mode"), USTR _("Insert mode"), USTR _("T Overtype ") },
	{USTR "hex",4, NULL, (unsigned char *) &fdefault.hex, USTR _("Hex edit mode"), USTR _("Text edit mode"), USTR _("  Hex edit mode ") },
	{USTR "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, USTR _("Autoindent enabled"), USTR _("Autoindent disabled"), USTR _("I Autoindent ") },
	{USTR "wordwrap",	4, NULL, (unsigned char *) &fdefault.wordwrap, USTR _("Wordwrap enabled"), USTR _("Wordwrap disabled"), USTR _("W Word wrap ") },
	{USTR "tab",	5, NULL, (unsigned char *) &fdefault.tab, USTR _("Tab width (%d): "), 0, USTR _("D Tab width "), 0, 1, 64 },
	{USTR "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, USTR _("Left margin (%d): "), 0, USTR _("L Left margin "), 0, 0, 63 },
	{USTR "rmargin",	7, NULL, (unsigned char *) &fdefault.rmargin, USTR _("Right margin (%d): "), 0, USTR _("R Right margin "), 0, 7, 255 },
	{USTR "restore",	0, &restore_file_pos, NULL, USTR _("Restore cursor position when files loaded"), USTR _("Don't restore cursor when files loaded"), USTR _("  Restore cursor ") },
	{USTR "square",	0, &square, NULL, USTR _("Rectangle mode"), USTR _("Text-stream mode"), USTR _("X Rectangle mode ") },
	{USTR "icase",	0, &icase, NULL, USTR _("Search ignores case by default"), USTR _("Case sensitive search by default"), USTR _("  Case insensitivity ") },
	{USTR "wrap",	0, &wrap, NULL, USTR _("Search wraps"), USTR _("Search doesn't wrap"), USTR _("  Search wraps ") },
	{USTR "menu_explorer",	0, &menu_explorer, NULL, USTR _("Menu explorer mode"), USTR _("Simple completion mode"), USTR _("  Menu explorer ") },
	{USTR "menu_above",	0, &menu_above, NULL, USTR _("Menu above prompt"), USTR _("Menu below prompt"), USTR _("  Menu position ") },
	{USTR "search_prompting",	0, &pico, NULL, USTR _("Search prompting on"), USTR _("Search prompting off"), USTR _("  Search prompting ") },
	{USTR "menu_jump",	0, &menu_jump, NULL, USTR _("Jump into menu is on"), USTR _("Jump into menu is off"), USTR _("  Jump into menu ") },
	{USTR "autoswap",	0, &autoswap, NULL, USTR _("Autoswap ^KB and ^KK"), USTR _("Autoswap off "), USTR _("  Autoswap mode ") },
	{USTR "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, USTR _("Indent char %d (SPACE=32, TAB=9, ^C to abort): "), 0, USTR _("  Indent char "), 0, 0, 255 },
	{USTR "istep",	5, NULL, (unsigned char *) &fdefault.istep, USTR _("Indent step %d (^C to abort): "), 0, USTR _("  Indent step "), 0, 1, 64 },
	{USTR "french",	4, NULL, (unsigned char *) &fdefault.french, USTR _("One space after periods for paragraph reformat"), USTR _("Two spaces after periods for paragraph reformat"), USTR _("  French spacing ") },
	{USTR "flowed",	4, NULL, (unsigned char *) &fdefault.flowed, USTR _("One space after paragraph lines"), USTR _("No spaces after paragraph lines"), USTR _("  Flowed text ") },
	{USTR "highlight",	4, NULL, (unsigned char *) &fdefault.highlight, USTR _("Highlighting enabled"), USTR _("Highlighting disabled"), USTR _("H Highlighting ") },
	{USTR "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, USTR _("Inserting spaces when tab key is hit"), USTR _("Inserting tabs when tab key is hit"), USTR _("  No tabs ") },
	{USTR "mid",	0, &mid, NULL, USTR _("Cursor will be recentered on scrolls"), USTR _("Cursor will not be recentered on scroll"), USTR _("C Center on scroll ") },
	{USTR "guess_crlf",0, &guesscrlf, NULL, USTR _("Automatically detect MS-DOS files"), USTR _("Do not automatically detect MS-DOS files"), USTR _("  Auto detect CR-LF ") },
	{USTR "guess_indent",0, &guessindent, NULL, USTR _("Automatically detect indentation"), USTR _("Do not automatically detect indentation"), USTR _("  Guess indent ") },
	{USTR "guess_non_utf8",0, &guess_non_utf8, NULL, USTR _("Automatically detect non-UTF-8 in UTF-8 locale"), USTR _("Do not automatically detect non-UTF-8"), USTR _("  Guess non-UTF-8 ") },
	{USTR "guess_utf8",0, &guess_utf8, NULL, USTR _("Automatically detect UTF-8 in non-UTF-8 locale"), USTR _("Do not automatically detect UTF-8"), USTR _("  Guess UTF-8 ") },
	{USTR "transpose",0, &transpose, NULL, USTR _("Menu is transposed"), USTR _("Menus are not transposed"), USTR _("  Transpose menus ") },
	{USTR "crlf",	4, NULL, (unsigned char *) &fdefault.crlf, USTR _("CR-LF is line terminator"), USTR _("LF is line terminator"), USTR _("Z CR-LF (MS-DOS) ") },
	{USTR "linums",	4, NULL, (unsigned char *) &fdefault.linums, USTR _("Line numbers enabled"), USTR _("Line numbers disabled"), USTR _("N Line numbers ") },
	{USTR "marking",	0, &marking, NULL, USTR _("Anchored block marking on"), USTR _("Anchored block marking off"), USTR _("  Marking ") },
	{USTR "asis",	0, &dspasis, NULL, USTR _("Characters above 127 shown as-is"), USTR _("Characters above 127 shown in inverse"), USTR _("  Meta chars as-is ") },
	{USTR "force",	0, &force, NULL, USTR _("Last line forced to have NL when file saved"), USTR _("Last line not forced to have NL"), USTR _("  Force last NL ") },
	{USTR "joe_state",0, &joe_state, NULL, USTR _("~/.joe_state file will be updated"), USTR _("~/.joe_state file will not be updated"), USTR _("  Joe_state file ") },
	{USTR "nobackup",	4, NULL, (unsigned char *) &fdefault.nobackup, USTR _("Nobackup enabled"), USTR _("Nobackup disabled"), USTR _("  No backup ") },
	{USTR "nobackups",	0, &nobackups, NULL, USTR _("Backup files will not be made"), USTR _("Backup files will be made"), USTR _("  Disable backups ") },
	{USTR "nolocks",	0, &nolocks, NULL, USTR _("Files will not be locked"), USTR _("Files will be locked"), USTR _("  Disable locks ") },
	{USTR "nomodcheck",	0, &nomodcheck, NULL, USTR _("No file modification time check"), USTR _("File modification time checking enabled"), USTR _("  Disable mtime check ") },
	{USTR "nocurdir",	0, &nocurdir, NULL, USTR _("No current dir"), USTR _("Current dir enabled"), USTR _("  Disable current dir ") },
	{USTR "break_hardlinks",	0, &break_links, NULL, USTR _("Hardlinks will be broken"), USTR _("Hardlinks not broken"), USTR _("  Break hard links ") },
	{USTR "break_links",	0, &break_symlinks, NULL, USTR _("Links will be broken"), USTR _("Links not broken"), USTR _("  Break links ") },
	{USTR "lightoff",	0, &lightoff, NULL, USTR _("Highlighting turned off after block operations"), USTR _("Highlighting not turned off after block operations"), USTR _("  Auto unmark ") },
	{USTR "exask",	0, &exask, NULL, USTR _("Prompt for filename in save & exit command"), USTR _("Don't prompt for filename in save & exit command"), USTR _("  Exit ask ") },
	{USTR "beep",	0, &joe_beep, NULL, USTR _("Warning bell enabled"), USTR _("Warning bell disabled"), USTR _("B Beeps ") },
	{USTR "nosta",	0, &staen, NULL, USTR _("Top-most status line disabled"), USTR _("Top-most status line enabled"), USTR _("  Disable status line ") },
	{USTR "keepup",	0, &keepup, NULL, USTR _("Status line updated constantly"), USTR _("Status line updated once/sec"), USTR _("  Fast status line ") },
	{USTR "pg",		1, &pgamnt, NULL, USTR _("Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): "), 0, USTR _("  No. PgUp/PgDn lines "), 0, -1, 64 },
	{USTR "undo_keep",		1, &undo_keep, NULL, USTR _("No. undo records to keep, or (0 for infinite): "), 0, USTR _("  No. undo records "), 0, -1, 64 },
	{USTR "csmode",	0, &csmode, NULL, USTR _("Start search after a search repeats previous search"), USTR _("Start search always starts a new search"), USTR _("  Continued search ") },
	{USTR "rdonly",	4, NULL, (unsigned char *) &fdefault.readonly, USTR _("Read only"), USTR _("Full editing"), USTR _("O Read only ") },
	{USTR "smarthome",	4, NULL, (unsigned char *) &fdefault.smarthome, USTR _("Smart home key enabled"), USTR _("Smart home key disabled"), USTR _("  Smart home key ") },
	{USTR "indentfirst",	4, NULL, (unsigned char *) &fdefault.indentfirst, USTR _("Smart home goes to indentation first"), USTR _("Smart home goes home first"), USTR _("  To indent first ") },
	{USTR "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, USTR _("Smart backspace key enabled"), USTR _("Smart backspace key disabled"), USTR _("  Smart backspace ") },
	{USTR "purify",	4, NULL, (unsigned char *) &fdefault.purify, USTR _("Indentation clean up enabled"), USTR _("Indentation clean up disabled"), USTR _("  Clean up indents ") },
	{USTR "picture",	4, NULL, (unsigned char *) &fdefault.picture, USTR _("Picture drawing mode enabled"), USTR _("Picture drawing mode disabled"), USTR _("P Picture mode ") },
	{USTR "backpath",	2, &backpath, NULL, USTR _("Backup files stored in (%s): "), 0, USTR _("  Path to backup files ") },
	{USTR "syntax",	9, NULL, NULL, USTR _("Select syntax (^C to abort): "), 0, USTR _("Y Syntax") },
	{USTR "encoding",13, NULL, NULL, USTR _("Select file character set (^C to abort): "), 0, USTR _("E Encoding ") },
	{USTR "single_quoted",	4, NULL, (unsigned char *) &fdefault.single_quoted, USTR _("Single quoting enabled"), USTR _("Single quoting disabled"), USTR _("  ^G ignores '... ' ") },
	{USTR "no_double_quoted",4, NULL, (unsigned char *) &fdefault.no_double_quoted, USTR _("Double quoting disabled"), USTR _("Double quoting enabled"), USTR _("  ^G ignores \"... \" ") },
	{USTR "c_comment",	4, NULL, (unsigned char *) &fdefault.c_comment, USTR _("/* comments enabled"), USTR _("/* comments disabled"), USTR _("  ^G ignores /*...*/ ") },
	{USTR "cpp_comment",	4, NULL, (unsigned char *) &fdefault.cpp_comment, USTR _("// comments enabled"), USTR _("// comments disabled"), USTR _("  ^G ignores //... ") },
	{USTR "pound_comment",	4, NULL, (unsigned char *) &fdefault.pound_comment, USTR _("# comments enabled"), USTR _("# comments disabled"), USTR _("  ^G ignores #... ") },
	{USTR "vhdl_comment",	4, NULL, (unsigned char *) &fdefault.vhdl_comment, USTR _("-- comments enabled"), USTR _("-- comments disabled"), USTR _("  ^G ignores --... ") },
	{USTR "semi_comment",	4, NULL, (unsigned char *) &fdefault.semi_comment, USTR _("; comments enabled"), USTR _("; comments disabled"), USTR _("  ^G ignores ;... ") },
	{USTR "tex_comment",	4, NULL, (unsigned char *) &fdefault.tex_comment, USTR _("% comments enabled"), USTR _("% comments disabled"), USTR _("  ^G ignores %... ") },
	{USTR "text_delimiters",	6, NULL, (unsigned char *) &fdefault.text_delimiters, USTR _("Text delimiters (%s): "), 0, USTR _("  Text delimiters ") },
	{USTR "language",	6, NULL, (unsigned char *) &fdefault.language, USTR _("Language (%s): "), 0, USTR _("V Language ") },
	{USTR "cpara",		6, NULL, (unsigned char *) &fdefault.cpara, USTR _("Characters which can indent paragraphs (%s): "), 0, USTR _("  Paragraph indent chars ") },
	{USTR "floatmouse",	0, &floatmouse, 0, USTR _("Clicking can move the cursor past end of line"), USTR _("Clicking past end of line moves cursor to the end"), USTR _("  Click past end ") },
	{USTR "rtbutton",	0, &rtbutton, 0, USTR _("Mouse action is done with the right button"), USTR _("Mouse action is done with the left button"), USTR _("  Right button ") },
	{USTR "nonotice",	0, &nonotice, NULL, 0, 0, 0 },
	{USTR "help_is_utf8",	0, &help_is_utf8, NULL, 0, 0, 0 },
	{USTR "noxon",	0, &noxon, NULL, 0, 0, 0 },
	{USTR "orphan",	0, &orphan, NULL, 0, 0, 0 },
	{USTR "help",	0, &help, NULL, 0, 0, 0 },
	{USTR "dopadding",	0, &dopadding, NULL, 0, 0, 0 },
	{USTR "lines",	1, &lines, NULL, 0, 0, 0, 0, 2, 1024 },
	{USTR "baud",	1, &Baud, NULL, 0, 0, 0, 0, 50, 32767 },
	{USTR "columns",	1, &columns, NULL, 0, 0, 0, 0, 2, 1024 },
	{USTR "skiptop",	1, &skiptop, NULL, 0, 0, 0, 0, 0, 64 },
	{USTR "notite",	0, &notite, NULL, 0, 0, 0 },
	{USTR "mouse",	0, &xmouse, NULL, 0, 0, 0 },
	{USTR "usetabs",	0, &usetabs, NULL, 0, 0, 0 },
	{USTR "assume_color", 0, &assume_color, NULL, 0, 0, 0 },
	{USTR "assume_256color", 0, &assume_256color, NULL, 0, 0, 0 },
	{USTR "joexterm", 0, &joexterm, NULL, 0, 0, 0 },
	{ NULL,		0, NULL, NULL, NULL, NULL, NULL, 0, 0, 0 }
};

/* Initialize .ofsts above.  Is this really necessary? */

int isiz = 0;
HASH *opt_tab;

static void izopts(void)
{
	int x;

	opt_tab = htmk(128);

	for (x = 0; glopts[x].name; ++x) {
		htadd(opt_tab, glopts[x].name, glopts + x);
		switch (glopts[x].type) {
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			glopts[x].ofst = glopts[x].addr - (unsigned char *) &fdefault;
		}
	}
	isiz = 1;
}

/* Set a global or local option:
 * 's' is option name
 * 'arg' is a possible argument string (taken only if option has an arg)
 * 'options' points to options structure to modify (can be NULL).
 * 'set'==0: set only in 'options' if it's given.
 * 'set'!=0: set global variable option.
 * return value: no. of fields taken (1 or 2), or 0 if option not found.
 *
 * So this function is used both to set options, and to parse over options
 * without setting them.
 *
 * These combinations are used:
 *
 * glopt(name,arg,NULL,1): set global variable option
 * glopt(name,arg,NULL,0): parse over option
 * glopt(name,arg,options,0): set file local option
 * glopt(name,arg,&fdefault,1): set default file options
 * glopt(name,arg,options,1): set file local option
 */

int glopt(unsigned char *s, unsigned char *arg, OPTIONS *options, int set)
{
	int val;
	int ret = 0;
	int st = 1;	/* 1 to set option, 0 to clear it */
	struct glopts *opt;

	/* Initialize offsets */
	if (!isiz)
		izopts();

	/* Clear instead of set? */
	if (s[0] == '-') {
		st = 0;
		++s;
	}

	opt = htfind(opt_tab, s);

	if (opt) {
		switch (opt->type) {
		case 0: /* Global variable flag option */
			if (set)
				*(int *)opt->set = st;
			break;
		case 1: /* Global variable integer option */
			if (set && arg) {
				sscanf((char *)arg, "%d", &val);
				if (val >= opt->low && val <= opt->high)
					*(int *)opt->set = val;
			}
			break;
		case 2: /* Global variable string option */
			if (set) {
				if (arg)
					*(unsigned char **) opt->set = zdup(arg);
				else
					*(unsigned char **) opt->set = 0;
			}
			break;
		case 4: /* Local option flag */
			if (options)
				*(int *) ((unsigned char *) options + opt->ofst) = st;
			break;
		case 5: /* Local option integer */
			if (arg) {
				if (options) {
					sscanf((char *)arg, "%d", &val);
					if (val >= opt->low && val <= opt->high)
						*(int *) ((unsigned char *)
							  options + opt->ofst) = val;
				} 
			}
			break;
		case 6: /* Local string option */
			if (options) {
				if (arg) {
					*(unsigned char **) ((unsigned char *)
							  options + opt->ofst) = zdup(arg);
				} else {
					*(unsigned char **) ((unsigned char *)
							  options + opt->ofst) = 0;
				}
			}
			break;
		case 7: /* Local option numeric + 1, with range checking */
			if (arg) {
				int zz = 0;

				sscanf((char *)arg, "%d", &zz);
				if (zz >= opt->low && zz <= opt->high) {
					--zz;
					if (options)
						*(int *) ((unsigned char *)
							  options + opt->ofst) = zz;
				}
			}
			break;

		case 9: /* Set syntax */
			if (arg && options)
				options->syntax_name = zdup(arg);
			/* this was causing all syntax files to be loaded...
			if (arg && options)
				options->syntax = load_syntax(arg); */
			break;

		case 13: /* Set byte mode encoding */
			if (arg && options)
				options->map_name = zdup(arg);
			break;
		}
		/* This is a stupid hack... */
		if ((opt->type & 3) == 0 || !arg)
			return 1;
		else
			return 2;
	} else {
		/* Why no case 6, string option? */
		/* Keymap, mold, mnew, etc. are not strings */
		/* These options do not show up in ^T */
		if (!zcmp(s, USTR "lmsg")) {
			if (arg) {
				if (options)
					options->lmsg = zdup(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "rmsg")) {
			if (arg) {
				if (options)
					options->rmsg = zdup(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "keymap")) {
			if (arg) {
				int y;

				for (y = 0; !joe_isspace(locale_map,arg[y]); ++y) ;
				if (!arg[y])
					arg[y] = 0;
				if (options && y)
					options->context = zdup(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "mnew")) {
			if (arg) {
				int sta;

				if (options)
					options->mnew = mparse(NULL, arg, &sta);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "mfirst")) {
			if (arg) {
				int sta;

				if (options)
					options->mfirst = mparse(NULL, arg, &sta);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "mold")) {
			if (arg) {
				int sta;

				if (options)
					options->mold = mparse(NULL, arg, &sta);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "msnew")) {
			if (arg) {
				int sta;

				if (options)
					options->msnew = mparse(NULL, arg, &sta);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "msold")) {
			if (arg) {
				int sta;

				if (options)
					options->msold = mparse(NULL, arg, &sta);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "text_color")) {
			if (arg) {
				bg_text = meta_color(arg);
				bg_help = bg_text;
				bg_prompt = bg_text;
				bg_menu = bg_text;
				bg_msg = bg_text;
				bg_stalin = bg_text;
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "help_color")) {
			if (arg) {
				bg_help = meta_color(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "status_color")) {
			if (arg) {
				bg_stalin = meta_color(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "menu_color")) {
			if (arg) {
				bg_menu = meta_color(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "prompt_color")) {
			if (arg) {
				bg_prompt = meta_color(arg);
				ret = 2;
			} else
				ret = 1;
		} else if (!zcmp(s, USTR "msg_color")) {
			if (arg) {
				bg_msg = meta_color(arg);
				ret = 2;
			} else
				ret = 1;
		}
	}

	return ret;
}

/* Option setting user interface (^T command) */

unsigned char **syntaxes = NULL; /* Array of available syntaxes */

static int syntaxcmplt(BW *bw)
{
	if (!syntaxes) {
		unsigned char *oldpwd = pwd();
		unsigned char **t;
		unsigned char *p;
		int x, y;

		if (chpwd(USTR (JOEDATA "syntax")))
			return -1;
		t = rexpnd(USTR "*.jsf");
		if (!t) {
			chpwd(oldpwd);
			return -1;
		}
		if (!valen(t)) {
			chpwd(oldpwd);
			return -1;
		}

		syntaxes = vamk(1);
		vaperm(syntaxes);

		for (x = 0; x != valen(t); ++x) {
			unsigned char *r = vsncpy(NULL,0,t[x],(unsigned char *)strrchr((char *)(t[x]),'.')-t[x]);
			syntaxes = vaadd(syntaxes,r);
		}

		p = (unsigned char *)getenv("HOME");
		if (p) {
			unsigned char *buf = vsfmt(NULL, 0, USTR "%s/.joe/syntax",p);
			if (!chpwd(buf) && (t = rexpnd(USTR "*.jsf"))) {
				for (x = 0; x != valen(t); ++x)
					*strrchr((char *)t[x],'.') = 0;
				for (x = 0; x != valen(t); ++x) {
					for (y = 0; y != valen(syntaxes); ++y)
						if (!zcmp(t[x],syntaxes[y]))
							break;
					if (y == valen(syntaxes)) {
						unsigned char *r = vsncpy(NULL,0,sv(t[x]));
						syntaxes = vaadd(syntaxes,r);
					}
				}
			}
		}

		vasort(av(syntaxes));
		chpwd(oldpwd);
	}
	return simple_cmplt(bw,syntaxes);
}

unsigned char **encodings = NULL; /* Array of available encodinges */

static int encodingcmplt(BW *bw)
{
	if (!encodings) {
		encodings = get_encodings();
		vasort(av(encodings));
	}
	return simple_cmplt(bw,encodings);
}

int check_for_hex(BW *bw)
{
	W *w;
	if (bw->o.hex)
		return 1;
	for (w = bw->parent->link.next; w != bw->parent; w = w->link.next)
		if ((w->watom == &watomtw || w->watom == &watompw) && ((BW *)w->object)->b == bw->b &&
		    ((BW *)w->object)->o.hex)
		    	return 1;
	return 0;
}

/* Menus of macros */

struct rc_menu_entry {
	MACRO *m;
	unsigned char *name;
};

struct rc_menu {
	struct rc_menu *next;	/* Next one in list */
	unsigned char *name;	/* Name of this menu */
	int last_position;	/* Last cursor position */
	int size;		/* Number of entries */
	struct rc_menu_entry **entries;
} *menus;

struct menu_instance {
	struct rc_menu *menu;
	unsigned char **s;
};

int find_option(unsigned char *s)
{
	int y;
	for (y = 0; glopts[y].name; ++y)
		if (!zcmp(glopts[y].name, s))
			return y;
	return -1;
}

struct rc_menu *find_menu(unsigned char *s)
{
	struct rc_menu *m;
	for (m = menus; m; m = m->next)
		if (!zcmp(m->name, s))
			break;
	return m;
}

struct rc_menu *create_menu(unsigned char *name)
{
	struct rc_menu *menu = find_menu(name);
	if (menu)
		return menu;
	menu = (struct rc_menu *)joe_malloc(sizeof(struct rc_menu));
	menu->name = zdup(name);
	menu->next = menus;
	menus = menu;
	menu->last_position = 0;
	menu->size = 0;
	menu->entries = 0;
	return menu;
}

void add_menu_entry(struct rc_menu *menu, unsigned char *entry_name, MACRO *m)
{
	struct rc_menu_entry *e = (struct rc_menu_entry *)joe_malloc(sizeof(struct rc_menu_entry));
	e->m = m;
	e->name = zdup(entry_name);
	++menu->size;
	if (!menu->entries) {
		menu->entries = (struct rc_menu_entry **)joe_malloc(menu->size * sizeof(struct rc_menu_entry *));
	} else {
		menu->entries = (struct rc_menu_entry **)joe_realloc(menu->entries, menu->size * sizeof(struct rc_menu_entry *));
	}
	menu->entries[menu->size - 1] = e;
}

static int olddoopt(BW *bw, int y, int flg)
{
	int ret = 0;
	unsigned char *buf = 0;
	unsigned char *s;

	if (y >= 0) {
		switch (glopts[y].type) {
			case 0: { /* Global option flag */
				if (!flg)
					*(int *)glopts[y].set = !*(int *)glopts[y].set;
				else if (flg == 1)
					*(int *)glopts[y].set = 1;
				else
					*(int *)glopts[y].set = 0;
				msgnw(bw->parent, *(int *)glopts[y].set ? joe_gettext(glopts[y].yes) : joe_gettext(glopts[y].no));
				break;
			} case 4: { /* Local option flag */
				if (!flg)
					*(int *) ((unsigned char *) &bw->o + glopts[y].ofst) = !*(int *) ((unsigned char *) &bw->o + glopts[y].ofst);
				else if (flg == 1)
					*(int *) ((unsigned char *) &bw->o + glopts[y].ofst) = 1;
				else
					*(int *) ((unsigned char *) &bw->o + glopts[y].ofst) = 0;
				msgnw(bw->parent, *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) ? joe_gettext(glopts[y].yes) : joe_gettext(glopts[y].no));
				if (glopts[y].ofst == (unsigned char *) &fdefault.readonly - (unsigned char *) &fdefault)
					bw->b->rdonly = bw->o.readonly;
				if (glopts[y].ofst == (unsigned char *) &fdefault.hex - (unsigned char *) &fdefault &&
				    bw->o.hex &&
				    bw->b->o.charmap->type) {
					/* Kill UTF-8 if we are turning on hex */
					bw->o.charmap = find_charmap(USTR "c");
					bw->b->o = bw->o;
					wfit(bw->parent->t);
					updall();
				}
				break;
			} case 6: { /* Local option string */
				/* Get current string */
				s = *(unsigned char **)((unsigned char *)&bw->o + glopts[y].ofst);
				if (!s)
					s = USTR "";
				/* Generate message */
				buf = vsfmt(buf, 0, glopts[y].yes, s);

				s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
				if (s) {
					*(unsigned char **)((unsigned char *)&bw->o + glopts[y].ofst) = zdup(s);
					break;
				} else {
					return -1;
				}
			} case 1: { /* global option numeric */
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), *(int *)glopts[y].set);
				s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
				if (s) {
					int v = calc(bw, s);
					if (merr) {
						msgnw(bw->parent, merr);
						ret = -1;
					} else if (v >= glopts[y].low && v <= glopts[y].high)
						*(int *)glopts[y].set = v;
					else {
						msgnw(bw->parent, joe_gettext(_("Value out of range")));
						ret = -1;
					}

					break;
				} else
					return -1;
			} case 2: { /* global option string */
				s = *(unsigned char **) glopts[y].set;
				if (!s)
					s = USTR "";
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), s);

				s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
				if (s) {
					*(unsigned char **)glopts[y].set = zdup(s);
					break;
				} else {
					return -1;
				}
			} case 5: { /* local option numeric */
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), *(int *) ((unsigned char *) &bw->o + glopts[y].ofst));
				s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
				if (s) {
					double v = calc(bw, s);
					if (merr) {
						msgnw(bw->parent, merr);
						ret = -1;
					} else if (v >= glopts[y].low && v <= glopts[y].high) {
						*(int *) ((unsigned char *) &bw->o + glopts[y].ofst) = v;
					} else {
						msgnw(bw->parent, joe_gettext(_("Value out of range")));
						ret = -1;
					}
					break;
				} else {
					return -1;
				}
			} case 7: { /* local option numeric+1, with range checking */
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) + 1);
				s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);

				if (s) {
					double v = calc(bw, s) - 1.0;
					if (merr) {
						msgnw(bw->parent, merr);
						ret = -1;
					} else if (v >= glopts[y].low && v <= glopts[y].high) {
						*(int *) ((unsigned char *) &bw->o + glopts[y].ofst) = v;
					} else {
						msgnw(bw->parent, joe_gettext(_("Value out of range")));
						ret = -1;
					}
					break;
				} else {
					return -1;
				}
			} case 9: { /* Choose syntax */
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), "");
				s = ask(bw->parent, buf, NULL, NULL, syntaxcmplt, locale_map, 0, 0, NULL);

				if (s) {
					struct high_syntax *syn;

					syn = load_syntax(s);

					if (syn) {
						bw->o.syntax = syn;
						break;
					} else {
						msgnw(bw->parent, joe_gettext(_("Syntax definition file not found")));
						return -1;
					}
				} else {
					return -1;
				}
			} case 13: { /* Choose encoding */
				buf = vsfmt(buf, 0, joe_gettext(glopts[y].yes), "");
				s = ask(bw->parent, buf, NULL, NULL, encodingcmplt, locale_map, 0, 0, NULL);
				if (s) {
					struct charmap *map;

					map = find_charmap(s);
					if (map && map->type && check_for_hex(bw)) {
						msgnw(bw->parent, joe_gettext(_("UTF-8 encoding not allowed with hexadecimal windows")));
						return -1;
					}

					if (map) {
						bw->o.charmap = map;
						msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%s encoding assumed for this file")), map->name));
						break;
					} else {
						msgnw(bw->parent, joe_gettext(_("Character set not found")));
						return -1;
					}
				} else {
					return -1;
				}
			}
		}
	}
	bw->b->o = bw->o;
	wfit(bw->parent->t);
	updall();
	return ret;
}

int menu_flg;

int display_menu(BW *bw, struct rc_menu *menu)
{
	unsigned char **s = vamk(20);
	int x;
	for (x = 0; x != menu->size; ++x) {
		vaadd(s, stagen(NULL, bw, menu->entries[x]->name, ' '));
	}
	x = choose(bw->parent, bw->parent, s, &menu->last_position);
	if (x == -1) {
		return -1;
	}
	menu_flg = x;
	return exmacro(menu->entries[menu->last_position]->m, 1);
}

unsigned char *get_status(BW *bw, unsigned char *s)
{
	int y = find_option(s);
	if (y == -1)
		return USTR "???";
	else {
		switch (glopts[y].type) {
			case 0: {
				return *(int *)glopts[y].set ? USTR "ON" : USTR "OFF";
			} case 1: {
				return vsfmt(NULL, 0, USTR "%d", *(int *)glopts[y].set);
			} case 4: {
				return *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) ? USTR "ON" : USTR "OFF";
			} case 5: {
				return vsfmt(NULL, 0, USTR "%d", *(int *) ((unsigned char *) &bw->o + glopts[y].ofst));
			} case 7: {
				return vsfmt(NULL, 0, USTR "%d", *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) + 1);
			} default: {
				return USTR "";
			}
		}
	}
}

/* Execute a menu */

unsigned char **getmenus(void)
{
	unsigned char **s = vaensure(NULL, 20);
	struct rc_menu *m;
	vaperm(s);

	for (m = menus; m; m = m->next)
		s = vaadd(s, vsncpy(NULL, 0, sz(m->name)));
	vasort(av(s));
	return s;
}

unsigned char **smenus = NULL;	/* Array of command names */

static int menucmplt(BW *bw)
{
	if (!smenus)
		smenus = getmenus();
	return simple_cmplt(bw,smenus);
}

B *menuhist = NULL;

int umenu(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(USTR _("Menu: ")), &menuhist, USTR "menu", menucmplt, locale_map, 0, 0, NULL);
	struct rc_menu *menu = find_menu(s);
	if (!menu) {
		msgnw(bw->parent, joe_gettext(_("No such menu")));
		return -1;
	} else {
		bw->b->o.readonly = bw->o.readonly = bw->b->rdonly;
		return display_menu(bw, menu);
	}
}

/* Simplified mode command */

unsigned char **getoptions(void)
{
	unsigned char **s = vaensure(NULL, 20);
	int x;
	vaperm(s);

	for (x = 0; glopts[x].name; ++x)
		s = vaadd(s, vsncpy(NULL, 0, sz(glopts[x].name)));
	vasort(av(s));
	return s;
}

unsigned char **sopts = NULL;	/* Array of command names */

static int optcmplt(BW *bw)
{
	if (!sopts)
		sopts = getoptions();
	return simple_cmplt(bw,sopts);
}

B *opthist = NULL;

int umode(BW *bw)
{
	unsigned char *s = ask(bw->parent, joe_gettext(USTR _("Options: ")), &opthist, USTR "opt", optcmplt, locale_map, 0, 0, NULL);
	int y = find_option(s);
	if (y == -1) {
		msgnw(bw->parent, joe_gettext(_("No such option")));
		return -1;
	} else {
		int flg = menu_flg;
		menu_flg = 0;
		return olddoopt(bw, y, flg);
	}
}

/* Process rc file
 * Returns 0 if the rc file was succefully processed
 *        -1 if the rc file couldn't be opened
 *         1 if there was a syntax error in the file
 */

int procrc(CAP *cap, unsigned char *name)
{
	OPTIONS *o = &fdefault;	/* Current options */
	KMAP *context = NULL;	/* Current context */
	struct rc_menu *current_menu = NULL;
	unsigned char *buf = vsmk(128);	/* Input buffer */
	JFILE *fd;		/* rc file */
	int line = 0;		/* Line number */
	int err = 0;		/* Set to 1 if there was a syntax error */

#ifdef __MSDOS__
	fd = jfopen(name, "rt");
#else
	fd = jfopen(name, "r");
#endif

	if (!fd)
		return -1;	/* Return if we couldn't open the rc file */

	fprintf(stderr,(char *)joe_gettext(_("Processing '%s'...")), name);
	fflush(stderr);

	while (jfgets(&buf, fd)) {
		line++;
		switch (buf[0]) {
		case ' ':
		case '\t':
		case '\n':
		case '\f':
		case 0:
			break;	/* Skip comment lines */

		case '=':	/* Define a global color */
			{ /* # introduces comment */
			parse_color_def(&global_colors,buf+1,name,line);
			}
			break;

		case '*':	/* Select file types for file-type dependant options */
			{ /* Space and tab introduce comments- which means we can't have them in the regex */
				int x;

				o = (OPTIONS *) joe_malloc(sizeof(OPTIONS));
				*o = fdefault;
				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t'; ++x) ;
				buf[x] = 0;
				o->next = options;
				options = o;
				o->name_regex = zdup(buf);
			}
			break;
		case '+':	/* Set file contents match regex */
			{ /* No comments allowed- entire line used. */
				int x;

				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != '\r'; ++x) ;
				buf[x] = 0;
				if (o)
					o->contents_regex = zdup(buf+1);
			}
			break;
		case '-':	/* Set an option */
			{ /* parse option and arg.  arg goes to end of line.  This is bad. */
				unsigned char *opt = buf + 1;
				int x;
				unsigned char *arg = NULL;

				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t'; ++x) ;
				if (buf[x] && buf[x] != '\n') {
					buf[x] = 0;
					for (arg = buf + ++x; buf[x] && buf[x] != '\n'; ++x) ;
				}
				buf[x] = 0;
				if (!glopt(opt, arg, o, 2)) {
					err = 1;
					fprintf(stderr,(char *)joe_gettext(_("\n%s %d: Unknown option %s")), name, line, opt);
				}
			}
			break;
		case '{':	/* Process help text.  No comment allowed after {name */
			{	/* everything after } is ignored. */
				line = help_init(fd,buf,line);
			}
			break;
		case ':':	/* Select context */
			{
				int x, c;

				for (x = 1; !joe_isspace_eof(locale_map,buf[x]); ++x) ;
				c = buf[x];
				buf[x] = 0;
				if (x != 1)
					if (!zcmp(buf + 1, USTR "def")) {
						int y;

						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (y = x; !joe_isspace_eof(locale_map,buf[y]); ++y) ;
						c = buf[y];
						buf[y] = 0;
						if (y != x) {
							int sta;
							MACRO *m;

							if (joe_isblank(locale_map,c)
							    && (m = mparse(NULL, buf + y + 1, &sta)))
								addcmd(buf + x, m);
							else {
								err = 1;
								fprintf(stderr, (char *)joe_gettext(_("\n%s %d: macro missing from :def")), name, line);
							}
						} else {
							err = 1;
							fprintf(stderr, (char *)joe_gettext(_("\n%s %d: command name missing from :def")), name, line);
						}
					} else if (!zcmp(buf + 1, USTR "inherit")) {
						if (context) {
							for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
							for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
							buf[c] = 0;
							if (c != x)
								kcpy(context, kmap_getcontext(buf + x));
							else {
								err = 1;
								fprintf(stderr, (char *)joe_gettext(_("\n%s %d: context name missing from :inherit")), name, line);
							}
						} else {
							err = 1;
							fprintf(stderr, (char *)joe_gettext(_("\n%s %d: No context selected for :inherit")), name, line);
						}
					} else if (!zcmp(buf + 1, USTR "include")) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
						buf[c] = 0;
						if (c != x) {
							unsigned char *bf = 0;
							unsigned char *p = (unsigned char *)getenv("HOME");
							int rtn = -1;
							if (p && buf[x] != '/') {
								bf = vsfmt(bf, 0, USTR "%s/.joe/%s",p,buf + x);
								rtn = procrc(cap, bf);
							}
							if (rtn == -1 && buf[x] != '/') {
								bf = vsfmt(bf, 0, USTR "%s%s",JOERC,buf + x);
								rtn = procrc(cap, bf);
							}
							if (rtn == -1 && buf[x] == '/') {
								bf = vsfmt(bf, 0, USTR "%s",buf + x);
								rtn = procrc(cap, bf);
							}
							switch (rtn) {
							case 1:
								err = 1;
								break;
							case -1:
								fprintf(stderr, (char *)joe_gettext(_("\n%s %d: Couldn't open %s")), name, line, bf);
								err = 1;
								break;
							}
							context = 0;
							o = &fdefault;
						} else {
							err = 1;
							fprintf(stderr, (char *)joe_gettext(_("\n%s %d: :include missing file name")), name, line);
						}
					} else if (!zcmp(buf + 1, USTR "delete")) {
						if (context) {
							int y;

							for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
							for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1]
															!= ' '); ++y) ;
							buf[y] = 0;
							kdel(context, buf + x);
						} else {
							err = 1;
							fprintf(stderr, (char *)joe_gettext(_("\n%s %d: No context selected for :delete")), name, line);
						}
					} else if (!zcmp(buf + 1, USTR "defmap")) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
						buf[c] = 0;
						if (c != x) {
							context = kmap_getcontext(buf + x);
							current_menu = 0;
						} else {
							err = 1;
							fprintf(stderr, (char *)joe_gettext(_("\n%s %d: :defmap missing name")), name, line);
						}
					} else if (!zcmp(buf + 1, USTR "defmenu")) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
						buf[c] = 0;
						current_menu = create_menu(buf + x);
						context = 0;
					} else {
						context = kmap_getcontext(buf + 1);
						current_menu = 0;
						/* err = 1;
						fprintf(stderr, (char *)joe_gettext(_("\n%s %d: unknown :command")), name, line);*/
					}
				else {
					err = 1;
					fprintf(stderr,(char *)joe_gettext(_("\n%s %d: Invalid context name")), name, line);
				}
			}
			break;
		default:	/* Get key-sequence to macro binding */
			{
				int x, y;
				MACRO *m;

				if (!context && !current_menu) {
					err = 1;
					fprintf(stderr,(char *)joe_gettext(_("\n%s %d: No context selected for macro to key-sequence binding")), name, line);
					break;
				}

				m = 0;
			      macroloop:
				m = mparse(m, buf, &x);
				if (x == -1) {
					err = 1;
					fprintf(stderr,(char *)joe_gettext(_("\n%s %d: Unknown command in macro")), name, line);
					break;
				} else if (x == -2) {
					jfgets(&buf, fd);
					++line;
					goto macroloop;
				}
				if (!m)
					break;

				/* Skip to end of key sequence */
				for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1] != ' '); ++y) ;
				buf[y] = 0;

				if (current_menu) {
					/* Add menu entry */
					add_menu_entry(current_menu, buf + x, m);
				} else {
					/* Add binding to context */
					if (kadd(cap, context, buf + x, m) == -1) {
						fprintf(stderr,(char *)joe_gettext(_("\n%s %d: Bad key sequence '%s'")), name, line, buf + x);
						err = 1;
					}
				}
			}
			break;
		}
	}
	jfclose(fd);		/* Close rc file */

	/* Print proper ending string */
	if (err)
		fprintf(stderr, (char *)joe_gettext(_("\ndone\n")));
	else
		fprintf(stderr, (char *)joe_gettext(_("done\n")));

	return err;		/* 0 for success, 1 for syntax error */
}

/* Save a history buffer */

void save_hist(FILE *f,B *b)
{
	unsigned char *buf = vsmk(128);
	if (b) {
		P *p = pdup(b->bof, USTR "save_hist");
		if (b->eof->line>10)
			pline(p,b->eof->line-10);
		while (!piseof(p)) {
			buf = brlinevs(buf, p);
			buf = vsadd(buf, '\n');
			pnextl(p);
			fprintf(f,"\t");
			emit_string(f,sv(buf));
			fprintf(f,"\n");
		}
		prm(p);
	}
	fprintf(f,"done\n");
}

/* Load a history buffer */

void load_hist(FILE *f,B **bp)
{
	B *b;
	unsigned char *buf = 0;
	unsigned char *bf = 0;
	P *q;

	b = *bp;
	if (!b)
		*bp = b = bmk(NULL);

	q = pdup(b->eof, USTR "load_hist");

	while(vsgets(&buf,f) && zcmp(buf,USTR "done")) {
		unsigned char *p = buf;
		int len;
		parse_ws(&p,'#');
		len = parse_string(&p,&bf);
		if (len>0) {
			binsm(q,bf,len);
			pset(q,b->eof);
		}
	}

	prm(q);
}

/* Save state */

#define STATE_ID (unsigned char *)"# JOE state file v1.0"

void save_state()
{
	unsigned char *path = (unsigned char *)getenv("HOME");
	int old_mask;
	FILE *f;
	if (!joe_state)
		return;
	if (!path)
		return;
	path = vsfmt(NULL,0,USTR "%s/.joe_state",path);
	old_mask = umask(0066);
	f = fopen((char *)path,"w");
	umask(old_mask);
	if(!f)
		return;

	/* Write ID */
	fprintf(f,"%s\n",(char *)STATE_ID);

	/* Write state information */
	fprintf(f,"search\n"); save_srch(f);
	fprintf(f,"macros\n"); save_macros(f);
	fprintf(f,"files\n"); save_hist(f,filehist);
	fprintf(f,"find\n"); save_hist(f,findhist);
	fprintf(f,"replace\n"); save_hist(f,replhist);
	fprintf(f,"run\n"); save_hist(f,runhist);
	fprintf(f,"build\n"); save_hist(f,buildhist);
	fprintf(f,"grep\n"); save_hist(f,grephist);
	fprintf(f,"cmd\n"); save_hist(f,cmdhist);
	fprintf(f,"math\n"); save_hist(f,mathhist);
	fprintf(f,"yank\n"); save_yank(f);
	fprintf(f,"file_pos\n"); save_file_pos(f);
	fclose(f);
}

/* Load state */

void load_state()
{
	unsigned char *path = (unsigned char *)getenv("HOME");
	unsigned char *buf = vsmk(128);
	FILE *f;
	if (!joe_state)
		return;
	if (!path)
		return;
	path = vsfmt(NULL,0,USTR "%s/.joe_state",path);
	f = fopen((char *)path,"r");
	if(!f)
		return;

	/* Only read state information if the version is correct */
	if (vsgets(&buf, f) && !zcmp(buf,STATE_ID)) {

		/* Read state information */
		while(vsgets(&buf,f)) {
			if(!zcmp(buf,USTR "search"))
				load_srch(f);
			else if(!zcmp(buf,USTR "macros"))
				load_macros(f);
			else if(!zcmp(buf,USTR "files"))
				load_hist(f,&filehist);
			else if(!zcmp(buf,USTR "find"))
				load_hist(f,&findhist);
			else if(!zcmp(buf,USTR "replace"))
				load_hist(f,&replhist);
			else if(!zcmp(buf,USTR "run"))
				load_hist(f,&runhist);
			else if(!zcmp(buf,USTR "build"))
				load_hist(f,&buildhist);
			else if(!zcmp(buf,USTR "grep"))
				load_hist(f,&grephist);
			else if(!zcmp(buf,USTR "cmd"))
				load_hist(f,&cmdhist);
			else if(!zcmp(buf,USTR "math"))
				load_hist(f,&mathhist);
			else if(!zcmp(buf,USTR "yank"))
				load_yank(f);
			else if (!zcmp(buf,USTR "file_pos"))
				load_file_pos(f);
			else { /* Unknown... skip until next done */
				while(vsgets(&buf,f) && zcmp(buf,USTR "done"));
			}
		}
	}

	fclose(f);
}
@


1.132
log
@Fix option force on/force off code.
@
text
@a728 1
	BW *org;
d836 1
a836 1
					bw->o.charmap = find_charmap("c");
d997 1
a997 1
		return "???";
d1003 1
a1003 1
				return vsfmt(NULL, 0, "%d", *(int *)glopts[y].set);
d1007 1
a1007 1
				return vsfmt(NULL, 0, "%d", *(int *) ((unsigned char *) &bw->o + glopts[y].ofst));
d1009 1
a1009 1
				return vsfmt(NULL, 0, "%d", *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) + 1);
a1022 1
	int x;
a1060 1
	HENTRY *e;
@


1.131
log
@Coroutine version of menus with macros
@
text
@d977 2
d990 1
d1091 3
a1093 1
		return olddoopt(bw, y, 0);
@


1.130
log
@Menu system
@
text
@a660 2
static int optx = 0; /* Menu cursor position: remember it for next time */

d739 7
d751 1
a751 1
	unsigned char **entries;/* Option or sub-menu name */
d777 28
a804 1
int display_menu(BW *bw, struct rc_menu *menu);
d806 1
a806 1
static int doopt(BW *bw, int x, struct menu_instance *mi, int flg)
a808 1
	struct rc_menu *menu = mi->menu;
a811 2
	int y = find_option(menu->entries[x]);

a969 8
	} else {
		struct rc_menu *sub_menu = find_menu(menu->entries[x]);
		if (sub_menu) {
			return display_menu(bw, sub_menu);
		} else {
			msgnw(bw->parent, joe_gettext(_("Unknown menu or option")));
			return -1;
		}
d977 1
a977 1
struct menu_instance *create_menu(BW *bw, struct rc_menu *menu)
a978 1
	struct menu_instance *m = (struct menu_instance *)joe_malloc(sizeof(struct menu_instance));
a980 1
	vaperm(s);
d982 28
a1009 25
		int y;
		if ((y = find_option(menu->entries[x])) >= 0) {
			unsigned char *t = vsmk(40);
			switch (glopts[y].type) {
			case 0:
				t = vsfmt(t, 0, joe_gettext(glopts[y].menu), *(int *)glopts[y].set ? "ON" : "OFF");
				break;
			case 1:
				t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[y].menu), *(int *)glopts[y].set);
				break;
			case 2:
			case 9:
			case 13:
			case 6:
				t = vscpyz(t,joe_gettext(glopts[y].menu));
				break;
			case 4:
				t = vsfmt(t, 0, USTR "%s%s", joe_gettext(glopts[y].menu), *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) ? "ON" : "OFF");
				break;
			case 5:
				t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[y].menu), *(int *) ((unsigned char *) &bw->o + glopts[y].ofst));
				break;
			case 7:
				t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[y].menu), *(int *) ((unsigned char *) &bw->o + glopts[y].ofst) + 1);
				break;
a1010 3
			s = vaadd(s, t);
		} else {
			s = vaadd(s, vsncpy(NULL, 0, sz(menu->entries[x])));
a1012 3
	m->menu = menu;
	m->s = s;
	return m;
d1015 3
a1017 1
int display_menu(BW *bw, struct rc_menu *menu)
d1019 9
a1027 8
	struct menu_instance *m = create_menu(bw, menu);
	int x = choose(bw->parent, bw->parent, m->s, &menu->last_position);
	if (x == -1) {
		varm(m->s);
		joe_free(m);
		return -1;
	}
	return doopt(bw, menu->last_position, m, x);
d1030 1
a1030 1
/* ^T command */
d1032 1
a1032 1
int umode(BW *bw)
d1034 6
a1039 1
	struct rc_menu *menu = find_menu("root");
d1041 8
a1048 1
	if (menu) {
a1050 3
	} else {
		msgnw(bw->parent, joe_gettext(_("No root menu in rc file")));
		return -1;
d1054 3
a1056 1
int menu_init(JFILE *fd, unsigned char *bf, int line)
d1058 9
a1066 31
	unsigned char *buf = vsmk(128);
	if (bf[0] == '[') {
		unsigned char *name = vsncpy(NULL, 0, sz(bf + 1));
		struct rc_menu *menu = find_menu(name);
		obj_perm(name);
		if (!menu) {
			menu = (struct rc_menu *)joe_malloc(sizeof(struct rc_menu));
			menu->name = name;
			menu->next = menus;
			menus = menu;
			menu->last_position = 0;
			menu->size = 0;
			menu->entries = vamk(1);
			vaperm(menu->entries);
		} else {
		}
		while ((jfgets(&buf, fd)) && (buf[0] != ']')) {
			++line;
			if (buf[0]) {
				unsigned char *entry = vsncpy(NULL, 0, sz(buf));
				menu->entries = vaadd(menu->entries, entry);
				++menu->size;
			}
		}
		if (buf[0] == ']') {
			++line;
		} else {
			fprintf(stderr, (char *)joe_gettext(_("\n%d: EOF before end of menu text\n")),line);
		}
	}
	return line;
d1069 8
d1078 13
d1102 1
a1181 5
		case '[':	/* Process menu definition */
			{
				line = menu_init(fd,buf,line);
			}
			break;
d1275 17
d1294 3
d1309 1
a1309 1
				if (!context) {
d1334 9
a1342 4
				/* Add binding to context */
				if (kadd(cap, context, buf + x, m) == -1) {
					fprintf(stderr,(char *)joe_gettext(_("\n%s %d: Bad key sequence '%s'")), name, line, buf + x);
					err = 1;
@


1.129
log
@Fix 64-bit problems
@
text
@d740 35
a774 2
 
static int doopt(BW *bw, int x, unsigned char **vary, int flg)
d777 1
d780 33
a812 42
	varm(vary);
	switch (glopts[x].type) {
		case 0: { /* Global option flag */
			if (!flg)
				*(int *)glopts[x].set = !*(int *)glopts[x].set;
			else if (flg == 1)
				*(int *)glopts[x].set = 1;
			else
				*(int *)glopts[x].set = 0;
			msgnw(bw->parent, *(int *)glopts[x].set ? joe_gettext(glopts[x].yes) : joe_gettext(glopts[x].no));
			break;
		} case 4: { /* Local option flag */
			if (!flg)
				*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = !*(int *) ((unsigned char *) &bw->o + glopts[x].ofst);
			else if (flg == 1)
				*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 1;
			else
				*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 0;
			msgnw(bw->parent, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? joe_gettext(glopts[x].yes) : joe_gettext(glopts[x].no));
			if (glopts[x].ofst == (unsigned char *) &fdefault.readonly - (unsigned char *) &fdefault)
				bw->b->rdonly = bw->o.readonly;
			if (glopts[x].ofst == (unsigned char *) &fdefault.hex - (unsigned char *) &fdefault &&
			    bw->o.hex &&
			    bw->b->o.charmap->type) {
			    	/* Kill UTF-8 if we are turning on hex */
			    	bw->o.charmap = find_charmap("c");
			    	bw->b->o = bw->o;
			    	wfit(bw->parent->t);
			    	updall();
			}
			break;
		} case 6: { /* Local option string */
			/* Get current string */
			s = *(unsigned char **)((unsigned char *)&bw->o + glopts[x].ofst);
			if (!s)
				s = USTR "";
			/* Generate message */
			buf = vsfmt(buf, 0, glopts[x].yes, s);

			s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
			if (s) {
				*(unsigned char **)((unsigned char *)&bw->o + glopts[x].ofst) = zdup(s);
d814 14
a827 16
			} else {
				return -1;
			}
		} case 1: { /* global option numeric */
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *)glopts[x].set);
			s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
			if (s) {
				int v = calc(bw, s);
				if (merr) {
					msgnw(bw->parent, merr);
					ret = -1;
				} else if (v >= glopts[x].low && v <= glopts[x].high)
					*(int *)glopts[x].set = v;
				else {
					msgnw(bw->parent, joe_gettext(_("Value out of range")));
					ret = -1;
d829 14
d844 13
a856 26
				break;
			} else
				return -1;
		} case 2: { /* global option string */
			s = *(unsigned char **) glopts[x].set;
			if (!s)
				s = USTR "";
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), s);

			s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
			if (s) {
				*(unsigned char **)glopts[x].set = zdup(s);
				break;
			} else {
				return -1;
			}
		} case 5: { /* local option numeric */
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
			s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);
			if (s) {
				double v = calc(bw, s);
				if (merr) {
					msgnw(bw->parent, merr);
					ret = -1;
				} else if (v >= glopts[x].low && v <= glopts[x].high) {
					*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
d858 1
a858 2
					msgnw(bw->parent, joe_gettext(_("Value out of range")));
					ret = -1;
d860 15
a874 15
				break;
			} else {
				return -1;
			}
		} case 7: { /* local option numeric+1, with range checking */
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
			s = ask(bw->parent, buf, NULL, NULL, utypebw, locale_map, 0, 0, NULL);

			if (s) {
				double v = calc(bw, s) - 1.0;
				if (merr) {
					msgnw(bw->parent, merr);
					ret = -1;
				} else if (v >= glopts[x].low && v <= glopts[x].high) {
					*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
d876 1
a876 2
					msgnw(bw->parent, joe_gettext(_("Value out of range")));
					ret = -1;
d878 15
a892 15
				break;
			} else {
				return -1;
			}
		} case 9: { /* Choose syntax */
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), "");
			s = ask(bw->parent, buf, NULL, NULL, syntaxcmplt, locale_map, 0, 0, NULL);

			if (s) {
				struct high_syntax *syn;

				syn = load_syntax(s);

				if (syn) {
					bw->o.syntax = syn;
a894 1
					msgnw(bw->parent, joe_gettext(_("Syntax definition file not found")));
d897 17
a913 12
			} else {
				return -1;
			}
		} case 13: { /* Choose encoding */
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), "");
			s = ask(bw->parent, buf, NULL, NULL, encodingcmplt, locale_map, 0, 0, NULL);
			if (s) {
				struct charmap *map;

				map = find_charmap(s);
				if (map && map->type && check_for_hex(bw)) {
					msgnw(bw->parent, joe_gettext(_("UTF-8 encoding not allowed with hexadecimal windows")));
d916 11
d928 8
a935 4
				if (map) {
					bw->o.charmap = map;
					msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%s encoding assumed for this file")), map->name));
					break;
a936 1
					msgnw(bw->parent, joe_gettext(_("Character set not found")));
a938 2
			} else {
				return -1;
d941 8
d956 1
a956 1
int umode(BW *bw)
d958 2
a959 1
	unsigned char **s = vamk(50);
a960 1

d962 30
a991 27

	bw->b->o.readonly = bw->o.readonly = bw->b->rdonly;

	for (x = 0; glopts[x].menu; ++x) {
		unsigned char *t = vsmk(40);
		switch (glopts[x].type) {
		case 0:
			t = vsfmt(t, 0, joe_gettext(glopts[x].menu), *(int *)glopts[x].set ? "ON" : "OFF");
			break;
		case 1:
			t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[x].menu), *(int *)glopts[x].set);
			break;
		case 2:
		case 9:
		case 13:
		case 6:
			t = vscpyz(t,joe_gettext(glopts[x].menu));
			break;
		case 4:
			t = vsfmt(t, 0, USTR "%s%s", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
			break;
		case 5:
			t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
			break;
		case 7:
			t = vsfmt(t, 0, USTR "%s%d", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
			break;
a992 1
		s = vaadd(s, t);
d994 9
a1002 1
	x = choose(bw->parent, bw->parent, s, &optx);
d1004 18
a1021 1
		varm(s);
a1023 1
	return doopt(bw, optx, s, x);
d1026 37
d1152 5
@


1.128
log
@Syntax highlighter stack
@
text
@d818 1
a818 1
				*(unsigned char **)glopts[x].ofst = zdup(s);
@


1.127
log
@Turn off UTF-8 when we enter hex
@
text
@d221 1
a221 1
	o->syntax = load_dfa(o->syntax_name);
d524 1
a524 1
				options->syntax = load_dfa(arg); */
d867 1
a867 1
				syn = load_dfa(s);
@


1.126
log
@Update configure scripts to use docdir and datadir
@
text
@d238 4
d728 13
d767 9
d886 4
@


1.125
log
@Update coroutine version too.
@
text
@d669 1
a669 1
		if (chpwd(USTR (JOERC "syntax")))
@


1.124
log
@Add -flowed option.
@
text
@d213 1
a213 1
	USTR ">;!#%/",	/* Characters which can indent paragraphs */
@


1.123
log
@Also use LC_MESSAGES for language to pass to aspell.
@
text
@d128 1
d185 1
d320 1
@


1.122
log
@Add -no_double_quoted and -tex_comment
@
text
@d235 1
a235 1
		o->language = zdup(locale_lang);
@


1.121
log
@Rename break_symlinks to break_links and rename break_links to break_hardlinks.
@
text
@d146 1
d152 1
d202 1
d208 1
d357 1
d363 1
@


1.120
log
@Change break_links to not break symbolic links.
Add break_symlinks.
@
text
@d333 2
a334 2
	{USTR "break_links",	0, &break_links, NULL, USTR _("Hardlinks will be broken"), USTR _("Hardlinks not broken"), USTR _("  Break hard links ") },
	{USTR "break_symlinks",	0, &break_symlinks, NULL, USTR _("Symlinks will be broken"), USTR _("Symlinks not broken"), USTR _("  Break symbolic links ") },
@


1.119
log
@More fixes:
	guessindent don't write to istep if spaces,
	lmargin limit is 1 not 2,
	add .js file type,
	allow file insert on zero width rectangle blocks,
@
text
@d334 1
@


1.118
log
@Apply two years of good user supplied patches.  See NEWS file for details.
@
text
@d300 1
a300 1
	{USTR "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, USTR _("Left margin (%d): "), 0, USTR _("L Left margin "), 0, 1, 63 },
@


1.117
log
@More work on coroutine refactoring.
@
text
@d118 1
d172 1
d328 1
@


1.116
log
@more refactoring
@
text
@d711 1
a711 1
static int doopt(MENU *m, int x, unsigned char **vary, int flg)
a713 1
	BW *bw = m->parent->win->object;
d716 1
a716 2
	int *notify = m->parent->notify;
	wabort (m->parent);
a754 1
			m->parent->notify = 0;
a775 1
			m->parent->notify = 0;
a785 1
			m->parent->notify = 0;
a803 2
			m->parent->notify = 0;

a822 2
			m->parent->notify = 0;

a841 2
			m->parent->notify = 0;

a860 2
	if (notify)
		*notify = 1;
a866 7
static int doabrt(MENU *m, int x, unsigned char **s)
{
	optx = x;
	varm(s);
	return -1;
}

d903 3
a905 3
	if (mkmenu(bw->parent, bw->parent, s, doopt, doabrt, NULL, optx, s, NULL))
		return 0;
	else
d907 2
@


1.115
log
@fix tags.
switch more wmkpw to ask
@
text
@d748 1
a748 1
			s = ask(bw->parent, buf, NULL, NULL, utypebw, notify, locale_map, 0, 0, NULL);
d758 1
a758 1
			s = ask(bw->parent, buf, NULL, NULL, utypebw, notify, locale_map, 0, 0, NULL);
d781 1
a781 1
			s = ask(bw->parent, buf, NULL, NULL, utypebw, notify, locale_map, 0, 0, NULL);
d791 1
a791 1
			s = ask(bw->parent, buf, NULL, NULL, utypebw, notify, locale_map, 0, 0, NULL);
d811 1
a811 1
			s = ask(bw->parent, buf, NULL, NULL, utypebw, notify, locale_map, 0, 0, NULL);
d832 1
a832 1
			s = ask(bw->parent, buf, NULL, NULL, syntaxcmplt, notify, locale_map, 0, 0, NULL);
d853 1
a853 1
			s = ask(bw->parent, buf, NULL, NULL, encodingcmplt, notify, locale_map, 0, 0, NULL);
@


1.114
log
@fix option menu problem
@
text
@a645 85
static int doabrt1(BW *bw, int *xx)
{
	joe_free(xx);
	return -1;
}

static int doopt1(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	int x = *xx;
	int v;

	joe_free(xx);
	switch (glopts[x].type) {
	case 1:
		v = calc(bw, s);
		if (merr) {
			msgnw(bw->parent, merr);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			*(int *)glopts[x].set = v;
		else {
			msgnw(bw->parent, joe_gettext(_("Value out of range")));
			ret = -1;
		}
		break;
	case 2:
		if (s[0])
			*(unsigned char **) glopts[x].set = zdup(s);
		break;
	case 6:
		*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst) = zdup(s);
		break;
	case 5:
		v = calc(bw, s);
		if (merr) {
			msgnw(bw->parent, merr);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
		else {
			msgnw(bw->parent, joe_gettext(_("Value out of range")));
			ret = -1;
		}
		break;
	case 7:
		v = calc(bw, s) - 1.0;
		if (merr) {
			msgnw(bw->parent, merr);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
		else {
			msgnw(bw->parent, joe_gettext(_("Value out of range")));
			ret = -1;
		}
		break;
	}
	bw->b->o = bw->o;
	wfit(bw->parent->t);
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

static int dosyntax(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	struct high_syntax *syn;

	syn = load_dfa(s);

	if (syn)
		bw->o.syntax = syn;
	else
		msgnw(bw->parent, joe_gettext(_("Syntax definition file not found")));

	bw->b->o = bw->o;
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

a699 21
static int doencoding(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	struct charmap *map;


	map = find_charmap(s);

	if (map) {
		bw->o.charmap = map;
		msgnw(bw->parent, vsfmt(NULL, 0, joe_gettext(_("%s encoding assumed for this file")), map->name));
	} else
		msgnw(bw->parent, joe_gettext(_("Character set not found")));

	bw->b->o = bw->o;
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

d713 1
a714 1
	int *xx;
d716 1
d718 118
d837 13
a849 51
	switch (glopts[x].type) {
	case 0:
		if (!flg)
			*(int *)glopts[x].set = !*(int *)glopts[x].set;
		else if (flg == 1)
			*(int *)glopts[x].set = 1;
		else
			*(int *)glopts[x].set = 0;
		wabort(m->parent);
		msgnw(bw->parent, *(int *)glopts[x].set ? joe_gettext(glopts[x].yes) : joe_gettext(glopts[x].no));
		break;
	case 4:
		if (!flg)
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = !*(int *) ((unsigned char *) &bw->o + glopts[x].ofst);
		else if (flg == 1)
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 1;
		else
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 0;
		wabort(m->parent);
		msgnw(bw->parent, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? joe_gettext(glopts[x].yes) : joe_gettext(glopts[x].no));
		if (glopts[x].ofst == (unsigned char *) &fdefault.readonly - (unsigned char *) &fdefault)
			bw->b->rdonly = bw->o.readonly;
		break;
	case 6:
		wabort(m->parent);
		xx = (int *) joe_malloc(sizeof(int));
		*xx = x;
		if(*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst))
			buf = vsfmt(buf, 0, glopts[x].yes, *(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst));
		else
			buf = vsfmt(buf, 0, glopts[x].yes,"");
		if(wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map, 0))
			return 0;
		else
			return -1;
		/* break; */
	case 1:
		buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *)glopts[x].set);
		xx = (int *) joe_malloc(sizeof(int));

		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map, 0))
			return 0;
		else
			return -1;
	case 2:
		if (*(unsigned char **) glopts[x].set)
			buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(unsigned char **) glopts[x].set);
		else
d851 1
a851 1
		xx = (int *) joe_malloc(sizeof(int));
d853 3
a855 21
		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map, 0))
			return 0;
		else
			return -1;
	case 5:
		buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
		goto in;
	case 7:
		buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
	      in:xx = (int *) joe_malloc(sizeof(int));

		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map, 0))
			return 0;
		else
			return -1;
d857 1
a857 8
	case 9:
		buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), "");
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, dosyntax, NULL, NULL, syntaxcmplt, NULL, notify, locale_map, 0))
			return 0;
		else
			return -1;
d859 12
a870 8
	case 13:
		buf = vsfmt(buf, 0, joe_gettext(glopts[x].yes), "");
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doencoding, NULL, NULL, encodingcmplt, NULL, notify, locale_map, 0))
			return 0;
		else
			return -1;
d877 1
a877 1
	return 0;
@


1.113
log
@semiautomatic variables
@
text
@a823 2
	varm(vary);

@


1.112
log
@UC -> USTR
@
text
@a37 2
#define OPT_BUF_SIZE 300

d266 1
a266 1
		vsrm(pieces[x]);
a703 1
	vsrm(s);
a723 1
	vsrm(s);
d748 1
a748 2
		if (!aLEN(t)) {
			varm(t);
d753 4
a756 1
		for (x = 0; x != aLEN(t); ++x) {
a759 1
		varm(t);
d763 1
a763 2
			unsigned char buf[1024];
			joe_snprintf_1(buf,sizeof(buf),"%s/.joe/syntax",p);
d765 1
a765 1
				for (x = 0; x != aLEN(t); ++x)
d767 2
a768 2
				for (x = 0; x != aLEN(t); ++x) {
					for (y = 0; y != aLEN(syntaxes); ++y)
d771 1
a771 1
					if (y == aLEN(syntaxes)) {
a775 1
				varm(t);
d795 1
a795 2
		joe_snprintf_1(msgbuf, JOE_MSGBUFSIZE, joe_gettext(_("%s encoding assumed for this file")), map->name);
		msgnw(bw->parent, msgbuf);
a798 1
	vsrm(s);
d817 1
a817 1
static int doopt(MENU *m, int x, void *object, int flg)
d821 1
a821 1
	unsigned char buf[OPT_BUF_SIZE];
d824 2
d854 1
a854 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, glopts[x].yes,*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst));
d856 1
a856 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, glopts[x].yes,"");
d861 1
a861 1
		/* break; warns on some systems */
d863 1
a863 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), *(int *)glopts[x].set);
d875 1
a875 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), *(unsigned char **) glopts[x].set);
d877 1
a877 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), "");
d888 1
a888 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d891 1
a891 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d903 1
a903 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), "");
d912 1
a912 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(glopts[x].yes), "");
d931 1
a931 3
	for (x = 0; s[x]; ++x)
		joe_free(s[x]);
	joe_free(s);
d937 1
a937 2
	int size;
	unsigned char **s;
d940 2
a942 2
	for (size = 0; glopts[size].menu; ++size) ;
	s = (unsigned char **) joe_malloc(sizeof(unsigned char *) * (size + 1));
d944 2
a945 2
	for (x = 0; x != size; ++x) {
		s[x] = (unsigned char *) joe_malloc(80);		/* FIXME: why 40 ??? */
d948 1
a948 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%s", joe_gettext(glopts[x].menu), *(int *)glopts[x].set ? "ON" : "OFF");
d951 1
a951 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", joe_gettext(glopts[x].menu), *(int *)glopts[x].set);
d957 1
a957 1
			zcpy(s[x], joe_gettext(glopts[x].menu));
d960 1
a960 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%s", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d963 1
a963 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d966 1
a966 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", joe_gettext(glopts[x].menu), *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d969 1
a970 1
	s[x] = 0;
d987 1
a987 1
	unsigned char buf[1024];	/* Input buffer */
a991 2
	strncpy((char *)buf, (char *)name, sizeof(buf) - 1);
	buf[sizeof(buf)-1] = '\0';
d993 1
a993 1
	fd = jfopen(buf, "rt");
d995 1
a995 1
	fd = jfopen(buf, "r");
d1004 1
a1004 1
	while (jfgets(buf, sizeof(buf), fd)) {
d1116 1
a1116 1
							unsigned char bf[1024];
a1118 1
							bf[0] = 0;
d1120 1
a1120 1
								joe_snprintf_2(bf,sizeof(bf),"%s/.joe/%s",p,buf + x);
d1124 1
a1124 1
								joe_snprintf_2(bf,sizeof(bf),"%s%s",JOERC,buf + x);
d1128 1
a1128 1
								joe_snprintf_1(bf,sizeof(bf),"%s",buf + x);
d1187 1
a1187 1
					jfgets(buf, 1024, fd);
d1222 1
a1222 2
	unsigned char buf[512];
	int len;
a1224 1
		P *q = pdup(b->bof, USTR "save_hist");
a1226 1
		pset(q,p);
d1228 3
a1230 8
			pnextl(q);
			if (q->byte-p->byte<512) {
				len = q->byte - p->byte;
				brmem(p,buf,len);
			} else {
				brmem(p,buf,512);
				len = 512;
			}
d1232 1
a1232 1
			emit_string(f,buf,len);
a1233 1
			pset(p,q);
a1235 1
		prm(q);
d1245 2
a1246 2
	unsigned char buf[1024];
	unsigned char bf[1024];
d1255 1
a1255 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,USTR "done\n")) {
d1259 1
a1259 1
		len = parse_string(&p,bf,sizeof(bf));
d1271 1
a1271 1
#define STATE_ID (unsigned char *)"# JOE state file v1.0\n"
d1275 1
a1275 1
	unsigned char *home = (unsigned char *)getenv("HOME");
d1280 1
a1280 1
	if (!home)
d1282 1
a1282 1
	joe_snprintf_1(stdbuf,stdsiz,"%s/.joe_state",home);
d1284 1
a1284 1
	f = fopen((char *)stdbuf,"w");
d1290 1
a1290 1
	fprintf(f,"%s",(char *)STATE_ID);
d1312 2
a1313 2
	unsigned char *home = (unsigned char *)getenv("HOME");
	unsigned char buf[1024];
d1317 1
a1317 1
	if (!home)
d1319 2
a1320 2
	joe_snprintf_1(stdbuf,stdsiz,"%s/.joe_state",home);
	f = fopen((char *)stdbuf,"r");
d1325 1
a1325 1
	if (fgets((char *)buf,1024,f) && !zcmp(buf,STATE_ID)) {
d1328 2
a1329 2
		while(fgets((char *)buf,1023,f)) {
			if(!zcmp(buf,USTR "search\n"))
d1331 1
a1331 1
			else if(!zcmp(buf,USTR "macros\n"))
d1333 1
a1333 1
			else if(!zcmp(buf,USTR "files\n"))
d1335 1
a1335 1
			else if(!zcmp(buf,USTR "find\n"))
d1337 1
a1337 1
			else if(!zcmp(buf,USTR "replace\n"))
d1339 1
a1339 1
			else if(!zcmp(buf,USTR "run\n"))
d1341 1
a1341 1
			else if(!zcmp(buf,USTR "build\n"))
d1343 1
a1343 1
			else if(!zcmp(buf,USTR "grep\n"))
d1345 1
a1345 1
			else if(!zcmp(buf,USTR "cmd\n"))
d1347 1
a1347 1
			else if(!zcmp(buf,USTR "math\n"))
d1349 1
a1349 1
			else if(!zcmp(buf,USTR "yank\n"))
d1351 1
a1351 1
			else if (!zcmp(buf,USTR "file_pos\n"))
d1354 1
a1354 1
				while(fgets((char *)buf,1023,f) && zcmp(buf,USTR "done\n"));
@


1.111
log
@change US to UC
@
text
@d82 1
a82 1
	KMAP *k = ngetcontext(UC "main");
d176 3
a178 3
	UC "main",		/* *context */
	UC "\\i%n %m %M",	/* *lmsg */
	UC " %S Ctrl-K H for help",	/* *rmsg */
d207 1
a207 1
	UC ">;!#%/",	/* Characters which can indent paragraphs */
d247 1
a247 1
				P *p = pdup(b->bof, UC "setopt");
d295 82
a376 82
	{UC "overwrite",4, NULL, (unsigned char *) &fdefault.overtype, UC _("Overtype mode"), UC _("Insert mode"), UC _("T Overtype ") },
	{UC "hex",4, NULL, (unsigned char *) &fdefault.hex, UC _("Hex edit mode"), UC _("Text edit mode"), UC _("  Hex edit mode ") },
	{UC "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, UC _("Autoindent enabled"), UC _("Autoindent disabled"), UC _("I Autoindent ") },
	{UC "wordwrap",	4, NULL, (unsigned char *) &fdefault.wordwrap, UC _("Wordwrap enabled"), UC _("Wordwrap disabled"), UC _("W Word wrap ") },
	{UC "tab",	5, NULL, (unsigned char *) &fdefault.tab, UC _("Tab width (%d): "), 0, UC _("D Tab width "), 0, 1, 64 },
	{UC "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, UC _("Left margin (%d): "), 0, UC _("L Left margin "), 0, 1, 63 },
	{UC "rmargin",	7, NULL, (unsigned char *) &fdefault.rmargin, UC _("Right margin (%d): "), 0, UC _("R Right margin "), 0, 7, 255 },
	{UC "restore",	0, &restore_file_pos, NULL, UC _("Restore cursor position when files loaded"), UC _("Don't restore cursor when files loaded"), UC _("  Restore cursor ") },
	{UC "square",	0, &square, NULL, UC _("Rectangle mode"), UC _("Text-stream mode"), UC _("X Rectangle mode ") },
	{UC "icase",	0, &icase, NULL, UC _("Search ignores case by default"), UC _("Case sensitive search by default"), UC _("  Case insensitivity ") },
	{UC "wrap",	0, &wrap, NULL, UC _("Search wraps"), UC _("Search doesn't wrap"), UC _("  Search wraps ") },
	{UC "menu_explorer",	0, &menu_explorer, NULL, UC _("Menu explorer mode"), UC _("Simple completion mode"), UC _("  Menu explorer ") },
	{UC "menu_above",	0, &menu_above, NULL, UC _("Menu above prompt"), UC _("Menu below prompt"), UC _("  Menu position ") },
	{UC "search_prompting",	0, &pico, NULL, UC _("Search prompting on"), UC _("Search prompting off"), UC _("  Search prompting ") },
	{UC "menu_jump",	0, &menu_jump, NULL, UC _("Jump into menu is on"), UC _("Jump into menu is off"), UC _("  Jump into menu ") },
	{UC "autoswap",	0, &autoswap, NULL, UC _("Autoswap ^KB and ^KK"), UC _("Autoswap off "), UC _("  Autoswap mode ") },
	{UC "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, UC _("Indent char %d (SPACE=32, TAB=9, ^C to abort): "), 0, UC _("  Indent char "), 0, 0, 255 },
	{UC "istep",	5, NULL, (unsigned char *) &fdefault.istep, UC _("Indent step %d (^C to abort): "), 0, UC _("  Indent step "), 0, 1, 64 },
	{UC "french",	4, NULL, (unsigned char *) &fdefault.french, UC _("One space after periods for paragraph reformat"), UC _("Two spaces after periods for paragraph reformat"), UC _("  French spacing ") },
	{UC "highlight",	4, NULL, (unsigned char *) &fdefault.highlight, UC _("Highlighting enabled"), UC _("Highlighting disabled"), UC _("H Highlighting ") },
	{UC "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, UC _("Inserting spaces when tab key is hit"), UC _("Inserting tabs when tab key is hit"), UC _("  No tabs ") },
	{UC "mid",	0, &mid, NULL, UC _("Cursor will be recentered on scrolls"), UC _("Cursor will not be recentered on scroll"), UC _("C Center on scroll ") },
	{UC "guess_crlf",0, &guesscrlf, NULL, UC _("Automatically detect MS-DOS files"), UC _("Do not automatically detect MS-DOS files"), UC _("  Auto detect CR-LF ") },
	{UC "guess_indent",0, &guessindent, NULL, UC _("Automatically detect indentation"), UC _("Do not automatically detect indentation"), UC _("  Guess indent ") },
	{UC "guess_non_utf8",0, &guess_non_utf8, NULL, UC _("Automatically detect non-UTF-8 in UTF-8 locale"), UC _("Do not automatically detect non-UTF-8"), UC _("  Guess non-UTF-8 ") },
	{UC "guess_utf8",0, &guess_utf8, NULL, UC _("Automatically detect UTF-8 in non-UTF-8 locale"), UC _("Do not automatically detect UTF-8"), UC _("  Guess UTF-8 ") },
	{UC "transpose",0, &transpose, NULL, UC _("Menu is transposed"), UC _("Menus are not transposed"), UC _("  Transpose menus ") },
	{UC "crlf",	4, NULL, (unsigned char *) &fdefault.crlf, UC _("CR-LF is line terminator"), UC _("LF is line terminator"), UC _("Z CR-LF (MS-DOS) ") },
	{UC "linums",	4, NULL, (unsigned char *) &fdefault.linums, UC _("Line numbers enabled"), UC _("Line numbers disabled"), UC _("N Line numbers ") },
	{UC "marking",	0, &marking, NULL, UC _("Anchored block marking on"), UC _("Anchored block marking off"), UC _("  Marking ") },
	{UC "asis",	0, &dspasis, NULL, UC _("Characters above 127 shown as-is"), UC _("Characters above 127 shown in inverse"), UC _("  Meta chars as-is ") },
	{UC "force",	0, &force, NULL, UC _("Last line forced to have NL when file saved"), UC _("Last line not forced to have NL"), UC _("  Force last NL ") },
	{UC "joe_state",0, &joe_state, NULL, UC _("~/.joe_state file will be updated"), UC _("~/.joe_state file will not be updated"), UC _("  Joe_state file ") },
	{UC "nobackups",	0, &nobackups, NULL, UC _("Backup files will not be made"), UC _("Backup files will be made"), UC _("  Disable backups ") },
	{UC "nolocks",	0, &nolocks, NULL, UC _("Files will not be locked"), UC _("Files will be locked"), UC _("  Disable locks ") },
	{UC "nomodcheck",	0, &nomodcheck, NULL, UC _("No file modification time check"), UC _("File modification time checking enabled"), UC _("  Disable mtime check ") },
	{UC "nocurdir",	0, &nocurdir, NULL, UC _("No current dir"), UC _("Current dir enabled"), UC _("  Disable current dir ") },
	{UC "break_links",	0, &break_links, NULL, UC _("Hardlinks will be broken"), UC _("Hardlinks not broken"), UC _("  Break hard links ") },
	{UC "lightoff",	0, &lightoff, NULL, UC _("Highlighting turned off after block operations"), UC _("Highlighting not turned off after block operations"), UC _("  Auto unmark ") },
	{UC "exask",	0, &exask, NULL, UC _("Prompt for filename in save & exit command"), UC _("Don't prompt for filename in save & exit command"), UC _("  Exit ask ") },
	{UC "beep",	0, &joe_beep, NULL, UC _("Warning bell enabled"), UC _("Warning bell disabled"), UC _("B Beeps ") },
	{UC "nosta",	0, &staen, NULL, UC _("Top-most status line disabled"), UC _("Top-most status line enabled"), UC _("  Disable status line ") },
	{UC "keepup",	0, &keepup, NULL, UC _("Status line updated constantly"), UC _("Status line updated once/sec"), UC _("  Fast status line ") },
	{UC "pg",		1, &pgamnt, NULL, UC _("Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): "), 0, UC _("  No. PgUp/PgDn lines "), 0, -1, 64 },
	{UC "undo_keep",		1, &undo_keep, NULL, UC _("No. undo records to keep, or (0 for infinite): "), 0, UC _("  No. undo records "), 0, -1, 64 },
	{UC "csmode",	0, &csmode, NULL, UC _("Start search after a search repeats previous search"), UC _("Start search always starts a new search"), UC _("  Continued search ") },
	{UC "rdonly",	4, NULL, (unsigned char *) &fdefault.readonly, UC _("Read only"), UC _("Full editing"), UC _("O Read only ") },
	{UC "smarthome",	4, NULL, (unsigned char *) &fdefault.smarthome, UC _("Smart home key enabled"), UC _("Smart home key disabled"), UC _("  Smart home key ") },
	{UC "indentfirst",	4, NULL, (unsigned char *) &fdefault.indentfirst, UC _("Smart home goes to indentation first"), UC _("Smart home goes home first"), UC _("  To indent first ") },
	{UC "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, UC _("Smart backspace key enabled"), UC _("Smart backspace key disabled"), UC _("  Smart backspace ") },
	{UC "purify",	4, NULL, (unsigned char *) &fdefault.purify, UC _("Indentation clean up enabled"), UC _("Indentation clean up disabled"), UC _("  Clean up indents ") },
	{UC "picture",	4, NULL, (unsigned char *) &fdefault.picture, UC _("Picture drawing mode enabled"), UC _("Picture drawing mode disabled"), UC _("P Picture mode ") },
	{UC "backpath",	2, &backpath, NULL, UC _("Backup files stored in (%s): "), 0, UC _("  Path to backup files ") },
	{UC "syntax",	9, NULL, NULL, UC _("Select syntax (^C to abort): "), 0, UC _("Y Syntax") },
	{UC "encoding",13, NULL, NULL, UC _("Select file character set (^C to abort): "), 0, UC _("E Encoding ") },
	{UC "single_quoted",	4, NULL, (unsigned char *) &fdefault.single_quoted, UC _("Single quoting enabled"), UC _("Single quoting disabled"), UC _("  ^G ignores '... ' ") },
	{UC "c_comment",	4, NULL, (unsigned char *) &fdefault.c_comment, UC _("/* comments enabled"), UC _("/* comments disabled"), UC _("  ^G ignores /*...*/ ") },
	{UC "cpp_comment",	4, NULL, (unsigned char *) &fdefault.cpp_comment, UC _("// comments enabled"), UC _("// comments disabled"), UC _("  ^G ignores //... ") },
	{UC "pound_comment",	4, NULL, (unsigned char *) &fdefault.pound_comment, UC _("# comments enabled"), UC _("# comments disabled"), UC _("  ^G ignores #... ") },
	{UC "vhdl_comment",	4, NULL, (unsigned char *) &fdefault.vhdl_comment, UC _("-- comments enabled"), UC _("-- comments disabled"), UC _("  ^G ignores --... ") },
	{UC "semi_comment",	4, NULL, (unsigned char *) &fdefault.semi_comment, UC _("; comments enabled"), UC _("; comments disabled"), UC _("  ^G ignores ;... ") },
	{UC "text_delimiters",	6, NULL, (unsigned char *) &fdefault.text_delimiters, UC _("Text delimiters (%s): "), 0, UC _("  Text delimiters ") },
	{UC "language",	6, NULL, (unsigned char *) &fdefault.language, UC _("Language (%s): "), 0, UC _("V Language ") },
	{UC "cpara",		6, NULL, (unsigned char *) &fdefault.cpara, UC _("Characters which can indent paragraphs (%s): "), 0, UC _("  Paragraph indent chars ") },
	{UC "floatmouse",	0, &floatmouse, 0, UC _("Clicking can move the cursor past end of line"), UC _("Clicking past end of line moves cursor to the end"), UC _("  Click past end ") },
	{UC "rtbutton",	0, &rtbutton, 0, UC _("Mouse action is done with the right button"), UC _("Mouse action is done with the left button"), UC _("  Right button ") },
	{UC "nonotice",	0, &nonotice, NULL, 0, 0, 0 },
	{UC "help_is_utf8",	0, &help_is_utf8, NULL, 0, 0, 0 },
	{UC "noxon",	0, &noxon, NULL, 0, 0, 0 },
	{UC "orphan",	0, &orphan, NULL, 0, 0, 0 },
	{UC "help",	0, &help, NULL, 0, 0, 0 },
	{UC "dopadding",	0, &dopadding, NULL, 0, 0, 0 },
	{UC "lines",	1, &lines, NULL, 0, 0, 0, 0, 2, 1024 },
	{UC "baud",	1, &Baud, NULL, 0, 0, 0, 0, 50, 32767 },
	{UC "columns",	1, &columns, NULL, 0, 0, 0, 0, 2, 1024 },
	{UC "skiptop",	1, &skiptop, NULL, 0, 0, 0, 0, 0, 64 },
	{UC "notite",	0, &notite, NULL, 0, 0, 0 },
	{UC "mouse",	0, &xmouse, NULL, 0, 0, 0 },
	{UC "usetabs",	0, &usetabs, NULL, 0, 0, 0 },
	{UC "assume_color", 0, &assume_color, NULL, 0, 0, 0 },
	{UC "assume_256color", 0, &assume_256color, NULL, 0, 0, 0 },
	{UC "joexterm", 0, &joexterm, NULL, 0, 0, 0 },
d526 1
a526 1
		if (!zcmp(s, UC "lmsg")) {
d533 1
a533 1
		} else if (!zcmp(s, UC "rmsg")) {
d540 1
a540 1
		} else if (!zcmp(s, UC "keymap")) {
d552 1
a552 1
		} else if (!zcmp(s, UC "mnew")) {
d561 1
a561 1
		} else if (!zcmp(s, UC "mfirst")) {
d570 1
a570 1
		} else if (!zcmp(s, UC "mold")) {
d579 1
a579 1
		} else if (!zcmp(s, UC "msnew")) {
d588 1
a588 1
		} else if (!zcmp(s, UC "msold")) {
d597 1
a597 1
		} else if (!zcmp(s, UC "text_color")) {
d608 1
a608 1
		} else if (!zcmp(s, UC "help_color")) {
d614 1
a614 1
		} else if (!zcmp(s, UC "status_color")) {
d620 1
a620 1
		} else if (!zcmp(s, UC "menu_color")) {
d626 1
a626 1
		} else if (!zcmp(s, UC "prompt_color")) {
d632 1
a632 1
		} else if (!zcmp(s, UC "msg_color")) {
d745 1
a745 1
		if (chpwd(UC (JOERC "syntax")))
d747 1
a747 1
		t = rexpnd(UC "*.jsf");
d768 1
a768 1
			if (!chpwd(buf) && (t = rexpnd(UC "*.jsf"))) {
d1084 1
a1084 1
					if (!zcmp(buf + 1, UC "def")) {
d1106 1
a1106 1
					} else if (!zcmp(buf + 1, UC "inherit")) {
d1121 1
a1121 1
					} else if (!zcmp(buf + 1, UC "include")) {
d1157 1
a1157 1
					} else if (!zcmp(buf + 1, UC "delete")) {
d1236 2
a1237 2
		P *p = pdup(b->bof, UC "save_hist");
		P *q = pdup(b->bof, UC "save_hist");
d1274 1
a1274 1
	q = pdup(b->eof, UC "load_hist");
d1276 1
a1276 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,UC "done\n")) {
d1350 1
a1350 1
			if(!zcmp(buf,UC "search\n"))
d1352 1
a1352 1
			else if(!zcmp(buf,UC "macros\n"))
d1354 1
a1354 1
			else if(!zcmp(buf,UC "files\n"))
d1356 1
a1356 1
			else if(!zcmp(buf,UC "find\n"))
d1358 1
a1358 1
			else if(!zcmp(buf,UC "replace\n"))
d1360 1
a1360 1
			else if(!zcmp(buf,UC "run\n"))
d1362 1
a1362 1
			else if(!zcmp(buf,UC "build\n"))
d1364 1
a1364 1
			else if(!zcmp(buf,UC "grep\n"))
d1366 1
a1366 1
			else if(!zcmp(buf,UC "cmd\n"))
d1368 1
a1368 1
			else if(!zcmp(buf,UC "math\n"))
d1370 1
a1370 1
			else if(!zcmp(buf,UC "yank\n"))
d1372 1
a1372 1
			else if (!zcmp(buf,UC "file_pos\n"))
d1375 1
a1375 1
				while(fgets((char *)buf,1023,f) && zcmp(buf,UC "done\n"));
@


1.110
log
@fix warnings
@
text
@d82 1
a82 1
	KMAP *k = ngetcontext(US "main");
d176 3
a178 3
	US "main",		/* *context */
	US "\\i%n %m %M",	/* *lmsg */
	US " %S Ctrl-K H for help",	/* *rmsg */
d207 1
a207 1
	US ">;!#%/",	/* Characters which can indent paragraphs */
d247 1
a247 1
				P *p = pdup(b->bof, US "setopt");
d295 82
a376 82
	{US "overwrite",4, NULL, (unsigned char *) &fdefault.overtype, US _("Overtype mode"), US _("Insert mode"), US _("T Overtype ") },
	{US "hex",4, NULL, (unsigned char *) &fdefault.hex, US _("Hex edit mode"), US _("Text edit mode"), US _("  Hex edit mode ") },
	{US "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, US _("Autoindent enabled"), US _("Autoindent disabled"), US _("I Autoindent ") },
	{US "wordwrap",	4, NULL, (unsigned char *) &fdefault.wordwrap, US _("Wordwrap enabled"), US _("Wordwrap disabled"), US _("W Word wrap ") },
	{US "tab",	5, NULL, (unsigned char *) &fdefault.tab, US _("Tab width (%d): "), 0, US _("D Tab width "), 0, 1, 64 },
	{US "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, US _("Left margin (%d): "), 0, US _("L Left margin "), 0, 1, 63 },
	{US "rmargin",	7, NULL, (unsigned char *) &fdefault.rmargin, US _("Right margin (%d): "), 0, US _("R Right margin "), 0, 7, 255 },
	{US "restore",	0, &restore_file_pos, NULL, US _("Restore cursor position when files loaded"), US _("Don't restore cursor when files loaded"), US _("  Restore cursor ") },
	{US "square",	0, &square, NULL, US _("Rectangle mode"), US _("Text-stream mode"), US _("X Rectangle mode ") },
	{US "icase",	0, &icase, NULL, US _("Search ignores case by default"), US _("Case sensitive search by default"), US _("  Case insensitivity ") },
	{US "wrap",	0, &wrap, NULL, US _("Search wraps"), US _("Search doesn't wrap"), US _("  Search wraps ") },
	{US "menu_explorer",	0, &menu_explorer, NULL, US _("Menu explorer mode"), US _("Simple completion mode"), US _("  Menu explorer ") },
	{US "menu_above",	0, &menu_above, NULL, US _("Menu above prompt"), US _("Menu below prompt"), US _("  Menu position ") },
	{US "search_prompting",	0, &pico, NULL, US _("Search prompting on"), US _("Search prompting off"), US _("  Search prompting ") },
	{US "menu_jump",	0, &menu_jump, NULL, US _("Jump into menu is on"), US _("Jump into menu is off"), US _("  Jump into menu ") },
	{US "autoswap",	0, &autoswap, NULL, US _("Autoswap ^KB and ^KK"), US _("Autoswap off "), US _("  Autoswap mode ") },
	{US "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, US _("Indent char %d (SPACE=32, TAB=9, ^C to abort): "), 0, US _("  Indent char "), 0, 0, 255 },
	{US "istep",	5, NULL, (unsigned char *) &fdefault.istep, US _("Indent step %d (^C to abort): "), 0, US _("  Indent step "), 0, 1, 64 },
	{US "french",	4, NULL, (unsigned char *) &fdefault.french, US _("One space after periods for paragraph reformat"), US _("Two spaces after periods for paragraph reformat"), US _("  French spacing ") },
	{US "highlight",	4, NULL, (unsigned char *) &fdefault.highlight, US _("Highlighting enabled"), US _("Highlighting disabled"), US _("H Highlighting ") },
	{US "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, US _("Inserting spaces when tab key is hit"), US _("Inserting tabs when tab key is hit"), US _("  No tabs ") },
	{US "mid",	0, &mid, NULL, US _("Cursor will be recentered on scrolls"), US _("Cursor will not be recentered on scroll"), US _("C Center on scroll ") },
	{US "guess_crlf",0, &guesscrlf, NULL, US _("Automatically detect MS-DOS files"), US _("Do not automatically detect MS-DOS files"), US _("  Auto detect CR-LF ") },
	{US "guess_indent",0, &guessindent, NULL, US _("Automatically detect indentation"), US _("Do not automatically detect indentation"), US _("  Guess indent ") },
	{US "guess_non_utf8",0, &guess_non_utf8, NULL, US _("Automatically detect non-UTF-8 in UTF-8 locale"), US _("Do not automatically detect non-UTF-8"), US _("  Guess non-UTF-8 ") },
	{US "guess_utf8",0, &guess_utf8, NULL, US _("Automatically detect UTF-8 in non-UTF-8 locale"), US _("Do not automatically detect UTF-8"), US _("  Guess UTF-8 ") },
	{US "transpose",0, &transpose, NULL, US _("Menu is transposed"), US _("Menus are not transposed"), US _("  Transpose menus ") },
	{US "crlf",	4, NULL, (unsigned char *) &fdefault.crlf, US _("CR-LF is line terminator"), US _("LF is line terminator"), US _("Z CR-LF (MS-DOS) ") },
	{US "linums",	4, NULL, (unsigned char *) &fdefault.linums, US _("Line numbers enabled"), US _("Line numbers disabled"), US _("N Line numbers ") },
	{US "marking",	0, &marking, NULL, US _("Anchored block marking on"), US _("Anchored block marking off"), US _("  Marking ") },
	{US "asis",	0, &dspasis, NULL, US _("Characters above 127 shown as-is"), US _("Characters above 127 shown in inverse"), US _("  Meta chars as-is ") },
	{US "force",	0, &force, NULL, US _("Last line forced to have NL when file saved"), US _("Last line not forced to have NL"), US _("  Force last NL ") },
	{US "joe_state",0, &joe_state, NULL, US _("~/.joe_state file will be updated"), US _("~/.joe_state file will not be updated"), US _("  Joe_state file ") },
	{US "nobackups",	0, &nobackups, NULL, US _("Backup files will not be made"), US _("Backup files will be made"), US _("  Disable backups ") },
	{US "nolocks",	0, &nolocks, NULL, US _("Files will not be locked"), US _("Files will be locked"), US _("  Disable locks ") },
	{US "nomodcheck",	0, &nomodcheck, NULL, US _("No file modification time check"), US _("File modification time checking enabled"), US _("  Disable mtime check ") },
	{US "nocurdir",	0, &nocurdir, NULL, US _("No current dir"), US _("Current dir enabled"), US _("  Disable current dir ") },
	{US "break_links",	0, &break_links, NULL, US _("Hardlinks will be broken"), US _("Hardlinks not broken"), US _("  Break hard links ") },
	{US "lightoff",	0, &lightoff, NULL, US _("Highlighting turned off after block operations"), US _("Highlighting not turned off after block operations"), US _("  Auto unmark ") },
	{US "exask",	0, &exask, NULL, US _("Prompt for filename in save & exit command"), US _("Don't prompt for filename in save & exit command"), US _("  Exit ask ") },
	{US "beep",	0, &joe_beep, NULL, US _("Warning bell enabled"), US _("Warning bell disabled"), US _("B Beeps ") },
	{US "nosta",	0, &staen, NULL, US _("Top-most status line disabled"), US _("Top-most status line enabled"), US _("  Disable status line ") },
	{US "keepup",	0, &keepup, NULL, US _("Status line updated constantly"), US _("Status line updated once/sec"), US _("  Fast status line ") },
	{US "pg",		1, &pgamnt, NULL, US _("Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): "), 0, US _("  No. PgUp/PgDn lines "), 0, -1, 64 },
	{US "undo_keep",		1, &undo_keep, NULL, US _("No. undo records to keep, or (0 for infinite): "), 0, US _("  No. undo records "), 0, -1, 64 },
	{US "csmode",	0, &csmode, NULL, US _("Start search after a search repeats previous search"), US _("Start search always starts a new search"), US _("  Continued search ") },
	{US "rdonly",	4, NULL, (unsigned char *) &fdefault.readonly, US _("Read only"), US _("Full editing"), US _("O Read only ") },
	{US "smarthome",	4, NULL, (unsigned char *) &fdefault.smarthome, US _("Smart home key enabled"), US _("Smart home key disabled"), US _("  Smart home key ") },
	{US "indentfirst",	4, NULL, (unsigned char *) &fdefault.indentfirst, US _("Smart home goes to indentation first"), US _("Smart home goes home first"), US _("  To indent first ") },
	{US "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, US _("Smart backspace key enabled"), US _("Smart backspace key disabled"), US _("  Smart backspace ") },
	{US "purify",	4, NULL, (unsigned char *) &fdefault.purify, US _("Indentation clean up enabled"), US _("Indentation clean up disabled"), US _("  Clean up indents ") },
	{US "picture",	4, NULL, (unsigned char *) &fdefault.picture, US _("Picture drawing mode enabled"), US _("Picture drawing mode disabled"), US _("P Picture mode ") },
	{US "backpath",	2, &backpath, NULL, US _("Backup files stored in (%s): "), 0, US _("  Path to backup files ") },
	{US "syntax",	9, NULL, NULL, US _("Select syntax (^C to abort): "), 0, US _("Y Syntax") },
	{US "encoding",13, NULL, NULL, US _("Select file character set (^C to abort): "), 0, US _("E Encoding ") },
	{US "single_quoted",	4, NULL, (unsigned char *) &fdefault.single_quoted, US _("Single quoting enabled"), US _("Single quoting disabled"), US _("  ^G ignores '... ' ") },
	{US "c_comment",	4, NULL, (unsigned char *) &fdefault.c_comment, US _("/* comments enabled"), US _("/* comments disabled"), US _("  ^G ignores /*...*/ ") },
	{US "cpp_comment",	4, NULL, (unsigned char *) &fdefault.cpp_comment, US _("// comments enabled"), US _("// comments disabled"), US _("  ^G ignores //... ") },
	{US "pound_comment",	4, NULL, (unsigned char *) &fdefault.pound_comment, US _("# comments enabled"), US _("# comments disabled"), US _("  ^G ignores #... ") },
	{US "vhdl_comment",	4, NULL, (unsigned char *) &fdefault.vhdl_comment, US _("-- comments enabled"), US _("-- comments disabled"), US _("  ^G ignores --... ") },
	{US "semi_comment",	4, NULL, (unsigned char *) &fdefault.semi_comment, US _("; comments enabled"), US _("; comments disabled"), US _("  ^G ignores ;... ") },
	{US "text_delimiters",	6, NULL, (unsigned char *) &fdefault.text_delimiters, US _("Text delimiters (%s): "), 0, US _("  Text delimiters ") },
	{US "language",	6, NULL, (unsigned char *) &fdefault.language, US _("Language (%s): "), 0, US _("V Language ") },
	{US "cpara",		6, NULL, (unsigned char *) &fdefault.cpara, US _("Characters which can indent paragraphs (%s): "), 0, US _("  Paragraph indent chars ") },
	{US "floatmouse",	0, &floatmouse, 0, US _("Clicking can move the cursor past end of line"), US _("Clicking past end of line moves cursor to the end"), US _("  Click past end ") },
	{US "rtbutton",	0, &rtbutton, 0, US _("Mouse action is done with the right button"), US _("Mouse action is done with the left button"), US _("  Right button ") },
	{US "nonotice",	0, &nonotice, NULL, 0, 0, 0 },
	{US "help_is_utf8",	0, &help_is_utf8, NULL, 0, 0, 0 },
	{US "noxon",	0, &noxon, NULL, 0, 0, 0 },
	{US "orphan",	0, &orphan, NULL, 0, 0, 0 },
	{US "help",	0, &help, NULL, 0, 0, 0 },
	{US "dopadding",	0, &dopadding, NULL, 0, 0, 0 },
	{US "lines",	1, &lines, NULL, 0, 0, 0, 0, 2, 1024 },
	{US "baud",	1, &Baud, NULL, 0, 0, 0, 0, 50, 32767 },
	{US "columns",	1, &columns, NULL, 0, 0, 0, 0, 2, 1024 },
	{US "skiptop",	1, &skiptop, NULL, 0, 0, 0, 0, 0, 64 },
	{US "notite",	0, &notite, NULL, 0, 0, 0 },
	{US "mouse",	0, &xmouse, NULL, 0, 0, 0 },
	{US "usetabs",	0, &usetabs, NULL, 0, 0, 0 },
	{US "assume_color", 0, &assume_color, NULL, 0, 0, 0 },
	{US "assume_256color", 0, &assume_256color, NULL, 0, 0, 0 },
	{US "joexterm", 0, &joexterm, NULL, 0, 0, 0 },
d526 1
a526 1
		if (!zcmp(s, US "lmsg")) {
d533 1
a533 1
		} else if (!zcmp(s, US "rmsg")) {
d540 1
a540 1
		} else if (!zcmp(s, US "keymap")) {
d552 1
a552 1
		} else if (!zcmp(s, US "mnew")) {
d561 1
a561 1
		} else if (!zcmp(s, US "mfirst")) {
d570 1
a570 1
		} else if (!zcmp(s, US "mold")) {
d579 1
a579 1
		} else if (!zcmp(s, US "msnew")) {
d588 1
a588 1
		} else if (!zcmp(s, US "msold")) {
d597 1
a597 1
		} else if (!zcmp(s, US "text_color")) {
d608 1
a608 1
		} else if (!zcmp(s, US "help_color")) {
d614 1
a614 1
		} else if (!zcmp(s, US "status_color")) {
d620 1
a620 1
		} else if (!zcmp(s, US "menu_color")) {
d626 1
a626 1
		} else if (!zcmp(s, US "prompt_color")) {
d632 1
a632 1
		} else if (!zcmp(s, US "msg_color")) {
d745 1
a745 1
		if (chpwd(US (JOERC "syntax")))
d747 1
a747 1
		t = rexpnd(US "*.jsf");
d768 1
a768 1
			if (!chpwd(buf) && (t = rexpnd(US "*.jsf"))) {
d1084 1
a1084 1
					if (!zcmp(buf + 1, US "def")) {
d1106 1
a1106 1
					} else if (!zcmp(buf + 1, US "inherit")) {
d1121 1
a1121 1
					} else if (!zcmp(buf + 1, US "include")) {
d1157 1
a1157 1
					} else if (!zcmp(buf + 1, US "delete")) {
d1236 2
a1237 2
		P *p = pdup(b->bof, US "save_hist");
		P *q = pdup(b->bof, US "save_hist");
d1274 1
a1274 1
	q = pdup(b->eof, US "load_hist");
d1276 1
a1276 1
	while(fgets((char *)buf,1023,f) && zcmp(buf,US "done\n")) {
d1350 1
a1350 1
			if(!zcmp(buf,US "search\n"))
d1352 1
a1352 1
			else if(!zcmp(buf,US "macros\n"))
d1354 1
a1354 1
			else if(!zcmp(buf,US "files\n"))
d1356 1
a1356 1
			else if(!zcmp(buf,US "find\n"))
d1358 1
a1358 1
			else if(!zcmp(buf,US "replace\n"))
d1360 1
a1360 1
			else if(!zcmp(buf,US "run\n"))
d1362 1
a1362 1
			else if(!zcmp(buf,US "build\n"))
d1364 1
a1364 1
			else if(!zcmp(buf,US "grep\n"))
d1366 1
a1366 1
			else if(!zcmp(buf,US "cmd\n"))
d1368 1
a1368 1
			else if(!zcmp(buf,US "math\n"))
d1370 1
a1370 1
			else if(!zcmp(buf,US "yank\n"))
d1372 1
a1372 1
			else if (!zcmp(buf,US "file_pos\n"))
d1375 1
a1375 1
				while(fgets((char *)buf,1023,f) && zcmp(buf,US "done\n"));
@


1.109
log
@fix compiler warnings
@
text
@d866 1
a866 1
		break;
@


1.108
log
@allow setting undo
@
text
@d1014 1
a1014 1
	while (jfgets((char *)buf, sizeof(buf), fd)) {
d1198 1
a1198 1
					jfgets((char *)buf, 1024, fd);
@


1.107
log
@Add builtins.  Fix syntax error in python.jsf.in
@
text
@d339 1
@


1.106
log
@hash table
@
text
@d995 1
a995 1
	FILE *fd;		/* rc file */
d1002 1
a1002 1
	fd = fopen((char *)buf, "rt");
d1004 1
a1004 1
	fd = fopen((char *)buf, "r");
d1013 1
a1013 1
	while (fgets((char *)buf, sizeof(buf), fd)) {
d1197 1
a1197 1
					fgets((char *)buf, 1024, fd);
d1217 1
a1217 1
	fclose(fd);		/* Close rc file */
@


1.105
log
@make rc parsing faster
@
text
@a428 1
	int x;
d1126 1
a1126 1
							unsigned char *p = getenv("HOME");
@


1.104
log
@aspell localized
@
text
@d382 1
d388 4
a391 1
	for (x = 0; glopts[x].name; ++x)
d400 1
d430 1
d442 30
a471 9
	for (x = 0; glopts[x].name; ++x)
		if (!zcmp(glopts[x].name, s)) {
			switch (glopts[x].type) {
			case 0: /* Global variable flag option */
				if (set)
					*(int *)glopts[x].set = st;
				break;
			case 1: /* Global variable integer option */
				if (set && arg) {
d473 8
a480 17
					if (val >= glopts[x].low && val <= glopts[x].high)
						*(int *)glopts[x].set = val;
				}
				break;
			case 2: /* Global variable string option */
				if (set) {
					if (arg)
						*(unsigned char **) glopts[x].set = zdup(arg);
					else
						*(unsigned char **) glopts[x].set = 0;
				}
				break;
			case 4: /* Local option flag */
				if (options)
					*(int *) ((unsigned char *) options + glopts[x].ofst) = st;
				break;
			case 5: /* Local option integer */
d482 5
a486 6
					if (options) {
						sscanf((char *)arg, "%d", &val);
						if (val >= glopts[x].low && val <= glopts[x].high)
							*(int *) ((unsigned char *)
								  options + glopts[x].ofst) = val;
					} 
d488 12
a499 10
				break;
			case 6: /* Local string option */
				if (options) {
					if (arg) {
						*(unsigned char **) ((unsigned char *)
								  options + glopts[x].ofst) = zdup(arg);
					} else {
						*(unsigned char **) ((unsigned char *)
								  options + glopts[x].ofst) = 0;
					}
d501 2
a502 4
				break;
			case 7: /* Local option numeric + 1, with range checking */
				if (arg) {
					int zz = 0;
d504 7
a510 9
					sscanf((char *)arg, "%d", &zz);
					if (zz >= glopts[x].low && zz <= glopts[x].high) {
						--zz;
						if (options)
							*(int *) ((unsigned char *)
								  options + glopts[x].ofst) = zz;
					}
				}
				break;
d512 43
a554 51
			case 9: /* Set syntax */
				if (arg && options)
					options->syntax_name = zdup(arg);
				/* this was causing all syntax files to be loaded...
				if (arg && options)
					options->syntax = load_dfa(arg); */
				break;

			case 13: /* Set byte mode encoding */
				if (arg && options)
					options->map_name = zdup(arg);
				break;
			}
			/* This is a stupid hack... */
			if ((glopts[x].type & 3) == 0 || !arg)
				return 1;
			else
				return 2;
		}
	/* Why no case 6, string option? */
	/* Keymap, mold, mnew, etc. are not strings */
	/* These options do not show up in ^T */
	if (!zcmp(s, US "lmsg")) {
		if (arg) {
			if (options)
				options->lmsg = zdup(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "rmsg")) {
		if (arg) {
			if (options)
				options->rmsg = zdup(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "keymap")) {
		if (arg) {
			int y;

			for (y = 0; !joe_isspace(locale_map,arg[y]); ++y) ;
			if (!arg[y])
				arg[y] = 0;
			if (options && y)
				options->context = zdup(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "mnew")) {
		if (arg) {
			int sta;
d556 8
a563 8
			if (options)
				options->mnew = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "mfirst")) {
		if (arg) {
			int sta;
d565 8
a572 8
			if (options)
				options->mfirst = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "mold")) {
		if (arg) {
			int sta;
d574 8
a581 8
			if (options)
				options->mold = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "msnew")) {
		if (arg) {
			int sta;
d583 8
a590 8
			if (options)
				options->msnew = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "msold")) {
		if (arg) {
			int sta;
d592 47
a638 46
			if (options)
				options->msold = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "text_color")) {
		if (arg) {
			bg_text = meta_color(arg);
			bg_help = bg_text;
			bg_prompt = bg_text;
			bg_menu = bg_text;
			bg_msg = bg_text;
			bg_stalin = bg_text;
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "help_color")) {
		if (arg) {
			bg_help = meta_color(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "status_color")) {
		if (arg) {
			bg_stalin = meta_color(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "menu_color")) {
		if (arg) {
			bg_menu = meta_color(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "prompt_color")) {
		if (arg) {
			bg_prompt = meta_color(arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!zcmp(s, US "msg_color")) {
		if (arg) {
			bg_msg = meta_color(arg);
			ret = 2;
		} else
			ret = 1;
@


1.103
log
@wordwrap improvements.
@
text
@d10 28
d140 1
d193 1
d230 2
d356 1
d851 1
a851 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, joe_gettext(_("Delimiters (%s): ")),*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst));
d853 1
a853 1
			joe_snprintf_0(buf, OPT_BUF_SIZE, joe_gettext(_("Delimiters: ")));
@


1.102
log
@transpose menus
@
text
@d177 1
a177 1
	US ">*;!#%/",	/* Characters which can indent paragraphs */
@


1.101
log
@clean up joerc files
@
text
@d289 1
@


1.100
log
@missing @@..@@ in rc file
@
text
@d1084 17
a1100 1
							switch (procrc(cap, buf + x)) {
d1105 1
a1105 1
								fprintf(stderr, (char *)joe_gettext(_("\n%s %d: Couldn't open %s")), name, line, buf + x);
@


1.99
log
@-help_is_utf8 option
@
text
@d983 1
a983 1
			{
d989 1
a989 1
			{
d1002 1
a1002 1
			{
d1012 1
a1012 1
			{
d1029 2
a1030 2
		case '{':	/* Process help text */
			{
d1064 1
a1064 1
					} else if (!zcmp(buf + 1, US "inherit"))
d1078 1
d1099 1
a1099 1
					} else if (!zcmp(buf + 1, US "delete"))
d1111 2
a1112 1
					} else
d1114 1
@


1.98
log
@clean up rc.c file messages
@
text
@d327 1
@


1.97
log
@gettext()
@
text
@d263 63
a325 63
	{US "overwrite",4, NULL, (unsigned char *) &fdefault.overtype, US "Overtype mode", US "Insert mode", US "T Overtype " },
	{US "hex",4, NULL, (unsigned char *) &fdefault.hex, US "Hex edit mode", US "Text edit mode", US "  Hex edit mode " },
	{US "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, US "Autoindent enabled", US "Autoindent disabled", US "I Autoindent " },
	{US "wordwrap",	4, NULL, (unsigned char *) &fdefault.wordwrap, US "Wordwrap enabled", US "Wordwrap disabled", US "Word wrap " },
	{US "tab",	5, NULL, (unsigned char *) &fdefault.tab, US "Tab width (%d): ", 0, US "D Tab width ", 0, 1, 64 },
	{US "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, US "Left margin (%d): ", 0, US "Left margin ", 0, 1, 63 },
	{US "rmargin",	7, NULL, (unsigned char *) &fdefault.rmargin, US "Right margin (%d): ", 0, US "Right margin ", 0, 7, 255 },
	{US "restore",	0, &restore_file_pos, NULL, US "Restore cursor pos mode", US "Don't restore cursor", US "  Restore cursor " },
	{US "square",	0, &square, NULL, US "Rectangle mode", US "Text-stream mode", US "X Rectangle mode " },
	{US "icase",	0, &icase, NULL, US "Ignore case by default", US "Case sensitive by default", US "  Case insensitivity " },
	{US "wrap",	0, &wrap, NULL, US "Search wraps", US "Search doesn't wrap", US "  Search wraps " },
	{US "menu_explorer",	0, &menu_explorer, NULL, US "Menu explorer mode", US "Simple completion", US "  Menu explorer " },
	{US "menu_above",	0, &menu_above, NULL, US "Menu above prompt", US "Menu below prompt", US "  Menu position " },
	{US "search_prompting",	0, &pico, NULL, US "Search prompting on", US "Search prompting off", US "  Search prompting " },
	{US "menu_jump",	0, &menu_jump, NULL, US "Jump is on", US "Jump is off", US "  Jump into menu " },
	{US "autoswap",	0, &autoswap, NULL, US "Autoswap ^KB and ^KK", US "  Autoswap off ", US "  Autoswap mode " },
	{US "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, US "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", 0, US "  Indent char ", 0, 0, 255 },
	{US "istep",	5, NULL, (unsigned char *) &fdefault.istep, US "Indent step %d (^C to abort): ", 0, US "  Indent step ", 0, 1, 64 },
	{US "french",	4, NULL, (unsigned char *) &fdefault.french, US "One space after periods for paragraph reformat", US "Two spaces after periods for paragraph reformat", US "  french spacing " },
	{US "highlight",	4, NULL, (unsigned char *) &fdefault.highlight, US "Highlighting enabled", US "Highlighting disabled", US "Highlighting " },
	{US "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, US "Inserting spaces when tab key is hit", US "Inserting tabs when tab key is hit", US "  no tabs " },
	{US "mid",	0, &mid, NULL, US "Cursor will be recentered on scrolls", US "Cursor will not be recentered on scroll", US "Center on scroll " },
	{US "guess_crlf",0, &guesscrlf, NULL, US "Automatically detect MS-DOS files", US "Do not automatically detect MS-DOS files", US "  Auto detect CR-LF " },
	{US "guess_indent",0, &guessindent, NULL, US "Automatically detect indentation", US "Do not automatically detect indentation", US "  Guess indent " },
	{US "guess_non_utf8",0, &guess_non_utf8, NULL, US "Automatically detect non-UTF-8 in UTF-8 locale", US "Do not automatically detect non-UTF-8", US "  Guess non-UTF-8 " },
	{US "guess_utf8",0, &guess_utf8, NULL, US "Automatically detect UTF-8 in non-UTF-8 locale", US "Do not automatically detect UTF-8", US "  Guess UTF-8 " },
	{US "crlf",	4, NULL, (unsigned char *) &fdefault.crlf, US "CR-LF is line terminator", US "LF is line terminator", US "Z CR-LF (MS-DOS) " },
	{US "linums",	4, NULL, (unsigned char *) &fdefault.linums, US "Line numbers enabled", US "Line numbers disabled", US "N Line numbers " },
	{US "marking",	0, &marking, NULL, US "Anchored block marking on", US "Anchored block marking off", US "Marking " },
	{US "asis",	0, &dspasis, NULL, US "Characters above 127 shown as-is", US "Characters above 127 shown in inverse", US "  Meta chars as-is " },
	{US "force",	0, &force, NULL, US "Last line forced to have NL when file saved", US "Last line not forced to have NL", US "Force last NL " },
	{US "joe_state",0, &joe_state, NULL, US "~/.joe_state file will be updated", US "~/.joe_state file will not be updated", US "  Joe_state file " },
	{US "nobackups",	0, &nobackups, NULL, US "Backup files will not be made", US "Backup files will be made", US "  Disable backups " },
	{US "nolocks",	0, &nolocks, NULL, US "Files will not be locked", US "Files will be locked", US "  Disable locks " },
	{US "nomodcheck",	0, &nomodcheck, NULL, US "No mtime check", US "Mtime checking enabled", US "  Disable mtime check " },
	{US "nocurdir",	0, &nocurdir, NULL, US "No current dir", US "Current dir enabled", US "  Disable current dir " },
	{US "break_links",	0, &break_links, NULL, US "Hardlinks will be broken", US "Hardlinks not broken", US "  Break hard links " },
	{US "lightoff",	0, &lightoff, NULL, US "Highlighting turned off after block operations", US "Highlighting not turned off after block operations", US "Auto unmark " },
	{US "exask",	0, &exask, NULL, US "Prompt for filename in save & exit command", US "Don't prompt for filename in save & exit command", US "  Exit ask " },
	{US "beep",	0, &joe_beep, NULL, US "Warning bell enabled", US "Warning bell disabled", US "Beeps " },
	{US "nosta",	0, &staen, NULL, US "Top-most status line disabled", US "Top-most status line enabled", US "  Disable status line " },
	{US "keepup",	0, &keepup, NULL, US "Status line updated constantly", US "Status line updated once/sec", US "  Fast status line " },
	{US "pg",		1, &pgamnt, NULL, US "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, US "  No. PgUp/PgDn lines ", 0, -1, 64 },
	{US "csmode",	0, &csmode, NULL, US "Start search after a search repeats previous search", US "Start search always starts a new search", US "Continued search " },
	{US "rdonly",	4, NULL, (unsigned char *) &fdefault.readonly, US "Read only", US "Full editing", US "O Read only " },
	{US "smarthome",	4, NULL, (unsigned char *) &fdefault.smarthome, US "Smart home key enabled", US "Smart home key disabled", US "  Smart home key " },
	{US "indentfirst",	4, NULL, (unsigned char *) &fdefault.indentfirst, US "Smart home goes to indent first", US "Smart home goes home first", US "  To indent first " },
	{US "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, US "Smart backspace key enabled", US "Smart backspace key disabled", US "  Smart backspace " },
	{US "purify",	4, NULL, (unsigned char *) &fdefault.purify, US "Indentation clean up enabled", US "Indentation clean up disabled", US "  Clean up indents " },
	{US "picture",	4, NULL, (unsigned char *) &fdefault.picture, US "Picture drawing mode enabled", US "Picture drawing mode disabled", US "Picture mode " },
	{US "backpath",	2, &backpath, NULL, US "Backup files stored in (%s): ", 0, US "  Path to backup files " },
	{US "syntax",	9, NULL, NULL, US "Select syntax (^C to abort): ", 0, US "Y Syntax" },
	{US "encoding",13, NULL, NULL, US "Select file character set (^C to abort): ", 0, US "Encoding " },
	{US "single_quoted",	4, NULL, (unsigned char *) &fdefault.single_quoted, US "Single quoting enabled", US "Single quoting disabled", US "  ^G ignores ' ' " },
	{US "c_comment",	4, NULL, (unsigned char *) &fdefault.c_comment, US "/* comments enabled", US "/* comments disabled", US "  ^G ignores /**/ " },
	{US "cpp_comment",	4, NULL, (unsigned char *) &fdefault.cpp_comment, US "// comments enabled", US "// comments disabled", US "  ^G ignores // " },
	{US "pound_comment",	4, NULL, (unsigned char *) &fdefault.pound_comment, US "# comments enabled", US "# comments disabled", US "  ^G ignores # " },
	{US "vhdl_comment",	4, NULL, (unsigned char *) &fdefault.vhdl_comment, US "-- comments enabled", US "-- comments disabled", US "  ^G ignores -- " },
	{US "semi_comment",	4, NULL, (unsigned char *) &fdefault.semi_comment, US "; comments enabled", US "; comments disabled", US "  ^G ignores ; " },
	{US "text_delimiters",	6, NULL, (unsigned char *) &fdefault.text_delimiters, US "Text delimiters (%s): ", 0, US "  Text delimiters " },
	{US "cpara",		6, NULL, (unsigned char *) &fdefault.cpara, US "Chars that can indent paragraphs (%s): ", 0, US "  paragraph indent chars " },
	{US "floatmouse",	0, &floatmouse, 0, US "Clicking can move the cursor past end of line", US "Clicking past end of line moves cursor to the end", US "  Click past end " },
	{US "rtbutton",	0, &rtbutton, 0, US "Mouse action is done with the right button", US "Mouse action is done with the left button", US "  Right button " },
d797 1
a797 1
		msgnw(bw->parent, *(int *)glopts[x].set ? glopts[x].yes : glopts[x].no);
d807 1
a807 1
		msgnw(bw->parent, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? glopts[x].yes : glopts[x].no);
d825 1
a825 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *)glopts[x].set);
d837 1
a837 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(unsigned char **) glopts[x].set);
d839 1
a839 1
			joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d850 1
a850 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d853 1
a853 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d865 1
a865 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d874 1
a874 1
		joe_snprintf_1(buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d913 1
a913 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *)glopts[x].set ? "ON" : "OFF");
d916 1
a916 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *)glopts[x].set);
d922 1
a922 1
			zcpy(s[x], glopts[x].menu);
d925 1
a925 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d928 1
a928 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d931 1
a931 1
			joe_snprintf_2((s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
@


1.96
log
@A option for search
Restore cursor to old position
@
text
@d270 1
d287 2
d627 1
a627 1
			msgnw(bw->parent, US "Value out of range");
d646 1
a646 1
			msgnw(bw->parent, US "Value out of range");
d658 1
a658 1
			msgnw(bw->parent, US "Value out of range");
d682 1
a682 1
		msgnw(bw->parent, US "Syntax definition file not found");
d724 1
a724 1
			joe_snprintf_1((char *)buf,sizeof(buf),"%s/.joe/syntax",p);
d757 1
a757 1
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%s encoding assumed for this file", map->name);
d760 1
a760 1
		msgnw(bw->parent, US "Character set not found");
d816 1
a816 1
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, "Delimiters (%s): ",*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst));
d818 1
a818 1
			joe_snprintf_0((char *)buf, OPT_BUF_SIZE, "Delimiters: ");
d825 1
a825 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *)glopts[x].set);
d837 1
a837 1
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(unsigned char **) glopts[x].set);
d839 1
a839 1
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d850 1
a850 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d853 1
a853 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d865 1
a865 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d874 1
a874 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d913 1
a913 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *)glopts[x].set ? "ON" : "OFF");
d916 1
a916 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *)glopts[x].set);
d925 1
a925 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d928 1
a928 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d931 1
a931 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d968 1
a968 1
	fprintf(stderr, "Processing '%s'...", name);
d1024 1
a1024 1
					fprintf(stderr, "\n%s %d: Unknown option %s", name, line, opt);
d1057 1
a1057 1
								fprintf(stderr, "\n%s %d: macro missing from :def", name, line);
d1061 1
a1061 1
							fprintf(stderr, "\n%s %d: command name missing from :def", name, line);
d1072 1
a1072 1
								fprintf(stderr, "\n%s %d: context name missing from :inherit", name, line);
d1076 1
a1076 1
							fprintf(stderr, "\n%s %d: No context selected for :inherit", name, line);
d1087 1
a1087 1
								fprintf(stderr, "\n%s %d: Couldn't open %s", name, line, buf + x);
d1095 1
a1095 1
							fprintf(stderr, "\n%s %d: :include missing file name", name, line);
d1108 1
a1108 1
							fprintf(stderr, "\n%s %d: No context selected for :delete", name, line);
d1113 1
a1113 1
					fprintf(stderr, "\n%s %d: Invalid context name", name, line);
d1124 1
a1124 1
					fprintf(stderr, "\n%s %d: No context selected for macro to key-sequence binding", name, line);
d1133 1
a1133 1
					fprintf(stderr, "\n%s %d: Unknown command in macro", name, line);
d1149 1
a1149 1
					fprintf(stderr, "\n%s %d: Bad key sequence '%s'", name, line, buf + x);
d1160 1
a1160 1
		fprintf(stderr, "\ndone\n");
d1162 1
a1162 1
		fprintf(stderr, "done\n");
d1241 1
a1241 1
	joe_snprintf_1((char *)stdbuf,stdsiz,"%s/.joe_state",home);
d1278 1
a1278 1
	joe_snprintf_1((char *)stdbuf,stdsiz,"%s/.joe_state",home);
@


1.95
log
@Subroutines for syntax highlighter.
@
text
@d1260 1
d1307 2
@


1.94
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d254 1
a254 1
	int *set;		/* Address of global option */
d310 1
a310 1
	{US "backpath",	2, (int *) &backpath, NULL, US "Backup files stored in (%s): ", 0, US "  Path to backup files " },
d403 1
a403 1
					*glopts[x].set = st;
d409 1
a409 1
						*glopts[x].set = val;
d622 1
a622 1
			*glopts[x].set = v;
d788 1
a788 1
			*glopts[x].set = !*glopts[x].set;
d790 1
a790 1
			*glopts[x].set = 1;
d792 1
a792 1
			*glopts[x].set = 0;
d794 1
a794 1
		msgnw(bw->parent, *glopts[x].set ? glopts[x].yes : glopts[x].no);
d822 1
a822 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *glopts[x].set);
d910 1
a910 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *glopts[x].set ? "ON" : "OFF");
d913 1
a913 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *glopts[x].set);
@


1.93
log
@new cvs server
@
text
@a7 1
#include "config.h"
a9 29
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "cmd.h"
#include "kbd.h"
#include "macro.h"
#include "menu.h"
#include "path.h"
#include "pw.h"
#include "tw.h"
#include "mouse.h"
#include "uedit.h"
#include "umath.h"
#include "utils.h"
#include "vs.h"
#include "b.h"
#include "syntax.h"
#include "va.h"
#include "utf8.h"
#include "charmap.h"
#include "ufile.h"
#include "usearch.h"
#include "ushell.h"
#include "undo.h"
#include "help.h"
#include "w.h"

a77 20
/* Global variable options */
extern int mid, dspasis, dspctrl, force, help, pgamnt, square, csmode, nobackups, lightoff, exask, skiptop;
extern int noxon, lines, staen, columns, Baud, dopadding, orphan, marking, joe_beep, keepup, nonotice;
extern int notite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer, icase, wrap, autoswap;
extern int menu_jump, break_links;
extern int xmouse;
extern unsigned char *backpath;
extern unsigned char *cpara_list;
extern int nolocks, nomodcheck, nocurdir;
extern int assume_256color;
extern int bg_text;
extern int bg_stalin;
extern int bg_menu;
extern int bg_help;
extern int bg_prompt;
extern int bg_msg;
extern int joexterm;
extern int pico;
extern int menu_above;

a553 2
			int sta;

a564 2
			int sta;

a570 2
			int sta;

a576 2
			int sta;

a582 2
			int sta;

a588 2
			int sta;

@


1.92
log
@Allow escape sequences in strings.
@
text
@d227 1
a227 1
	">*;!#%/",	/* Characters which can indent paragraphs */
d233 1
a233 1
void lazy_opts(OPTIONS *o)
d236 12
a247 1
	o->charmap = find_charmap(o->map_name);
d269 1
a269 1
					lazy_opts(&b->o);
d276 1
a276 1
				lazy_opts(&b->o);
d282 1
a282 1
	lazy_opts(&b->o);
d368 1
a368 1
	{US "semi_comment",	4, NULL, (unsigned char *) &fdefault.vhdl_comment, US "; comments enabled", US "; comments disabled", US "  ^G ignores ; " },
@


1.91
log
@New -cpara option
@
text
@d1237 1
a1237 1
			emit_hdlc(f,buf,len);
d1266 1
a1266 1
		len = parse_hdlc(&p,bf,1023);
@


1.90
log
@add joe_debug
@
text
@d115 1
d175 1
d227 1
d359 1
@


1.89
log
@Allow setting foreground and background colors.  Added new status line color.
@
text
@d251 1
a251 1
				P *p = pdup(b->bof);
d1218 2
a1219 2
		P *p = pdup(b->bof);
		P *q = pdup(b->bof);
d1256 1
a1256 1
	q = pdup(b->eof);
d1293 1
a1293 1
	fprintf(f,"%s",STATE_ID);
@


1.88
log
@menu_above option
@
text
@d118 1
d587 1
a587 1
	} else if (!zcmp(s, US "bg_text")) {
d596 1
d600 1
a600 1
	} else if (!zcmp(s, US "bg_help")) {
d608 9
a616 1
	} else if (!zcmp(s, US "bg_menu")) {
d624 1
a624 1
	} else if (!zcmp(s, US "bg_prompt")) {
d632 1
a632 1
	} else if (!zcmp(s, US "bg_msg")) {
@


1.87
log
@File selection menu is now above prompt instead of below it.
@
text
@d124 1
d309 1
@


1.86
log
@Don't run editor if rc file is bad.
@
text
@d968 1
a968 1
	if (mkmenu(bw->parent, s, doopt, doabrt, NULL, optx, s, NULL))
@


1.85
log
@fix gcc-4.0.0 warnings
@
text
@d80 16
@


1.84
log
@Grep find improvements
@
text
@a11 1
#include <string.h>
d57 1
a57 1
		if (!strcmp(c->name, name))
d62 1
a62 1
	c->name = joe_strdup(name);
d75 1
a75 1
		if(!strcmp(c->name,name))
d234 1
a234 1
				if (pmatch(pieces,o->contents_regex,strlen((char *)o->contents_regex),p,0,0)) {
d415 1
a415 1
		if (!strcmp(glopts[x].name, s)) {
d431 1
a431 1
						*(unsigned char **) glopts[x].set = joe_strdup(arg);
d454 1
a454 1
								  options + glopts[x].ofst) = joe_strdup(arg);
d477 1
a477 1
					options->syntax_name = joe_strdup(arg);
d485 1
a485 1
					options->map_name = joe_strdup(arg);
d497 1
a497 1
	if (!strcmp(s, "lmsg")) {
d500 1
a500 1
				options->lmsg = joe_strdup(arg);
d504 1
a504 1
	} else if (!strcmp(s, "rmsg")) {
d507 1
a507 1
				options->rmsg = joe_strdup(arg);
d511 1
a511 1
	} else if (!strcmp(s, "keymap")) {
d519 1
a519 1
				options->context = joe_strdup(arg);
d523 1
a523 1
	} else if (!strcmp(s, "mnew")) {
d532 1
a532 1
	} else if (!strcmp(s, "mfirst")) {
d541 1
a541 1
	} else if (!strcmp(s, "mold")) {
d550 1
a550 1
	} else if (!strcmp(s, "msnew")) {
d559 1
a559 1
	} else if (!strcmp(s, "msold")) {
d568 1
a568 1
	} else if (!strcmp(s, "bg_text")) {
d580 1
a580 1
	} else if (!strcmp(s, "bg_help")) {
d588 1
a588 1
	} else if (!strcmp(s, "bg_menu")) {
d596 1
a596 1
	} else if (!strcmp(s, "bg_prompt")) {
d604 1
a604 1
	} else if (!strcmp(s, "bg_msg")) {
d649 1
a649 1
			*(unsigned char **) glopts[x].set = joe_strdup(s);
d652 1
a652 1
		*(unsigned char **)((unsigned char *)&bw->o+glopts[x].ofst) = joe_strdup(s);
d746 1
a746 1
						if (!strcmp(t[x],syntaxes[y]))
d938 1
a938 1
			strcpy((char *)(s[x]), (char *)glopts[x].menu);
d1013 1
a1013 1
				o->name_regex = joe_strdup(buf);
d1023 1
a1023 1
					o->contents_regex = joe_strdup(buf+1);
d1057 1
a1057 1
					if (!strcmp(buf + 1, "def")) {
d1079 1
a1079 1
					} else if (!strcmp(buf + 1, "inherit"))
d1093 1
a1093 1
					} else if (!strcmp(buf + 1, "include")) {
d1113 1
a1113 1
					} else if (!strcmp(buf + 1, "delete"))
d1230 1
a1230 1
	while(fgets((char *)buf,1023,f) && strcmp(buf,"done\n")) {
d1246 1
a1246 1
#define STATE_ID "# JOE state file v1.0\n"
d1299 1
a1299 1
	if (fgets((char *)buf,1024,f) && !strcmp((char *)buf,STATE_ID)) {
d1303 1
a1303 1
			if(!strcmp(buf,"search\n"))
d1305 1
a1305 1
			else if(!strcmp(buf,"macros\n"))
d1307 1
a1307 1
			else if(!strcmp(buf,"files\n"))
d1309 1
a1309 1
			else if(!strcmp(buf,"find\n"))
d1311 1
a1311 1
			else if(!strcmp(buf,"replace\n"))
d1313 1
a1313 1
			else if(!strcmp(buf,"run\n"))
d1315 1
a1315 1
			else if(!strcmp(buf,"build\n"))
d1317 1
a1317 1
			else if(!strcmp(buf,"grep\n"))
d1319 1
a1319 1
			else if(!strcmp(buf,"cmd\n"))
d1321 1
a1321 1
			else if(!strcmp(buf,"math\n"))
d1323 1
a1323 1
			else if(!strcmp(buf,"yank\n"))
d1326 1
a1326 1
				while(fgets((char *)buf,1023,f) && strcmp((char *)buf,"done\n"));
@


1.83
log
@Add search prompting for better jpico
@
text
@d1276 1
d1318 2
@


1.82
log
@XTerm hack.
@
text
@d108 1
d293 1
@


1.81
log
@Background color for screen item
@
text
@d107 1
d352 1
@


1.80
log
@Background color
@
text
@d102 5
a106 1
extern int bg_color;
d565 1
a565 1
	} else if (!strcmp(s, "bg_color")) {
d569 37
a605 1
			bg_color = meta_color(arg);
@


1.79
log
@Fix some resize window bugs, add 256 color support.
@
text
@d102 1
d561 8
@


1.78
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d101 1
d345 1
@


1.77
log
@hex edit mode
@
text
@d329 2
a330 2
	{US "floatmouse",	0, &floatmouse, 0, "Clicking can move the cursor past end of line", "Clicking past end of line moves cursor to the end", "  Click past end " },
	{US "rtbutton",	0, &rtbutton, 0, "Mouse action is done with the right button", "Mouse action is done with the left button", "  Right button " },
d1176 1
a1176 1
	while(fgets(buf,1023,f) && strcmp(buf,"done\n")) {
d1203 1
a1203 1
	joe_snprintf_1(stdbuf,stdsiz,"%s/.joe_state",home);
d1205 1
a1205 1
	f = fopen(stdbuf,"w");
d1238 2
a1239 2
	joe_snprintf_1(stdbuf,stdsiz,"%s/.joe_state",home);
	f = fopen(stdbuf,"r");
d1244 1
a1244 1
	if (fgets(buf,1024,f) && !strcmp(buf,STATE_ID)) {
d1247 1
a1247 1
		while(fgets(buf,1023,f)) {
d1269 1
a1269 1
				while(fgets(buf,1023,f) && strcmp(buf,"done\n"));
@


1.76
log
@Current directory stuff
@
text
@d147 1
d198 1
d275 1
@


1.75
log
@parse rc file only once
@
text
@d100 1
a100 1
extern int nolocks, nomodcheck;
d301 1
@


1.74
log
@Save file names from command line in state file
@
text
@d38 1
d986 1
a986 1
		case '{':	/* Ignore help text */
d988 1
a988 8
				while ((fgets((char *)buf, 256, fd)) && (buf[0] != '}'))
					++line;
				++line;
				if (buf[0] != '}') {
					err = 1;
					fprintf(stderr, "\n%s %d: End of joerc file occured before end of help text\n", name, line);
					break;
				}
@


1.73
log
@Get joe to compile on irix
@
text
@d1194 2
d1212 3
d1245 28
a1272 24
	/* Read state information */
	while(fgets(buf,1023,f)) {
		if(!strcmp(buf,"search\n"))
			load_srch(f);
		else if(!strcmp(buf,"macros\n"))
			load_macros(f);
		else if(!strcmp(buf,"files\n"))
			load_hist(f,&filehist);
		else if(!strcmp(buf,"find\n"))
			load_hist(f,&findhist);
		else if(!strcmp(buf,"replace\n"))
			load_hist(f,&replhist);
		else if(!strcmp(buf,"run\n"))
			load_hist(f,&runhist);
		else if(!strcmp(buf,"build\n"))
			load_hist(f,&buildhist);
		else if(!strcmp(buf,"cmd\n"))
			load_hist(f,&cmdhist);
		else if(!strcmp(buf,"math\n"))
			load_hist(f,&mathhist);
		else if(!strcmp(buf,"yank\n"))
			load_yank(f);
		else { /* Unknown... skip until next done */
			while(fgets(buf,1023,f) && strcmp(buf,"done\n"));
@


1.72
log
@Fix ~ expansion insanity
@
text
@d94 1
a94 1
extern int noxon, lines, staen, columns, Baud, dopadding, orphan, marking, beep, keepup, nonotice;
d303 1
a303 1
	{US "beep",	0, &beep, NULL, US "Warning bell enabled", US "Warning bell disabled", US "Beeps " },
@


1.71
log
@Fix line number accounting for joerc files.
Check if system joerc file is newer than home directory one.
@
text
@d776 1
a776 1
		if(wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
d788 1
a788 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
d802 1
a802 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
d816 1
a816 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
d825 1
a825 1
		if (wmkpw(bw->parent, buf, NULL, dosyntax, NULL, NULL, syntaxcmplt, NULL, notify, locale_map))
d834 1
a834 1
		if (wmkpw(bw->parent, buf, NULL, doencoding, NULL, NULL, encodingcmplt, NULL, notify, locale_map))
@


1.70
log
@File changed check.
@
text
@d988 2
a989 1
					/* do nothing */;
d1101 1
@


1.69
log
@Add -break_links option.
@
text
@d99 1
a99 1
extern int nolocks;
d299 1
@


1.68
log
@Perforce macro and support for it.
@
text
@d96 1
a96 1
extern int menu_jump;
d299 1
@


1.67
log
@make locking optional
@
text
@d151 1
d197 1
a197 1
	NULL, NULL, NULL, NULL	/* macros (see above) */
d515 9
@


1.66
log
@Allow colors to controlled from joerc file
@
text
@d99 1
d297 1
@


1.65
log
@Accept buffer overflow patch.
@
text
@d923 7
@


1.64
log
@jpico fix
@
text
@d900 2
a901 1
	strcpy((char *)buf, (char *)name);
@


1.63
log
@option for mouse support
use \ for escape in joe_state
@
text
@d273 1
a273 1
	{US "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, US "Left margin (%d): ", 0, US "Left margin ", 0, 0, 63 },
@


1.62
log
@Fix syntax file warnings.
Add -jump_menu
@
text
@d97 1
d331 1
@


1.61
log
@Fix keymap command.  Add name command.
@
text
@d96 1
d277 2
a278 1
	{US "menu_explorer",	0, &menu_explorer, NULL, US "Menu explorer mode", US "  Simple completion", US "  Menu explorer " },
@


1.60
log
@Jesse McGrew's xterm mouse support.
@
text
@d80 10
@


1.59
log
@Fix perl highlighter bug, enhance ^G
@
text
@d24 1
d67 13
d306 2
@


1.58
log
@Fix type-o in rc.c
@
text
@d113 7
d162 7
d285 7
d400 11
d548 3
d724 13
d834 1
@


1.57
log
@Clean up .joe_state file stuff some more.
@
text
@d230 1
a230 1
	{US "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, US "Autoindent enabled", US "Autindent disabled", US "I Autoindent " },
@


1.56
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@d1080 4
a1083 2
		binsm(q,bf,len);
		pset(q,b->eof);
@


1.55
log
@Fix -pedantic warnings.
@
text
@d33 4
d74 3
d253 1
d1027 137
@


1.54
log
@Now it will use sprintf if snprintf does not exist.
Can now build on IRIX 6.2
@
text
@d57 1
a57 1
	c->name = (unsigned char *)strdup((char *)name);
d352 1
a352 1
						*(unsigned char **) glopts[x].set = (unsigned char *)strdup((char *)arg);
d387 1
a387 1
					options->syntax_name = (unsigned char *)strdup((char *)arg);
d395 1
a395 1
					options->map_name = (unsigned char *)strdup((char *)arg);
d410 1
a410 1
				options->lmsg = (unsigned char *)strdup((char *)arg);
d417 1
a417 1
				options->rmsg = (unsigned char *)strdup((char *)arg);
d429 1
a429 1
				options->context = (unsigned char *)strdup((char *)arg);
d506 1
a506 1
			*(unsigned char **) glopts[x].set = (unsigned char *)strdup((char *)s);
d845 1
a845 1
				o->name_regex = (unsigned char *)strdup((char *)buf);
d855 1
a855 1
					o->contents_regex = (unsigned char *)strdup((char *)(buf+1));
@


1.53
log
@Fix segfault due to bad management of 'pieces' in rc/setopt().
@
text
@d594 1
a594 1
			snprintf((char *)buf,sizeof(buf),"%s/.joe/syntax",p);
d627 1
a627 1
		snprintf((char *)msgbuf, JOE_MSGBUFSIZE, "%s encoding assumed for this file", map->name);
d682 1
a682 1
		snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *glopts[x].set);
d694 1
a694 1
			snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(unsigned char **) glopts[x].set);
d696 1
a696 1
			snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d707 1
a707 1
		snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d710 1
a710 1
		snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d722 1
a722 1
		snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d731 1
a731 1
		snprintf((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d770 1
a770 1
			snprintf((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *glopts[x].set ? "ON" : "OFF");
d773 1
a773 1
			snprintf((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *glopts[x].set);
d781 1
a781 1
			snprintf((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d784 1
a784 1
			snprintf((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d787 1
a787 1
			snprintf((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
@


1.52
log
@Now we understand aliases for character maps, like latin1 ->
iso-8859-1 and 8859-1 -> iso-8859-1.
@
text
@a175 2
					for (x = 0; x != 26; ++x)
						vsrm(pieces[x]);
d179 1
a179 1
					return;
a180 2
					for (x = 0; x != 26; ++x)
						vsrm(pieces[x]);
d186 1
a186 1
				return;
d189 1
d192 4
@


1.51
log
@Smart indent and backspace now work even if cursor
is not right at indentation point.  Also autoindent
does not happen if cursor is on a space or tab character.

Jmacs: ^W (cut) now works if mark is after point.  (Added -autoswap
mode).  Also: preserve mark and point positions during block
operations.
@
text
@d624 1
a624 1
	if (map)
d626 3
a628 1
	else
@


1.50
log
@Fix -syntax and -encoding on command line.

Check for "pty.h" when openpty is used.
@
text
@d67 1
a67 1
extern int notite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer, icase, wrap;
d230 2
a231 1
	{US "menu_explorer",	0, &menu_explorer, NULL, US "Menu explorer mode", US "Simple completion", US "  Menu explorer " },
@


1.49
log
@Added -wrap flag so that search wraps.
@
text
@d384 2
a385 1
				options->syntax_name = (unsigned char *)strdup((char *)arg);
d392 2
a393 1
				options->map_name = (unsigned char *)strdup((char *)arg);
@


1.48
log
@Added -icase: make search case insensitive by default.
@
text
@d67 1
a67 1
extern int notite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer, icase;
d229 1
@


1.47
log
@joe a b c, now windows are in order a, b, c.

TAB completion now works on last path in prompt window:
for example '!ls foo', tab will complete the foo.

Added menu_explorer option.  When set: menu stays up when
a directory is seleted.  When clear: directory is added
to path and menu is closed.

Menus are now 40% of window size (or smaller if they are
not filled).

Cursor is now position after selected menu entry.
@
text
@d67 1
a67 1
extern int notite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer;
d228 1
@


1.46
log
@Ctrl-<space> drops anchor and turns on marking mode.
@
text
@d67 1
a67 1
extern int notite, usetabs, assume_color, guesscrlf, guessindent;
d228 1
@


1.45
log
@Can now parse charmap files.
@
text
@d239 1
a239 1
	{US "asis",	0, &dspasis, NULL, US "Characters above 127 shown as-is", US "Characters above 127 shown in inverse", US "Meta chars as-is " },
@


1.44
log
@Checks ~/.joe/syntax for syntax files.
Applied new Selinux patch.
@
text
@d597 1
a597 1
						vaadd(syntaxes,r);
@


1.43
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d562 1
d564 1
d582 22
a604 1
		varm(t);
@


1.42
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d99 2
a100 3
	0,		/* UTF-8 */
	NULL,		/* Name of byte mode character set */
	NULL,		/* Byte mode character set */
d141 2
a142 3
	0,		/* UTF-8 */
	NULL,		/* Name of byte mode character set */
	NULL,		/* Byte mode character set */
a236 1
	{US "utf8",	4, NULL, (unsigned char *) &fdefault.utf8, US "UTF-8 encoding enabled", US "UTF-8 encoding disabled", US "U UTF-8 " },
d257 1
a257 1
	{US "encoding",13, NULL, NULL, US "Select byte-mode character set (^C to abort): ", 0, US "Encoding " },
d418 1
a418 1
			for (y = 0; !joe_isspace(arg[y]); ++y) ;
d580 1
d614 1
d656 1
a656 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, -1))
d670 1
a670 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, -1))
d684 1
a684 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, -1))
d693 1
a693 1
		if (wmkpw(bw->parent, buf, NULL, dosyntax, NULL, NULL, syntaxcmplt, NULL, notify, -1))
d702 1
a702 1
		if (wmkpw(bw->parent, buf, NULL, doencoding, NULL, NULL, encodingcmplt, NULL, notify, -1))
d859 1
a859 1
				for (x = 1; !isspace_eof(buf[x]); ++x) ;
d866 2
a867 2
						for (buf[x] = c; joe_isblank(buf[x]); ++x) ;
						for (y = x; !isspace_eof(buf[y]); ++y) ;
d874 1
a874 1
							if (joe_isblank(c)
d887 2
a888 2
							for (buf[x] = c; joe_isblank(buf[x]); ++x) ;
							for (c = x; !isspace_eof(buf[c]); ++c) ;
d900 2
a901 2
						for (buf[x] = c; joe_isblank(buf[x]); ++x) ;
						for (c = x; !isspace_eof(buf[c]); ++c) ;
d923 1
a923 1
							for (buf[x] = c; joe_isblank(buf[x]); ++x) ;
@


1.41
log
@Elimiante --pedantic warnings.
@
text
@a11 1
#include <ctype.h>
d31 2
d100 2
d143 2
d158 3
d246 1
a246 1
	{US "exask",	0, &exask, NULL, US "Prompt for filename in save & exit command", US "Don't prompt for filename in save & exit command", US "Exit ask " },
d260 1
d389 4
d421 1
a421 1
			for (y = 0; !isspace(arg[y]); ++y) ;
a550 1
	bw->o.syntax = syn;
d589 31
d698 9
d746 1
@


1.40
log
@Improve Fortran again.

Added '-indentfirst' option to control
how smarthome works.

Now syntax files are loaded as needed.

New version of automake and autoconf

Print UTF-8 (c) if terminal is utf-8.
@
text
@d556 1
a556 1
		t = rexpnd("*.jsf");
d729 1
a729 1
	strcpy(buf, name);
@


1.39
log
@Prepare for release
@
text
@d96 1
d100 1
d137 1
d141 1
d148 7
d174 1
d183 1
d188 1
d246 1
d375 2
d378 1
a378 1
					options->syntax = load_dfa(arg);
d538 1
@


1.38
log
@Fixed uopen() ^] for overtype mode.

Added 'istrings' option in syntax files for ignoring case
in strings.

Added ^T Y- allows you to select syntax during run time (tab
completion works too!)

Added ^T P- picture mode: can move and type anywhere on the screen,
good for drawing ASCII art.
@
text
@d66 1
a66 1
extern int notite, usetabs, assume_color;
d214 2
@


1.37
log
@Added -purify option.
@
text
@d31 1
d101 1
d140 1
d232 3
a234 1
	{US "backpath",	2, (int *) &backpath, NULL, US "Backup files stored in (%s): ", 0, US "Path to backup files " },
d356 5
d362 1
a432 7
	} else if (!strcmp(s, "syntax")) {
		if (arg) {
			if (options)
				options->syntax = load_dfa(arg);
			ret = 2;
		} else
			ret = 1;
d506 51
d626 9
d664 1
a664 1
		s[x] = (unsigned char *) joe_malloc(40);		/* FIXME: why 40 ??? */
d673 1
@


1.36
log
@Added 'smartbacks' option.
@
text
@d99 1
d137 1
d227 2
a228 1
	{US "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, US "Smart backspace key enabled", US "Smart backspace key disabled", US "  Smart backspace key " },
@


1.35
log
@Applied David Phillips' smart home key patch.

Changed  ` u to ` x.
@
text
@d98 1
d135 1
d225 1
@


1.34
log
@UTF-8 now supported in file names and prompts.

Search should be partially working.  \+ with
a UTF-8 character following is broken and
\[ ] only works for bytes.
@
text
@d97 1
d133 1
d222 1
@


1.33
log
@Fixed bug where '-syntax' on command line had
no effect.

Now if terminal is UTF-8, the default file type
is assumed to be UTF-8.
@
text
@d530 1
a530 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
d544 1
a544 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
d558 1
a558 1
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
@


1.32
log
@Fix syntax definition file loader so that you don't
get seg faults when you refer to a state which doesn't
exist.

Fix outatr() to work with non-UTF-8 character sets again.
Need to start thinking about iconv().

Mess with option strings to make ^T look nicer: no longer
four columns in 80 character terminal windows.

Got rid of yellow selection bar from ^T.
@
text
@d30 1
d61 4
a64 1
extern int mid, dspasis, dspctrl, force, help, pgamnt, square, csmode, nobackups, lightoff, exask, skiptop, noxon, lines, staen, columns, Baud, dopadding, orphan, marking, beep, keepup, nonotice;
d68 2
d102 3
d136 1
d168 5
d181 1
a181 1
				   7 for local option numeric+1
d236 2
d256 18
a273 1
/* Set a global or local option 
d275 1
d280 1
a280 1
	int st = 1;
d283 1
d286 2
d292 1
d296 1
a296 1
			case 0:
d300 1
a300 1
			case 1:
d307 1
a307 1
			case 2:
d315 1
a315 1
			case 4:
a317 2
				else if (set == 2)
					*(int *) ((unsigned char *) &fdefault + glopts[x].ofst) = st;
d319 1
a319 1
			case 5:
d326 1
a326 6
					} else if (set == 2) {
						sscanf((char *)arg, "%d", &val);
						if (val >= glopts[x].low && val <= glopts[x].high)
							*(int *) ((unsigned char *)
								  &fdefault + glopts[x].ofst) = val;
					}
d329 1
a329 1
			case 7:
a338 3
						else if (set == 2)
							*(int *) ((unsigned char *)
								  &fdefault + glopts[x].ofst) = zz;
d348 3
a354 2
			else if (set == 2)
				fdefault.lmsg = (unsigned char *)strdup((char *)arg);
a361 2
			else if (set == 2)
				fdefault.rmsg = (unsigned char *)strdup((char *)arg);
a382 2
			else if (set == 2)
				fdefault.mnew = mparse(NULL, arg, &sta);
a391 2
			else if (set == 2)
				fdefault.mold = mparse(NULL, arg, &sta);
a400 2
			else if (set == 2)
				fdefault.msnew = mparse(NULL, arg, &sta);
a409 2
			else if (set == 2)
				fdefault.msold = mparse(NULL, arg, &sta);
d416 1
a416 3
				options->syntax = (unsigned char *)strdup((char *)arg);
			else if (set == 2)
				fdefault.syntax = (unsigned char *)strdup((char *)arg);
d425 3
a427 1
static int optx = 0;
a619 1

d628 1
a628 1
	OPTIONS *o = NULL;	/* Current options */
d676 1
a676 1
				if(o)
d768 1
a768 1
							o = 0;
@


1.31
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@d184 3
a186 3
	{US "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, US "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", 0, US " Indent char ", 0, 0, 255 },
	{US "istep",	5, NULL, (unsigned char *) &fdefault.istep, US "Indent step %d (^C to abort): ", 0, US " Indent step ", 0, 1, 64 },
	{US "french",	4, NULL, (unsigned char *) &fdefault.french, US "One space after periods for paragraph reformat", US "Two spaces after periods for paragraph reformat", US " french spacing " },
d188 1
a188 1
	{US "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, US "Inserting spaces when tab key is hit", US "Inserting tabs when tab key is hit", US " no tabs " },
d196 1
a196 1
	{US "nobackups",	0, &nobackups, NULL, US "Backup files will not be made", US "Backup files will be made", US " Disable backups " },
d200 3
a202 3
	{US "nosta",	0, &staen, NULL, US "Top-most status line disabled", US "Top-most status line enabled", US " Disable status line " },
	{US "keepup",	0, &keepup, NULL, US "Status line updated constantly", US "Status line updated once/sec", US " Fast status line " },
	{US "pg",		1, &pgamnt, NULL, US "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, US " No. PgUp/PgDn lines ", 0, -1, 64 },
@


1.30
log
@Added -assume_color global option.
@
text
@d701 1
a701 1
						for (buf[x] = c; isblank(buf[x]); ++x) ;
d709 1
a709 1
							if (isblank(c)
d722 1
a722 1
							for (buf[x] = c; isblank(buf[x]); ++x) ;
d735 1
a735 1
						for (buf[x] = c; isblank(buf[x]); ++x) ;
d758 1
a758 1
							for (buf[x] = c; isblank(buf[x]); ++x) ;
@


1.29
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d61 1
a61 1
extern int notite, usetabs;
d217 1
@


1.28
log
@Initial check-in of UTF-8 support (^T U).  JOE is likely to have many bugs
at this point.
@
text
@d36 1
a36 1
	char *name;
d54 1
a54 1
	c->name = strdup(name);
d61 2
a62 1
extern char *backpath;
d108 3
a110 3
	"main",		/* *context */
	"\\i%n %m %M",	/* *lmsg */
	" %S Ctrl-K H for help",	/* *rmsg */
d127 1
a127 1
void setopt(B *b, char *parsed_name)
d131 1
a131 1
	char *pieces[26];
d139 1
a139 1
				if (pmatch(pieces,o->contents_regex,strlen(o->contents_regex),p,0,0)) {
d159 1
a159 1
	char *name;		/* Option name */
d169 4
a172 4
	char *addr;		/* Local options structure member address */
	char *yes;		/* Message if option was turned on, or prompt string */
	char *no;		/* Message if option was turned off */
	char *menu;		/* Menu string */
d177 40
a216 38
	{ "overwrite",	4, NULL, (char *) &fdefault.overtype, "Overtype mode", "Insert mode", "T Overtype " },
	{ "autoindent",	4, NULL, (char *) &fdefault.autoindent, "Autoindent enabled", "Autindent disabled", "I Autoindent " },
	{ "wordwrap",	4, NULL, (char *) &fdefault.wordwrap, "Wordwrap enabled", "Wordwrap disabled", "Word wrap " },
	{ "tab",	5, NULL, (char *) &fdefault.tab, "Tab width (%d): ", 0, "D Tab width ", 0, 1, 64 },
	{ "lmargin",	7, NULL, (char *) &fdefault.lmargin, "Left margin (%d): ", 0, "Left margin ", 0, 0, 63 },
	{ "rmargin",	7, NULL, (char *) &fdefault.rmargin, "Right margin (%d): ", 0, "Right margin ", 0, 7, 255 },
	{ "square",	0, &square, NULL, "Rectangle mode", "Text-stream mode", "X Rectangle mode " },
	{ "indentc",	5, NULL, (char *) &fdefault.indentc, "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", 0, " Indent char ", 0, 0, 255 },
	{ "istep",	5, NULL, (char *) &fdefault.istep, "Indent step %d (^C to abort): ", 0, " Indent step ", 0, 1, 64 },
	{ "french",	4, NULL, (char *) &fdefault.french, "One space after periods for paragraph reformat", "Two spaces after periods for paragraph reformat", " french spacing " },
	{ "highlight",	4, NULL, (char *) &fdefault.highlight, "Highlighting enabled", "Highlighting disabled", "Highlighting " },
	{ "spaces",	4, NULL, (char *) &fdefault.spaces, "Inserting spaces when tab key is hit", "Inserting tabs when tab key is hit", " no tabs " },
	{ "mid",	0, &mid, NULL, "Cursor will be recentered on scrolls", "Cursor will not be recentered on scroll", "Center on scroll " },
	{ "crlf",	4, NULL, (char *) &fdefault.crlf, "CR-LF is line terminator", "LF is line terminator", "Z CR-LF (MS-DOS) " },
	{ "utf8",	4, NULL, (char *) &fdefault.utf8, "UTF-8 encoding enabled", "UTF-8 encoding disabled", "U UTF-8 " },
	{ "linums",	4, NULL, (char *) &fdefault.linums, "Line numbers enabled", "Line numbers disabled", "N Line numbers " },
	{ "marking",	0, &marking, NULL, "Anchored block marking on", "Anchored block marking off", "Marking " },
	{ "asis",	0, &dspasis, NULL, "Characters above 127 shown as-is", "Characters above 127 shown in inverse", "Meta chars as-is " },
	{ "force",	0, &force, NULL, "Last line forced to have NL when file saved", "Last line not forced to have NL", "Force last NL " },
	{ "nobackups",	0, &nobackups, NULL, "Backup files will not be made", "Backup files will be made", " Disable backups " },
	{ "lightoff",	0, &lightoff, NULL, "Highlighting turned off after block operations", "Highlighting not turned off after block operations", "Auto unmark " },
	{ "exask",	0, &exask, NULL, "Prompt for filename in save & exit command", "Don't prompt for filename in save & exit command", "Exit ask " },
	{ "beep",	0, &beep, NULL, "Warning bell enabled", "Warning bell disabled", "Beeps " },
	{ "nosta",	0, &staen, NULL, "Top-most status line disabled", "Top-most status line enabled", " Disable status line " },
	{ "keepup",	0, &keepup, NULL, "Status line updated constantly", "Status line updated once/sec", " Fast status line " },
	{ "pg",		1, &pgamnt, NULL, "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, " No. PgUp/PgDn lines ", 0, -1, 64 },
	{ "csmode",	0, &csmode, NULL, "Start search after a search repeats previous search", "Start search always starts a new search", "Continued search " },
	{ "rdonly",	4, NULL, (char *) &fdefault.readonly, "Read only", "Full editing", "O Read only " },
	{ "backpath",	2, (int *) &backpath, NULL, "Backup files stored in (%s): ", 0, "Path to backup files " },
	{ "nonotice",	0, &nonotice, NULL, 0, 0, 0 },
	{ "noxon",	0, &noxon, NULL, 0, 0, 0 },
	{ "orphan",	0, &orphan, NULL, 0, 0, 0 },
	{ "help",	0, &help, NULL, 0, 0, 0 },
	{ "dopadding",	0, &dopadding, NULL, 0, 0, 0 },
	{ "lines",	1, &lines, NULL, 0, 0, 0, 0, 2, 1024 },
	{ "baud",	1, &Baud, NULL, 0, 0, 0, 0, 50, 32767 },
	{ "columns",	1, &columns, NULL, 0, 0, 0, 0, 2, 1024 },
	{ "skiptop",	1, &skiptop, NULL, 0, 0, 0, 0, 0, 64 },
d233 1
a233 1
			glopts[x].ofst = glopts[x].addr - (char *) &fdefault;
d262 1
a262 1
					sscanf(arg, "%d", &val);
d270 1
a270 1
						*(char **) glopts[x].set = strdup(arg);
d272 1
a272 1
						*(char **) glopts[x].set = 0;
d277 1
a277 1
					*(int *) ((char *) options + glopts[x].ofst) = st;
d279 1
a279 1
					*(int *) ((char *) &fdefault + glopts[x].ofst) = st;
d284 1
a284 1
						sscanf(arg, "%d", &val);
d286 1
a286 1
							*(int *) ((char *)
d289 1
a289 1
						sscanf(arg, "%d", &val);
d291 1
a291 1
							*(int *) ((char *)
d300 1
a300 1
					sscanf(arg, "%d", &zz);
d304 1
a304 1
							*(int *) ((char *)
d307 1
a307 1
							*(int *) ((char *)
d321 1
a321 1
				options->lmsg = strdup(arg);
d323 1
a323 1
				fdefault.lmsg = strdup(arg);
d330 1
a330 1
				options->rmsg = strdup(arg);
d332 1
a332 1
				fdefault.rmsg = strdup(arg);
d344 1
a344 1
				options->context = strdup(arg);
d395 1
a395 1
				options->syntax = strdup(arg);
d397 1
a397 1
				fdefault.syntax = strdup(arg);
d414 1
a414 1
static int doopt1(BW *bw, char *s, int *xx, int *notify)
d430 1
a430 1
			msgnw(bw->parent, "Value out of range");
d436 1
a436 1
			*(char **) glopts[x].set = strdup(s);
d444 1
a444 1
			*(int *) ((char *) &bw->o + glopts[x].ofst) = v;
d446 1
a446 1
			msgnw(bw->parent, "Value out of range");
d456 1
a456 1
			*(int *) ((char *) &bw->o + glopts[x].ofst) = v;
d458 1
a458 1
			msgnw(bw->parent, "Value out of range");
d476 1
a476 1
	char buf[OPT_BUF_SIZE];
d492 1
a492 1
			*(int *) ((char *) &bw->o + glopts[x].ofst) = !*(int *) ((char *) &bw->o + glopts[x].ofst);
d494 1
a494 1
			*(int *) ((char *) &bw->o + glopts[x].ofst) = 1;
d496 1
a496 1
			*(int *) ((char *) &bw->o + glopts[x].ofst) = 0;
d498 2
a499 2
		msgnw(bw->parent, *(int *) ((char *) &bw->o + glopts[x].ofst) ? glopts[x].yes : glopts[x].no);
		if (glopts[x].ofst == (char *) &fdefault.readonly - (char *) &fdefault)
d503 1
a503 1
		snprintf(buf, OPT_BUF_SIZE, glopts[x].yes, *glopts[x].set);
d514 2
a515 2
		if (*(char **) glopts[x].set)
			snprintf(buf, OPT_BUF_SIZE, glopts[x].yes, *(char **) glopts[x].set);
d517 1
a517 1
			snprintf(buf, OPT_BUF_SIZE, glopts[x].yes, "");
d528 1
a528 1
		snprintf(buf, OPT_BUF_SIZE, glopts[x].yes, *(int *) ((char *) &bw->o + glopts[x].ofst));
d531 1
a531 1
		snprintf(buf, OPT_BUF_SIZE, glopts[x].yes, *(int *) ((char *) &bw->o + glopts[x].ofst) + 1);
d550 1
a550 1
static int doabrt(MENU *m, int x, char **s)
d562 1
a562 1
	char **s;
d567 1
a567 1
	s = (char **) joe_malloc(sizeof(char *) * (size + 1));
d570 1
a570 1
		s[x] = (char *) joe_malloc(40);		/* FIXME: why 40 ??? */
d573 1
a573 1
			snprintf(s[x], OPT_BUF_SIZE, "%s%s", glopts[x].menu, *glopts[x].set ? "ON" : "OFF");
d576 1
a576 1
			snprintf(s[x], OPT_BUF_SIZE, "%s%d", glopts[x].menu, *glopts[x].set);
d579 1
a579 1
			strcpy(s[x], glopts[x].menu);
d582 1
a582 1
			snprintf(s[x], OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *) ((char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d585 1
a585 1
			snprintf(s[x], OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((char *) &bw->o + glopts[x].ofst));
d588 1
a588 1
			snprintf(s[x], OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((char *) &bw->o + glopts[x].ofst) + 1);
d617 1
a617 1
	fd = fopen(buf, "rt");
d619 1
a619 1
	fd = fopen(buf, "r");
d628 1
a628 1
	while (fgets(buf, sizeof(buf), fd)) {
d647 1
a647 1
				o->name_regex = strdup(buf);
d657 1
a657 1
					o->contents_regex = strdup(buf+1);
d680 1
a680 1
				while ((fgets(buf, 256, fd)) && (buf[0] != '}'))
d792 1
a792 1
					fgets(buf, 1024, fd);
@


1.27
log
@Fix screen update bug introduced with Apr 7th change.

Option settings now can be based on file contents as well as
file name.

Added syntax indicator for status line.
@
text
@d89 1
d121 1
d190 1
@


1.26
log
@Clean up meaning of default color.

Allow syntax to be specified in joerc file: "-syntax perl"

Add class definitions to syntax files.

Add perl and verilog definitions (they need work).

Change joerc to assume files with . in their name do not want word
wrap enabled (except for .txt).
@
text
@d29 1
d65 2
a66 1
	NULL,		/* *name */
d96 2
a97 1
	NULL,		/* *name */
d123 2
a124 6
/* Set a global or local option 
 * returns 0 for no such option,
 *         1 for option accepted
 *         2 for option + argument accepted
 */
void setopt(OPTIONS *n, char *name)
d127 4
d133 18
a150 3
		if (rmatch(o->name, name)) {
			*n = *o;
			return;
d152 1
a152 1
	*n = fdefault;
d232 2
d641 11
a651 1
				o->name = strdup(buf);
@


1.25
log
@Syntax highlighting baby steps.
@
text
@d86 1
d116 1
d366 9
@


1.24
log
@fix typos
@
text
@d85 1
d114 1
d164 1
@


1.23
log
@change 0 to NULL where we're talking about pointers
@
text
@d168 1
a168 1
	{ "force",	0, &force, NULL, "Last line forced to have NL when file saved", "Last line not forces to have NL", "Force last NL " },
@


1.22
log
@change type of variables holding string to unsigned char *
@
text
@d37 1
a37 1
} *contexts = 0;		/* List of named contexts */
d58 1
a58 1
OPTIONS *options = 0;
d568 2
a569 2
	OPTIONS *o = 0;		/* Current options */
	KMAP *context = 0;	/* Current context */
d614 1
a614 1
				unsigned char *arg = 0;
@


1.21
log
@eliminate "expr, expr"; change "magic number" to the sizeof()
@
text
@d43 1
a43 1
KMAP *kmap_getcontext(char *name)
d209 1
a209 1
int glopt(char *s, char *arg, OPTIONS *options, int set)
d566 1
a566 1
int procrc(CAP *cap, char *name)
@


1.20
log
@rename getcontext() to kmap_getcontext() to prevent conflict with glibc
@
text
@d588 2
a589 1
	while (++line, fgets(buf, 1024, fd))
d760 1
@


1.19
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d43 1
a43 1
KMAP *getcontext(char *name)
d674 1
a674 1
								kcpy(context, getcontext(buf + x));
d715 1
a715 1
						context = getcontext(buf + 1);
@


1.18
log
@kill some warnings when compiled with -Wall
@
text
@d218 4
a221 2
	if (s[0] == '-')
		st = 0, ++s;
d405 4
a408 2
		else
			msgnw(bw->parent, "Value out of range"), ret = -1;
d417 4
a420 2
		else
			msgnw(bw->parent, "Value out of range"), ret = -1;
@


1.17
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d441 1
a441 1
		uabort(m, MAXINT);
d451 1
a451 1
		uabort(m, MAXINT);
d462 1
a462 1
		uabort(m, MAXINT);
d476 1
a476 1
		uabort(m, MAXINT);
d490 1
a490 1
		uabort(m, MAXINT);
@


1.16
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d387 4
a390 2
		else
			msgnw(bw->parent, "Value out of range"), ret = -1;
@


1.15
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d50 1
a50 1
	c = (struct context *) malloc(sizeof(struct context));
d368 1
a368 1
	free(xx);
d378 1
a378 1
	free(xx);
d456 1
a456 1
		xx = (int *) malloc(sizeof(int));
d470 1
a470 1
		xx = (int *) malloc(sizeof(int));
d484 1
a484 1
	      in:xx = (int *) malloc(sizeof(int));
d506 2
a507 2
		free(s[x]);
	free(s);
d519 1
a519 1
	s = (char **) malloc(sizeof(char *) * (size + 1));
d522 1
a522 1
		s[x] = (char *) malloc(40);
d592 1
a592 1
				o = (OPTIONS *) malloc(sizeof(OPTIONS));
@


1.14
log
@change indentation of pdefault, fdefault and glopts arrays
@
text
@d209 1
a209 1
int glopt(char *s, char *arg, OPTIONS * options, int set)
d366 1
a366 1
static int doabrt1(BW * bw, int *xx)
d372 1
a372 1
static int doopt1(BW * bw, char *s, int *xx, int *notify)
d424 1
a424 1
static int doopt(MENU * m, int x, void *object, int flg)
d502 1
a502 1
static int doabrt(MENU * m, int x, char **s)
d511 1
a511 1
int umode(BW * bw)
d558 1
a558 1
int procrc(CAP * cap, char *name)
@


1.13
log
@change indentation of cases in the switch() statement
@
text
@d62 18
d81 8
a88 6
OPTIONS pdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,

	0
};
OPTIONS fdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
	" %S Ctrl-K H for help", 0, 0, 0, 0, 1, 0, 0, 0, 0
d90 20
d111 3
a113 6
OPTIONS pdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

	0
};
OPTIONS fdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
	" %S Ctrl-K H for help", 0, 0, 0, 0, 0, 0, 0, 0, 0
a114 1
#endif
d116 6
a121 1
void setopt(OPTIONS * n, char *name)
a132 6
/* Set a global or local option 
 * returns 0 for no such option,
 *         1 for option accepted
 *         2 for option + argument accepted
 */

d152 37
a188 75

	{
	"overwrite", 4, 0, (char *) &fdefault.overtype, "Overtype mode", "Insert mode", "T Overtype "}
	, {
	"autoindent", 4, 0, (char *) &fdefault.autoindent, "Autoindent enabled", "Autindent disabled", "I Autoindent "}
	, {
	"wordwrap", 4, 0, (char *) &fdefault.wordwrap, "Wordwrap enabled", "Wordwrap disabled", "Word wrap "}
	, {
	"tab", 5, 0, (char *) &fdefault.tab, "Tab width (%d): ", 0, "D Tab width ", 0, 1, 64}
	, {
	"lmargin", 7, 0, (char *) &fdefault.lmargin, "Left margin (%d): ", 0, "Left margin ", 0, 0, 63}
	, {
	"rmargin", 7, 0, (char *) &fdefault.rmargin, "Right margin (%d): ", 0, "Right margin ", 0, 7, 255}
	, {
	"square", 0, &square, 0, "Rectangle mode", "Text-stream mode", "X Rectangle mode "}
	, {
	"indentc", 5, 0, (char *) &fdefault.indentc, "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", 0, " Indent char ", 0, 0, 255}
	, {
	"istep", 5, 0, (char *) &fdefault.istep, "Indent step %d (^C to abort): ", 0, " Indent step ", 0, 1, 64}
	, {
	"french", 4, 0, (char *) &fdefault.french, "One space after periods for paragraph reformat", "Two spaces after periods for paragraph reformat", " french spacing "}
	, {
	"spaces", 4, 0, (char *) &fdefault.spaces, "Inserting spaces when tab key is hit", "Inserting tabs when tab key is hit", " no tabs "}
	, {
	"mid", 0, &mid, 0, "Cursor will be recentered on scrolls", "Cursor will not be recentered on scroll", "Center on scroll "}
	, {
	"crlf", 4, 0, (char *) &fdefault.crlf, "CR-LF is line terminator", "LF is line terminator", "Z CR-LF (MS-DOS) "}
	, {
	"linums", 4, 0, (char *) &fdefault.linums, "Line numbers enabled", "Line numbers disabled", "N Line numbers "}
	, {
	"marking", 0, &marking, 0, "Anchored block marking on", "Anchored block marking off", "Marking "}
	, {
	"asis", 0, &dspasis, 0, "Characters above 127 shown as-is", "Characters above 127 shown in inverse", "Meta chars as-is "}
	, {
	"force", 0, &force, 0, "Last line forced to have NL when file saved", "Last line not forces to have NL", "Force last NL "}
	, {
	"nobackups", 0, &nobackups, 0, "Backup files will not be made", "Backup files will be made", " Disable backups "}
	, {
	"lightoff", 0, &lightoff, 0, "Highlighting turned off after block operations", "Highlighting not turned off after block operations", "Auto unmark "}
	, {
	"exask", 0, &exask, 0, "Prompt for filename in save & exit command", "Don't prompt for filename in save & exit command", "Exit ask "}
	, {
	"beep", 0, &beep, 0, "Warning bell enabled", "Warning bell disabled", "Beeps "}
	, {
	"nosta", 0, &staen, 0, "Top-most status line disabled", "Top-most status line enabled", " Disable status line "}
	, {
	"keepup", 0, &keepup, 0, "Status line updated constantly", "Status line updated once/sec", " Fast status line "}
	, {
	"pg", 1, &pgamnt, 0, "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, " No. PgUp/PgDn lines ", 0, -1, 64}
	, {
	"csmode", 0, &csmode, 0, "Start search after a search repeats previous search", "Start search always starts a new search", "Continued search "}
	, {
	"rdonly", 4, 0, (char *) &fdefault.readonly, "Read only", "Full editing", "O Read only "}
	, {
	"backpath", 2, (int *) &backpath, 0, "Backup files stored in (%s): ", 0, "Path to backup files "}
	, {
	"nonotice", 0, &nonotice, 0, 0, 0, 0}
	, {
	"noxon", 0, &noxon, 0, 0, 0, 0}
	, {
	"orphan", 0, &orphan, 0, 0, 0, 0}
	, {
	"help", 0, &help, 0, 0, 0, 0}
	, {
	"dopadding", 0, &dopadding, 0, 0, 0, 0}
	, {
	"lines", 1, &lines, 0, 0, 0, 0, 0, 2, 1024}
	, {
	"baud", 1, &Baud, 0, 0, 0, 0, 0, 50, 32767}
	, {
	"columns", 1, &columns, 0, 0, 0, 0, 0, 2, 1024}
	, {
	"skiptop", 1, &skiptop, 0, 0, 0, 0, 0, 0, 64}
	, {
	0, 0, 0}
@


1.12
log
@change indentation of do {} while() cycles
@
text
@d202 5
a206 5
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
d226 1
a226 1
				case 0:
d230 1
a230 2

				case 1:
d237 1
a237 2

				case 2:
d245 1
a245 2

				case 4:
d251 1
a251 2

				case 5:
d266 1
a266 2

				case 7:
d383 1
a383 1
		case 1:
d393 1
a393 1
		case 2:
d397 1
a397 1
		case 5:
d407 1
a407 1
		case 7:
d435 1
a435 1
		case 0:
d445 1
a445 2

		case 4:
d457 1
a457 2

		case 1:
d468 1
a468 2

		case 2:
d482 1
a482 2

		case 5:
d485 1
a485 2

		case 7:
d527 1
a527 1
			case 0:
d530 1
a530 2

			case 1:
d533 1
a533 2

			case 2:
d536 1
a536 2

			case 4:
d539 1
a539 2

			case 5:
d542 1
a542 2

			case 7:
d585 5
a589 5
			case ' ':
			case '\t':
			case '\n':
			case '\f':
			case 0:
d591 1
a591 2

			case '*':	/* Select file types for file-type dependant options */
d604 1
a604 2

			case '-':	/* Set an option */
d622 1
a622 2

			case '{':	/* Ignore help text */
d633 1
a633 2

			case ':':	/* Select context */
d683 1
a683 1
								case 1:
d686 1
a686 1
								case -1:
d717 1
a717 2

			default:	/* Get key-sequence to macro binding */
@


1.11
log
@include only headers which are needed
@
text
@d642 2
a643 1
				while ((fgets(buf, 256, fd)) && (buf[0] != '}'));
@


1.10
log
@put struct definitions and other goodies into types.h
@
text
@d17 3
a19 1
#include "utils.h"
a20 5
#include "cmd.h"
#include "bw.h"
#include "help.h"
#include "vs.h"
#include "va.h"
d22 4
d27 2
a28 3
#include "uedit.h"
#include "pw.h"
#include "path.h"
a29 3
#include "tw.h"
#include "termcap.h"
#include "rc.h"
@


1.9
log
@use mkmenu(W *, ...) instead of mkmenu(BASE *, ...)
@
text
@d2 8
a9 6
	*rc file parser
	Copyright
		(C) 1992 Joseph H. Allen; 

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.8
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d565 1
a565 1
	if (mkmenu(bw, s, doopt, doabrt, NULL, optx, s, NULL))
@


1.7
log
@version 2.9.7-pre3
@
text
@d392 4
a395 3
		if (merr)
			msgnw(bw, merr), ret = -1;
		else if (v >= glopts[x].low && v <= glopts[x].high)
d398 1
a398 1
			msgnw(bw, "Value out of range"), ret = -1;
d406 4
a409 3
		if (merr)
			msgnw(bw, merr), ret = -1;
		else if (v >= glopts[x].low && v <= glopts[x].high)
d412 1
a412 1
			msgnw(bw, "Value out of range"), ret = -1;
d416 4
a419 3
		if (merr)
			msgnw(bw, merr), ret = -1;
		else if (v >= glopts[x].low && v <= glopts[x].high)
d422 1
a422 1
			msgnw(bw, "Value out of range"), ret = -1;
d450 1
a450 1
		msgnw(bw, *glopts[x].set ? glopts[x].yes : glopts[x].no);
d461 1
a461 1
		msgnw(bw, *(int *) ((char *) &bw->o + glopts[x].ofst) ? glopts[x].yes : glopts[x].no);
@


1.6
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d198 1
a198 1
void izopts(void)
d376 1
a376 1
int doabrt1(BW * bw, int *xx)
d382 1
a382 1
int doopt1(BW * bw, char *s, int *xx, int *notify)
d431 1
a431 1
int doopt(MENU * m, int x, void *object, int flg)
d514 1
a514 1
int doabrt(MENU * m, int x, char **s)
@


1.5
log
@changed as of joe-2.9.6
@
text
@d9 1
d13 3
d33 1
a33 1
#define OPT_BUF_SIZE 80
d35 1
a35 2
static struct context
{
d39 1
a39 3
}

 *contexts = 0;			/* List of named contexts */
d45 1
a45 2
KMAP *
getcontext (char *name)
d50 1
a50 1
		if (!strcmp (c->name, name))
d52 2
a53 1
	c = (struct context *) malloc (sizeof (struct context));
d55 1
a55 1
	c->name = strdup (name);
d57 1
a57 1
	return c->kmap = mkkmap ();
d61 1
a61 3
extern int mid, dspasis, dspctrl, force, help, pgamnt, square, csmode,
	nobackups, lightoff, exask, skiptop, noxon, lines, staen,
	columns, Baud, dopadding, orphan, marking, beep, keepup, nonotice;
d65 1
a65 2
OPTIONS pdefault =
	{ 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
d67 5
a71 4
		0 };
OPTIONS fdefault =
	{ 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
     " %S Ctrl-K H for help", 0, 0, 0, 0, 1, 0, 0, 0, 0 };
d73 1
a73 2
OPTIONS pdefault =
	{ 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d75 5
a79 4
		0 };
OPTIONS fdefault =
	{ 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
     " %S Ctrl-K H for help", 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d82 1
a82 2
void
setopt (OPTIONS * n, char *name)
d87 4
a90 5
		if (rmatch (o->name, name))
		  {
			  *n = *o;
			  return;
		  }
d100 1
a100 2
struct glopts
{
d118 1
a118 1
}
a119 138
glopts[] =
{
	{
		"overwrite", 4, 0, (char *) &fdefault.overtype,
			"Overtype mode", "Insert mode", "T Overtype "}
	,
	{
		"autoindent", 4, 0, (char *) &fdefault.autoindent,
			"Autoindent enabled", "Autindent disabled",
			"I Autoindent "}
	,
	{
		"wordwrap", 4, 0, (char *) &fdefault.wordwrap,
			"Wordwrap enabled", "Wordwrap disabled", "Word wrap "}
	,
	{
		"tab", 5, 0, (char *) &fdefault.tab,
			"Tab width (%d): ", 0, "D Tab width ", 0, 1, 64}
	,
	{
		"lmargin", 7, 0, (char *) &fdefault.lmargin,
			"Left margin (%d): ", 0, "Left margin ", 0, 0, 63}
	,
	{
		"rmargin", 7, 0, (char *) &fdefault.rmargin,
			"Right margin (%d): ", 0, "Right margin ", 0, 7, 255}
	,
	{
		"square", 0, &square, 0,
			"Rectangle mode", "Text-stream mode",
			"X Rectangle mode "}
	,
	{
		"indentc", 5, 0, (char *) &fdefault.indentc,
			"Indent char %d (SPACE=32, TAB=9, ^C to abort): ",
			0, " Indent char ", 0, 0, 255}
	,
	{
		"istep", 5, 0, (char *) &fdefault.istep,
			"Indent step %d (^C to abort): ", 0, " Indent step ",
			0, 1, 64}
	,
	{
		"french", 4, 0, (char *) &fdefault.french,
			"One space after periods for paragraph reformat",
			"Two spaces after periods for paragraph reformat",
			" french spacing "}
	,
	{
		"spaces", 4, 0, (char *) &fdefault.spaces,
			"Inserting spaces when tab key is hit",
			"Inserting tabs when tab key is hit", " no tabs "}
	,
	{
		"mid", 0, &mid, 0,
			"Cursor will be recentered on scrolls",
			"Cursor will not be recentered on scroll",
			"Center on scroll "}
	,
	{
		"crlf", 4, 0, (char *) &fdefault.crlf,
			"CR-LF is line terminator", "LF is line terminator",
			"Z CR-LF (MS-DOS) "}
	,
	{
		"linums", 4, 0, (char *) &fdefault.linums,
			"Line numbers enabled", "Line numbers disabled",
			"N Line numbers "}
	,
	{
		"marking", 0, &marking, 0,
			"Anchored block marking on",
			"Anchored block marking off", "Marking "}
	,
	{
		"asis", 0, &dspasis, 0,
			"Characters above 127 shown as-is",
			"Characters above 127 shown in inverse",
			"Meta chars as-is "}
	,
	{
		"force", 0, &force, 0,
			"Last line forced to have NL when file saved",
			"Last line not forces to have NL", "Force last NL "}
	,
	{
		"nobackups", 0, &nobackups, 0,
			"Backup files will not be made",
			"Backup files will be made", " Disable backups "}
	,
	{
		"lightoff", 0, &lightoff, 0,
			"Highlighting turned off after block operations",
			"Highlighting not turned off after block operations",
			"Auto unmark "}
	,
	{
		"exask", 0, &exask, 0,
			"Prompt for filename in save & exit command",
			"Don't prompt for filename in save & exit command",
			"Exit ask "}
	,
	{
		"beep", 0, &beep, 0,
			"Warning bell enabled", "Warning bell disabled",
			"Beeps "}
	,
	{
		"nosta", 0, &staen, 0,
			"Top-most status line disabled",
			"Top-most status line enabled",
			" Disable status line "}
	,
	{
		"keepup", 0, &keepup, 0,
			"Status line updated constantly",
			"Status line updated once/sec", " Fast status line "}
	,
	{
		"pg", 1, &pgamnt, 0,
			"Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ",
			0, " No. PgUp/PgDn lines ", 0, -1, 64}
	,
	{
		"csmode", 0, &csmode, 0,
			"Start search after a search repeats previous search",
			"Start search always starts a new search",
			"Continued search "}
	,
	{
		"rdonly", 4, 0, (char *) &fdefault.readonly,
			"Read only", "Full editing", "O Read only "}
	,
	{
		"backpath", 2, (int *) &backpath, 0,
			"Backup files stored in (%s): ", 0,
			"Path to backup files "}
	,
d121 54
d176 1
a176 2
	,
	{
d178 1
a178 2
	,
	{
d180 1
a180 2
	,
	{
d182 1
a182 2
	,
	{
d184 1
a184 2
	,
	{
d186 1
a186 2
	,
	{
d188 1
a188 2
	,
	{
d190 1
a190 2
	,
	{
d192 1
a192 2
	,
	{
d198 1
a198 2
void
izopts (void)
d201 1
d203 8
a210 10
		switch (glopts[x].type)
		  {
		  case 4:
		  case 5:
		  case 6:
		  case 7:
		  case 8:
			  glopts[x].ofst =
				  glopts[x].addr - (char *) &fdefault;
		  }
d214 1
a214 2
int
glopt (char *s, char *arg, OPTIONS * options, int set)
d220 1
d222 1
a222 1
		izopts ();
d226 146
a371 205
		if (!strcmp (glopts[x].name, s))
		  {
			  switch (glopts[x].type)
			    {
			    case 0:
				    if (set)
					    *glopts[x].set = st;
				    break;

			    case 1:
				    if (set && arg)
				      {
					      sscanf (arg, "%d", &val);
					      if (val >= glopts[x].low
						  && val <= glopts[x].high)
						      *glopts[x].set = val;
				      }
				    break;

			    case 2:
				    if (set)
					    if (arg)
						    *(char **) glopts[x].set =
							    strdup (arg);
					    else
						    *(char **) glopts[x].set =
							    0;
				    break;

			    case 4:
				    if (options)
					    *(int *) ((char *) options +
						      glopts[x].ofst) = st;
				    else if (set == 2)
					    *(int *) ((char *) &fdefault +
						      glopts[x].ofst) = st;
				    break;

			    case 5:
				    if (arg)
					    if (options)
					      {
						      sscanf (arg, "%d",
							      &val);
						      if (val >= glopts[x].low
							  && val <=
							  glopts[x].high)
							      *(int
								*) ((char *)
								    options +
								    glopts[x].
								    ofst) =
								      val;
					      }
					    else if (set == 2)
					      {
						      sscanf (arg, "%d",
							      &val);
						      if (val >= glopts[x].low
							  && val <=
							  glopts[x].high)
							      *(int
								*) ((char *)
								    &fdefault
								    +
								    glopts[x].
								    ofst) =
								      val;
					      }
				    break;

			    case 7:
				    if (arg)
				      {
					      int zz = 0;
					      sscanf (arg, "%d", &zz);
					      if (zz >= glopts[x].low
						  && zz <= glopts[x].high)
						{
							--zz;
							if (options)
								*(int
								  *) ((char *)
								      options
								      +
								      glopts
								      [x].
								      ofst) =
									zz;
							else if (set == 2)
								*(int
								  *) ((char *)
								      &fdefault
								      +
								      glopts
								      [x].
								      ofst) =
									zz;
						}
				      }
				    break;
			    }
			  if ((glopts[x].type & 3) == 0 || !arg)
				  return 1;
			  else
				  return 2;
		  }
	if (!strcmp (s, "lmsg"))
	  {
		  if (arg)
		    {
			    if (options)
				    options->lmsg = strdup (arg);
			    else if (set == 2)
				    fdefault.lmsg = strdup (arg);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "rmsg"))
	  {
		  if (arg)
		    {
			    if (options)
				    options->rmsg = strdup (arg);
			    else if (set == 2)
				    fdefault.rmsg = strdup (arg);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "keymap"))
	  {
		  if (arg)
		    {
			    int y;
			    for (y = 0; !isspace (arg[y]); ++y);
			    if (!arg[y])
				    arg[y] = 0;
			    if (options && y)
				    options->context = strdup (arg);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "mnew"))
	  {
		  if (arg)
		    {
			    int sta;
			    if (options)
				    options->mnew = mparse (NULL, arg, &sta);
			    else if (set == 2)
				    fdefault.mnew = mparse (NULL, arg, &sta);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "mold"))
	  {
		  if (arg)
		    {
			    int sta;
			    if (options)
				    options->mold = mparse (NULL, arg, &sta);
			    else if (set == 2)
				    fdefault.mold = mparse (NULL, arg, &sta);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "msnew"))
	  {
		  if (arg)
		    {
			    int sta;
			    if (options)
				    options->msnew = mparse (NULL, arg, &sta);
			    else if (set == 2)
				    fdefault.msnew = mparse (NULL, arg, &sta);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
	else if (!strcmp (s, "msold"))
	  {
		  if (arg)
		    {
			    int sta;
			    if (options)
				    options->msold = mparse (NULL, arg, &sta);
			    else if (set == 2)
				    fdefault.msold = mparse (NULL, arg, &sta);
			    ret = 2;
		    }
		  else
			  ret = 1;
	  }
      done:return ret;
d376 1
a376 2
int
doabrt1 (BW * bw, int *xx)
d378 1
a378 1
	free (xx);
d382 1
a382 2
int
doopt1 (BW * bw, char *s, int *xx, int *notify)
d387 36
a422 36
	free (xx);
	switch (glopts[x].type)
	  {
	  case 1:
		  v = calc (bw, s);
		  if (merr)
			  msgnw (bw, merr), ret = -1;
		  else if (v >= glopts[x].low && v <= glopts[x].high)
			  *glopts[x].set = v;
		  else
			  msgnw (bw, "Value out of range"), ret = -1;
		  break;
	  case 2:
		  if (s[0])
			  *(char **) glopts[x].set = strdup (s);
		  break;
	  case 5:
		  v = calc (bw, s);
		  if (merr)
			  msgnw (bw, merr), ret = -1;
		  else if (v >= glopts[x].low && v <= glopts[x].high)
			  *(int *) ((char *) &bw->o + glopts[x].ofst) = v;
		  else
			  msgnw (bw, "Value out of range"), ret = -1;
		  break;
	  case 7:
		  v = calc (bw, s) - 1.0;
		  if (merr)
			  msgnw (bw, merr), ret = -1;
		  else if (v >= glopts[x].low && v <= glopts[x].high)
			  *(int *) ((char *) &bw->o + glopts[x].ofst) = v;
		  else
			  msgnw (bw, "Value out of range"), ret = -1;
		  break;
	  }
	vsrm (s);
d424 2
a425 2
	wfit (bw->parent->t);
	updall ();
d431 1
a431 2
int
doopt (MENU * m, int x, void *object, int flg)
d437 69
a505 82
	switch (glopts[x].type)
	  {
	  case 0:
		  if (!flg)
			  *glopts[x].set = !*glopts[x].set;
		  else if (flg == 1)
			  *glopts[x].set = 1;
		  else
			  *glopts[x].set = 0;
		  uabort (m, MAXINT);
		  msgnw (bw, *glopts[x].set ? glopts[x].yes : glopts[x].no);
		  break;

	  case 4:
		  if (!flg)
			  *(int *) ((char *) &bw->o + glopts[x].ofst) =
				  !*(int *) ((char *) &bw->o +
					     glopts[x].ofst);
		  else if (flg == 1)
			  *(int *) ((char *) &bw->o + glopts[x].ofst) = 1;
		  else
			  *(int *) ((char *) &bw->o + glopts[x].ofst) = 0;
		  uabort (m, MAXINT);
		  msgnw (bw,
			 *(int *) ((char *) &bw->o +
				   glopts[x].ofst) ? glopts[x].
			 yes : glopts[x].no);
		  if (glopts[x].ofst ==
		      (char *) &fdefault.readonly - (char *) &fdefault)
			  bw->b->rdonly = bw->o.readonly;
		  break;

	  case 1:
		  snprintf (buf, OPT_BUF_SIZE, glopts[x].yes, *glopts[x].set);
		  xx = (int *) malloc (sizeof (int));
		  *xx = x;
		  m->parent->notify = 0;
		  uabort (m, MAXINT);
		  if (wmkpw
		      (bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx,
		       notify))
			  return 0;
		  else
			  return -1;

	  case 2:
		  if (*(char **) glopts[x].set)
			  snprintf (buf, OPT_BUF_SIZE, glopts[x].yes,
				   *(char **) glopts[x].set);
		  else
			  snprintf (buf, OPT_BUF_SIZE, glopts[x].yes, "");

		  xx = (int *) malloc (sizeof (int));
		  *xx = x;
		  m->parent->notify = 0;
		  uabort (m, MAXINT);
		  if (wmkpw
		      (bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx,
		       notify))
			  return 0;
		  else
			  return -1;

	  case 5:
		  snprintf (buf, OPT_BUF_SIZE, glopts[x].yes,
			   *(int *) ((char *) &bw->o + glopts[x].ofst));
		  goto in;

	  case 7:
		  snprintf (buf, OPT_BUF_SIZE, glopts[x].yes,
			   *(int *) ((char *) &bw->o + glopts[x].ofst) + 1);
		in:xx = (int *) malloc (sizeof (int));
		  *xx = x;
		  m->parent->notify = 0;
		  uabort (m, MAXINT);
		  if (wmkpw
		      (bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx,
		       notify))
			  return 0;
		  else
			  return -1;
	  }
d509 2
a510 2
	wfit (bw->parent->t);
	updall ();
d514 1
a514 2
int
doabrt (MENU * m, int x, char **s)
d518 2
a519 2
		free (s[x]);
	free (s);
d523 1
a523 2
int
umode (BW * bw)
d528 1
a528 1
	int buf_len = 40;
d530 2
d533 28
a560 46
	/*
	 * FIXME: A more obvious way of finding the largest valid size is needed
	 * The trailing ; in the next line is easily missed
	 */
	for (size = 0; glopts[size].menu; ++size) ;	/* ONE LINE LOOP */

	s = (char **) malloc (sizeof (char *) * (size + 1));
	for (x = 0; x != size; ++x)
	  {
		  s[x] = (char *) malloc (buf_len);
		  switch (glopts[x].type)
		    {
		    case 0:
			    snprintf (s[x], buf_len,"%s%s", glopts[x].menu,
				     *glopts[x].set ? "ON" : "OFF");
			    break;

		    case 1:
			    snprintf (s[x], buf_len, "%s%d", glopts[x].menu,
				     *glopts[x].set);
			    break;

		    case 2:
			    strcpy (s[x], glopts[x].menu);
			    break;

		    case 4:
			    snprintf (s[x], buf_len, "%s%s", glopts[x].menu,
				     *(int *) ((char *) &bw->o +
					       glopts[x].
					       ofst) ? "ON" : "OFF");
			    break;

		    case 5:
			    snprintf (s[x], buf_len, "%s%d", glopts[x].menu,
				     *(int *) ((char *) &bw->o +
					       glopts[x].ofst));
			    break;

		    case 7:
			    snprintf (s[x], buf_len, "%s%d", glopts[x].menu,
				     *(int *) ((char *) &bw->o +
					       glopts[x].ofst) + 1);
			    break;
		    }
	  }
d562 1
a562 1
	if (mkmenu (bw, s, doopt, doabrt, NULL, optx, s, NULL))
d575 1
a575 2
int
procrc (CAP * cap, char *name)
d583 2
a584 1
	ossep (strcpy (buf, name));
d586 1
a586 1
	fd = fopen (buf, "rt");
d588 1
a588 1
	fd = fopen (buf, "r");
d594 2
a595 2
	fprintf (stderr, "Processing '%s'...", name);
	fflush (stderr);
d597 103
a699 230
	while (++line, fgets (buf, 1024, fd))
		switch (buf[0])
		  {
		  case ' ':
		  case '\t':
		  case '\n':
		  case '\f':
		  case 0:
			  break;	/* Skip comment lines */

		  case '*':	/* Select file types for file-type dependant options */
			  {
				  int x;
				  o = (OPTIONS *) malloc (sizeof (OPTIONS));
				  *o = fdefault;
				  for (x = 0;
				       buf[x] && buf[x] != '\n'
				       && buf[x] != ' ' && buf[x] != '\t';
				       ++x);
				  buf[x] = 0;
				  o->next = options;
				  options = o;
				  o->name = strdup (buf);
			  }
			  break;

		  case '-':	/* Set an option */
			  {
				  unsigned char *opt = buf + 1;
				  int x;
				  unsigned char *arg = 0;
				  for (x = 0;
				       buf[x] && buf[x] != '\n'
				       && buf[x] != ' ' && buf[x] != '\t';
				       ++x);
				  if (buf[x] && buf[x] != '\n')
				    {
					    buf[x] = 0;
					    for (arg = buf + ++x;
						 buf[x] && buf[x] != '\n';
						 ++x);
				    }
				  buf[x] = 0;
				  if (!glopt (opt, arg, o, 2))
				    {
					    err = 1;
					    fprintf (stderr,
						     "\n%s %d: Unknown option %s",
						     name, line, opt);
				    }
			  }
			  break;

		  case '{':	/* Enter help text */
			  {
				  int bfl;
				  struct help *tmp =
					  (struct help *)
					  malloc (sizeof (struct help));
				  tmp->next = help_first;
				  help_first = tmp;
				  tmp->name =
					  vsncpy (NULL, 0, sz (buf + 1) - 1);
				  help_names = vaadd (help_names, tmp->name);
				  tmp->hlptxt = 0;
				  tmp->hlpsiz = 0;
				  tmp->hlpbsz = 0;
				  tmp->hlplns = 0;
				up:
				  if (++line, !fgets (buf, 256, fd))
				    {
					    err = 1;
					    fprintf (stderr,
						     "\n%s %d: End of joerc file occured before end of help text",
						     name, line);
					    break;
				    }
				  if (buf[0] == '}')
				    {
					    if (!hlptxt)
						    hlptxt = tmp->hlptxt,
							    hlpsiz =
							    tmp->hlpsiz,
							    hlpbsz =
							    tmp->hlpbsz,
							    hlplns =
							    tmp->hlplns;
					    continue;
				    }
				  bfl = strlen (buf);
				  if (tmp->hlpsiz + bfl > tmp->hlpbsz)
				    {
					    if (tmp->hlptxt)
						    tmp->hlptxt =
							    (char *)
							    realloc (tmp->
								     hlptxt,
								     tmp->
								     hlpbsz +
								     bfl +
								     1024);
					    else
						    tmp->hlptxt =
							    (char *)
							    malloc (bfl +
								    1024),
							    tmp->hlptxt[0] =
							    0;
					    tmp->hlpbsz += bfl + 1024;
				    }
				  strcpy (tmp->hlptxt + tmp->hlpsiz, buf);
				  tmp->hlpsiz += bfl;
				  ++tmp->hlplns;
				  goto up;
			  }
			  break;

		  case ':':	/* Select context */
			  {
				  int x, c;
				  for (x = 1; !isspace_eof (buf[x]); ++x);
				  c = buf[x];
				  buf[x] = 0;
				  if (x != 1)
					  if (!strcmp (buf + 1, "def"))
					    {
						    int y;
						    for (buf[x] = c;
							 isblank (buf[x]);
							 ++x);
						    for (y = x;
							 !isspace_eof (buf
								       [y]);
							 ++y);
						    c = buf[y];
						    buf[y] = 0;
						    if (y != x)
						      {
							      int sta;
							      MACRO *m;
							      if (isblank (c)
								  && (m =
								      mparse
								      (NULL,
								       buf +
								       y + 1,
								       &sta)))
								      addcmd
									      (buf
									       +
									       x,
									       m);
							      else
								{
									err =
										1;
									fprintf
										(stderr,
										 "\n%s %d: macro missing from :def",
										 name,
										 line);
								}
						      }
						    else
						      {
							      err = 1;
							      fprintf (stderr,
								       "\n%s %d: command name missing from :def",
								       name,
								       line);
						      }
					    }
					  else
						  if (!strcmp
						      (buf + 1, "inherit"))
						  if (context)
						    {
							    for (buf[x] = c;
								 isblank (buf
									  [x]);
								 ++x);
							    for (c = x;
								 !isspace_eof
								 (buf[c]);
								 ++c);
							    buf[c] = 0;
							    if (c != x)
								    kcpy
									    (context,
									     getcontext
									     (buf
									      +
									      x));
							    else
							      {
								      err = 1;
								      fprintf
									      (stderr,
									       "\n%s %d: context name missing from :inherit",
									       name,
									       line);
							      }
						    }
						  else
						    {
							    err = 1;
							    fprintf (stderr,
								     "\n%s %d: No context selected for :inherit",
								     name,
								     line);
						    }
					  else
						  if (!strcmp
						      (buf + 1, "include"))
					    {
						    for (buf[x] = c;
							 isblank (buf[x]);
							 ++x);
						    for (c = x;
							 !isspace_eof (buf
								       [c]);
							 ++c);
						    buf[c] = 0;
						    if (c != x)
						      {
							      switch (procrc
								      (cap,
								       buf +
								       x))
								{
d701 72
a772 130
									err =
										1;
									break;
									case
								-1:
									fprintf
										(stderr,
										 "\n%s %d: Couldn't open %s",
										 name,
										 line,
										 buf
										 +
										 x);
									err =
										1;
									break;
								}
							      context = 0;
							      o = 0;
						      }
						    else
						      {
							      err = 1;
							      fprintf (stderr,
								       "\n%s %d: :include missing file name",
								       name,
								       line);
						      }
					    }
					  else
						  if (!strcmp
						      (buf + 1, "delete"))
						  if (context)
						    {
							    int y;
							    for (buf[x] = c;
								 isblank (buf
									  [x]);
								 ++x);
							    for (y = x;
								 buf[y] != 0
								 && buf[y] !=
								 '\t'
								 && buf[y] !=
								 '\n'
								 && (buf[y] !=
								     ' '
								     || buf[y
									    +
									    1]
								     != ' ');
								 ++y);
							    buf[y] = 0;
							    kdel (context,
								  buf + x);
						    }
						  else
						    {
							    err = 1;
							    fprintf (stderr,
								     "\n%s %d: No context selected for :delete",
								     name,
								     line);
						    }
					  else
						  context =
							  getcontext (buf +
								      1);
				  else
				    {
					    err = 1;
					    fprintf (stderr,
						     "\n%s %d: Invalid context name",
						     name, line);
				    }
			  }
			  break;

		  default:	/* Get key-sequence to macro binding */
			  {
				  int x, y, c;
				  MACRO *m;
				  if (!context)
				    {
					    err = 1;
					    fprintf (stderr,
						     "\n%s %d: No context selected for macro to key-sequence binding",
						     name, line);
					    break;
				    }

				  m = 0;
				macroloop:
				  m = mparse (m, buf, &x);
				  if (x == -1)
				    {
					    err = 1;
					    fprintf (stderr,
						     "\n%s %d: Unknown command in macro",
						     name, line);
					    break;
				    }
				  else if (x == -2)
				    {
					    fgets (buf, 1024, fd);
					    goto macroloop;
				    }
				  if (!m)
					  break;

				  /* Skip to end of key sequence */
				  for (y = x;
				       buf[y] != 0 && buf[y] != '\t'
				       && buf[y] != '\n' && (buf[y] != ' '
							     || buf[y + 1] !=
							     ' '); ++y);
				  buf[y] = 0;

				  /* Add binding to context */
				  if (kadd (cap, context, buf + x, m) == -1)
				    {
					    fprintf (stderr,
						     "\n%s %d: Bad key sequence '%s'",
						     name, line, buf + x);
					    err = 1;
				    }
			  }
			  break;
		  }
	fclose (fd);		/* Close rc file */
d776 1
a776 1
		fprintf (stderr, "\ndone\n");
d778 1
a778 1
		fprintf (stderr, "done\n");
@


1.4
log
@changed as of joe-2.9.5
@
text
@d7 1
a7 1
*/ 
d29 7
a35 4
static struct context {
  struct context *next;
  char *name;
  KMAP *kmap;
d38 1
a38 1
*contexts = 0;			/* List of named contexts */
d44 3
a46 1
KMAP *getcontext (char *name) {
d49 8
a56 8
for (c = contexts; c; c = c->next)
    if (!strcmp (c->name, name))
      return c->kmap;
  c = (struct context *) malloc (sizeof (struct context));
  c->next = contexts;
  c->name = strdup (name);
  contexts = c;
  return c->kmap = mkkmap ();
d61 2
a62 2
  nobackups, lightoff, exask, skiptop, noxon, lines, staen,
  columns, Baud, dopadding, orphan, marking, beep, keepup, nonotice;
d66 7
a72 2
OPTIONS pdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
OPTIONS fdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M", " %S Ctrl-K H for help", 0, 0, 0, 0, 1, 0, 0, 0, 0 };
d74 7
a80 2
OPTIONS pdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
OPTIONS fdefault = { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M", " %S Ctrl-K H for help", 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d83 3
a85 1
void setopt (OPTIONS *n, char *name) {
d89 7
a95 6
		if (rmatch (o->name, name)) {
			*n = *o;
			return;
		}
		*n = fdefault;
	}
d103 19
a121 18
struct glopts {
	char *name;			/* Option name */
	int type;			/* 	0 for global option flag
				   		1 for global option numeric
				   		2 for global option string
				   		4 for local option flag
				   		5 for local option numeric
				   		6 for local option string
						7 for local option numeric+1
					*/
	int *set;			/* Address of global option */
	char *addr;			/* Local options structure member address */
	char *yes;			/* Message if option was turned on, or prompt string */
	char *no;			/* Message if option was turned off */
	char *menu;			/* Menu string */
	int ofst;			/* Local options structure member offset */
	int low;			/* Low limit for numeric options */
	int high;			/* High limit for numeric options */
d126 165
a290 150
  {
    "overwrite", 4, 0, (char *) &fdefault.overtype,
      "Overtype mode", "Insert mode", "T Overtype "}
  ,
  {
    "autoindent", 4, 0, (char *) &fdefault.autoindent,
      "Autoindent enabled", "Autindent disabled", "I Autoindent "}
  ,
  {
    "wordwrap", 4, 0, (char *) &fdefault.wordwrap,
      "Wordwrap enabled", "Wordwrap disabled", "Word wrap "}
  ,
  {
    "tab", 5, 0, (char *) &fdefault.tab,
      "Tab width (%d): ", 0, "D Tab width ", 0, 1, 64}
  ,
  {
    "lmargin", 7, 0, (char *) &fdefault.lmargin,
      "Left margin (%d): ", 0, "Left margin ", 0, 0, 63}
  ,
  {
    "rmargin", 7, 0, (char *) &fdefault.rmargin,
      "Right margin (%d): ", 0, "Right margin ", 0, 7, 255}
  ,
  {
    "square", 0, &square, 0,
      "Rectangle mode", "Text-stream mode", "X Rectangle mode "}
  ,
  {
    "indentc", 5, 0, (char *) &fdefault.indentc,
      "Indent char %d (SPACE=32, TAB=9, ^C to abort): ",
      0, " Indent char ", 0, 0, 255}
  ,
  {
    "istep", 5, 0, (char *) &fdefault.istep,
      "Indent step %d (^C to abort): ", 0, " Indent step ", 0, 1, 64}
  ,
  {
    "french", 4, 0, (char *) &fdefault.french,
      "One space after periods for paragraph reformat",
      "Two spaces after periods for paragraph reformat", " french spacing "}
  ,
  {
    "spaces", 4, 0, (char *) &fdefault.spaces,
      "Inserting spaces when tab key is hit",
      "Inserting tabs when tab key is hit", " no tabs "}
  ,
  {
    "mid", 0, &mid, 0,
      "Cursor will be recentered on scrolls",
      "Cursor will not be recentered on scroll", "Center on scroll "}
  ,
  {
    "crlf", 4, 0, (char *) &fdefault.crlf,
      "CR-LF is line terminator", "LF is line terminator", "Z CR-LF (MS-DOS) "}
  ,
  {
    "linums", 4, 0, (char *) &fdefault.linums,
      "Line numbers enabled", "Line numbers disabled", "N Line numbers "}
  ,
  {
    "marking", 0, &marking, 0,
      "Anchored block marking on", "Anchored block marking off", "Marking "}
  ,
  {
    "asis", 0, &dspasis, 0,
      "Characters above 127 shown as-is",
      "Characters above 127 shown in inverse", "Meta chars as-is "}
  ,
  {
    "force", 0, &force, 0,
      "Last line forced to have NL when file saved",
      "Last line not forces to have NL", "Force last NL "}
  ,
  {
    "nobackups", 0, &nobackups, 0,
      "Backup files will not be made",
      "Backup files will be made", " Disable backups "}
  ,
  {
    "lightoff", 0, &lightoff, 0,
      "Highlighting turned off after block operations",
      "Highlighting not turned off after block operations", "Auto unmark "}
  ,
  {
    "exask", 0, &exask, 0,
      "Prompt for filename in save & exit command",
      "Don't prompt for filename in save & exit command", "Exit ask "}
  ,
  {
    "beep", 0, &beep, 0,
      "Warning bell enabled", "Warning bell disabled", "Beeps "}
  ,
  {
    "nosta", 0, &staen, 0,
      "Top-most status line disabled",
      "Top-most status line enabled", " Disable status line "}
  ,
  {
    "keepup", 0, &keepup, 0,
      "Status line updated constantly",
      "Status line updated once/sec", " Fast status line "}
  ,
  {
    "pg", 1, &pgamnt, 0,
      "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ",
      0, " No. PgUp/PgDn lines ", 0, -1, 64}
  ,
  {
    "csmode", 0, &csmode, 0,
      "Start search after a search repeats previous search",
      "Start search always starts a new search", "Continued search "}
  ,
  {
    "rdonly", 4, 0, (char *) &fdefault.readonly,
      "Read only", "Full editing", "O Read only "}
  ,
  {
    "backpath", 2, (int *) &backpath, 0,
      "Backup files stored in (%s): ", 0, "Path to backup files "}
  ,
  {
  "nonotice", 0, &nonotice, 0, 0, 0, 0}
  ,
  {
  "noxon", 0, &noxon, 0, 0, 0, 0}
  ,
  {
  "orphan", 0, &orphan, 0, 0, 0, 0}
  ,
  {
  "help", 0, &help, 0, 0, 0, 0}
  ,
  {
  "dopadding", 0, &dopadding, 0, 0, 0, 0}
  ,
  {
  "lines", 1, &lines, 0, 0, 0, 0, 0, 2, 1024}
  ,
  {
  "baud", 1, &Baud, 0, 0, 0, 0, 0, 50, 32767}
  ,
  {
  "columns", 1, &columns, 0, 0, 0, 0, 0, 2, 1024}
  ,
  {
  "skiptop", 1, &skiptop, 0, 0, 0, 0, 0, 0, 64}
  ,
  {
  0, 0, 0}
d295 303
a597 30
void izopts () {
  int x;
  for (x = 0; glopts[x].name; ++x)
    switch (glopts[x].type)
      {
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
	glopts[x].ofst = glopts[x].addr - (char *) &fdefault;
      }
  isiz = 1;
}

int glopt (s, arg, options, set)
     char *s, *arg;
     OPTIONS *options;
{
  int val;
  int ret = 0;
  int st = 1;
  int x;
  if (!isiz)
    izopts ();
  if (s[0] == '-')
    st = 0, ++s;
  for (x = 0; glopts[x].name; ++x)
    if (!strcmp (glopts[x].name, s))
      {
d601 28
a628 3
	    if (set)
	      *glopts[x].set = st;
	    break;
d631 11
a641 7
	    if (set && arg)
	      {
		sscanf (arg, "%d", &val);
		if (val >= glopts[x].low && val <= glopts[x].high)
		  *glopts[x].set = val;
	      }
	    break;
d644 5
a648 6
	    if (set)
	      if (arg)
		*(char **) glopts[x].set = strdup (arg);
	      else
		*(char **) glopts[x].set = 0;
	    break;
d650 10
a659 6
	  case 4:
	    if (options)
	      *(int *) ((char *) options + glopts[x].ofst) = st;
	    else if (set == 2)
	      *(int *) ((char *) &fdefault + glopts[x].ofst) = st;
	    break;
d662 3
a664 14
	    if (arg)
	      if (options)
		{
		  sscanf (arg, "%d", &val);
		  if (val >= glopts[x].low && val <= glopts[x].high)
		    *(int *) ((char *) options + glopts[x].ofst) = val;
		}
	      else if (set == 2)
		{
		  sscanf (arg, "%d", &val);
		  if (val >= glopts[x].low && val <= glopts[x].high)
		    *(int *) ((char *) &fdefault + glopts[x].ofst) = val;
		}
	    break;
d667 12
a678 14
	    if (arg)
	      {
		int zz = 0;
		sscanf (arg, "%d", &zz);
		if (zz >= glopts[x].low && zz <= glopts[x].high)
		  {
		    --zz;
		    if (options)
		      *(int *) ((char *) options + glopts[x].ofst) = zz;
		    else if (set == 2)
		      *(int *) ((char *) &fdefault + glopts[x].ofst) = zz;
		  }
	      }
	    break;
d680 6
a685 103
	if ((glopts[x].type & 3) == 0 || !arg)
	  return 1;
	else
	  return 2;
      }
  if (!strcmp (s, "lmsg"))
    {
      if (arg)
	{
	  if (options)
	    options->lmsg = strdup (arg);
	  else if (set == 2)
	    fdefault.lmsg = strdup (arg);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "rmsg"))
    {
      if (arg)
	{
	  if (options)
	    options->rmsg = strdup (arg);
	  else if (set == 2)
	    fdefault.rmsg = strdup (arg);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "keymap"))
    {
      if (arg)
	{
	  int y;
	  for (y = 0; !isspace (arg[y]); ++y);
	  if (!arg[y])
	    arg[y] = 0;
	  if (options && y)
	    options->context = strdup (arg);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "mnew"))
    {
      if (arg)
	{
	  int sta;
	  if (options)
	    options->mnew = mparse (NULL, arg, &sta);
	  else if (set == 2)
	    fdefault.mnew = mparse (NULL, arg, &sta);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "mold"))
    {
      if (arg)
	{
	  int sta;
	  if (options)
	    options->mold = mparse (NULL, arg, &sta);
	  else if (set == 2)
	    fdefault.mold = mparse (NULL, arg, &sta);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "msnew"))
    {
      if (arg)
	{
	  int sta;
	  if (options)
	    options->msnew = mparse (NULL, arg, &sta);
	  else if (set == 2)
	    fdefault.msnew = mparse (NULL, arg, &sta);
	  ret = 2;
	}
      else
	ret = 1;
    }
  else if (!strcmp (s, "msold"))
    {
      if (arg)
	{
	  int sta;
	  if (options)
	    options->msold = mparse (NULL, arg, &sta);
	  else if (set == 2)
	    fdefault.msold = mparse (NULL, arg, &sta);
	  ret = 2;
	}
      else
	ret = 1;
    }
done:return ret;
d688 7
a694 109
static int optx = 0;

int doabrt1 (bw, xx)
     BW *bw;
     int *xx;
{
  free (xx);
  return -1;
}

int doopt1 (bw, s, xx, notify)
     BW *bw;
     char *s;
     int *xx;
     int *notify;
{
  int ret = 0;
  int x = *xx;
  int v;
  free (xx);
  switch (glopts[x].type)
    {
    case 1:
      v = calc (bw, s);
      if (merr)
	msgnw (bw, merr), ret = -1;
      else if (v >= glopts[x].low && v <= glopts[x].high)
	*glopts[x].set = v;
      else
	msgnw (bw, "Value out of range"), ret = -1;
      break;
    case 2:
      if (s[0])
	*(char **) glopts[x].set = strdup (s);
      break;
    case 5:
      v = calc (bw, s);
      if (merr)
	msgnw (bw, merr), ret = -1;
      else if (v >= glopts[x].low && v <= glopts[x].high)
	*(int *) ((char *) &bw->o + glopts[x].ofst) = v;
      else
	msgnw (bw, "Value out of range"), ret = -1;
      break;
    case 7:
      v = calc (bw, s) - 1.0;
      if (merr)
	msgnw (bw, merr), ret = -1;
      else if (v >= glopts[x].low && v <= glopts[x].high)
	*(int *) ((char *) &bw->o + glopts[x].ofst) = v;
      else
	msgnw (bw, "Value out of range"), ret = -1;
      break;
    }
  vsrm (s);
  bw->b->o = bw->o;
  wfit (bw->parent->t);
  updall ();
  if (notify)
    *notify = 1;
  return ret;
}

int doopt (m, x, object, flg)
     MENU *m;
     void *object;
{
  BW *bw = m->parent->win->object;
  int *xx;
  char buf[80];
  int *notify = m->parent->notify;
  switch (glopts[x].type)
    {
    case 0:
      if (!flg)
	*glopts[x].set = !*glopts[x].set;
      else if (flg == 1)
	*glopts[x].set = 1;
      else
	*glopts[x].set = 0;
      uabort (m, MAXINT);
      msgnw (bw, *glopts[x].set ? glopts[x].yes : glopts[x].no);
      break;

    case 4:
      if (!flg)
	*(int *) ((char *) &bw->o + glopts[x].ofst) =
	  !*(int *) ((char *) &bw->o + glopts[x].ofst);
      else if (flg == 1)
	*(int *) ((char *) &bw->o + glopts[x].ofst) = 1;
      else
	*(int *) ((char *) &bw->o + glopts[x].ofst) = 0;
      uabort (m, MAXINT);
      msgnw (bw,
	     *(int *) ((char *) &bw->o +
		       glopts[x].ofst) ? glopts[x].yes : glopts[x].no);
      if (glopts[x].ofst == (char *) &fdefault.readonly - (char *) &fdefault)
	bw->b->rdonly = bw->o.readonly;
      break;

    case 1:
      sprintf (buf, glopts[x].yes, *glopts[x].set);
      xx = (int *) malloc (sizeof (int));
      *xx = x;
      m->parent->notify = 0;
      uabort (m, MAXINT);
      if (wmkpw (bw, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
	return 0;
      else
d696 1
d698 14
a711 13
    case 2:
      if (*(char **) glopts[x].set)
	sprintf (buf, glopts[x].yes, *(char **) glopts[x].set);
      else
	sprintf (buf, glopts[x].yes, "");
      xx = (int *) malloc (sizeof (int));
      *xx = x;
      m->parent->notify = 0;
      uabort (m, MAXINT);
      if (wmkpw (bw, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
	return 0;
      else
	return -1;
d713 45
a757 85
    case 5:
      sprintf (buf, glopts[x].yes,
	       *(int *) ((char *) &bw->o + glopts[x].ofst));
      goto in;

    case 7:
      sprintf (buf, glopts[x].yes,
	       *(int *) ((char *) &bw->o + glopts[x].ofst) + 1);
    in:xx = (int *) malloc (sizeof (int));
      *xx = x;
      m->parent->notify = 0;
      uabort (m, MAXINT);
      if (wmkpw (bw, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify))
	return 0;
      else
	return -1;
    }
  if (notify)
    *notify = 1;
  bw->b->o = bw->o;
  wfit (bw->parent->t);
  updall ();
  return 0;
}

int doabrt (m, x, s)
     MENU *m;
     char **s;
{
  optx = x;
  for (x = 0; s[x]; ++x)
    free (s[x]);
  free (s);
  return -1;
}

int umode (bw)
     BW *bw;
{
  int size;
  char **s;
  int x;
  bw->b->o.readonly = bw->o.readonly = bw->b->rdonly;
  for (size = 0; glopts[size].menu; ++size);
  s = (char **) malloc (sizeof (char *) * (size + 1));
  for (x = 0; x != size; ++x)
    {
      s[x] = (char *) malloc (40);
      switch (glopts[x].type)
	{
	case 0:
	  sprintf (s[x], "%s%s", glopts[x].menu,
		   *glopts[x].set ? "ON" : "OFF");
	  break;

	case 1:
	  sprintf (s[x], "%s%d", glopts[x].menu, *glopts[x].set);
	  break;

	case 2:
	  strcpy (s[x], glopts[x].menu);
	  break;

	case 4:
	  sprintf (s[x], "%s%s", glopts[x].menu,
		   *(int *) ((char *) &bw->o +
			     glopts[x].ofst) ? "ON" : "OFF");
	  break;

	case 5:
	  sprintf (s[x], "%s%d", glopts[x].menu,
		   *(int *) ((char *) &bw->o + glopts[x].ofst));
	  break;

	case 7:
	  sprintf (s[x], "%s%d", glopts[x].menu,
		   *(int *) ((char *) &bw->o + glopts[x].ofst) + 1);
	  break;
	}
    }
  s[x] = 0;
  if (mkmenu (bw, s, doopt, doabrt, NULL, optx, s, NULL))
    return 0;
  else
    return -1;
d767 10
a776 11
int procrc (cap, name)
     CAP *cap;
     char *name;
{
  OPTIONS *o = 0;		/* Current options */
  KMAP *context = 0;		/* Current context */
  unsigned char buf[1024];	/* Input buffer */
  FILE *fd;			/* rc file */
  int line = 0;			/* Line number */
  int err = 0;			/* Set to 1 if there was a syntax error */
  ossep (strcpy (buf, name));
d778 1
a778 1
  fd = fopen (buf, "rt");
d780 1
a780 1
  fd = fopen (buf, "r");
d783 2
a784 2
  if (!fd)
    return -1;			/* Return if we couldn't open the rc file */
d786 2
a787 2
  fprintf (stderr, "Processing '%s'...", name);
  fflush (stderr);
d789 2
a790 109
  while (++line, fgets (buf, 1024, fd))
    switch (buf[0])
      {
      case ' ':
      case '\t':
      case '\n':
      case '\f':
      case 0:
	break;			/* Skip comment lines */

      case '*':		/* Select file types for file-type dependant options */
	{
	  int x;
	  o = (OPTIONS *) malloc (sizeof (OPTIONS));
	  *o = fdefault;
	  for (x = 0;
	       buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t';
	       ++x);
	  buf[x] = 0;
	  o->next = options;
	  options = o;
	  o->name = strdup (buf);
	}
	break;

      case '-':		/* Set an option */
	{
	  unsigned char *opt = buf + 1;
	  int x;
	  unsigned char *arg = 0;
	  for (x = 0;
	       buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t';
	       ++x);
	  if (buf[x] && buf[x] != '\n')
	    {
	      buf[x] = 0;
	      for (arg = buf + ++x; buf[x] && buf[x] != '\n'; ++x);
	    }
	  buf[x] = 0;
	  if (!glopt (opt, arg, o, 2))
	    {
	      err = 1;
	      fprintf (stderr, "\n%s %d: Unknown option %s", name, line, opt);
	    }
	}
	break;

      case '{':		/* Enter help text */
	{
	  int bfl;
	  struct help *tmp = (struct help *) malloc (sizeof (struct help));
	  tmp->next = help_first;
	  help_first = tmp;
	  tmp->name = vsncpy (NULL, 0, sz (buf + 1) - 1);
	  help_names = vaadd (help_names, tmp->name);
	  tmp->hlptxt = 0;
	  tmp->hlpsiz = 0;
	  tmp->hlpbsz = 0;
	  tmp->hlplns = 0;
	up:
	  if (++line, !fgets (buf, 256, fd))
	    {
	      err = 1;
	      fprintf (stderr,
		       "\n%s %d: End of joerc file occured before end of help text",
		       name, line);
	      break;
	    }
	  if (buf[0] == '}')
	    {
	      if (!hlptxt)
		hlptxt = tmp->hlptxt,
		  hlpsiz = tmp->hlpsiz,
		  hlpbsz = tmp->hlpbsz, hlplns = tmp->hlplns;
	      continue;
	    }
	  bfl = strlen (buf);
	  if (tmp->hlpsiz + bfl > tmp->hlpbsz)
	    {
	      if (tmp->hlptxt)
		tmp->hlptxt =
		  (char *) realloc (tmp->hlptxt, tmp->hlpbsz + bfl + 1024);
	      else
		tmp->hlptxt = (char *) malloc (bfl + 1024), tmp->hlptxt[0] =
		  0;
	      tmp->hlpbsz += bfl + 1024;
	    }
	  strcpy (tmp->hlptxt + tmp->hlpsiz, buf);
	  tmp->hlpsiz += bfl;
	  ++tmp->hlplns;
	  goto up;
	}
	break;

      case ':':		/* Select context */
	{
	  int x, c;
	  for (x = 1; !isspace_eof (buf[x]); ++x);
	  c = buf[x];
	  buf[x] = 0;
	  if (x != 1)
	    if (!strcmp (buf + 1, "def"))
	      {
		int y;
		for (buf[x] = c; isblank (buf[x]); ++x);
		for (y = x; !isspace_eof (buf[y]); ++y);
		c = buf[y];
		buf[y] = 0;
		if (y != x)
d792 356
a1147 10
		    int sta;
		    MACRO *m;
		    if (isblank (c) && (m = mparse (NULL, buf + y + 1, &sta)))
		      addcmd (buf + x, m);
		    else
		      {
			err = 1;
			fprintf (stderr, "\n%s %d: macro missing from :def",
				 name, line);
		      }
d1149 7
a1155 139
		else
		  {
		    err = 1;
		    fprintf (stderr,
			     "\n%s %d: command name missing from :def", name,
			     line);
		  }
	      }
	    else if (!strcmp (buf + 1, "inherit"))
	      if (context)
		{
		  for (buf[x] = c; isblank (buf[x]); ++x);
		  for (c = x; !isspace_eof (buf[c]); ++c);
		  buf[c] = 0;
		  if (c != x)
		    kcpy (context, getcontext (buf + x));
		  else
		    {
		      err = 1;
		      fprintf (stderr,
			       "\n%s %d: context name missing from :inherit",
			       name, line);
		    }
		}
	      else
		{
		  err = 1;
		  fprintf (stderr,
			   "\n%s %d: No context selected for :inherit", name,
			   line);
		}
	    else if (!strcmp (buf + 1, "include"))
	      {
		for (buf[x] = c; isblank (buf[x]); ++x);
		for (c = x; !isspace_eof (buf[c]); ++c);
		buf[c] = 0;
		if (c != x)
		  {
		    switch (procrc (buf + x))
		      {
		      case 1:
			err = 1;
			break;
		      case -1:
			fprintf (stderr, "\n%s %d: Couldn't open %s", name,
				 line, buf + x);
			err = 1;
			break;
		      }
		    context = 0;
		    o = 0;
		  }
		else
		  {
		    err = 1;
		    fprintf (stderr, "\n%s %d: :include missing file name",
			     name, line);
		  }
	      }
	    else if (!strcmp (buf + 1, "delete"))
	      if (context)
		{
		  int y;
		  for (buf[x] = c; isblank (buf[x]); ++x);
		  for (y = x;
		       buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n'
		       && (buf[y] != ' ' || buf[y + 1] != ' '); ++y);
		  buf[y] = 0;
		  kdel (context, buf + x);
		}
	      else
		{
		  err = 1;
		  fprintf (stderr, "\n%s %d: No context selected for :delete",
			   name, line);
		}
	    else
	      context = getcontext (buf + 1);
	  else
	    {
	      err = 1;
	      fprintf (stderr, "\n%s %d: Invalid context name", name, line);
	    }
	}
	break;

      default:			/* Get key-sequence to macro binding */
	{
	  int x, y, c;
	  MACRO *m;
	  if (!context)
	    {
	      err = 1;
	      fprintf (stderr,
		       "\n%s %d: No context selected for macro to key-sequence binding",
		       name, line);
	      break;
	    }

	  m = 0;
	macroloop:
	  m = mparse (m, buf, &x);
	  if (x == -1)
	    {
	      err = 1;
	      fprintf (stderr, "\n%s %d: Unknown command in macro", name,
		       line);
	      break;
	    }
	  else if (x == -2)
	    {
	      fgets (buf, 1024, fd);
	      goto macroloop;
	    }
	  if (!m)
	    break;

	  /* Skip to end of key sequence */
	  for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' &&
	       (buf[y] != ' ' || buf[y + 1] != ' '); ++y);
	  buf[y] = 0;

	  /* Add binding to context */
	  if (kadd (cap, context, buf + x, m) == -1)
	    {
	      fprintf (stderr, "\n%s %d: Bad key sequence '%s'", name, line,
		       buf + x);
	      err = 1;
	    }
	}
	break;
      }
  fclose (fd);			/* Close rc file */

  /* Print proper ending string */
  if (err)
    fprintf (stderr, "\ndone\n");
  else
    fprintf (stderr, "done\n");
d1157 1
a1157 1
  return err;			/* 0 for success, 1 for syntax error */
@


1.3
log
@changed as of joe-2.9.4
@
text
@d12 1
a12 1
#include "zstr.h"
@


1.2
log
@changed as of joe-2.9.2
@
text
@d1 7
a7 1
/* rc file parser */
d29 7
a35 6
static struct context
 {
 struct context *next;
 char *name;
 KMAP *kmap;
 } *contexts=0;		/* List of named contexts */
d41 2
a42 11
KMAP *getcontext(name)
char *name;
 {
 struct context *c;
 for(c=contexts;c;c=c->next) if(!strcmp(c->name,name)) return c->kmap;
 c=(struct context *)malloc(sizeof(struct context));
 c->next=contexts;
 c->name=strdup(name);
 contexts=c;
 return c->kmap=mkkmap();
 }
d44 11
a54 1
OPTIONS *options=0;
d56 2
a57 3
           nobackups, lightoff, exask, skiptop, noxon, lines, staen,
           columns, Baud, dopadding, orphan, marking, beep, keepup,
           nonotice;
d61 2
a62 6
OPTIONS pdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };

OPTIONS fdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
   " %S Ctrl-K H for help", 0, 0, 0, 0, 1, 0, 0, 0, 0 };
d64 3
a66 2
OPTIONS pdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d68 2
a69 4
OPTIONS fdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
   " %S Ctrl-K H for help", 0, 0, 0, 0, 0, 0, 0, 0, 0 };
#endif
d71 7
a77 13
void setopt(n,name)
OPTIONS *n;
char *name;
 {
 OPTIONS *o;
 for(o=options;o;o=o->next)
  if(rmatch(o->name,name))
   {
   *n= *o;
   return;
   }
 *n=fdefault;
 }
d85 545
a629 215
struct glopts
 {
 char *name;	/* Option name */
 int type;	/* 0 for global option flag
                   1 for global option numeric
                   2 for global option string
                   4 for local option flag
                   5 for local option numeric
                   6 for local option string
                   7 for local option numeric+1
                */
 int *set;	/* Address of global option */
 char *addr;	/* Local options structure member address */
 char *yes;	/* Message if option was turned on, or prompt string */
 char *no;	/* Message if option was turned off */
 char *menu;	/* Menu string */
 int ofst;	/* Local options structure member offset */
 int low;	/* Low limit for numeric options */
 int high;	/* High limit for numeric options */
 } glopts[]=
 {
  {"overwrite", 4, 0, (char *)&fdefault.overtype,
   "Overtype mode",
   "Insert mode",
   "T Overtype "},

  {"autoindent", 4, 0, (char *)&fdefault.autoindent,
   "Autoindent enabled",
   "Autindent disabled",
   "I Autoindent "},

  {"wordwrap", 4, 0, (char *)&fdefault.wordwrap,
   "Wordwrap enabled",
   "Wordwrap disabled",
   "Word wrap "},

  {"tab", 5, 0, (char *)&fdefault.tab,
   "Tab width (%d): ",
   0,
   "D Tab width ",0,1,64},

  {"lmargin", 7, 0, (char *)&fdefault.lmargin,
   "Left margin (%d): ",
   0,
   "Left margin ",0,0,63},

  {"rmargin", 7, 0, (char *)&fdefault.rmargin,
   "Right margin (%d): ",
   0,
   "Right margin ",0,7,255},

  {"square", 0, &square, 0,
   "Rectangle mode",
   "Text-stream mode",
   "X Rectangle mode " },

  {"indentc", 5, 0, (char *)&fdefault.indentc,
   "Indent char %d (SPACE=32, TAB=9, ^C to abort): ",
   0,
   " Indent char ",0,0,255},

  {"istep", 5, 0, (char *)&fdefault.istep,
   "Indent step %d (^C to abort): ",
   0,
   " Indent step ",0,1,64},

  {"french", 4, 0, (char *)&fdefault.french,
   "One space after periods for paragraph reformat",
   "Two spaces after periods for paragraph reformat",
   " french spacing "},

  {"spaces", 4, 0, (char *)&fdefault.spaces,
   "Inserting spaces when tab key is hit",
   "Inserting tabs when tab key is hit",
   " no tabs "},

  {"mid", 0, &mid, 0,
   "Cursor will be recentered on scrolls",
   "Cursor will not be recentered on scroll",
   "Center on scroll " },

  {"crlf", 4, 0, (char *)&fdefault.crlf,
   "CR-LF is line terminator",
   "LF is line terminator",
   "Z CR-LF (MS-DOS) "},

  {"linums", 4, 0, (char *)&fdefault.linums,
   "Line numbers enabled",
   "Line numbers disabled",
   "N Line numbers "},

  {"marking", 0, &marking, 0,
   "Anchored block marking on",
   "Anchored block marking off",
   "Marking " },

  {"asis", 0, &dspasis, 0,
   "Characters above 127 shown as-is",
   "Characters above 127 shown in inverse",
   "Meta chars as-is "
    },

  {"force", 0, &force, 0,
   "Last line forced to have NL when file saved",
   "Last line not forces to have NL",
   "Force last NL " },

  {"nobackups", 0, &nobackups, 0,
   "Backup files will not be made",
   "Backup files will be made",
   " Disable backups " },

  {"lightoff", 0, &lightoff, 0,
   "Highlighting turned off after block operations",
   "Highlighting not turned off after block operations",
   "Auto unmark " },

  {"exask", 0, &exask, 0,
   "Prompt for filename in save & exit command",
   "Don't prompt for filename in save & exit command",
   "Exit ask "},

  {"beep", 0, &beep, 0,
   "Warning bell enabled", 
   "Warning bell disabled",
   "Beeps " },

  {"nosta", 0, &staen, 0,
   "Top-most status line disabled",
   "Top-most status line enabled",
   " Disable status line " },

  {"keepup", 0, &keepup, 0,
   "Status line updated constantly",
   "Status line updated once/sec",
   " Fast status line " },

  {"pg", 1, &pgamnt, 0,
   "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ",
   0,
   " No. PgUp/PgDn lines ", 0, -1, 64 },

  {"csmode", 0, &csmode, 0,
   "Start search after a search repeats previous search",
   "Start search always starts a new search",
   "Continued search " },

  {"rdonly", 4, 0, (char *)&fdefault.readonly,
   "Read only",
   "Full editing",
   "O Read only "},

  {"backpath", 2, (int *)&backpath, 0,
   "Backup files stored in (%s): ",
   0,
   "Path to backup files " },

  {"nonotice", 0, &nonotice, 0,
   0, 0, 0 },

  {"noxon", 0, &noxon, 0,
   0, 0, 0 },

  {"orphan", 0, &orphan, 0,
   0, 0, 0 },

  {"help", 0, &help, 0,
   0, 0, 0 },

  {"dopadding", 0, &dopadding, 0,
   0, 0, 0 },

  {"lines", 1, &lines, 0,
   0, 0, 0, 0, 2, 1024 },

  {"baud", 1, &Baud, 0,
   0, 0, 0, 0, 50, 32767 }, 

  {"columns", 1, &columns, 0,
   0, 0, 0, 0, 2, 1024 },

  {"skiptop", 1, &skiptop, 0,
   0, 0, 0, 0, 0, 64 }, 

  { 0, 0, 0 }
 };

int isiz=0;

void izopts()
 {
 int x;
 for(x=0;glopts[x].name;++x)
  switch(glopts[x].type)
   {
   case 4: case 5: case 6: case 7: case 8:
   glopts[x].ofst=glopts[x].addr-(char *)&fdefault;
   }
 isiz=1;
 }

int glopt(s,arg,options,set)
char *s, *arg;
OPTIONS *options;
 {
 int val;
 int ret=0;
 int st=1;
 int x;
 if(!isiz) izopts();
 if(s[0]=='-') st=0, ++s;
 for(x=0;glopts[x].name;++x)
  if(!strcmp(glopts[x].name,s))
   {
   switch(glopts[x].type)
d631 32
a662 46
    case 0: if(set) *glopts[x].set=st;
    break;
    
    case 1: if(set && arg)
             {
             sscanf(arg,"%d",&val);
             if(val>=glopts[x].low && val<=glopts[x].high) *glopts[x].set=val;
             }
    break;

    case 2: if(set)
             if(arg) *(char **)glopts[x].set=strdup(arg);
             else *(char **)glopts[x].set=0;
    break;

    case 4: if(options) *(int *)((char *)options+glopts[x].ofst)=st;
            else if(set==2) *(int *)((char *)&fdefault+glopts[x].ofst)=st;
    break;
    
    case 5: if(arg)
             if(options)
              {
              sscanf(arg,"%d",&val);
              if(val>=glopts[x].low && val<=glopts[x].high)
               *(int *)((char *)options+glopts[x].ofst)=val;
              }
             else if(set==2)
              {
              sscanf(arg,"%d",&val);
              if(val>=glopts[x].low && val<=glopts[x].high)
               *(int *)((char *)&fdefault+glopts[x].ofst)=val;
              }
    break;

    case 7: if(arg)
             {
             int zz=0;
             sscanf(arg,"%d",&zz);
             if(zz>=glopts[x].low && zz <=glopts[x].high)
              {
              --zz;
              if(options) *(int *)((char *)options+glopts[x].ofst)=zz;
              else if(set==2) *(int *)((char *)&fdefault+glopts[x].ofst)=zz;
              }
             }
    break;
d664 6
a669 243
   if((glopts[x].type&3)==0 || !arg) return 1;
   else return 2;
   }
 if(!strcmp(s,"lmsg"))
  {
  if(arg)
   {
   if(options) options->lmsg=strdup(arg);
   else if(set==2) fdefault.lmsg=strdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"rmsg"))
  {
  if(arg)
   {
   if(options) options->rmsg=strdup(arg);
   else if(set==2) fdefault.rmsg=strdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"keymap"))
  {
  if(arg)
   {
   int y;
   for(y=0;!isspace(arg[y]);++y);
   if(!arg[y]) arg[y]=0;
   if(options && y) options->context=strdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"mnew"))
  {
  if(arg)
   {
   int sta;
   if(options) options->mnew=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.mnew=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"mold"))
  {
  if(arg)
   {
   int sta;
   if(options) options->mold=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.mold=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"msnew"))
  {
  if(arg)
   {
   int sta;
   if(options) options->msnew=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.msnew=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!strcmp(s,"msold"))
  {
  if(arg)
   {
   int sta;
   if(options) options->msold=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.msold=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 done: return ret;
 }

static int optx=0;

int doabrt1(bw,xx)
BW *bw;
int *xx;
 {
 free(xx);
 return -1;
 }

int doopt1(bw,s,xx,notify)
BW *bw;
char *s;
int *xx;
int *notify;
 {
 int ret=0;
 int x= *xx;
 int v;
 free(xx);
 switch(glopts[x].type)
  {
  case 1:
   v=calc(bw,s);
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *glopts[x].set=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  case 2: if(s[0]) *(char **)glopts[x].set=strdup(s); break;
  case 5:
   v=calc(bw,s);
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *(int *)((char *)&bw->o+glopts[x].ofst)=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  case 7:
   v=calc(bw,s)-1.0;
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *(int *)((char *)&bw->o+glopts[x].ofst)=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  }
 vsrm(s);
 bw->b->o=bw->o;
 wfit(bw->parent->t);
 updall();
 if(notify) *notify=1;
 return ret;
 }

int doopt(m,x,object,flg)
MENU *m;
void *object;
 {
 BW *bw=m->parent->win->object;
 int *xx;
 char buf[80];
 int *notify=m->parent->notify;
 switch(glopts[x].type)
  {
  case 0:
  if(!flg) *glopts[x].set= !*glopts[x].set;
  else if(flg==1) *glopts[x].set= 1;
  else *glopts[x].set=0;
  uabort(m,MAXINT);
  msgnw(bw,*glopts[x].set?glopts[x].yes:glopts[x].no);
  break;

  case 4:
  if(!flg) *(int *)((char *)&bw->o+glopts[x].ofst)= !*(int *)((char *)&bw->o+glopts[x].ofst);
  else if(flg==1) *(int *)((char *)&bw->o+glopts[x].ofst)=1;
  else *(int *)((char *)&bw->o+glopts[x].ofst)=0;
  uabort(m,MAXINT);
  msgnw(bw,*(int *)((char *)&bw->o+glopts[x].ofst)?glopts[x].yes:glopts[x].no);
  if(glopts[x].ofst==(char *)&fdefault.readonly-(char *)&fdefault)
   bw->b->rdonly=bw->o.readonly;
  break;

  case 1:
  sprintf(buf,glopts[x].yes,*glopts[x].set);
  xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;

  case 2:
  if(*(char **)glopts[x].set) sprintf(buf,glopts[x].yes,*(char **)glopts[x].set);
  else sprintf(buf,glopts[x].yes,"");
  xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;

  case 5:
  sprintf(buf,glopts[x].yes,*(int *)((char *)&bw->o+glopts[x].ofst));
  goto in;
  
  case 7:
  sprintf(buf,glopts[x].yes,*(int *)((char *)&bw->o+glopts[x].ofst)+1);
  in: xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;
  }
 if(notify) *notify=1;
 bw->b->o=bw->o;
 wfit(bw->parent->t);
 updall();
 return 0;
 }

int doabrt(m,x,s)
MENU *m;
char **s;
 {
 optx=x;
 for(x=0;s[x];++x) free(s[x]);
 free(s);
 return -1;
 }

int umode(bw)
BW *bw;
 {
 int size;
 char **s;
 int x;
 bw->b->o.readonly=bw->o.readonly=bw->b->rdonly;
 for(size=0;glopts[size].menu;++size);
 s=(char **)malloc(sizeof(char *)*(size+1));
 for(x=0;x!=size;++x)
  {
  s[x]=(char *)malloc(40);
  switch(glopts[x].type)
   {
   case 0: sprintf(s[x],"%s%s",glopts[x].menu,*glopts[x].set?"ON":"OFF");
   break;
   
   case 1: sprintf(s[x],"%s%d",glopts[x].menu,*glopts[x].set);
   break;

   case 2: strcpy(s[x],glopts[x].menu);
   break;

   case 4: sprintf(s[x],"%s%s",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst)?"ON":"OFF");
   break;
   
   case 5: sprintf(s[x],"%s%d",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst));
   break;

   case 7: sprintf(s[x],"%s%d",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst)+1);
   break;
   }
  }
 s[x]=0;
 if(mkmenu(bw,s,doopt,doabrt,NULL,optx,s,NULL)) return 0;
 else return -1;
 }
d678 11
a688 13
int nhelp=0;			/* No. help screens so far */

int procrc(cap,name)
CAP *cap;
char *name;
 {
 OPTIONS *o=0;			/* Current options */
 KMAP *context=0;		/* Current context */
 unsigned char buf[1024];	/* Input buffer */
 FILE *fd;			/* rc file */
 int line=0;			/* Line number */
 int err=0;			/* Set to 1 if there was a syntax error */
 ossep(strcpy(buf,name));
d690 1
a690 1
 fd=fopen(buf,"rt");
d692 1
a692 1
 fd=fopen(buf,"r");
a693 10
 
 if(!fd) return -1;		/* Return if we couldn't open the rc file */
 
 fprintf(stderr,"Processing '%s'...",name); fflush(stderr);
 
 while(++line, fgets(buf,1024,fd))
  switch(buf[0])
   {
   case ' ': case '\t': case '\n': case '\f': case 0:
   break;	/* Skip comment lines */
d695 5
a699 75
   case '*':	/* Select file types for file-type dependant options */
    {
    int x;
    o=(OPTIONS *)malloc(sizeof(OPTIONS));
    *o=fdefault;
    for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
    buf[x]=0;
    o->next=options;
    options=o;
    o->name=strdup(buf);
    }
   break;
   
   case '-':	/* Set an option */
    {
    unsigned char *opt=buf+1;
    int x;
    unsigned char *arg=0;
    for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
    if(buf[x] && buf[x]!='\n')
     {
     buf[x]=0;
     for(arg=buf+ ++x;buf[x] && buf[x]!='\n';++x);
     }
    buf[x]=0;
    if(!glopt(opt,arg,o,2))
     {
     err=1;
     fprintf(stderr,"\n%s %d: Unknown option %s",name,line,opt);
     }
    }
   break;
   
   case '{':	/* Enter help text */
    {
    int bfl;
    struct help *tmp=(struct help *)malloc(sizeof(struct help));
    nhelp++;
    tmp->next=first_help;
    first_help=tmp;
    tmp->name=vsncpy(NULL,0,sz(buf+1)-1);
    help_names=vaadd(help_names,tmp->name);
    tmp->hlptxt=0;
    tmp->hlpsiz=0;
    tmp->hlpbsz=0;
    tmp->hlplns=0;
    up:
    if(++line, !fgets(buf,256,fd))
     {
     err=1;
     fprintf(stderr,"\n%s %d: End of joerc file occured before end of help text",name,line);
     break;
     }
    if(buf[0]=='}')
     {
     if(!hlptxt)
      hlptxt=tmp->hlptxt,
      hlpsiz=tmp->hlpsiz,
      hlpbsz=tmp->hlpbsz,
      hlplns=tmp->hlplns;
     continue;
     }
    bfl=strlen(buf);
    if(tmp->hlpsiz+bfl>tmp->hlpbsz)
     {
     if(tmp->hlptxt) tmp->hlptxt=(char *)realloc(tmp->hlptxt,tmp->hlpbsz+bfl+1024);
     else tmp->hlptxt=(char *)malloc(bfl+1024), tmp->hlptxt[0]=0;
     tmp->hlpbsz+=bfl+1024;
     }
    strcpy(tmp->hlptxt+tmp->hlpsiz,buf);
    tmp->hlpsiz+=bfl;
    ++tmp->hlplns;
    goto up;
    }
   break;
d701 2
a702 7
   case ':':	/* Select context */
    {
    int x, c;
    for(x=1;!cwhitef(buf[x]);++x);
    c=buf[x]; buf[x]=0;
    if(x!=1)
     if(!strcmp(buf+1,"def"))
d704 249
a952 21
      int y;
      for(buf[x]=c;isblank(buf[x]);++x);
      for(y=x;!cwhitef(buf[y]);++y);
      c=buf[y]; buf[y]=0;
      if(y!=x)
       {
       int sta;
       MACRO *m;
       if(isblank(c) && (m=mparse(NULL,buf+y+1,&sta)))
        addcmd(buf+x,m);
       else
        {
        err=1;
        fprintf(stderr,"\n%s %d: macro missing from :def",name,line);
        }
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: command name missing from :def",name,line);
       }
d954 7
a960 63
     else if(!strcmp(buf+1,"inherit"))
      if(context)
       {
       for(buf[x]=c;isblank(buf[x]);++x);
       for(c=x;!cwhitef(buf[c]);++c);
       buf[c]=0;
       if(c!=x) kcpy(context,getcontext(buf+x));
       else
        {
        err=1;
        fprintf(stderr,"\n%s %d: context name missing from :inherit",name,line);
        }
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: No context selected for :inherit",name,line);
       }
     else if(!strcmp(buf+1,"include"))
      {
      for(buf[x]=c;isblank(buf[x]);++x);
      for(c=x;!cwhitef(buf[c]);++c);
      buf[c]=0;
      if(c!=x)
       {
       switch(procrc(buf+x))
        {
        case 1: err=1; break;
        case -1: fprintf(stderr,"\n%s %d: Couldn't open %s",name,line,buf+x);
                 err=1; break;
        }
       context=0;
       o=0;
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: :include missing file name",name,line);
       }
      }
     else if(!strcmp(buf+1,"delete"))
      if(context)
       {
       int y;
       for(buf[x]=c;isblank(buf[x]);++x);
       for(y=x;buf[y]!=0 && buf[y]!='\t' && buf[y]!='\n' &&
               (buf[y]!=' ' || buf[y+1]!=' ');++y);
       buf[y]=0;
       kdel(context,buf+x);
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: No context selected for :delete",name,line);
       }
     else context=getcontext(buf+1);
    else
     {
     err=1;
     fprintf(stderr,"\n%s %d: Invalid context name",name,line);
     }
    }
   break;
d962 2
a963 66
   default:	/* Get key-sequence to macro binding */
    {
    int x, y, c;
    MACRO *m;
    if(!context)
     {
     err=1;
     fprintf(stderr,"\n%s %d: No context selected for macro to key-sequence binding",name,line);
     break;
     }

    m=0;
    macroloop:
    m=mparse(m,buf,&x);
    if(x== -1)
     {
     err=1;
     fprintf(stderr,"\n%s %d: Unknown command in macro",name,line);
     break;
     }
    else if(x== -2)
     {
     fgets(buf,1024,fd);
     goto macroloop;
     }
    if(!m) break;

    /* Skip to end of key sequence */
    for(y=x;buf[y]!=0 && buf[y]!='\t' && buf[y]!='\n' && 
            (buf[y]!=' ' || buf[y+1]!=' ');++y);
    buf[y]=0;

    /* Add binding to context */
    if(kadd(cap,context,buf+x,m)== -1)
     {
     fprintf(stderr,"\n%s %d: Bad key sequence '%s'",name,line,buf+x);
     err=1;
     }
    }
   break;
   }
 fclose(fd);			/* Close rc file */

 /* Print proper ending string */
 if(err) fprintf(stderr,"\ndone\n");
 else fprintf(stderr,"done\n");

 return err;			/* 0 for success, 1 for syntax error */
 }

void izhelp()
 {
 struct help *tmp;
 /* Convert list of help screens into an array */
 if(nhelp)
  {
  help_structs=(struct help **) malloc(sizeof(struct help *)*(nhelp+1));
  help_structs[nhelp]=0;
  tmp=first_help;
  while(nhelp--)
   {
   help_structs[nhelp]=tmp;
   tmp=tmp->next;
   }
  }
 }
@


1.1
log
@Initial revision
@
text
@d4 2
d38 1
a38 1
 for(c=contexts;c;c=c->next) if(!zcmp(c->name,name)) return c->kmap;
d41 1
a41 1
 c->name=zdup(name);
d301 1
a301 1
  if(!zcmp(glopts[x].name,s))
d316 1
a316 1
             if(arg) *(char **)glopts[x].set=zdup(arg);
d355 1
a355 1
 if(!zcmp(s,"lmsg"))
d359 2
a360 2
   if(options) options->lmsg=zdup(arg);
   else if(set==2) fdefault.lmsg=zdup(arg);
d365 1
a365 1
 else if(!zcmp(s,"rmsg"))
d369 2
a370 2
   if(options) options->rmsg=zdup(arg);
   else if(set==2) fdefault.rmsg=zdup(arg);
d375 1
a375 1
 else if(!zcmp(s,"keymap"))
d380 1
a380 1
   for(y=0;!cwhitel(arg[y]);++y);
d382 1
a382 1
   if(options && y) options->context=zdup(arg);
d387 1
a387 1
 else if(!zcmp(s,"mnew"))
d398 1
a398 1
 else if(!zcmp(s,"mold"))
d409 1
a409 1
 else if(!zcmp(s,"msnew"))
d420 1
a420 1
 else if(!zcmp(s,"msold"))
d462 1
a462 1
  case 2: if(s[0]) *(char **)glopts[x].set=zdup(s); break;
d578 1
a578 1
   case 2: zcpy(s[x],glopts[x].menu);
d615 1
a615 1
 ossep(zcpy(buf,name));
d641 1
a641 1
    o->name=zdup(buf);
d694 1
a694 1
    bfl=zlen(buf);
d701 1
a701 1
    zcpy(tmp->hlptxt+tmp->hlpsiz,buf);
d714 1
a714 1
     if(!zcmp(buf+1,"def"))
d717 1
a717 1
      for(buf[x]=c;cwhite(buf[x]);++x);
d724 1
a724 1
       if(cwhite(c) && (m=mparse(NULL,buf+y+1,&sta)))
d738 1
a738 1
     else if(!zcmp(buf+1,"inherit"))
d741 1
a741 1
       for(buf[x]=c;cwhite(buf[x]);++x);
d756 1
a756 1
     else if(!zcmp(buf+1,"include"))
d758 1
a758 1
      for(buf[x]=c;cwhite(buf[x]);++x);
d778 1
a778 1
     else if(!zcmp(buf+1,"delete"))
d782 1
a782 1
       for(buf[x]=c;cwhite(buf[x]);++x);
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
