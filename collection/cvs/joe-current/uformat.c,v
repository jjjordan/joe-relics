head	1.43;
access;
symbols
	joe_3_5:1.32
	joe-3_4:1.27
	help:1.27
	joe_3_1:1.18
	joe_3_0:1.16
	joe_2_9_8:1.14
	joe_2_9_8_pre1:1.10
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2010.04.24.14.05.44;	author jhallen;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.27.15.41.06;	author jhallen;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.26.23.34.41;	author jhallen;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.26.18.05.46;	author jhallen;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.26.16.33.59;	author jhallen;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.26.02.29.30;	author jhallen;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.25.04.08.47;	author jhallen;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.24.23.40.47;	author jhallen;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.24.23.25.07;	author jhallen;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.24.16.24.40;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.18.23.28.56;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.18.19.32.08;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.15.18.26.33;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.30.18.08.31;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.30.12.57.13;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.05.14.46.18;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.26.05.14.42;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.16.35.12;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.03.22.55.53;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.14.17.09.48;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.17.13.51.00;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.21.11.23.05;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.13.15.18.24;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.17;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Fix bug where hitting '-' until word wrap caused segfault.
@
text
@/*
 *	User text formatting functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

/* Center line cursor is on and move cursor to beginning of next line */

int ucenter(BW *bw)
{
	P *p = bw->cursor, *q;
	long endcol, begcol, x;
	int c;

	p_goto_eol(p);
	while (joe_isblank(bw->b->o.charmap, (c = prgetc(p))))
		/* do nothing */;
	if (c == '\n') {
		pgetc(p);
		goto done;
	}
	if (c == NO_MORE_DATA)
		goto done;
	pgetc(p);
	endcol = piscol(p);

	p_goto_bol(p);
	while (joe_isblank(bw->b->o.charmap, (c = pgetc(p))))
		/* do nothing */;
	if (c == '\n') {
		prgetc(p);
		goto done;
	}
	if (c == NO_MORE_DATA)
		goto done;
	prgetc(p);
	begcol = piscol(p);

	if (endcol - begcol > bw->o.rmargin + bw->o.lmargin)
		goto done;

	q = pdup(p, USTR "ucenter");
	p_goto_bol(q);
	bdel(q, p);
	prm(q);

	for (x = 0; x != (bw->o.lmargin + bw->o.rmargin) / 2 - (endcol - begcol) / 2; ++x)
		binsc(p, ' ');

      done:
	if (!pnextl(p)) {
		binsc(p, '\n');
		pgetc(p);
		return -1;
	} else
		return 0;
}

/* Return true if c is a character which can indent a paragraph */

/*   > is for mail/news
 *   * is for C comments
 *   / is for C++ comments
 *   # is for shell script comments
 *   % is for TeX comments
 */

static int cpara(BW *bw, int c)
{
	int x;
	if (c == ' ' || c == '\t')
		return 1;
	if (bw->o.cpara)
		for (x = 0; bw->o.cpara[x]; ++x)
			if (bw->o.cpara[x] == c)
				return 1;
	return 0;
#ifdef junk
	if (c == ' ' || c == '\t' || c == '\\' ||
	    c == '>' || c == '|' || c == ':' || c == '*' || c == '/' ||
	    c == ',' || c == '.' || c == '?' || c == ';' || c == ']' ||
	    c == '}' || c == '=' || c == '+' || c == '-' || c == '_' ||
	    c == ')' || c == '&' || c == '^' || c == '%' || c == '$' ||
	    c == '#' || c == '@@' || c == '!' || c == '~')
		return 1;
	else
		return 0;
#endif
}

/* Return true if line is definitly not a paragraph line.
 * Lines which arn't paragraph lines:
 *  1) Blank lines
 *  2) Lines which begin with '.'
 */

static int pisnpara(BW *bw, P *p)
{
	P *q;
	int c;

	q = pdup(p, USTR "pisnpara");
	p_goto_bol(q);
	while (cpara(bw, c = pgetc(q)))
		/* do nothing */;
	prm(q);
	if (c == '.' || c == '\r' || c == '\n')
		return 1;
	else
		return 0;
}

/* Determine amount of indentation on current line.  Set first
   to include '-' and '*' bullets. */

static long nindent(BW *bw, P *p, int first)
{
	P *q = pdup(p, USTR "nindent");
	long col;
	int c;

	p_goto_bol(q);
	do {
		col = q->col;
	} while (cpara(bw, (c = pgetc(q))));
	if (first && (c == '-' || c == '*')) {
		c = pgetc(q);
		if (c == ' ') {
			col = q->col;
		}
	}
	prm(q);
	return col;
}

/* Get indentation prefix column */

static long prefix(BW *bw, P *p,int up)
{
	long len;
	P *q = pdup(p, USTR "prefix");

	p_goto_bol(q);
	while (cpara(bw, brch(q)))
		pgetc(q);
	while (!pisbol(q)) {
		/* int c; */
		if (!joe_isblank(p->b->o.charmap, (/* c = */ prgetc(q)))) {
		/*
			if (up && (c == '*' || c == '-')) {
				if (!pisbol(q)) {
					c = prgetc(q);
					pgetc(q);
					if (c == ' ' || c == '\t')
						goto skip;
				} else
					goto skip;
			}
			pgetc(q);
		*/
			break;
		/* 	skip:; */
		}
	}
	len = piscol(q);
	prm(q);
	return len;
}

/* Move pointer to beginning of paragraph
 *
 * This function simply moves backwards until it sees:
 *  0) The beginning of the file
 *  1) A blank line
 *  2) A line with a different indentation prefix
 *  3) A line with indentation greater than that of the line we started with
 *  4) A line with indentation less than that of the starting line, but with
 *     a blank line (or beginning of file) preceeding it.
 */

int within = 0;

P *pbop(BW *bw, P *p)
{
	P *last;
	long indent;
	long prelen;

	p_goto_bol(p);
	last = pdup(p, USTR "pbop");
	indent = nindent(bw, p, 0);
	prelen = prefix(bw, p, 0);
	while (!pisbof(p) && (!within || !markb || p->byte > markb->byte)) {
		long ind;
		long len;

		pprevl(p);
		p_goto_bol(p);
		ind = nindent(bw, p, 0);
		len = prefix(bw, p, 0);
		if (pisnpara(bw, p) || len != prelen) {
			pset(p, last);
			break;
		}
		if (ind > indent) {
/*
			int ok = 1;
			P *q = pdup(p, USTR "pbop");
			if (pprevl(q)) {
				p_goto_bol(q);
				if (nindent(bw, q, 0) == ind)
					ok = 0;
			}
			prm(q);
			if (!ok)
				pnextl(p);
*/
			break;
		}
		if (ind < indent) {
			pset(p, last);
			break;
			/*
			if (pisbof(p)) {
				break;
			}
			pprevl(p);
			p_goto_bol(p);
			if (pisnpara(bw, p)) {
				pnextl(p);
				break;
			} else {
				pnextl(p);
				pnextl(p);
				break;
			} */
		}
		pset(last, p);
	}
	prm(last);
	return p;
}

/* Move pointer to end of paragraph.  Pointer must already be on first
 * line of paragraph for this to work correctly.
 *
 * This function moves forwards until it sees:
 *  0) The end of the file.
 *  1) A blank line
 *  2) A line with indentation different from the second line of the paragraph
 *  3) A line with prefix column different from first line
 */

P *peop(BW *bw, P *p)
{
	long indent;
	long prelen;

	if (!pnextl(p) || pisnpara(bw, p) || (within && markk && p->byte >= markk->byte))
		return p;
	indent = nindent(bw, p, 0);
	prelen = prefix(bw, p, 0);
	while (pnextl(p) && (!within || !markk || p->byte < markk->byte)) {
		long ind = nindent(bw, p, 0);
		long len = prefix(bw, p, 0);

		if (ind != indent || len != prelen || pisnpara(bw, p))
			break;
	}
	return p;
}

/* Motion commands */

int ubop(BW *bw)
{
	P *q = pdup(bw->cursor, USTR "ubop");

      up:
	while (pisnpara(bw, q) && !pisbof(q) && (!within || !markb || q->byte > markb->byte))
		pprevl(q);
	pbop(bw, q);
	if (q->byte != bw->cursor->byte) {
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else if (!pisbof(q)) {
		prgetc(q);
		goto up;
	} else {
		prm(q);
		return -1;
	}
}

int ueop(BW *bw)
{
	P *q = pdup(bw->cursor, USTR "ueop");

      up:
	while (pisnpara(bw, q) && !piseof(q))
		pnextl(q);
	pbop(bw, q);
	peop(bw, q);
	if (q->byte != bw->cursor->byte) {
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else if (!piseof(q)) {
		pnextl(q);
		goto up;
	} else {
		prm(q);
		return -1;
	}
}

/* Wrap word.  If 'french' is set, only one space will be placed
 * after . ? or !
 */

void wrapword(BW *bw, P *p, long int indent, int french, int no_over, unsigned char *indents)
{
	P *q;
	P *r;
	P *s;
	int rmf = 0;
	int c;
	long to = p->byte;
	int my_indents = 0;
	
	/* autoindent when called by utype */
	if (!indents) {
		/* Get indentation prefix from beginning of line */
		s = pdup(p, USTR "wrapword");
		p_goto_bol(s);
		pbop(bw, s);
		/* Record indentation of second line of paragraph, of first
		 * line if there is only one line */
		q = pdup(s, USTR "wrapword");
		pnextl(q);
		if (q->line < p->line) {
			/* Second line */
			P *r = pdup(q, USTR "wrapword");

			indent = nindent(bw, q, 0);
			pcol(r, indent);
			indents = brs(q, r->byte - q->byte);
			prm(r);
		} else {
			/* First line */
			P *r = pdup(s, USTR "uformat");
			int x, y;

			indent = nindent(bw, s, 1);
			pcol(r, indent);
			indents = brs(s, r->byte - s->byte);
			prm(r);
			if (!bw->o.autoindent) {
				/* Don't indent second line of single-line paragraphs if autoindent is off */
				int x = zlen(indents);
				int orgx;
				while (x && (indents[x - 1] == ' ' || indents[x - 1] == '\t'))
					indents[--x] = 0;
				if (x && x != orgx) {
					indents[x++] = ' ';
					indents[x] = 0;
				}
				indent = txtwidth1(bw->o.charmap, bw->o.tab, indents, x);
			}
			/* Don't duplicate if it looks like a bullet */
			for (x = 0; indents[x] && (indents[x] == ' ' || indents[x] == '\t'); ++x);
			y = zlen(indents);
			while (y && (indents[y - 1] == ' ' || indents[y - 1] == '\t'))
				--y;
			/* Don't duplicate bullet */
/*			if (y && (indents[y - 1] == '*' || indents[y - 1] == '-') &&
			    (y == 1 || indents[y - 2] == ' ' || indents[y - 2] == '\t'))
				indents[y - 1] = ' '; */
			/* Fix C comment */
			if (indents[x] == '/' && indents[x + 1] == '*')
				indents[x] = ' ';
		}
		if (bw->o.lmargin > indent) {
			int x;
			for (x = 0; indents[x] == ' ' || indents[x] == '\t'; ++x);
			if (!indents[x]) {
				joe_free(indents);
				indent = bw->o.lmargin;
				indents = joe_malloc(indent+1);
				for (x = 0; x != indent; ++x)
					indents[x] = ' ';
				indents[x] = 0;
			}
		}
		my_indents = 1;
		prm(q);
		prm(s);
	}


/*
	if(!indents) {
		int f = 0;
		P *r = pdup(p);

		p_goto_bol(r);
		q = pdup(r);
		while(cpara(c = brc(q))) {
			if(!joe_isblank(c))
				f = 1;
			pgetc(q);
		}
		if(f) {
			indents = brs(r, q->byte-r->byte);
			rmf = 1;
			if(indents[0] == '/' && indents[1] == '*')
				indents[0] = ' ';
		}
		prm(r);
		prm(q);
	}
*/

	/* Get to beginning of word */
	while (!pisbol(p) && piscol(p) > indent && !joe_isblank(p->b->o.charmap, prgetc(p)))
		/* do nothing */;

	/* If we found the beginning of a word... */
	if (!pisbol(p) && piscol(p) > indent) {
		/* Move q to two (or one if 'french' is set) spaces after end of previous
		   word */
		q = pdup(p, USTR "wrapword");
		while (!pisbol(q))
			if (!joe_isblank(p->b->o.charmap, (c = prgetc(q)))) {
				pgetc(q);
				if ((c == '.' || c == '?' || c == '!')
				    && q->byte != p->byte && !french)
					pgetc(q);
				break;
			}
		pgetc(p);

		/* Delete space between start of word and end of previous word */
		to -= p->byte - q->byte;
		bdel(q, p);
		prm(q);

		if (bw->o.flowed) {
			binsc(p, ' ');
			pgetc(p);
			++to;
		}

		/* Move word to beginning of next line */
		binsc(p, '\n');
		
		/* Take care that wordwrap is done the right way when overtype mode is active */
		if (!no_over && p->b->o.overtype) {
			/* delete the next line break which is unnecessary */
			r = pdup(p, USTR "wrapword");
			/* p_goto_eol(r); */
			pgetc(r);
			p_goto_eol(r);
			s = pdup(r, USTR "wrapword");
			pgetc(r);
			bdel(s,r);
			binsc(r, ' ');
			
			/* Now we got to take care that all subsequent lines are not longer than the right margin */
			/* Move cursor to right margin */
			pfwrd(r, r->b->o.rmargin - r->col);
			
			/* Make a copy of the cursor and move the copied cursor to the end of the line */
			prm(s);
			s = pdup(r, USTR "wrapword");
			p_goto_eol(s);
			
			/* If s is located behind r then the line goes beyond the right margin and we need to call wordwrap() for that line. */
/* for this to work properly we need to detect end of paragraph
			if (r->byte < s->byte){
				wrapword(bw, r, indent, french, 1, indents);
			}
*/			
			prm(r);
			prm(s);
		}
		
		++to;
		if (p->b->o.crlf)
			++to;
		pgetc(p);

		/* Indent to left margin */
		if (indents) {
			binss(p, indents);
			to += zlen(indents);
		} else
			while (indent--) {
				binsc(p, ' ');
				++to;
			}

		if (rmf)
			joe_free(indents);
	}

	/* Move cursor back to original position */
	pfwrd(p, to - p->byte);
	if (my_indents)
		joe_free(indents);
}

/* Reformat paragraph */

int uformat(BW *bw)
{
	long indent;
	unsigned char *indents;
	B *buf;
	P *b;
	long curoff;
	int c;
	P *p, *q;

	p = pdup(bw->cursor, USTR "uformat");
	p_goto_bol(p);

	/* Do nothing if we're not on a paragraph line */
	if (pisnpara(bw, p)) {
		prm(p);
		return 0;
	}

	/* Move p to beginning of paragraph, bw->cursor to end of paragraph and
	 * set curoff to original cursor offset within the paragraph */
	pbop(bw, p);
	curoff = bw->cursor->byte - p->byte;
	pset(bw->cursor, p);
	peop(bw, bw->cursor);

	/* Ensure that paragraph ends on a beginning of a line */
	if (!pisbol(bw->cursor))
		binsc(bw->cursor, '\n'), pgetc(bw->cursor);

	/* Record indentation of second line of paragraph, of first line if there
	 * is only one line */
	q = pdup(p, USTR "uformat");
	pnextl(q);
	if (q->line != bw->cursor->line) {
		P *r = pdup(q, USTR "uformat");

		indent = nindent(bw, q, 0);
		pcol(r, indent);
		indents = brs(q, r->byte - q->byte);
		prm(r);
	} else {
		P *r = pdup(p, USTR "uformat");
		int x, y;
		indent = nindent(bw, p, 1); /* allowing * and - here */
		pcol(r, indent);
		indents = brs(p, r->byte - p->byte);
		prm(r);
		if (!bw->o.autoindent) {
			/* Don't indent second line of single-line paragraphs if autoindent is off */
			int x = zlen(indents);
			while (x && (indents[x - 1] == ' ' || indents[x - 1] == '\t'))
				indents[--x] = 0;
			if (x) {
				indents[x++] = ' ';
				indents[x] = 0;
			}
			indent = txtwidth1(bw->o.charmap, bw->o.tab, indents, x);
		}
		for (x = 0; indents[x] && (indents[x] == ' ' || indents[x] == '\t'); ++x);
		y = zlen(indents);
		while (y && (indents[y - 1] == ' ' || indents[y - 1] == '\t'))
			--y;
		/* Don't duplicate bullet */
/*		if (y && (indents[y - 1] == '*' || indents[y - 1] == '-') &&
		    (y == 1 || indents[y - 2] == ' ' || indents[y - 2] == '\t'))
			indents[y - 1] = ' '; */
		/* Fix C comment */
		if (indents[x] == '/' && indents[x + 1] == '*')
			indents[x] = ' ';
	}
	prm(q);

	/* But if the left margin is greater, we use that instead */
	if (bw->o.lmargin > indent) {
		int x;
		for (x = 0; indents[x] == ' ' || indents[x] == '\t'; ++x);
		if (!indents[x]) {
			joe_free(indents);
			indent = bw->o.lmargin;
			indents = joe_malloc(indent+1);
			for (x = 0; x != indent; ++x)
				indents[x] = ' ';
			indents[x] = 0;
		}
	}

	/* Cut paragraph into new buffer */
	
	/* New buffer needs to inherit UTF-8 and CR-LF options */
	buf = bcpy(p, bw->cursor);
	buf->o.crlf = p->b->o.crlf;
	buf->o.charmap = p->b->o.charmap;
	bdel(p, bw->cursor);

	/* text is in buffer.  insert it at cursor */

	/* Do first line */
	b = pdup(buf->bof, USTR "uformat");

	while (!piseof(b)) {
		/* Set cursor position if we're at original offset */
		if (b->byte == curoff)
			pset(bw->cursor, p);

		/* Get character from buffer */
		c = pgetc(b);

		/* Stop if we found end of line */
		if (c == '\n') {
			prgetc(b);
			break;
		}

		/* Stop if we found white-space followed by end of line */
		if (joe_isblank(b->b->o.charmap, c) && piseolblank(b)) {
			prgetc(b);
			break;
		}

		/* Insert character, advance pointer */
		binsc(p, c);
		pgetc(p);

		/* Do word wrap if we reach right margin */
		if (piscol(p) > bw->o.rmargin && !joe_isblank(p->b->o.charmap,c)) {
			wrapword(bw, p, indent, bw->o.french, 1, indents);
			break;
		}
	}

	/* Do rest */

	while (!piseof(b)) {
		c = brch(b);
		if (joe_isblank(b->b->o.charmap,c) || c == '\n') {
			int f = 0;
			P *d;
			int g;

			/* Set f if there are two spaces after . ? or ! instead of one */
			/* (What is c was '\n'?) */
			d=pdup(b, USTR "uformat");
			g=prgetc(d);
			if (g=='.' || g=='?' || g=='!') {
				f = 1;
/*				pset(d,b);
				pgetc(d);
				if (joe_isspace(bw->b->o.charmap,brch(d)))
					f = 1; */
			}
			prm(d);
			
			/* Skip past the whitespace.  Skip over indentations */
		      loop:
			
			c = brch(b);
			if (c == '\n') {
				if (b->byte == curoff)
					pset(bw->cursor, p);

				pgetc(b);
				while (cpara(bw, (c=brch(b)))) {
					if (b->byte == curoff)
						pset(bw->cursor, p);
					pgetc(b);
				}
			}

			if (joe_isblank(b->b->o.charmap,c)) {
				if(b->byte == curoff)
					pset(bw->cursor, p);
				pgetc(b);
				goto loop;
			}

			/* Insert proper amount of whitespace */
			if (!piseof(b)) {
				if (f && !bw->o.french)
					binsc(p, ' '), pgetc(p);
				binsc(p, ' ');
				pgetc(p);
			}
		} else {
			/* Insert characters of word and wrap if necessary */
			if (b->byte == curoff)
				pset(bw->cursor, p);

			binsc(p, pgetc(b));
			pgetc(p);
			if (piscol(p) > bw->o.rmargin)
				wrapword(bw, p, indent, bw->o.french, 1, indents);
		}
	}

	binsc(p, '\n');
	prm(p);
	brm(buf);
	joe_free(indents);
	return 0;
}

/* Format entire block */

int ufmtblk(BW *bw)
{
	if (markv(1) && bw->cursor->byte >= markb->byte && bw->cursor->byte <= markk->byte) {
		markk->end = 1;
		utomarkk(bw);
		within = 1;
		do {
			ubop(bw), uformat(bw);
		} while (bw->cursor->byte > markb->byte);
		within = 0;
		markk->end = 0;
		if (lightoff)
			unmark(bw);
		return 0;
	} else
		return uformat(bw);
}
@


1.42
log
@ubop fixes.
@
text
@d365 1
d368 1
a368 1
				if (x) {
@


1.41
log
@Preserve setuid bit
@
text
@d188 1
d193 1
d205 1
a205 1
			pnextl(p);
d209 1
d220 1
d224 1
d241 1
d243 1
@


1.40
log
@fix paragraph format when overtype is one
@
text
@d454 1
a454 1
		if (!no_over && p->b->o.overtype){
d478 2
a479 2
*/			}
			
d637 1
a637 1
			wrapword(bw, p, indent, bw->o.french, no_over, indents);
d702 1
a702 1
				wrapword(bw, p, indent, bw->o.french, no_over, indents);
@


1.39
log
@Update coroutine version too.
@
text
@d318 1
a318 1
void wrapword(BW *bw, P *p, long int indent, int french, unsigned char *indents)
d454 1
a454 1
		if (p->b->o.overtype){
d475 1
d477 2
a478 2
				wrapword(bw, r, indent, french, indents);
			}
d637 1
a637 1
			wrapword(bw, p, indent, bw->o.french, indents);
d702 1
a702 1
				wrapword(bw, p, indent, bw->o.french, indents);
@


1.38
log
@Make uformat same as wrapword for *, - treatment.
@
text
@d372 1
a372 1
			if (y && (indents[y - 1] == '*' || indents[y - 1] == '-') &&
d374 1
a374 1
				indents[y - 1] = ' ';
d574 1
a574 1
		if (y && (indents[y - 1] == '*' || indents[y - 1] == '-') &&
d576 1
a576 1
			indents[y - 1] = ' ';
d625 2
a626 1
		if (joe_isblank(b->b->o.charmap, c) && piseolblank(b))
d628 1
d655 2
a656 1
				pset(d,b);
d659 1
a659 1
					f = 1;
@


1.37
log
@Add -flowed option.
@
text
@d554 1
a554 1
		indent = nindent(bw, p, 0);
@


1.36
log
@Get wordwrap to use lmargin.
@
text
@d444 6
@


1.35
log
@Fix formatter: don't duplicate bullet in case with leading >.
@
text
@d379 12
d578 12
a589 2
	if (bw->o.lmargin > indent)
		indent = bw->o.lmargin;
@


1.34
log
@Do not indent single line paragraphs with autoindent is off.  Better dealing
with bullets.
@
text
@d371 4
a374 3
			/* We have non-space between x and y */
			if (y == x + 1 && (indents[x] == '*' || indents[x] == '-'))
				indents[x] = ' ';
a550 1
		/* Don't duplicate if it looks like a bullet */
d555 4
a558 3
		/* We have non-space between x and y */
		if (y == x + 1 && (indents[x] == '*' || indents[x] == '-'))
			indents[x] = ' ';
@


1.33
log
@semiautomatic variables
@
text
@d349 1
a349 1
			int x;
d355 10
a364 12
			/* Ignore blanks unless autoindent is on */
			for (x = 0; indents[x] == ' ' || indents[x] == '\t'; ++x);
			if (!indents[x] && !bw->o.autoindent) {
				indents[0] = 0;
				x = 0;
			}
			/* Don't duplicate bullet, but leave VHDL comment */
			while (indents[x])
				++x;
			if (x >= 2 && indents[x - 1] == ' ' &&
			    ((indents[x - 2] == '*' && (x == 2 || indents[x - 3] == ' ' || indents[x - 3] == '\t')) || (indents[x - 2] == '-' && (x == 2 || indents[x - 3] != '-')))) {
			    	indents[x - 2] = ' ';
d366 8
d375 2
a376 3
			if (x >= 3 && indents[x - 3] == '/' && indents[x - 2] == '*' && indents[x - 1] == ' ')
				indents[x - 3] = ' ';
			
d534 1
a534 1

d539 22
a563 4
	/* Fix C */
	if (indents[0] == '/' && indents[1] == '*' && indents[2] == ' ')
		indents[0] = ' ';

@


1.32
log
@UC -> USTR
@
text
@d151 1
a151 1
		if (!joe_isblank(p->b->o.charmap, ( /* c = */ prgetc(q)))) {
d221 2
a222 1
			/* if (pisbof(p)) {
@


1.31
log
@change US to UC
@
text
@d45 1
a45 1
	q = pdup(p, UC "ucenter");
d105 1
a105 1
	q = pdup(p, UC "pisnpara");
d121 1
a121 1
	P *q = pdup(p, UC "nindent");
d144 1
a144 1
	P *q = pdup(p, UC "prefix");
d208 1
a208 1
			P *q = pdup(p, UC "pbop");
d272 1
a272 1
	P *q = pdup(bw->cursor, UC "ubop");
d293 1
a293 1
	P *q = pdup(bw->cursor, UC "ueop");
d330 1
a330 1
		s = pdup(p, UC "wrapword");
d335 1
a335 1
		q = pdup(s, UC "wrapword");
d339 1
a339 1
			P *r = pdup(q, UC "wrapword");
d347 1
a347 1
			P *r = pdup(s, UC "uformat");
d409 1
a409 1
		q = pdup(p, UC "wrapword");
d431 1
a431 1
			r = pdup(p, UC "wrapword");
d435 1
a435 1
			s = pdup(r, UC "wrapword");
d446 1
a446 1
			s = pdup(r, UC "wrapword");
d495 1
a495 1
	p = pdup(bw->cursor, UC "uformat");
d517 1
a517 1
	q = pdup(p, UC "uformat");
d520 1
a520 1
		P *r = pdup(q, UC "uformat");
d527 1
a527 1
		P *r = pdup(p, UC "uformat");
d555 1
a555 1
	b = pdup(buf->bof, UC "uformat");
d597 1
a597 1
			d=pdup(b, UC "uformat");
@


1.30
log
@fix warnings
@
text
@d45 1
a45 1
	q = pdup(p, US "ucenter");
d105 1
a105 1
	q = pdup(p, US "pisnpara");
d121 1
a121 1
	P *q = pdup(p, US "nindent");
d144 1
a144 1
	P *q = pdup(p, US "prefix");
d208 1
a208 1
			P *q = pdup(p, US "pbop");
d272 1
a272 1
	P *q = pdup(bw->cursor, US "ubop");
d293 1
a293 1
	P *q = pdup(bw->cursor, US "ueop");
d330 1
a330 1
		s = pdup(p, US "wrapword");
d335 1
a335 1
		q = pdup(s, US "wrapword");
d339 1
a339 1
			P *r = pdup(q, US "wrapword");
d347 1
a347 1
			P *r = pdup(s, US "uformat");
d409 1
a409 1
		q = pdup(p, US "wrapword");
d431 1
a431 1
			r = pdup(p, US "wrapword");
d435 1
a435 1
			s = pdup(r, US "wrapword");
d446 1
a446 1
			s = pdup(r, US "wrapword");
d495 1
a495 1
	p = pdup(bw->cursor, US "uformat");
d517 1
a517 1
	q = pdup(p, US "uformat");
d520 1
a520 1
		P *r = pdup(q, US "uformat");
d527 1
a527 1
		P *r = pdup(p, US "uformat");
d555 1
a555 1
	b = pdup(buf->bof, US "uformat");
d597 1
a597 1
			d=pdup(b, US "uformat");
@


1.29
log
@fix compiler warnings
@
text
@d150 2
a151 2
		int c;
		if (!joe_isblank(p->b->o.charmap, (c = prgetc(q)))) {
@


1.28
log
@update TODO
@
text
@d221 1
a221 1
			if (pisbof(p)) {
d233 1
a233 1
			}
@


1.27
log
@Compiler warning fix.  Bump to JOE 3.4
@
text
@d165 1
a165 1
			skip:;
@


1.26
log
@wordwrap improvements.
@
text
@d364 1
a364 1
			    ((indents[x - 2] == '*' && (x == 2 || indents[x - 3] == ' ' || indents[x - 3] == '\t')) || indents[x - 2] == '-' && (x == 2 || indents[x - 3] != '-'))) {
@


1.25
log
@transpose menus
@
text
@d116 2
a117 1
/* Determine amount of indentation on current line */
d119 1
a119 1
static long nindent(BW *bw, P *p)
d123 1
d128 7
a134 1
	} while (cpara(bw, pgetc(q)));
d141 1
a141 1
static long prefix(BW *bw, P *p)
d149 13
a161 2
	while (!pisbol(q))
		if (!joe_isblank(p->b->o.charmap, prgetc(q))) {
d163 1
d165 1
d167 2
a168 1
	len = q->col;
d192 2
a193 2
	indent = nindent(bw, p);
	prelen = prefix(bw, p);
d200 2
a201 2
		ind = nindent(bw, p);
		len = prefix(bw, p);
d206 11
a216 1
		if (ind > indent)
d218 1
d220 2
a221 1
			if (pisbof(p))
d223 1
d256 2
a257 2
	indent = nindent(bw, p);
	prelen = prefix(bw, p);
d259 2
a260 2
		long ind = nindent(bw, p);
		long len = prefix(bw, p);
d328 1
a328 1
	if (bw->o.autoindent && !indents) {
d333 2
a334 2
		/* Record indentation of second line of paragraph, of first line if there
		 * is only one line */
d337 2
a338 1
		if (q->line != p->line) {
d341 1
a341 1
			indent = nindent(bw, q);
d346 1
d348 1
d350 1
a350 1
			indent = nindent(bw, s);
d354 17
a374 4
		/* Fix C */
		if (indents[0] == '/' && indents[1] == '*' && indents[2] == ' ')
			indents[0] = ' ';

d522 1
a522 1
		indent = nindent(bw, q);
d529 1
a529 1
		indent = nindent(bw, p);
@


1.24
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d282 1
a282 1
void wrapword(P *p, long int indent, int french, unsigned char *indents)
d290 1
d292 35
a326 1
	/* Get indentation prefix from beginning of line */
d400 1
a400 1
				wrapword(r, indent, french, indents);
d428 2
d485 4
d530 1
a530 1
			wrapword(p, indent, bw->o.french, indents);
d594 1
a594 1
				wrapword(p, indent, bw->o.french, indents);
@


1.23
log
@New -cpara option
@
text
@a7 1
#include "config.h"
a9 9
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "b.h"
#include "ublock.h"
#include "charmap.h"
#include "utils.h"

a565 2
extern int lightoff;

@


1.22
log
@add joe_debug
@
text
@d74 8
a81 1
static int cpara(int c)
d83 9
d101 1
d110 1
a110 1
static int pisnpara(P *p)
d117 1
a117 1
	while (cpara(c = pgetc(q)))
d128 1
a128 1
static long nindent(P *p)
d136 1
a136 1
	} while (cpara(pgetc(q)));
d143 1
a143 1
static long prefix(P *p)
d149 1
a149 1
	while (cpara(brch(q)))
d174 1
a174 1
P *pbop(P *p)
d180 2
a181 2
	indent = nindent(p);
	prelen = prefix(p);
d188 3
a190 3
		ind = nindent(p);
		len = prefix(p);
		if (pisnpara(p) || len != prelen) {
d201 1
a201 1
			if (pisnpara(p)) {
d224 1
a224 1
P *peop(P *p)
d229 1
a229 1
	if (!pnextl(p) || pisnpara(p) || (within && markk && p->byte >= markk->byte))
d231 2
a232 2
	indent = nindent(p);
	prelen = prefix(p);
d234 2
a235 2
		long ind = nindent(p);
		long len = prefix(p);
d237 1
a237 1
		if (ind != indent || len != prelen || pisnpara(p))
d250 1
a250 1
	while (pisnpara(q) && !pisbof(q) && (!within || !markb || q->byte > markb->byte))
d252 1
a252 1
	pbop(q);
d271 1
a271 1
	while (pisnpara(q) && !piseof(q))
d273 2
a274 2
	pbop(q);
	peop(q);
d421 1
a421 1
	if (pisnpara(p)) {
d428 1
a428 1
	pbop(p);
d431 1
a431 1
	peop(bw->cursor);
d444 1
a444 1
		indent = nindent(q);
d451 1
a451 1
		indent = nindent(p);
d534 1
a534 1
				while (cpara(c=brch(b))) {
@


1.21
log
@fix gcc-4.0.0 warnings
@
text
@d55 1
a55 1
	q = pdup(p);
d98 1
a98 1
	q = pdup(p);
d113 1
a113 1
	P *q = pdup(p);
d129 1
a129 1
	P *q = pdup(p);
d230 1
a230 1
	P *q = pdup(bw->cursor);
d251 1
a251 1
	P *q = pdup(bw->cursor);
d316 1
a316 1
		q = pdup(p);
d338 1
a338 1
			r = pdup(p);
d342 1
a342 1
			s = pdup(r);
d353 1
a353 1
			s = pdup(r);
d400 1
a400 1
	p = pdup(bw->cursor);
d422 1
a422 1
	q = pdup(p);
d425 1
a425 1
		P *r = pdup(q);
d432 1
a432 1
		P *r = pdup(p);
d456 1
a456 1
	b = pdup(buf->bof);
d498 1
a498 1
			d=pdup(b);
@


1.20
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@a13 3
#ifdef HAVE_STRING_H
#include <string.h>
#endif
d373 1
a373 1
			to += strlen((char *)indents);
@


1.19
log
@Apply patches, improve verilog syntax.
@
text
@d342 1
a342 1
			//p_goto_eol(r);
@


1.18
log
@
Everything about character set is now contained in struct charmap.

Deprecate ^T U.  Now use ^T E to select file encoding.
@
text
@d281 2
d286 1
a286 1

d337 31
@


1.17
log
@Clean up pass: use internal ctype function everywhere.
@
text
@d20 1
d32 1
a32 1
	while (joe_isblank(c = prgetc(p)))
d44 1
a44 1
	while (joe_isblank(c = pgetc(p)))
d138 1
a138 1
		if (!joe_isblank(prgetc(q))) {
d310 1
a310 1
	while (!pisbol(p) && piscol(p) > indent && !joe_isblank(prgetc(p)))
d319 1
a319 1
			if (!joe_isblank(c = prgetc(q))) {
d420 1
a420 1
	buf->o.utf8 = p->b->o.utf8;
d443 1
a443 1
		if (joe_isblank(c) && piseolblank(b))
d451 1
a451 1
		if (piscol(p) > bw->o.rmargin && !joe_isblank(c)) {
d461 1
a461 1
		if (joe_isblank(c) || c == '\n') {
d473 1
a473 1
				if (joe_isspace(brch(d)))
d494 1
a494 1
			if (joe_isblank(c)) {
@


1.16
log
@Fix many edit fuctions for UTF-8.  Now we use iswalnum() when in UTF-8 mode.
Paragraph format works.

Search is still broken.
@
text
@a10 1
#include <ctype.h>
d472 1
a472 1
				if (isspace(brch(d)))
@


1.15
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d32 1
a32 1
	while (isblank(c = prgetc(p)))
d44 1
a44 1
	while (isblank(c = pgetc(p)))
d135 1
a135 1
	while (cpara(brc(q)))
d138 1
a138 1
		if (!isblank(prgetc(q))) {
d294 1
a294 1
			if(!isblank(c))
d310 1
a310 1
	while (!pisbol(p) && piscol(p) > indent && !isblank(prgetc(p)))
d319 1
a319 1
			if (!isblank(c = prgetc(q))) {
d364 2
a365 2
	unsigned char *buf, *b;
	int len;
d386 1
a386 1
	/* Insure that paragraph ends on a beginning of a line */
d415 6
a420 3
	/* Cut paragraph into memory buffer */
	buf = (unsigned char *) joe_malloc(len = (bw->cursor->byte - p->byte));
	brmem(p, buf, len);
d426 1
a426 1
	b = buf;
d428 1
a428 1
	while (len--) {
d430 1
a430 1
		if (b - buf == curoff)
d434 1
a434 1
		c = *b++;
d437 2
a438 3
		if (c == '\n' || (c == '\r' && len && *b == '\n')) {
			++len;
			--b;
d443 1
a443 14
		if (isblank(c)) {
			unsigned char *r = b;
			int rlen = len;
			int z;

			while (rlen--) {
				z = *r++;
				if (z == '\n')
					break;
				if (!isblank(z))
					goto ok;
			}
			++len;
			--b;
a444 2
		      ok:;
		}
d451 1
a451 1
		if (piscol(p) > bw->o.rmargin && !isblank(c)) {
d459 3
a461 2
	while (len > 0)
		if (isblank(*b) || *b == '\n' || *b == '\r') {
d463 2
d467 11
a477 4
			if ((b[-1] == '.' || b[-1] == '?' || b[-1] == '!')
			    && isspace(b[1]))
				f = 1;

d480 4
a483 3

			if (*b == '\r' && len) {
				if (b - buf == curoff)
a484 3
				++b;
				--len;
			}
d486 3
a488 7
			if (*b == '\n' && len) {
				if (b - buf == curoff)
					pset(bw->cursor, p);
				++b;
				--len;
				while (cpara(*b) && len) {
					if (b - buf == curoff)
d490 1
a490 2
					++b;
					--len;
d494 2
a495 2
			if (len && isblank(*b)) {
				if (b - buf == curoff)
d497 1
a497 2
				++b;
				--len;
d502 1
a502 1
			if (len) {
d510 1
a510 1
			if (b - buf == curoff)
d512 2
a513 2
			binsc(p, *b++);
			--len;
d518 1
d522 1
a522 1
	joe_free(buf);
@


1.14
log
@fix segafults in isalpha()-like functions
@
text
@d278 1
a278 1
void wrapword(P *p, long int indent, int french, char *indents)
d343 1
a343 1
			to += strlen(indents);
d363 2
a364 2
	char *indents;
	char *buf, *b;
d416 1
a416 1
	buf = (char *) joe_malloc(len = (bw->cursor->byte - p->byte));
d442 1
a442 1
			char *r = b;
@


1.13
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d38 1
a38 1
	if (c == MAXINT)
d50 1
a50 1
	if (c == MAXINT)
@


1.12
log
@include headers needed to compile without implicit function declarations warnings
@
text
@d80 5
a84 2
	    c == '>' || c == '|' || c == ':' || c == '*' || c == '/'
	    || c == ',' || c == '.' || c == '?' || c == ';' || c == ']' || c == '}' || c == '=' || c == '+' || c == '-' || c == '_' || c == ')' || c == '&' || c == '^' || c == '%' || c == '$' || c == '#' || c == '@@' || c == '!' || c == '~')
d334 2
a335 1
		binsc(p, '\n'), ++to;
d341 8
a348 5
		if (indents)
			binss(p, indents), to += strlen(indents);
		else
			while (indent--)
				binsc(p, ' '), ++to;
d487 2
a488 1
				++b, --len;
d494 2
a495 1
				++b, --len;
d499 2
a500 1
					++b, --len;
d507 2
a508 1
				++b, --len;
@


1.11
log
@remove deadlock when reformating paragraph
@
text
@d15 3
@


1.10
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d463 1
a463 1
		if (isspace(*b) || *b == '\r') {
@


1.9
log
@change indentation of do {} while() cycles
@
text
@d341 1
a341 1
			free(indents);
d406 1
a406 1
	buf = (char *) malloc(len = (bw->cursor->byte - p->byte));
d518 2
a519 2
	free(buf);
	free(indents);
@


1.8
log
@include only headers which are needed
@
text
@d29 2
a30 1
	while (isblank(c = prgetc(p))) ;
d41 2
a42 1
	while (isblank(c = pgetc(p))) ;
d97 2
a98 1
	while (cpara(c = pgetc(q))) ;
d114 1
a114 1
	do
d116 1
a116 1
	while (cpara(pgetc(q)));
d229 2
a230 1
      up:while (pisnpara(q) && !pisbof(q) && (!within || !markb || q->byte > markb->byte))
d250 2
a251 1
      up:while (pisnpara(q) && !piseof(q))
d281 20
a300 18
 if(!indents)
  {
  int f=0;
  P *r=pdup(p);
  p_goto_bol(r);
  q=pdup(r);
  while(cpara(c=brc(q)))
   {
   if(!isblank(c)) f=1;
   pgetc(q);
   }
  if(f)
   {
   indents=brs(r,q->byte-r->byte); rmf=1;
   if(indents[0]=='/' && indents[1]=='*') indents[0]=' ';
   }
  prm(r); prm(q);
  }
d304 2
a305 1
	while (!pisbol(p) && piscol(p) > indent && !isblank(prgetc(p))) ;
d533 1
a533 1
		do
d535 1
a535 1
		while (bw->cursor->byte > markb->byte);
@


1.7
log
@put struct definitions and other goodies into types.h
@
text
@a11 1
#include <string.h>
a16 1
#include "bw.h"
a17 1
#include "uformat.h"
@


1.6
log
@version 2.9.7-pre3
@
text
@d2 6
a7 6
	User text formatting functions
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/

d9 1
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d24 1
a24 2
int ucenter(bw)
BW *bw;
d74 1
a74 1
int cpara(c)
d90 1
a90 2
int pisnpara(p)
P *p;
d107 1
a107 2
long nindent(p)
P *p;
d122 1
a122 2
long prefix(p)
P *p;
d153 1
a153 2
P *pbop(p)
P *p;
d203 1
a203 2
P *peop(p)
P *p;
d224 1
a224 2
int ubop(bw)
BW *bw;
d244 1
a244 2
int ueop(bw)
BW *bw;
d269 1
a269 4
void wrapword(p, indent, french, indents)
P *p;
long indent;
char *indents;
d344 1
a344 2
int uformat(bw)
BW *bw;
d521 1
a521 2
int ufmtblk(bw)
BW *bw;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d8 2
d12 4
a15 1
#include "config.h"
d24 2
a25 3
int
ucenter (bw)
     BW *bw;
d31 6
a36 7
	p_goto_eol (p);
	while (isblank (c = prgetc (p)));
	if (c == '\n')
	  {
		  pgetc (p);
		  goto done;
	  }
d39 2
a40 2
	pgetc (p);
	endcol = piscol (p);
d42 6
a47 7
	p_goto_bol (p);
	while (isblank (c = pgetc (p)));
	if (c == '\n')
	  {
		  prgetc (p);
		  goto done;
	  }
d50 2
a51 2
	prgetc (p);
	begcol = piscol (p);
d56 7
a62 8
	q = pdup (p);
	p_goto_bol (q);
	bdel (q, p);
	prm (q);

	for (x = 0;
	     x != (bw->o.lmargin + bw->o.rmargin) / 2 - (endcol - begcol) / 2;
	     ++x) binsc (p, ' ');
d65 5
a69 7
	if (!pnextl (p))
	  {
		  binsc (p, '\n');
		  pgetc (p);
		  return -1;
	  }
	else
d75 1
a75 2
int
cpara (c)
d79 1
a79 4
	    || c == ',' || c == '.' || c == '?' || c == ';' || c == ']'
	    || c == '}' || c == '=' || c == '+' || c == '-' || c == '_'
	    || c == ')' || c == '&' || c == '^' || c == '%' || c == '$'
	    || c == '#' || c == '@@' || c == '!' || c == '~')
d91 2
a92 3
int
pisnpara (p)
     P *p;
d96 5
a100 4
	q = pdup (p);
	p_goto_bol (q);
	while (cpara (c = pgetc (q)));
	prm (q);
d109 2
a110 3
long
nindent (p)
     P *p;
d112 1
a112 1
	P *q = pdup (p);
d114 2
a115 1
	p_goto_bol (q);
d118 2
a119 2
	while (cpara (pgetc (q)));
	prm (q);
d125 2
a126 3
long
prefix (p)
     P *p;
d129 10
a138 10
	P *q = pdup (p);
	p_goto_bol (q);
	while (cpara (brc (q)))
		pgetc (q);
	while (!pisbol (q))
		if (!isblank (prgetc (q)))
		  {
			  pgetc (q);
			  break;
		  }
d140 1
a140 1
	prm (q);
d157 2
a158 3
P *
pbop (p)
     P *p;
d162 33
a194 37
	p_goto_bol (p);
	indent = nindent (p);
	prelen = prefix (p);
	while (!pisbof (p) && (!within || !markb || p->byte > markb->byte))
	  {
		  long ind;
		  long len;
		  pprevl (p);
		  p_goto_bol (p);
		  ind = nindent (p);
		  len = prefix (p);
		  if (pisnpara (p) || len != prelen)
		    {
			    pnextl (p);
			    break;
		    }
		  if (ind > indent)
			  break;
		  if (ind < indent)
		    {
			    if (pisbof (p))
				    break;
			    pprevl (p);
			    p_goto_bol (p);
			    if (pisnpara (p))
			      {
				      pnextl (p);
				      break;
			      }
			    else
			      {
				      pnextl (p);
				      pnextl (p);
				      break;
			      }
		    }
	  }
d208 2
a209 3
P *
peop (p)
     P *p;
d213 12
a224 11
	if (!pnextl (p) || pisnpara (p) ||
	    (within && markk && p->byte >= markk->byte)) return p;
	indent = nindent (p);
	prelen = prefix (p);
	while (pnextl (p) && (!within || !markk || p->byte < markk->byte))
	  {
		  long ind = nindent (p);
		  long len = prefix (p);
		  if (ind != indent || len != prelen || pisnpara (p))
			  break;
	  }
d230 41
a270 52
int
ubop (bw)
     BW *bw;
{
	P *q = pdup (bw->cursor);
      up:while (pisnpara (q) && !pisbof (q) &&
	       (!within || !markb || q->byte > markb->byte))
		pprevl (q);
	pbop (q);
	if (q->byte != bw->cursor->byte)
	  {
		  pset (bw->cursor, q);
		  prm (q);
		  return 0;
	  }
	else if (!pisbof (q))
	  {
		  prgetc (q);
		  goto up;
	  }
	else
	  {
		  prm (q);
		  return -1;
	  }
}

int
ueop (bw)
     BW *bw;
{
	P *q = pdup (bw->cursor);
      up:while (pisnpara (q) && !piseof (q))
		pnextl (q);
	pbop (q);
	peop (q);
	if (q->byte != bw->cursor->byte)
	  {
		  pset (bw->cursor, q);
		  prm (q);
		  return 0;
	  }
	else if (!piseof (q))
	  {
		  pnextl (q);
		  goto up;
	  }
	else
	  {
		  prm (q);
		  return -1;
	  }
d277 4
a280 5
void
wrapword (p, indent, french, indents)
     P *p;
     long indent;
     char *indents;
d310 1
a310 1
	while (!pisbol (p) && piscol (p) > indent && !isblank (prgetc (p)));
d313 35
a347 37
	if (!pisbol (p) && piscol (p) > indent)
	  {
		  /* Move q to two (or one if 'french' is set) spaces after end of previous
		     word */
		  q = pdup (p);
		  while (!pisbol (q))
			  if (!isblank (c = prgetc (q)))
			    {
				    pgetc (q);
				    if ((c == '.' || c == '?' || c == '!')
					&& q->byte != p->byte && !french)
					    pgetc (q);
				    break;
			    }
		  pgetc (p);

		  /* Delete space between start of word and end of previous word */
		  to -= p->byte - q->byte;
		  bdel (q, p);
		  prm (q);

		  /* Move word to beginning of next line */
		  binsc (p, '\n'), ++to;
		  if (p->b->o.crlf)
			  ++to;
		  pgetc (p);

		  /* Indent to left margin */
		  if (indents)
			  binss (p, indents), to += strlen (indents);
		  else
			  while (indent--)
				  binsc (p, ' '), ++to;

		  if (rmf)
			  free (indents);
	  }
d350 1
a350 1
	pfwrd (p, to - p->byte);
d355 2
a356 3
int
uformat (bw)
     BW *bw;
d365 3
a367 2
	p = pdup (bw->cursor);
	p_goto_bol (p);
d370 4
a373 5
	if (pisnpara (p))
	  {
		  prm (p);
		  return 0;
	  }
d377 1
a377 1
	pbop (p);
d379 2
a380 2
	pset (bw->cursor, p);
	peop (bw->cursor);
d383 2
a384 2
	if (!pisbol (bw->cursor))
		binsc (bw->cursor, '\n'), pgetc (bw->cursor);
d388 18
a405 19
	q = pdup (p);
	pnextl (q);
	if (q->line != bw->cursor->line)
	  {
		  P *r = pdup (q);
		  indent = nindent (q);
		  pcol (r, indent);
		  indents = brs (q, r->byte - q->byte);
		  prm (r);
	  }
	else
	  {
		  P *r = pdup (p);
		  indent = nindent (p);
		  pcol (r, indent);
		  indents = brs (p, r->byte - p->byte);
		  prm (r);
	  }
	prm (q);
d412 3
a414 3
	buf = (char *) malloc (len = (bw->cursor->byte - p->byte));
	brmem (p, buf, len);
	bdel (p, bw->cursor);
d421 44
a464 48
	while (len--)
	  {
		  /* Set cursor position if we're at original offset */
		  if (b - buf == curoff)
			  pset (bw->cursor, p);

		  /* Get character from buffer */
		  c = *b++;

		  /* Stop if we found end of line */
		  if (c == '\n' || (c == '\r' && len && *b == '\n'))
		    {
			    ++len;
			    --b;
			    break;
		    }

		  /* Stop if we found white-space followed by end of line */
		  if (isblank (c))
		    {
			    char *r = b;
			    int rlen = len;
			    int z;
			    while (rlen--)
			      {
				      z = *r++;
				      if (z == '\n')
					      break;
				      if (!isblank (z))
					      goto ok;
			      }
			    ++len;
			    --b;
			    break;
			  ok:;
		    }

		  /* Insert character, advance pointer */
		  binsc (p, c);
		  pgetc (p);

		  /* Do word wrap if we reach right margin */
		  if (piscol (p) > bw->o.rmargin && !isblank (c))
		    {
			    wrapword (p, indent, bw->o.french, indents);
			    break;
		    }
	  }
d469 57
a525 64
		if (isspace (*b) || *b == '\r')
		  {
			  int f = 0;
			  /* Set f if there are two spaces after . ? or ! instead of one */
			  if ((b[-1] == '.' || b[-1] == '?' || b[-1] == '!')
			      && isspace (b[1]))
				  f = 1;

			  /* Skip past the whitespace.  Skip over indentations */
			loop:

			  if (*b == '\r' && len)
			    {
				    if (b - buf == curoff)
					    pset (bw->cursor, p);
				    ++b, --len;
			    }

			  if (*b == '\n' && len)
			    {
				    if (b - buf == curoff)
					    pset (bw->cursor, p);
				    ++b, --len;
				    while (cpara (*b) && len)
				      {
					      if (b - buf == curoff)
						      pset (bw->cursor, p);
					      ++b, --len;
				      }
			    }

			  if (len && isblank (*b))
			    {
				    if (b - buf == curoff)
					    pset (bw->cursor, p);
				    ++b, --len;
				    goto loop;
			    }

			  /* Insert proper amount of whitespace */
			  if (len)
			    {
				    if (f && !bw->o.french)
					    binsc (p, ' '), pgetc (p);
				    binsc (p, ' ');
				    pgetc (p);
			    }
		  }
		else
		  {
			  /* Insert characters of word and wrap if necessary */
			  if (b - buf == curoff)
				  pset (bw->cursor, p);
			  binsc (p, *b++);
			  --len;
			  pgetc (p);
			  if (piscol (p) > bw->o.rmargin)
				  wrapword (p, indent, bw->o.french, indents);
		  }

	binsc (p, '\n');
	prm (p);
	free (buf);
	free (indents);
d533 17
a549 21
int
ufmtblk (bw)
     BW *bw;
{
	if (markv (1) && bw->cursor->byte >= markb->byte
	    && bw->cursor->byte <= markk->byte)
	  {
		  markk->end = 1;
		  utomarkk (bw);
		  within = 1;
		  do
			  ubop (bw), uformat (bw);
		  while (bw->cursor->byte > markb->byte);
		  within = 0;
		  markk->end = 0;
		  if (lightoff)
			  unmark (bw);
		  return 0;
	  }
	else
		return uformat (bw);
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* User text formatting functions
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d15 1
d19 54
a72 34
int ucenter(bw)
BW *bw;
 {
 P *p=bw->cursor, *q;
 long endcol, begcol, x;
 int c;
 
 peol(p);
 while(isblank(c=prgetc(p)));
 if(c=='\n') { pgetc(p); goto done; }
 if(c==MAXINT) goto done;
 pgetc(p); endcol=piscol(p);
 
 pbol(p);
 while(isblank(c=pgetc(p)));
 if(c=='\n') { prgetc(p); goto done; }
 if(c==MAXINT) goto done;
 prgetc(p); begcol=piscol(p);
 
 if(endcol-begcol>bw->o.rmargin+bw->o.lmargin) goto done;
 
 q=pdup(p); pbol(q); bdel(q,p); prm(q);
 
 for(x=0;x!=(bw->o.lmargin+bw->o.rmargin)/2-(endcol-begcol)/2;++x) binsc(p,' ');
 
 done:
 if(!pnextl(p))
  {
  binsc(p,'\n');
  pgetc(p);
  return -1;
  }
 else return 0;
 }
d76 13
a88 11
int cpara(c)
 {
 if(c==' ' || c=='\t' || c=='\\' ||
    c=='>' || c=='|' || c==':' || c=='*' || c=='/' || c==',' || c=='.' ||
    c=='?' || c==';' || c==']' || c=='}' || c=='=' || c=='+' || c=='-' ||
    c=='_' || c==')' || c=='&' || c=='^' || c=='%' || c=='$' || c=='#' ||
    c=='@@' || c=='!' || c=='~')
  return 1;
 else
  return 0;
 }
d96 15
a110 12
int pisnpara(p)
P *p;
 {
 P *q;
 int c;
 q=pdup(p);
 pbol(q);
 while(cpara(c=pgetc(q)));
 prm(q);
 if(c=='.' || c=='\r' || c=='\n') return 1;
 else return 0;
 }
d114 13
a126 10
long nindent(p)
P *p;
 {
 P *q=pdup(p);
 long col;
 pbol(q);
 do col=q->col; while(cpara(pgetc(q)));
 prm(q);
 return col;
 }
d130 19
a148 17
long prefix(p)
P *p;
 {
 long len;
 P *q=pdup(p);
 pbol(q);
 while(cpara(brc(q))) pgetc(q);
 while(!pisbol(q))
  if(!isblank(prgetc(q)))
   {
   pgetc(q);
   break;
   }
 len=q->col;
 prm(q);
 return len;
 }
d161 1
a161 1
int within=0;
d163 45
a207 23
P *pbop(p)
P *p;
 {
 long indent;
 long prelen;
 pbol(p); indent=nindent(p); prelen=prefix(p);
 while(!pisbof(p) && (!within || !markb || p->byte>markb->byte))
  {
  long ind;
  long len;
  pprevl(p); pbol(p); ind=nindent(p); len=prefix(p);
  if(pisnpara(p) || len!=prelen) { pnextl(p); break; }
  if(ind>indent) break;
  if(ind<indent)
   {
   if(pisbof(p)) break;
   pprevl(p); pbol(p);
   if(pisnpara(p)) { pnextl(p); break; }
   else { pnextl(p); pnextl(p); break; }
   }
  }
 return p;
 }
d219 19
a237 17
P *peop(p)
P *p;
 {
 long indent;
 long prelen;
 if(!pnextl(p) || pisnpara(p) ||
    (within && markk && p->byte>=markk->byte)) return p;
 indent=nindent(p);
 prelen=prefix(p);
 while(pnextl(p) && (!within || !markk || p->byte<markk->byte))
  {
  long ind=nindent(p);
  long len=prefix(p);
  if(ind!=indent || len!=prelen || pisnpara(p)) break;
  }
 return p;
 }
d241 53
a293 48
int ubop(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 up: while(pisnpara(q) && !pisbof(q) &&
           (!within || !markb || q->byte>markb->byte)) pprevl(q);
 pbop(q);
 if(q->byte!=bw->cursor->byte)
  {
  pset(bw->cursor,q);
  prm(q);
  return 0;
  }
 else if(!pisbof(q))
  {
  prgetc(q);
  goto up;
  }
 else
  {
  prm(q);
  return -1;
  }
 }

int ueop(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 up: while(pisnpara(q) && !piseof(q)) pnextl(q);
 pbop(q); peop(q);
 if(q->byte!=bw->cursor->byte)
  {
  pset(bw->cursor,q);
  prm(q);
  return 0;
  }
 else if(!piseof(q))
  {
  pnextl(q);
  goto up;
  }
 else
  {
  prm(q);
  return -1;
  }
 }
d299 10
a308 9
void wrapword(p,indent,french,indents)
P *p;
long indent;
char *indents;
 {
 P *q;
 int rmf=0;
 int c;
 long to=p->byte;
d310 1
a310 1
 /* Get indentation prefix from beginning of line */
d316 1
a316 1
  pbol(r);
d332 2
a333 34
 /* Get to beginning of word */
 while(!pisbol(p) && piscol(p)>indent && !isblank(prgetc(p)));

 /* If we found the beginning of a word... */
 if(!pisbol(p) && piscol(p)>indent)
  {
  /* Move q to two (or one if 'french' is set) spaces after end of previous
     word */
  q=pdup(p);
  while(!pisbol(q))
   if(!isblank(c=prgetc(q)))
    {
    pgetc(q);
    if((c=='.'||c=='?'||c=='!') && q->byte!=p->byte && !french) pgetc(q);
    break;
    }
  pgetc(p);

  /* Delete space between start of word and end of previous word */
  to-=p->byte-q->byte;
  bdel(q,p);
  prm(q);

  /* Move word to beginning of next line */
  binsc(p,'\n'), ++to;
  if(p->b->o.crlf) ++to;
  pgetc(p);

  /* Indent to left margin */
  if(indents) binss(p,indents), to+=strlen(indents);
  else while(indent--) binsc(p,' '), ++to;

  if(rmf) free(indents);
  }
d335 42
a376 3
 /* Move cursor back to original position */
 pfwrd(p,to-p->byte);
 }
d380 186
a565 158
int uformat(bw)
BW *bw;
 {
 long indent;
 char *indents;
 char *buf, *b;
 int len;
 long curoff;
 int c;
 P *p, *q;
 p=pdup(bw->cursor); pbol(p);
 
 /* Do nothing if we're not on a paragraph line */
 if(pisnpara(p))
  {
  prm(p);
  return 0;
  }
 
 /* Move p to beginning of paragraph, bw->cursor to end of paragraph and
  * set curoff to original cursor offset within the paragraph */
 pbop(p);
 curoff=bw->cursor->byte-p->byte;
 pset(bw->cursor,p); peop(bw->cursor);
 
 /* Insure that paragraph ends on a beginning of a line */
 if(!pisbol(bw->cursor)) binsc(bw->cursor,'\n'), pgetc(bw->cursor);
 
 /* Record indentation of second line of paragraph, of first line if there
  * is only one line */
 q=pdup(p); pnextl(q);
 if(q->line!=bw->cursor->line)
  {
  P *r=pdup(q);
  indent=nindent(q);
  pcol(r,indent);
  indents=brs(q,r->byte-q->byte);
  prm(r);
  }
 else
  {
  P *r=pdup(p);
  indent=nindent(p);
  pcol(r,indent);
  indents=brs(p,r->byte-p->byte);
  prm(r);
  }
 prm(q);

 /* But if the left margin is greater, we use that instead */
 if(bw->o.lmargin>indent) indent=bw->o.lmargin;
 
 /* Cut paragraph into memory buffer */
 buf=(char *)malloc(len=(bw->cursor->byte-p->byte));
 brmem(p,buf,len);
 bdel(p,bw->cursor);
 
 /* text is in buffer.  insert it at cursor */
 
 /* Do first line */
 b=buf;
 
 while(len--)
  {
  /* Set cursor position if we're at original offset */
  if(b-buf==curoff) pset(bw->cursor,p);

  /* Get character from buffer */
  c= *b++;

  /* Stop if we found end of line */
  if(c=='\n' ||
     c=='\r' && len && *b=='\n') { ++len; --b; break; }

  /* Stop if we found white-space followed by end of line */
  if(isblank(c))
   {
   char *r=b;
   int rlen=len;
   int z;
   while(rlen--)
    {
    z= *r++;
    if(z=='\n') break;
    if(!isblank(z)) goto ok;
    }
   ++len; --b; break;
   ok:;
   }

  /* Insert character, advance pointer */
  binsc(p,c); pgetc(p);

  /* Do word wrap if we reach right margin */
  if(piscol(p)>bw->o.rmargin && !isblank(c))
   {
   wrapword(p,indent,bw->o.french,indents);
   break;
   }
  }
 
 /* Do rest */
 
 while(len>0)
  if(isspace(*b) || *b=='\r')
   {
   int f=0;
   /* Set f if there are two spaces after . ? or ! instead of one */
   if((b[-1]=='.' || b[-1]=='?' || b[-1]=='!') && isspace(b[1])) f=1;

   /* Skip past the whitespace.  Skip over indentations */
   loop:

   if(*b=='\r' && len)
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    }

   if(*b=='\n' && len)
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    while(cpara(*b) && len)
     {
     if(b-buf==curoff) pset(bw->cursor,p);
     ++b, --len;
     }
    }

   if(len && isblank(*b))
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    goto loop;
    }

   /* Insert proper amount of whitespace */
   if(len)
    {
    if(f && !bw->o.french) binsc(p,' '), pgetc(p);
    binsc(p,' '); pgetc(p);
    }
   }
  else
   {
   /* Insert characters of word and wrap if necessary */
   if(b-buf==curoff) pset(bw->cursor,p);
   binsc(p,*b++); --len; pgetc(p);
   if(piscol(p)>bw->o.rmargin) wrapword(p,indent,bw->o.french,indents);
   }
 
 binsc(p,'\n');
 prm(p);
 free(buf);
 free(indents);
 return 0;
 }
d571 22
a592 18
int ufmtblk(bw)
BW *bw;
 {
 if(markv(1) && bw->cursor->byte>=markb->byte && bw->cursor->byte<=markk->byte)
  {
  markk->end=1;
  utomarkk(bw);
  within=1;
  do
   ubop(bw), uformat(bw);
   while(bw->cursor->byte>markb->byte);
  within=0;
  markk->end=0;
  if(lightoff) unmark(bw);
  return 0;
  }
 else return uformat(bw);
 }
@


1.2
log
@changed as of joe-2.9.2
@
text
@a23 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d19 2
d38 1
a38 1
 while(cwhite(c=prgetc(p)));
d44 1
a44 1
 while(cwhite(c=pgetc(p)));
d121 1
a121 1
  if(!cwhite(prgetc(q)))
d271 1
a271 1
   if(!cwhite(c)) f=1;
d284 1
a284 1
 while(!pisbol(p) && piscol(p)>indent && !cwhite(prgetc(p)));
d293 1
a293 1
   if(!cwhite(c=prgetc(q)))
d312 1
a312 1
  if(indents) binss(p,indents), to+=zlen(indents);
d399 1
a399 1
  if(cwhite(c))
d408 1
a408 1
    if(!cwhite(z)) goto ok;
d418 1
a418 1
  if(piscol(p)>bw->o.rmargin && !cwhite(c))
d428 1
a428 1
  if(cwhitel(*b) || *b=='\r')
d432 1
a432 1
   if((b[-1]=='.' || b[-1]=='?' || b[-1]=='!') && cwhitel(b[1])) f=1;
d454 1
a454 1
   if(len && cwhite(*b))
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
