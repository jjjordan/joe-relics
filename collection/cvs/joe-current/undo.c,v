head	1.33;
access;
symbols
	joe_3_5:1.32
	joe-3_4:1.27
	help:1.27
	joe_3_1:1.14
	joe_3_0:1.14
	joe_2_9_8:1.13
	joe_2_9_8_pre1:1.11
	joe_2_9_7:1.4
	joe_2_9_7_pre3:1.4
	joe_2_9_7_pre2:1.3
	joe_2_9_6:1.2
	joe_2_9_5:1.1.1.1
	joe_2_9_4:1.1.1.1
	joe_2_9_2:1.1.1.1
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.19.00.27.13;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.10.17.44.46;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.10.17.38.54;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.02.16.54.06;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.26.22.44.04;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.05.18.18.45;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.08.03.00.57;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.24.04.30.52;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.22.03.22.39;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.14.00.23.09;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.14.00.07.50;	author jhallen;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.02.18.55.39;	author jhallen;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.09.18.13.48;	author jhallen;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.09.18.01.32;	author jhallen;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.08.21.16.11;	author jhallen;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.04.17.39.28;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.13.59.06;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.12.15.52.27;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.12.15.35.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.19;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.33
log
@semiautomatic variables
@
text
@/*
 *	UNDO system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

int undo_keep = 100; /* Number of undo records to keep */

#define SMALL 1024

#define MAX_YANK 100

static UNDO undos = { {&undos, &undos} };
static UNDO frdos = { {&frdos, &frdos} };

int inundo = 0;
int inredo = 0;	/* Turns off recording of undo records */

UNDOREC yanked = { {&yanked, &yanked} };
int nyanked = 0;
int inyank = 0;
int justkilled = 0;

UNDOREC frrecs = { {&frrecs, &frrecs} };

static UNDOREC *alrec(void)
{
	UNDOREC *rec = (UNDOREC *) alitem(&frrecs, sizeof(UNDOREC));

	return rec;
}

static void frrec(UNDOREC *rec)
{
	if (rec->del) {
		if (rec->len < SMALL)
			joe_free(rec->small);
		else {
			B *b = rec->big;

			bonline(b);
			brm(b);
		}
	}
	enquef(UNDOREC, link, &frrecs, rec);
}

UNDO *undomk(B *b)
{
	UNDO *undo = (UNDO *) alitem(&frdos, sizeof(UNDO));

	undo->nrecs = 0;
	undo->ptr = NULL;
	undo->last = NULL;
	undo->first = NULL;
	undo->b = b;
	izque(UNDOREC, link, &undo->recs);
	enquef(UNDO, link, &undos, undo);
	return undo;
}

void undorm(UNDO *undo)
{
	frchn(&frrecs, &undo->recs);
	demote(UNDO, link, &frdos, undo);
}

void bw_unlock(BW *bw)
{
	if (bw->b->locked && !bw->b->ignored_lock && plain_file(bw->b)) {
		unlock_it(bw->b->name);
		bw->b->locked = 0;
	}
}

static void doundo(BW *bw, UNDOREC *ptr)
{
	dostaupd = 1;

	if (ptr->del) {
		if (ptr->len < SMALL)
			binsm(bw->cursor, ptr->small, (int) ptr->len);
		else {
			B *b = ptr->big;

			bonline(b);
			binsb(bw->cursor, bcpy(b->bof, b->eof));
			boffline(b);
		}
	} else {
		P *q = pdup(bw->cursor, USTR "doundo");

		pfwrd(q, ptr->len);
		bdel(bw->cursor, q);
		prm(q);
	}
	if (bw->b->changed && !ptr->changed)
		bw_unlock(bw);
	bw->b->changed = ptr->changed;
}

int uundo(BW *bw)
{
	UNDOREC *upto;
	UNDO *undo = bw->b->undo;

	if (!undo)
		return -1;
	if (!undo->nrecs)
		return -1;
	if (!undo->ptr) {
		pgoto(bw->cursor, undo->recs.link.prev->where);
		undo->ptr = &undo->recs;
		/* If this return is uncommented, then uundo will jump
		   to where the undo is about to occur before actually
		   undoing anything */
		/* return 0; */
	}
	if (undo->ptr->link.prev == &undo->recs)
		return -1;
	upto = undo->ptr->link.prev->unit;
	do {
		undo->ptr = undo->ptr->link.prev;
		pgoto(bw->cursor, undo->ptr->where);
		inundo = 1;
		doundo(bw, undo->ptr);
		inundo = 0;
	} while (upto && upto != undo->ptr);
	return 0;
}

int uredo(BW *bw)
{
	UNDOREC *upto;
	UNDOREC *ptr;
	UNDO *undo = bw->b->undo;

	if (!undo)
		return -1;
	if (!undo->ptr)
		return -1;
	if (undo->ptr == &undo->recs)
		return -1;
	upto = undo->recs.link.prev->unit;
	do {
		ptr = undo->recs.link.prev;
		pgoto(bw->cursor, ptr->where);
		inredo = 1;
		doundo(bw, ptr);
		inredo = 0;
		frrec(deque_f(UNDOREC, link, ptr)); /* Delete record created by undo command */
		undo->ptr = undo->ptr->link.next;
	} while (upto && upto != ptr);
	/* We just deleted one undo record */
	--undo->nrecs;
	return 0;
}

void umclear(void)
{
	UNDO *undo;

	for (undo = undos.link.next; undo != &undos; undo = undo->link.next) {
		UNDOREC *rec;

		for (rec = undo->recs.link.next; rec != &undo->recs; rec = rec->link.next)
			rec->min = 0;
	}
}

/* Eliminate excess undo records */

static void undogc(UNDO *undo)
{
	UNDOREC *unit = undo->recs.link.next->unit;
	int flg = 0;

	if (unit)
		while (unit != undo->recs.link.next) {
			if (undo->recs.link.next == undo->ptr)
				flg = 1;
			frrec(deque_f(UNDOREC, link, undo->recs.link.next));
		}
	if (undo->recs.link.next == undo->ptr)
		flg = 1;
	frrec(deque_f(UNDOREC, link, undo->recs.link.next));
	--undo->nrecs;
	if (flg)
		undo->ptr = undo->recs.link.next;
}

void undomark(void)
{
	UNDO *undo;

	/* Force undo_keep to be a multiple of 2.  Redo needs pairs of undo records. */
	if (undo_keep & 1)
		++undo_keep;

	for (undo = undos.link.next; undo != &undos; undo = undo->link.next)
		if (undo->first) {
			undo->first->unit = undo->last;
			undo->last->unit = undo->first;
			undo->first = undo->last = 0;
			++undo->nrecs;
			if (undo_keep)
				while (undo->nrecs > undo_keep)
					undogc(undo);
		}
}

/* Forget pointer to latest "undone" record.  This is called when the first non-undo
 * command is executed after a bunch of undo commands, which then prevents redo. */

static void undoover(UNDO *undo)
{
	undo->ptr = NULL;
}

void undoins(UNDO *undo, P *p, long size)
{
	UNDOREC *rec;

	if (inredo)
		return;
	if (!inundo)
		if (undo->ptr && undo->ptr != &undo->recs)
			undoover(undo);
	rec = undo->recs.link.prev;
	if (rec != &undo->recs && rec->min && !rec->del && (p->byte == rec->where + rec->len || p->byte == rec->where))
		rec->len += size;
	else {
		rec = alrec();
		rec->del = 0;
		if (!undo->first)
			undo->first = rec;
		undo->last = rec;
		rec->where = p->byte;
		rec->min = 1;
		rec->unit = NULL;
		rec->len = size;
		rec->changed = undo->b->changed;
		enqueb(UNDOREC, link, &undo->recs, rec);
	}
}


int uyapp(BW *bw)
{
	UNDOREC *rec = yanked.link.prev;

	if (rec != &yanked)
		rec->where = bw->cursor->byte;
	return 0;
}

static void yankdel(long where, B *b)
{
	UNDOREC *rec;
	long size = b->eof->byte;

	/* Store in yank buffer */
	rec = yanked.link.prev;
	if (!inyank) {
		if (rec != &yanked && where == rec->where && justkilled) {
			if (rec->len + size >= SMALL) {
				if (rec->len < SMALL) {
					rec->big = bmk(NULL);
					binsm(rec->big->bof, rec->small, (int) rec->len);
					boffline(rec->big);
					joe_free(rec->small);
				}
				bonline(rec->big);
				binsb(rec->big->eof, bcpy(b->bof, b->eof));
				boffline(rec->big);
			} else {
				rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
				brmem(b->bof, rec->small + rec->len, (int) size);
			}
			rec->len += size;
		} else if (rec != &yanked && where + size == rec->where && justkilled) {
			if (rec->len + size >= SMALL) {
				if (rec->len < SMALL) {
					rec->big = bmk(NULL);
					binsm(rec->big->bof, rec->small, (int) rec->len);
					boffline(rec->big);
					joe_free(rec->small);
				}
				bonline(rec->big);
				binsb(rec->big->bof, bcpy(b->bof, b->eof));
				boffline(rec->big);
			} else {
				rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
				mmove(rec->small + size, rec->small, (int) rec->len);
				brmem(b->bof, rec->small, (int) size);
			}
			rec->len += size;
			rec->where = where;
		} else {
			if (++nyanked == MAX_YANK) {
				frrec(deque_f(UNDOREC, link, yanked.link.next));
				--nyanked;
			}
			rec = alrec();
			if (size < SMALL) {
				rec->small = (unsigned char *) joe_malloc(size);
				brmem(b->bof, rec->small, (int) b->eof->byte);
			} else {
				rec->big = bcpy(b->bof, b->eof);
				boffline(rec->big);
			}
			rec->where = where;
			rec->len = size;
			rec->del = 1;
			enqueb(UNDOREC, link, &yanked, rec);
		}
	}
}

void undodel(UNDO *undo, long where, B *b)
{
	UNDOREC *rec;
	long size = b->eof->byte;

	if (inredo) {
		brm(b);
		return;
	}
	if (!inundo)
		if (undo->ptr && undo->ptr != &undo->recs)
			undoover(undo);

	yankdel(where, b);

	/* Store in undo buffer */
	rec = undo->recs.link.prev;
	if (rec != &undo->recs && rec->min && rec->del && where == rec->where) {
		if (rec->len + size >= SMALL) {
			if (rec->len < SMALL) {
				rec->big = bmk(NULL);
				binsm(rec->big->bof, rec->small, (int) rec->len);
				boffline(rec->big);
				joe_free(rec->small);
			}
			bonline(rec->big);
			binsb(rec->big->eof, b);
			boffline(rec->big);
		} else {
			rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
			brmem(b->bof, rec->small + rec->len, (int) size);
			brm(b);
		}
		rec->len += size;
	} else if (rec != &undo->recs && rec->min && rec->del && where + size == rec->where) {
		if (rec->len + size >= SMALL) {
			if (rec->len < SMALL) {
				rec->big = bmk(NULL);
				binsm(rec->big->bof, rec->small, (int) rec->len);
				boffline(rec->big);
				joe_free(rec->small);
			}
			bonline(rec->big);
			binsb(rec->big->bof, b);
			boffline(rec->big);
		} else {
			rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
			mmove(rec->small + size, rec->small, (int) rec->len);
			brmem(b->bof, rec->small, (int) size);
			brm(b);
		}
		rec->len += size;
		rec->where = where;
	} else {
		rec = alrec();
		if (size < SMALL) {
			rec->small = (unsigned char *) joe_malloc(size);
			brmem(b->bof, rec->small, (int) b->eof->byte);
			brm(b);
		} else {
			rec->big = b;
			boffline(b);
		}
		if (!undo->first)
			undo->first = rec;
		undo->last = rec;
		rec->where = where;
		rec->min = 1;
		rec->unit = NULL;
		rec->len = size;
		rec->del = 1;
		rec->changed = undo->b->changed;
		enqueb(UNDOREC, link, &undo->recs, rec);
	}
}

B *yankbuf = NULL;
long yankwhere = -1;

int uyank(BW *bw)
{
	UNDOREC *ptr = yanked.link.prev;

	if (ptr != &yanked) {
		if (ptr->len < SMALL)
			binsm(bw->cursor, ptr->small, (int) ptr->len);
		else {
			B *b = ptr->big;

			bonline(b);
			binsb(bw->cursor, bcpy(b->bof, b->eof));
			boffline(b);
		}
		pfwrd(bw->cursor, ptr->len);
		yankbuf = bw->b;
		yankwhere = bw->cursor->byte;
		return 0;
	} else
		return -1;
}

int uyankpop(BW *bw)
{
	if (bw->b == yankbuf && bw->cursor->byte == yankwhere) {
		P *q;
		UNDOREC *ptr = yanked.link.prev;

		deque(UNDOREC, link, &yanked);
		enqueb(UNDOREC, link, ptr, &yanked);
		q = pdup(bw->cursor, USTR "uyankpop");
		pbkwd(q, ptr->len);
		inyank = 1;
		bdel(q, bw->cursor);
		inyank = 0;
		prm(q);
		return uyank(bw);
	} else
		return uyank(bw);
}

/* Clear changed-flag: make buffer look unmodified */

int unotmod(BW *bw)
{
	bw_unlock(bw);
	bw->b->changed = 0;
	msgnw(bw->parent, joe_gettext(_("Modified flag cleared")));
	return 0;
}



int ucopy(BW *bw)
{
	if (markv(1) && !square) {
		B *b = bcpy(markb, markk);

		yankdel(markb->byte, b);
		brm(b);
		if (lightoff)
			unmark(bw);
		return 0;
	} else {
		msgnw(bw->parent, joe_gettext(_("No block")));
		return -1;
	}
}

/* Save yank buffers */

void save_yank(FILE *f)
{
	UNDOREC *rec;
	for (rec = yanked.link.next; rec != &yanked; rec = rec->link.next) {
		if (rec->len < SMALL) {
			fprintf(f,"	");
			emit_string(f,rec->small,rec->len);
			fprintf(f,"\n");
		}
	}
	fprintf(f,"done\n");
}

/* Load yank buffers */

void load_yank(FILE *f)
{
	UNDOREC *rec;
	unsigned char *buf = vsmk(1024);
	unsigned char *bf = vsmk(1024);
	while(vsgets(&buf,f) && zcmp(buf,USTR "done")) {
		unsigned char *p = buf;
		int len;
		parse_ws(&p,'#');
		len = parse_string(&p,&bf);
		if (len>0 && len<=SMALL) {
			if (++nyanked == MAX_YANK) {
				frrec(deque_f(UNDOREC, link, yanked.link.next));
				--nyanked;
			}
			rec = alrec();
			rec->small = (unsigned char *) joe_malloc(len);
			memcpy(rec->small,bf,len);
			rec->where = -1;
			rec->len = len;
			rec->del = 1;
			enqueb(UNDOREC, link, &yanked, rec);
		}
	}
}
@


1.32
log
@UC -> USTR
@
text
@d491 3
a493 3
	unsigned char buf[SMALL*4+80];
	unsigned char bf[SMALL+1];
	while(fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,USTR "done\n")) {
d497 1
a497 1
		len = parse_string(&p,bf,sizeof(bf));
@


1.31
log
@change US to UC
@
text
@d94 1
a94 1
		P *q = pdup(bw->cursor, UC "doundo");
d432 1
a432 1
		q = pdup(bw->cursor, UC "uyankpop");
d493 1
a493 1
	while(fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,UC "done\n")) {
@


1.30
log
@eliminate debug messages
@
text
@d94 1
a94 1
		P *q = pdup(bw->cursor, US "doundo");
d432 1
a432 1
		q = pdup(bw->cursor, US "uyankpop");
d493 1
a493 1
	while(fgets((char *)buf,sizeof(buf)-1,f) && zcmp(buf,US "done\n")) {
@


1.29
log
@undo_keep bug
@
text
@a28 12
static undodump()
{
	UNDO *undo;
	for (undo = undos.link.next; undo != &undos; undo = undo->link.next) {
		UNDOREC *rec;
		printf("\rUNDO %x nrecs=%d ptr=%x first=%x last=%x\n",undo,undo->nrecs,undo->ptr,undo->first,undo->last);
		for (rec = undo->recs.link.next; rec != &undo->recs; rec = rec->link.next) {
			printf("	recs=%x, del=%d, unit=%x\n",rec,rec->del,rec->unit);
		}
	}
}

@


1.28
log
@allow setting undo
@
text
@d20 1
a20 1
int inredo = 0;
d29 12
d137 7
a143 8
      loop:
	undo->ptr = undo->ptr->link.prev;
	pgoto(bw->cursor, undo->ptr->where);
	inundo = 1;
	doundo(bw, undo->ptr);
	inundo = 0;
	if (upto && upto != undo->ptr)
		goto loop;
d166 1
a166 1
		frrec(deque_f(UNDOREC, link, ptr));
d169 2
a192 2
	if (undo->ptr && undo->ptr->link.prev == &undo->recs)
		flg = 1;
d194 3
a196 1
		while (unit != undo->recs.link.next)
d198 3
d211 4
d227 2
a228 3
/* Delete the alternate time-line after the user has resumed editing after
 * undoing some number of changes
 */
@


1.27
log
@transpose menus
@
text
@d10 2
d200 4
a203 2
			if (++undo->nrecs == UNDOKEEP)
				undogc(undo);
@


1.26
log
@gettext()
@
text
@d12 2
d292 1
a292 1
			if (++nyanked == 100) {
d488 4
@


1.25
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d436 1
a436 1
	msgnw(bw->parent, US "Modified flag cleared");
d453 1
a453 1
		msgnw(bw->parent, US "No block");
@


1.24
log
@Allow escape sequences in strings.
@
text
@a7 1
#include "config.h"
a9 14
#include <string.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include "b.h"
#include "blocks.h"
#include "queue.h"
#include "ublock.h"
#include "utils.h"
#include "w.h"

extern int lightoff;

a17 2
extern int dostaupd;

@


1.23
log
@add joe_debug
@
text
@d483 1
a483 1
			emit_hdlc(f,rec->small,rec->len);
d501 1
a501 1
		len = parse_hdlc(&p,bf,sizeof(bf)-1);
@


1.22
log
@fix gcc-4.0.0 warnings
@
text
@d107 1
a107 1
		P *q = pdup(bw->cursor);
d436 1
a436 1
		q = pdup(bw->cursor);
@


1.21
log
@Fix bugs where doedit() was called and we expected the window to immediately
change.

Run -pedantic
@
text
@d11 1
d497 1
a497 1
	while(fgets((char *)buf,sizeof(buf)-1,f) && strcmp((char *)buf,"done\n")) {
@


1.20
log
@make locking optional
@
text
@d496 1
a496 1
	while(fgets(buf,sizeof(buf)-1,f) && strcmp(buf,"done\n")) {
@


1.19
log
@file locking.
@
text
@d85 1
a85 2
	if (bw->b->locked && !bw->b->ignored_lock && bw->b->name && bw->b->name[0]!='!' &&
	    bw->b->name[0]!='>' && bw->b->name[0]!='-') {
@


1.18
log
@option for mouse support
use \ for escape in joe_state
@
text
@d83 9
d113 2
d451 1
d457 2
@


1.17
log
@Clean up .joe_state file stuff some more.
@
text
@d481 3
a483 3
	unsigned char buf[4096];
	unsigned char bf[4096];
	while(fgets(buf,4095,f) && strcmp(buf,"done\n")) {
d487 1
a487 1
		len = parse_hdlc(&p,bf,4095);
@


1.16
log
@Fix bug in joe_state code: buffer was not large enough.
@
text
@d488 9
a496 7
		rec = alrec();
		rec->small = (unsigned char *) joe_malloc(len);
		memcpy(rec->small,bf,len);
		rec->where = -1;
		rec->len = len;
		rec->del = 1;
		enqueb(UNDOREC, link, &yanked, rec);
@


1.15
log
@Thu Jul  8 2004  Joe Allen <jhallen@@world.std.com>

	Merge last two changes (described below...)


Tue Jul  6 2004  Pavel Fedin <sonimiga@@rambler.ru>

     Changed some fork()s to vfork()s.
	Added ^# (CSI = 0x9B) control character.
	Added Amiga CSI sequences to keys definitions in joerc files.
	Added some #ifdef's to compile properly on AmigaOS.

Tue Jun 22 2004  Joe Allen <jhallen@@world.std.com>

	~/.joe_state file.

	Saves macros, yanks records, and file name history in a file.
@
text
@d481 3
a483 3
	unsigned char buf[1024];
	unsigned char bf[1024];
	while(fgets(buf,1023,f) && strcmp(buf,"done\n")) {
d487 1
a487 1
		len = parse_hdlc(&p,bf,1023);
@


1.14
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@d460 37
@


1.13
log
@change 0 to NULL where we're talking about pointers
@
text
@d273 1
a273 1
				rec->small = (char *) joe_realloc(rec->small, rec->len + size);
d289 1
a289 1
				rec->small = (char *) joe_realloc(rec->small, rec->len + size);
d302 1
a302 1
				rec->small = (char *) joe_malloc(size);
d345 1
a345 1
			rec->small = (char *) joe_realloc(rec->small, rec->len + size);
d362 1
a362 1
			rec->small = (char *) joe_realloc(rec->small, rec->len + size);
d372 1
a372 1
			rec->small = (char *) joe_malloc(size);
d441 1
a441 1
	msgnw(bw->parent, "Modified flag cleared");
d456 1
a456 1
		msgnw(bw->parent, "No block");
@


1.12
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d68 3
a70 3
	undo->ptr = 0;
	undo->last = 0;
	undo->first = 0;
d213 1
a213 1
	undo->ptr = 0;
d236 1
a236 1
		rec->unit = 0;
d384 1
a384 1
		rec->unit = 0;
d392 1
a392 1
B *yankbuf = 0;
@


1.11
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d119 4
a122 4
		/* If this return is uncommented, then uundo will jump to 
		   where the undo
		   is about to occur before actually undoing anything
		   return 0; */
d296 4
a299 2
			if (++nyanked == 100)
				frrec(deque_f(UNDOREC, link, yanked.link.next)), --nyanked;
@


1.10
log
@change function declaration "void a(P * p)" to "void a(P *p)"
@
text
@d19 1
d52 1
a52 1
			free(rec->small);
d267 1
a267 1
					free(rec->small);
d273 1
a273 1
				rec->small = (char *) realloc(rec->small, rec->len + size);
d283 1
a283 1
					free(rec->small);
d289 1
a289 1
				rec->small = (char *) realloc(rec->small, rec->len + size);
d300 1
a300 1
				rec->small = (char *) malloc(size);
d337 1
a337 1
				free(rec->small);
d343 1
a343 1
			rec->small = (char *) realloc(rec->small, rec->len + size);
d354 1
a354 1
				free(rec->small);
d360 1
a360 1
			rec->small = (char *) realloc(rec->small, rec->len + size);
d370 1
a370 1
			rec->small = (char *) malloc(size);
@


1.9
log
@change indentation of do {} while() cycles
@
text
@d47 1
a47 1
static void frrec(UNDOREC * rec)
d62 1
a62 1
UNDO *undomk(B * b)
d76 1
a76 1
void undorm(UNDO * undo)
d82 1
a82 1
static void doundo(BW * bw, UNDOREC * ptr)
d106 1
a106 1
int uundo(BW * bw)
d137 1
a137 1
int uredo(BW * bw)
d176 1
a176 1
static void undogc(UNDO * undo)
d210 1
a210 1
static void undoover(UNDO * undo)
d215 1
a215 1
void undoins(UNDO * undo, P * p, long size)
d243 1
a243 1
int uyapp(BW * bw)
d252 1
a252 1
static void yankdel(long where, B * b)
d313 1
a313 1
void undodel(UNDO * undo, long where, B * b)
d392 1
a392 1
int uyank(BW * bw)
d414 1
a414 1
int uyankpop(BW * bw)
d435 1
a435 1
int unotmod(BW * bw)
d442 1
a442 1
int ucopy(BW * bw)
@


1.8
log
@include only headers which are needed
@
text
@d158 1
a158 2
	}
	while (upto && upto != ptr);
@


1.7
log
@put struct definitions and other goodies into types.h
@
text
@d14 1
a15 1
#include "bw.h"
d17 1
d19 1
a19 1
#include "undo.h"
@


1.6
log
@use msgnw[t](W *, char *) instead of msgnw[t](BASE *, char *)
@
text
@d2 8
a9 5
	UNDO system
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a10 1
#include "config.h"
@


1.5
log
@use mfwrd() and mbkwd() only as internal functions to mmove()
@
text
@d436 1
a436 1
	msgnw(bw, "Modified flag cleared");
d451 1
a451 1
		msgnw(bw, "No block");
@


1.4
log
@version 2.9.7-pre3
@
text
@d287 1
a287 1
				mbkwd(rec->small + size, rec->small, (int) rec->len);
d358 1
a358 1
			mbkwd(rec->small + size, rec->small, (int) rec->len);
@


1.3
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d37 1
a37 1
UNDOREC *alrec()
d44 1
a44 1
void frrec(UNDOREC * rec)
d79 1
a79 1
void doundo(BW * bw, UNDOREC * ptr)
d160 1
a160 1
void umclear()
d190 1
a190 1
void undomark()
d250 1
a250 1
void yankdel(long where, B * b)
@


1.2
log
@changed as of joe-2.9.6
@
text
@d8 4
d37 1
a37 2
UNDOREC *
alrec ()
d39 2
a40 1
	UNDOREC *rec = (UNDOREC *) alitem (&frrecs, sizeof (UNDOREC));
d44 1
a44 2
void
frrec (UNDOREC * rec)
d46 1
a46 1
	if (rec->del)
d48 9
a56 8
			free (rec->small);
		else
		  {
			  B *b = rec->big;
			  bonline (b);
			  brm (b);
		  }
	enquef (UNDOREC, link, &frrecs, rec);
d59 1
a59 2
UNDO *
undomk (B * b)
d61 2
a62 1
	UNDO *undo = (UNDO *) alitem (&frdos, sizeof (UNDO));
d68 2
a69 2
	izque (UNDOREC, link, &undo->recs);
	enquef (UNDO, link, &undos, undo);
d73 4
a76 3
void undorm (UNDO *undo) {
	frchn (&frrecs, &undo->recs);
	demote (UNDO, link, &frdos, undo);
d79 1
a79 2
void
doundo (BW * bw, UNDOREC * ptr)
d83 17
a99 19
	if (ptr->del)
	  {
		  if (ptr->len < SMALL)
			  binsm (bw->cursor, ptr->small, (int) ptr->len);
		  else
		    {
			    B *b = ptr->big;
			    bonline (b);
			    binsb (bw->cursor, bcpy (b->bof, b->eof));
			    boffline (b);
		    }
	  }
	else
	  {
		  P *q = pdup (bw->cursor);
		  pfwrd (q, ptr->len);
		  bdel (bw->cursor, q);
		  prm (q);
	  }
d103 1
a103 2
int
uundo (BW * bw)
d112 8
a119 9
	if (!undo->ptr)
	  {
		  pgoto (bw->cursor, undo->recs.link.prev->where);
		  undo->ptr = &undo->recs;
		  /* If this return is uncommented, then uundo will jump to 
		     where the undo
		     is about to occur before actually undoing anything
		     return 0; */
	  }
d125 1
a125 1
	pgoto (bw->cursor, undo->ptr->where);
d127 1
a127 1
	doundo (bw, undo->ptr);
d134 1
a134 2
int
uredo (BW * bw)
d147 9
a155 10
	do
	  {
		  ptr = undo->recs.link.prev;
		  pgoto (bw->cursor, ptr->where);
		  inredo = 1;
		  doundo (bw, ptr);
		  inredo = 0;
		  frrec (deque (UNDOREC, link, ptr));
		  undo->ptr = undo->ptr->link.next;
	  }
d160 1
a160 2
void
umclear ()
d164 6
a169 6
	for (undo = undos.link.next; undo != &undos; undo = undo->link.next)
	  {
		  UNDOREC *rec;
		  for (rec = undo->recs.link.next; rec != &undo->recs;
		       rec = rec->link.next) rec->min = 0;
	  }
d174 1
a174 2
static void
undogc (UNDO * undo)
d183 2
a184 2
			frrec (deque (UNDOREC, link, undo->recs.link.next));
	frrec (deque (UNDOREC, link, undo->recs.link.next));
d190 1
a190 2
void
undomark ()
d193 1
d195 7
a201 8
		if (undo->first)
		  {
			  undo->first->unit = undo->last;
			  undo->last->unit = undo->first;
			  undo->first = undo->last = 0;
			  if (++undo->nrecs == UNDOKEEP)
				  undogc (undo);
		  }
d208 1
a208 2
static void
undoover (UNDO * undo)
d213 1
a213 2
void
undoins (UNDO * undo, P * p, long size)
d221 1
a221 1
			undoover (undo);
d223 1
a223 2
	if (rec != &undo->recs && rec->min && !rec->del
	    && (p->byte == rec->where + rec->len || p->byte == rec->where))
d225 13
a237 14
	else
	  {
		  rec = alrec ();
		  rec->del = 0;
		  if (!undo->first)
			  undo->first = rec;
		  undo->last = rec;
		  rec->where = p->byte;
		  rec->min = 1;
		  rec->unit = 0;
		  rec->len = size;
		  rec->changed = undo->b->changed;
		  enqueb (UNDOREC, link, &undo->recs, rec);
	  }
d241 1
a241 2
int
uyapp (BW * bw)
d244 1
d250 1
a250 2
void
yankdel (long where, B * b)
d257 52
a308 85
	if (!inyank)
		if (rec != &yanked && where == rec->where && justkilled)
		  {
			  if (rec->len + size >= SMALL)
			    {
				    if (rec->len < SMALL)
				      {
					      rec->big = bmk (NULL);
					      binsm (rec->big->bof,
						     rec->small,
						     (int) rec->len);
					      boffline (rec->big);
					      free (rec->small);
				      }
				    bonline (rec->big);
				    binsb (rec->big->eof,
					   bcpy (b->bof, b->eof));
				    boffline (rec->big);
			    }
			  else
			    {
				    rec->small =
					    (char *) realloc (rec->small,
							      rec->len +
							      size);
				    brmem (b->bof, rec->small + rec->len,
					   (int) size);
			    }
			  rec->len += size;
		  }
		else if (rec != &yanked && where + size == rec->where
			 && justkilled)
		  {
			  if (rec->len + size >= SMALL)
			    {
				    if (rec->len < SMALL)
				      {
					      rec->big = bmk (NULL);
					      binsm (rec->big->bof,
						     rec->small,
						     (int) rec->len);
					      boffline (rec->big);
					      free (rec->small);
				      }
				    bonline (rec->big);
				    binsb (rec->big->bof,
					   bcpy (b->bof, b->eof));
				    boffline (rec->big);
			    }
			  else
			    {
				    rec->small =
					    (char *) realloc (rec->small,
							      rec->len +
							      size);
				    mbkwd (rec->small + size, rec->small,
					   (int) rec->len);
				    brmem (b->bof, rec->small, (int) size);
			    }
			  rec->len += size;
			  rec->where = where;
		  }
		else
		  {
			  if (++nyanked == 100)
				  frrec (deque
					 (UNDOREC, link, yanked.link.next)),
					  --nyanked;
			  rec = alrec ();
			  if (size < SMALL)
			    {
				    rec->small = (char *) malloc (size);
				    brmem (b->bof, rec->small,
					   (int) b->eof->byte);
			    }
			  else
			    {
				    rec->big = bcpy (b->bof, b->eof);
				    boffline (rec->big);
			    }
			  rec->where = where;
			  rec->len = size;
			  rec->del = 1;
			  enqueb (UNDOREC, link, &yanked, rec);
		  }
d311 1
a311 2
void
undodel (UNDO * undo, long where, B * b)
d316 4
a319 5
	if (inredo)
	  {
		  brm (b);
		  return;
	  }
d322 1
a322 1
			undoover (undo);
d324 1
a324 1
	yankdel (where, b);
d328 57
a384 81
	if (rec != &undo->recs && rec->min && rec->del && where == rec->where)
	  {
		  if (rec->len + size >= SMALL)
		    {
			    if (rec->len < SMALL)
			      {
				      rec->big = bmk (NULL);
				      binsm (rec->big->bof, rec->small,
					     (int) rec->len);
				      boffline (rec->big);
				      free (rec->small);
			      }
			    bonline (rec->big);
			    binsb (rec->big->eof, b);
			    boffline (rec->big);
		    }
		  else
		    {
			    rec->small =
				    (char *) realloc (rec->small,
						      rec->len + size);
			    brmem (b->bof, rec->small + rec->len, (int) size);
			    brm (b);
		    }
		  rec->len += size;
	  }
	else if (rec != &undo->recs && rec->min && rec->del
		 && where + size == rec->where)
	  {
		  if (rec->len + size >= SMALL)
		    {
			    if (rec->len < SMALL)
			      {
				      rec->big = bmk (NULL);
				      binsm (rec->big->bof, rec->small,
					     (int) rec->len);
				      boffline (rec->big);
				      free (rec->small);
			      }
			    bonline (rec->big);
			    binsb (rec->big->bof, b);
			    boffline (rec->big);
		    }
		  else
		    {
			    rec->small =
				    (char *) realloc (rec->small,
						      rec->len + size);
			    mbkwd (rec->small + size, rec->small,
				   (int) rec->len);
			    brmem (b->bof, rec->small, (int) size);
			    brm (b);
		    }
		  rec->len += size;
		  rec->where = where;
	  }
	else
	  {
		  rec = alrec ();
		  if (size < SMALL)
		    {
			    rec->small = (char *) malloc (size);
			    brmem (b->bof, rec->small, (int) b->eof->byte);
			    brm (b);
		    }
		  else
		    {
			    rec->big = b;
			    boffline (b);
		    }
		  if (!undo->first)
			  undo->first = rec;
		  undo->last = rec;
		  rec->where = where;
		  rec->min = 1;
		  rec->unit = 0;
		  rec->len = size;
		  rec->del = 1;
		  rec->changed = undo->b->changed;
		  enqueb (UNDOREC, link, &undo->recs, rec);
	  }
d390 1
a390 2
int
uyank (BW * bw)
d394 15
a408 17
	if (ptr != &yanked)
	  {
		  if (ptr->len < SMALL)
			  binsm (bw->cursor, ptr->small, (int) ptr->len);
		  else
		    {
			    B *b = ptr->big;
			    bonline (b);
			    binsb (bw->cursor, bcpy (b->bof, b->eof));
			    boffline (b);
		    }
		  pfwrd (bw->cursor, ptr->len);
		  yankbuf = bw->b;
		  yankwhere = bw->cursor->byte;
		  return 0;
	  }
	else
d412 1
a412 2
int
uyankpop (BW * bw)
d414 15
a428 16
	if (bw->b == yankbuf && bw->cursor->byte == yankwhere)
	  {
		  P *q;
		  UNDOREC *ptr = yanked.link.prev;
		  deque (UNDOREC, link, &yanked);
		  enqueb (UNDOREC, link, ptr, &yanked);
		  q = pdup (bw->cursor);
		  pbkwd (q, ptr->len);
		  inyank = 1;
		  bdel (q, bw->cursor);
		  inyank = 0;
		  prm (q);
		  return uyank (bw);
	  }
	else
		return uyank (bw);
d433 1
a433 2
int
unotmod (BW * bw)
d436 1
a436 1
	msgnw (bw, "Modified flag cleared");
d440 1
a440 2
int
ucopy (BW * bw)
d442 12
a453 14
	if (markv (1) && !square)
	  {
		  B *b = bcpy (markb, markk);
		  yankdel (markb->byte, b);
		  brm (b);
		  if (lightoff)
			  unmark (bw);
		  return 0;
	  }
	else
	  {
		  msgnw (bw, "No block");
		  return -1;
	  }
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
/* UNDO system
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d18 2
a19 7
static UNDO undos={{&undos,&undos}};
static UNDO frdos={{&frdos,&frdos}};

int inundo=0;
int inredo=0;

UNDOREC frrecs={{&frrecs,&frrecs}};
d21 2
a22 40
UNDOREC *alrec()
 {
 UNDOREC *rec=(UNDOREC *)alitem(&frrecs,sizeof(UNDOREC));
 return rec;
 }

void frrec(rec)
UNDOREC *rec;
 {
 if(rec->del)
  if(rec->len<SMALL) free(rec->small);
  else
   {
   B *b=rec->big;
   bonline(b);
   brm(b);
   }
 enquef(UNDOREC,link,&frrecs,rec);
 }

UNDO *undomk(b)
B *b;
 {
 UNDO *undo=(UNDO *)alitem(&frdos,sizeof(UNDO));
 undo->nrecs=0;
 undo->ptr=0;
 undo->last=0;
 undo->first=0;
 undo->b=b;
 izque(UNDOREC,link,&undo->recs);
 enquef(UNDO,link,&undos,undo);
 return undo;
 }

void undorm(undo)
UNDO *undo;
 {
 frchn(&frrecs,&undo->recs);
 demote(UNDO,link,&frdos,undo);
 }
d26 148
a173 87
void doundo(bw,ptr)
BW *bw;
UNDOREC *ptr;
 {
 dostaupd=1;
 if(ptr->del)
  {
  if(ptr->len<SMALL)
   binsm(bw->cursor,ptr->small,(int)ptr->len);
  else
   {
   B *b=ptr->big;
   bonline(b);
   binsb(bw->cursor,bcpy(b->bof,b->eof));
   boffline(b);
   }
  }
 else
  {
  P *q=pdup(bw->cursor);
  pfwrd(q,ptr->len);
  bdel(bw->cursor,q);
  prm(q);
  }
 bw->b->changed=ptr->changed;
 }

int uundo(bw)
BW *bw;
 {
 UNDOREC *upto;
 UNDO *undo=bw->b->undo;
 if(!undo) return -1;
 if(!undo->nrecs) return -1;
 if(!undo->ptr)
  {
  pgoto(bw->cursor,undo->recs.link.prev->where);
  undo->ptr= &undo->recs;
  /* If this return is uncommented, then uundo will jump to where the undo
  is about to occur before actually undoing anything
  return 0; */
  }
 if(undo->ptr->link.prev==&undo->recs) return -1;
 upto=undo->ptr->link.prev->unit;
 loop:
 undo->ptr=undo->ptr->link.prev;
 pgoto(bw->cursor,undo->ptr->where);
 inundo=1;
 doundo(bw,undo->ptr);
 inundo=0;
 if(upto && upto!=undo->ptr) goto loop;
 return 0;
 }

int uredo(bw)
BW *bw;
 {
 UNDOREC *upto;
 UNDOREC *ptr;
 UNDO *undo=bw->b->undo;
 if(!undo) return -1;
 if(!undo->ptr) return -1;
 if(undo->ptr==&undo->recs) return -1;
 upto=undo->recs.link.prev->unit;
 do
  {
  ptr=undo->recs.link.prev;
  pgoto(bw->cursor,ptr->where);
  inredo=1;
  doundo(bw,ptr);
  inredo=0;
  frrec(deque(UNDOREC,link,ptr));
  undo->ptr=undo->ptr->link.next;
  }
  while(upto && upto!=ptr);
 return 0;
 }

void umclear()
 {
 UNDO *undo;
 for(undo=undos.link.next;undo!=&undos;undo=undo->link.next)
  {
  UNDOREC *rec;
  for(rec=undo->recs.link.next;rec!=&undo->recs;rec=rec->link.next) rec->min=0;
  }
 }
d177 31
a207 26
static void undogc(undo)
UNDO *undo;
 {
 UNDOREC *unit=undo->recs.link.next->unit;
 int flg=0;
 if(undo->ptr && undo->ptr->link.prev==&undo->recs) flg=1;
 if(unit)
  while(unit!=undo->recs.link.next)
   frrec(deque(UNDOREC,link,undo->recs.link.next));
 frrec(deque(UNDOREC,link,undo->recs.link.next));
 --undo->nrecs;
 if(flg) undo->ptr=undo->recs.link.next;
 }

void undomark()
 {
 UNDO *undo;
 for(undo=undos.link.next;undo!=&undos;undo=undo->link.next)
  if(undo->first)
   {
   undo->first->unit=undo->last;
   undo->last->unit=undo->first;
   undo->first=undo->last=0;
   if(++undo->nrecs==UNDOKEEP) undogc(undo);
   }
 }
d213 291
a503 260
static void undoover(undo)
UNDO *undo;
 {
 undo->ptr=0;
 }

void undoins(undo,p,size)
UNDO *undo;
P *p;
long size;
 {
 UNDOREC *rec;
 if(inredo) return;
 if(!inundo) if(undo->ptr && undo->ptr!=&undo->recs) undoover(undo);
 rec=undo->recs.link.prev;
 if(rec!=&undo->recs && rec->min && !rec->del &&
    (p->byte==rec->where+rec->len || p->byte==rec->where)) rec->len+=size;
 else
  {
  rec=alrec();
  rec->del=0;
  if(!undo->first) undo->first=rec;
  undo->last=rec;
  rec->where=p->byte;
  rec->min=1;
  rec->unit=0;
  rec->len=size;
  rec->changed=undo->b->changed;
  enqueb(UNDOREC,link,&undo->recs,rec);
  }
 }

UNDOREC yanked={{&yanked,&yanked}};
int nyanked=0;
int inyank=0;
int justkilled=0;

int uyapp(bw)
BW *bw;
 {
 UNDOREC *rec=yanked.link.prev;
 if(rec!=&yanked) rec->where=bw->cursor->byte;
 return 0;
 }

void yankdel(where,b)
long where;
B *b;
 {
 UNDOREC *rec;
 long size=b->eof->byte;

 /* Store in yank buffer */
 rec=yanked.link.prev;
 if(!inyank)
 if(rec!=&yanked && where==rec->where && justkilled)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->eof,bcpy(b->bof,b->eof));
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   brmem(b->bof,rec->small+rec->len,(int)size);
   }
  rec->len+=size;
  }
 else if(rec!=&yanked && where+size==rec->where && justkilled)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->bof,bcpy(b->bof,b->eof));
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   mbkwd(rec->small+size,rec->small,(int)rec->len);
   brmem(b->bof,rec->small,(int)size);
   }
  rec->len+=size;
  rec->where=where;
  }
 else
  {
  if(++nyanked==100)
   frrec(deque(UNDOREC,link,yanked.link.next)), --nyanked;
  rec=alrec();
  if(size<SMALL)
   {
   rec->small=(char *)malloc(size);
   brmem(b->bof,rec->small,(int)b->eof->byte);
   }
  else
   {
   rec->big=bcpy(b->bof,b->eof);
   boffline(rec->big);
   }
  rec->where=where;
  rec->len=size;
  rec->del=1;
  enqueb(UNDOREC,link,&yanked,rec);
  }
 }

void undodel(undo,where,b)
UNDO *undo;
long where;
B *b;
 {
 UNDOREC *rec;
 long size=b->eof->byte;
 if(inredo)
  {
  brm(b);
  return;
  }
 if(!inundo) if(undo->ptr && undo->ptr!=&undo->recs) undoover(undo);

 yankdel(where,b);

 /* Store in undo buffer */
 rec=undo->recs.link.prev;
 if(rec!=&undo->recs && rec->min && rec->del && where==rec->where)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->eof,b);
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   brmem(b->bof,rec->small+rec->len,(int)size);
   brm(b);
   }
  rec->len+=size;
  }
 else if(rec!=&undo->recs && rec->min && rec->del && where+size==rec->where)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->bof,b);
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   mbkwd(rec->small+size,rec->small,(int)rec->len);
   brmem(b->bof,rec->small,(int)size);
   brm(b);
   }
  rec->len+=size;
  rec->where=where;
  }
 else
  {
  rec=alrec();
  if(size<SMALL)
   {
   rec->small=(char *)malloc(size);
   brmem(b->bof,rec->small,(int)b->eof->byte);
   brm(b);
   }
  else
   {
   rec->big=b;
   boffline(b);
   }
  if(!undo->first) undo->first=rec;
  undo->last=rec;
  rec->where=where;
  rec->min=1;
  rec->unit=0;
  rec->len=size;
  rec->del=1;
  rec->changed=undo->b->changed;
  enqueb(UNDOREC,link,&undo->recs,rec);
  }
 }

B *yankbuf=0;
long yankwhere= -1;

int uyank(bw)
BW *bw;
 {
 UNDOREC *ptr=yanked.link.prev;
 if(ptr!=&yanked)
  {
  if(ptr->len<SMALL)
   binsm(bw->cursor,ptr->small,(int)ptr->len);
  else
   {
   B *b=ptr->big;
   bonline(b);
   binsb(bw->cursor,bcpy(b->bof,b->eof));
   boffline(b);
   }
  pfwrd(bw->cursor,ptr->len);
  yankbuf=bw->b;
  yankwhere=bw->cursor->byte;
  return 0;
  }
 else return -1;
 }

int uyankpop(bw)
BW *bw;
 {
 if(bw->b==yankbuf && bw->cursor->byte==yankwhere)
  {
  P *q;
  UNDOREC *ptr=yanked.link.prev;
  deque(UNDOREC,link,&yanked);
  enqueb(UNDOREC,link,ptr,&yanked);
  q=pdup(bw->cursor);
  pbkwd(q,ptr->len);
  inyank=1;
  bdel(q,bw->cursor);
  inyank=0;
  prm(q);
  return uyank(bw);
  }
 else return uyank(bw);
 }
d507 26
a532 25
int unotmod(bw)
BW *bw;
 {
 bw->b->changed=0;
 msgnw(bw,"Modified flag cleared");
 return 0;
 }

int ucopy(bw)
BW *bw;
 {
 if(markv(1) && !square)
  {
  B *b=bcpy(markb,markk);
  yankdel(markb->byte,b);
  brm(b);
  if(lightoff) unmark(bw);
  return 0;
  }
 else
  {
  msgnw(bw,"No block");
  return -1;
  }
 }
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
