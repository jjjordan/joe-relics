head	1.34;
access;
symbols
	joe_3_5:1.33
	joe-3_4:1.27
	help:1.27
	joe_3_1:1.22
	joe_3_0:1.20
	joe_2_9_8:1.19
	joe_2_9_8_pre1:1.13
	joe_2_9_7:1.6
	joe_2_9_7_pre3:1.6
	joe_2_9_7_pre2:1.5
	joe_2_9_6:1.4
	joe_2_9_5:1.3
	joe_2_9_4:1.2
	joe_2_9_2:1.2
	joe_2_9_1:1.1.1.1
	joe_2_9:1.1.1.1
	joe_source:1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2006.07.20.20.56.17;	author jhallen;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.19.14.07.43;	author jhallen;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.19.00.27.12;	author jhallen;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.19.00.05.55;	author jhallen;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.18.23.31.54;	author jhallen;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.18.23.28.56;	author jhallen;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.18.23.16.09;	author jhallen;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.22.04.15.41;	author jhallen;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.14.18.06.20;	author jhallen;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.14.17.14.04;	author jhallen;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.20.01.31.50;	author jhallen;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.24.04.30.51;	author jhallen;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.13.03.51.53;	author jhallen;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.03.12.17.02;	author jhallen;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.12.13.58.27;	author jhallen;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.04.17.39.17;	author vsamel;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.10.12.15.16;	author vsamel;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.10.12.13.32;	author vsamel;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.12.10.28;	author vsamel;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.10.12.09.40;	author vsamel;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.13.15.27.18;	author vsamel;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.14.01.27;	author vsamel;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.13.17.42;	author vsamel;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.13.14.16;	author vsamel;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.29.14.43.34;	author vsamel;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.13.27.32;	author vsamel;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.15.57.45;	author vsamel;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.12.15.35.52;	author vsamel;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.29.15.28.38;	author vsamel;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.29.14.39.52;	author vsamel;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.04.38.37;	author polesapart;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.04.06.35;	author polesapart;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.03.57.30;	author polesapart;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.11.03.40.05;	author polesapart;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.11.03.40.05;	author polesapart;	state Exp;
branches;
next	;


desc
@@


1.34
log
@semiautomatic variables
@
text
@/*
 *	TERMCAP/TERMINFO database interface
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "types.h"

#ifdef TERMINFO

/* Fixes for itanium */

#ifdef HAVE_CURSES_H
#include <curses.h>
#endif

/* curses has to come before term.h on SGI */
#ifdef HAVE_TERM_H
/* term.h is a disaster: it #defines 'tab' */
#include <term.h>
#endif

#endif

int dopadding = 0;
unsigned char *joeterm = NULL;

/* Default termcap entry */

unsigned char defentry[] = "\
:co#80:li#25:am:\
:ho=\\E[H:cm=\\E[%i%d;%dH:cV=\\E[%i%dH:\
:up=\\E[A:UP=\\E[%dA:DO=\\E[%dB:nd=\\E[C:RI=\\E[%dC:LE=\\E[%dD:\
:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:\
:so=\\E[7m:se=\\E[m:us=\\E[4m:ue=\\E[m:\
:mb=\\E[5m:md=\\E[1m:mh=\\E[2m:me=\\E[m:\
:ku=\\E[A:kd=\\E[B:kl=\\E[D:kr=\\E[C:\
:al=\\E[L:AL=\\E[%dL:dl=\\E[M:DL=\\E[%dM:\
:ic=\\E[@@:IC=\\E[%d@@:dc=\\E[P:DC=\\E[%dP:\
";

/* Return true if termcap line matches name */

static int match(unsigned char *s, unsigned char *name)
{
	if (s[0] == 0 || s[0] == '#')
		return 0;
	do {
		int x;

		for (x = 0; s[x] == name[x] && name[x] && s[x]; ++x) ;
		if (name[x] == 0 && (s[x] == ':' || s[x] == '|'))
			return 1;
		while (s[x] != ':' && s[x] != '|' && s[x])
			++x;
		s += x + 1;
	} while (s[-1] == '|');
	return 0;
}

/* Find termcap entry in a file */

static unsigned char *lfind(unsigned char *s, int pos, FILE *fd, unsigned char *name)
{
	int c, x;

	if (!s)
		s = vsmk(1024);
      loop:
	while (c = getc(fd), c == ' ' || c == '\t' || c == '#')
		do {
			c = getc(fd);
		} while (!(c == -1 || c == '\n'));
	if (c == -1)
		return s = vstrunc(s, pos);
	ungetc(c, fd);
	s = vstrunc(s, x = pos);
	while (1) {
		c = getc(fd);
		if (c == -1 || c == '\n')
			if (x != pos && s[x - 1] == '\\') {
				--x;
				if (!match(s + pos, name))
					goto loop;
				else
					break;
			} else if (!match(s + pos, name))
				goto loop;
			else
				return vstrunc(s, x);
		else if (c == '\r')
			/* do nothing */;
		else {
			s = vsset(s, x, c);
			++x;
		}
	}
	while (c = getc(fd), c != -1)
		if (c == '\n')
			if (s[x - 1] == '\\')
				--x;
			else
				break;
		else if (c == '\r')
			/* do nothing */;
		else {
			s = vsset(s, x, c);
			++x;
		}
	s = vstrunc(s, x);
	return s;
}

/* Lookup termcap entry in index */

static long findidx(FILE *file, unsigned char *name)
{
	unsigned char buf[80];
	long addr = 0;

	while (fgets((char *)buf, 80, file)) {
		int x = 0, flg = 0, c, y, z;

		do {
			for (y = x; buf[y] && buf[y] != ' ' && buf[y] != '\n'; ++y) ;
			c = buf[y];
			buf[y] = 0;
			if (c == '\n' || !c) {
				z = 0;
				sscanf((char *)(buf + x), "%x", (unsigned *)&z);
				addr += z;
			} else if (!zcmp(buf + x, name))
				flg = 1;
			x = y + 1;
		} while (c && c != '\n');
		if (flg)
			return addr;
	}
	return 0;
}

/* Load termcap entry */

CAP *getcap(unsigned char *name, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
{
	CAP *cap;
	FILE *f, *f1;
	long idx;
	int x, y, c, z, ti;
	unsigned char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
	int sortsiz;

	if (!name && !(name = joeterm) && !(name = (unsigned char *)getenv("TERM")))
		return NULL;
	cap = (CAP *) joe_malloc(sizeof(CAP));
	cap->tbuf = vsmk(4096);
	obj_perm(cap->tbuf);
	cap->abuf = NULL;
	cap->sort = NULL;

#ifdef TERMINFO
	cap->abuf = (unsigned char *) joe_malloc(4096);
	cap->abufp = cap->abuf;
	if (tgetent((char *)cap->tbuf, (char *)name) == 1)
		return setcap(cap, baud, out, outptr);
	else {
		joe_free(cap->abuf);
		cap->abuf = NULL;
	}
#endif

	name = vsncpy(NULL, 0, sz(name));
	cap->sort = (struct sortentry *) joe_malloc(sizeof(struct sortentry) * (sortsiz = 64));

	cap->sortlen = 0;

	tp = (unsigned char *)getenv("TERMCAP");

	if (tp && tp[0] == '/')
		namebuf = vsncpy(NULL, 0, sz(tp));
	else {
		if (tp)
			cap->tbuf = vsncpy(sv(cap->tbuf), sz(tp));
		if ((tp = (unsigned char *)getenv("TERMPATH")))
			namebuf = vsncpy(NULL, 0, sz(tp));
		else {
			if ((tp = (unsigned char *)getenv("HOME"))) {
				namebuf = vsncpy(NULL, 0, sz(tp));
				namebuf = vsadd(namebuf, '/');
			} else
				namebuf = NULL;
			namebuf = vsncpy(sv(namebuf), sc(".termcap "));
			namebuf = vsncpy(sv(namebuf), sc(JOERC));
			namebuf = vsncpy(sv(namebuf), sc("termcap /etc/termcap"));
		}
	}

	npbuf = vawords(NULL, sv(namebuf), sc("\t :"));

	y = 0;
	ti = 0;

	if (match(cap->tbuf, name))
		goto checktc;

	cap->tbuf = vstrunc(cap->tbuf, 0);

      nextfile:
	if (!npbuf[y]) {
/*
 varm(npbuf);
 vsrm(name);
 vsrm(cap->tbuf);
 joe_free(cap->sort);
 joe_free(cap);
 return 0;
*/
		fprintf(stderr, (char *)joe_gettext(_("Couldn't load termcap entry.  Using ansi default\n")));
		ti = 0;
		cap->tbuf = vsncpy(cap->tbuf, 0, sc(defentry));
		goto checktc;
	}
	idx = 0;
	idxname = vsncpy(NULL, 0, sz(npbuf[y]));
	idxname = vsncpy(idxname, vslen(idxname), sc(".idx"));
	f1 = fopen((char *)(npbuf[y]), "r");
	++y;
	if (!f1)
		goto nextfile;
	f = fopen((char *)idxname, "r");
	if (f) {
		struct stat buf, buf1;

		fstat(fileno(f), &buf);
		fstat(fileno(f1), &buf1);
		if (buf.st_mtime > buf1.st_mtime)
			idx = findidx(f, name);
		else
			fprintf(stderr, (char *)joe_gettext(_("%s is out of date\n")), idxname);
		fclose(f);
	}
	fseek(f1, idx, 0);
	cap->tbuf = lfind(cap->tbuf, ti, f1, name);
	fclose(f1);
	if (vslen(cap->tbuf) == ti)
		goto nextfile;

      checktc:
	x = vslen(cap->tbuf);
	do {
		cap->tbuf[x] = 0;
		while (x && cap->tbuf[--x] != ':')
			/* do nothing */;
	} while (x && (!cap->tbuf[x + 1] || cap->tbuf[x + 1] == ':'));

	if (cap->tbuf[x + 1] == 't' && cap->tbuf[x + 2] == 'c' && cap->tbuf[x + 3] == '=') {
		name = vsncpy(NULL, 0, sz(cap->tbuf + x + 4));
		cap->tbuf[x] = 0;
		cap->tbuf[x + 1] = 0;
		ti = x + 1;
		obj_len(cap->tbuf) = x + 1;
		if (y)
			--y;
		goto nextfile;
	}

      doline:
	pp = cap->tbuf + ti;

/* Process line at pp */

      loop:
	while (*pp && *pp != ':')
		++pp;
	if (*pp) {
		int q;

		*pp++ = 0;
	      loop1:
		if (pp[0] == ' ' || pp[0] == '\t')
			goto loop;
		for (q = 0; pp[q] && pp[q] != '#' && pp[q] != '=' && pp[q] != '@@' && pp[q] != ':'; ++q) ;
		qq = pp;
		c = pp[q];
		pp[q] = 0;
		if (c)
			pp += q + 1;
		else
			pp += q;

		x = 0;
		y = cap->sortlen;
		z = -1;
		if (!y) {
			z = 0;
			goto in;
		}
		while (z != (x + y) / 2) {
			int found;

			z = (x + y) / 2;
			found = zcmp(qq, cap->sort[z].name);
			if(found > 0) {
				x = z;
			} else if(found < 0) {
				y = z;
			} else {
				if (c == '@@')
					mmove(cap->sort + z, cap->sort + z + 1, (cap->sortlen-- - (z + 1)) * sizeof(struct sortentry));

				else if (c && c != ':')
					cap->sort[z].value = qq + q + 1;
				else
					cap->sort[z].value = NULL;
				if (c == ':')
					goto loop1;
				else
					goto loop;
			}
		}
	      in:
		if (cap->sortlen == sortsiz)
			cap->sort = (struct sortentry *) joe_realloc(cap->sort, (sortsiz += 32) * sizeof(struct sortentry));
		mmove(cap->sort + y + 1, cap->sort + y, (cap->sortlen++ - y) * sizeof(struct sortentry));

		cap->sort[y].name = qq;
		if (c && c != ':')
			cap->sort[y].value = qq + q + 1;
		else
			cap->sort[y].value = NULL;
		if (c == ':')
			goto loop1;
		else
			goto loop;
	}

	if (ti) {
		for (--ti; ti; --ti)
			if (!cap->tbuf[ti - 1])
				break;
		goto doline;
	}

	cap->pad = jgetstr(cap, USTR "pc");
	if (dopadding)
		cap->dopadding = 1;
	else
		cap->dopadding = 0;

/* show sorted entries
	for(x=0;x!=cap->sortlen;++x)
		printf("%s = %s\n",cap->sort[x].name,cap->sort[x].value);
*/
	return setcap(cap, baud, out, outptr);
}

static struct sortentry *findcap(CAP *cap, unsigned char *name)
{
	int x, y, z;
	int found;

	x = 0;
	y = cap->sortlen;
	z = -1;
	while (z != (x + y) / 2) {
		z = (x + y) / 2;
		found = zcmp(name, cap->sort[z].name);
		if (found > 0)
			x = z;
		else if (found < 0)
			y = z;
		else
			return cap->sort + z;
	}
	return NULL;
}

CAP *setcap(CAP *cap, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
{
	cap->baud = baud;
	cap->div = 100000 / baud;
	cap->out = out;
	cap->outptr = outptr;
	return cap;
}

int getflag(CAP *cap, unsigned char *name)
{
#ifdef TERMINFO
	if (cap->abuf)
		return tgetflag((char *)name);
#endif
	return findcap(cap, name) != NULL;
}

unsigned char *jgetstr(CAP *cap, unsigned char *name)
{
	struct sortentry *s;

#ifdef TERMINFO
	if (cap->abuf) {
		char *new_ptr = (char *)cap->abufp;
		char *rtn;
		rtn = tgetstr((char *)name, &new_ptr);
		cap->abufp = (unsigned char *)new_ptr;
		return (unsigned char *)rtn;
	}
#endif
	s = findcap(cap, name);
	if (s)
		return s->value;
	else
		return NULL;
}

int getnum(CAP *cap, unsigned char *name)
{
	struct sortentry *s;

#ifdef TERMINFO
	if (cap->abuf)
		return tgetnum((char *)name);
#endif
	s = findcap(cap, name);
	if (s && s->value)
		return atoi((char *)(s->value));
	return -1;
}

void rmcap(CAP *cap)
{
	obj_free(cap->tbuf);
	if (cap->abuf)
		joe_free(cap->abuf);
	if (cap->sort)
		joe_free(cap->sort);
	joe_free(cap);
}

static unsigned char escape1(unsigned char **s)
{
	unsigned char c = *(*s)++;

	if (c == '^' && **s)
		if (**s != '?')
			return 037 & *(*s)++;
		else {
			(*s)++;
			return 127;
		}
	else if (c == '\\' && **s)
		switch (c = *((*s)++)) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			c -= '0';
			if (**s >= '0' && **s <= '7')
				c = (c << 3) + *((*s)++) - '0';
			if (**s >= '0' && **s <= '7')
				c = (c << 3) + *((*s)++) - '0';
			return c;
		case 'e':
		case 'E':
			return 27;
		case 'n':
		case 'l':
			return 10;
		case 'r':
			return 13;
		case 't':
			return 9;
		case 'b':
			return 8;
		case 'f':
			return 12;
		case 's':
			return 32;
		default:
			return c;
	} else
		return c;
}

static CAP *outcap;
static int outout(int c)
{
	outcap->out(outcap->outptr, c);
	return(c);	/* act like putchar() - return written char */
}

void texec(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3)
{
	int c, tenth = 0, x;
	int args[4];
	int vars[128];
	int *a = args;

/* Do nothing if there is no string */
	if (!s)
		return;

#ifdef TERMINFO
	if (cap->abuf) {
		unsigned char *a;

		outcap = cap;
		a = (unsigned char *)tgoto((char *)s, a1, a0);
		tputs((char *)a, l, outout);
		return;
	}
#endif

/* Copy args into array (yuk) */
	args[0] = a0;
	args[1] = a1;
	args[2] = a2;
	args[3] = a3;

/* Get tenths of MS of padding needed */
	while (*s >= '0' && *s <= '9')
		tenth = tenth * 10 + *s++ - '0';
	tenth *= 10;
	if (*s == '.') {
		++s;
		tenth += *s++ - '0';
	}

/* Check if we have to multiply by number of lines */
	if (*s == '*') {
		++s;
		tenth *= l;
	}

/* Output string */
	while ((c = *s++) != '\0')
		if (c == '%' && *s) {
			switch (x = a[0], c = escape1(&s)) {
			case 'C':
				if (x >= 96) {
					cap->out(cap->outptr, x / 96);
					x %= 96;
				}
			case '+':
				if (*s)
					x += escape1(&s);
			case '.':
				cap->out(cap->outptr, x);
				++a;
				break;
			case 'd':
				if (x < 10)
					goto one;
			case '2':
				if (x < 100)
					goto two;
			case '3':
				c = '0';
				while (x >= 100) {
					++c;
					x -= 100;
				}
				cap->out(cap->outptr, c);
			      two:c = '0';
				while (x >= 10) {
					++c;
					x -= 10;
				}
				cap->out(cap->outptr, c);
			      one:cap->out(cap->outptr, '0' + x);
				++a;
				break;
			case 'r':
				a[0] = a[1];
				a[1] = x;
				break;
			case 'i':
				++a[0];
				++a[1];
				break;
			case 'n':
				a[0] ^= 0140;
				a[1] ^= 0140;
				break;
			case 'm':
				a[0] ^= 0177;
				a[1] ^= 0177;
				break;
			case 'f':
				++a;
				break;
			case 'b':
				--a;
				break;
			case 'a':
				x = s[2];
				if (s[1] == 'p')
					x = a[x - 0100];
				switch (*s) {
				case '+':
					a[0] += x;
					break;
				case '-':
					a[0] -= x;
					break;
				case '*':
					a[0] *= x;
					break;
				case '/':
					a[0] /= x;
					break;
				case '%':
					a[0] %= x;
					break;
				case 'l':
					a[0] = vars[x];
					break;
				case 's':
					vars[x] = a[0];
					break;
				default:
					a[0] = x;
				}
				s += 3;
				break;
			case 'D':
				a[0] = a[0] - 2 * (a[0] & 15);
				break;
			case 'B':
				a[0] = 16 * (a[0] / 10) + a[0] % 10;
				break;
			case '>':
				if (a[0] > escape1(&s))
					a[0] += escape1(&s);
				else
					escape1(&s);
			default:
				cap->out(cap->outptr, '%');
				cap->out(cap->outptr, c);
			}
		} else {
			--s;
			cap->out(cap->outptr, escape1(&s));
		}

/* Output padding characters */
	if (cap->dopadding) {
		if (cap->pad)
			while (tenth >= cap->div)
				for (s = cap->pad; *s; ++s) {
					cap->out(cap->outptr, *s);
					tenth -= cap->div;
				}
		else
			while (tenth >= cap->div) {
				cap->out(cap->outptr, 0);
				tenth -= cap->div;
			}
	}
}

static int total;

static void cst(unsigned char *ptr, unsigned char c)
{
	++total;
}

int tcost(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3)
{
	void (*out) (unsigned char *, unsigned char) = cap->out;

	if (!s)
		return 10000;
	total = 0;
	cap->out = cst;
	texec(cap, s, l, a0, a1, a2, a3);
	cap->out = out;
	return total;
}

static unsigned char *ssp;
static void cpl(unsigned char *ptr, unsigned char c)
{
	ssp = vsadd(ssp, c);
}

unsigned char *tcompile(CAP *cap, unsigned char *s, int a0, int a1, int a2, int a3)
{
	void (*out) (unsigned char *, unsigned char) = cap->out;
	int div = cap->div;

	if (!s)
		return NULL;
	cap->out = cpl;
	cap->div = 10000;
	ssp = vsmk(10);
	texec(cap, s, 0, a0, a1, a2, a3);
	cap->out = out;
	cap->div = div;
	return ssp;
}

/* Old termcap compatibility (not to be used when TERMINFO is set) */
#ifdef junk
short ospeed;			/* Output speed */
unsigned char PC, *UP, *BC;		/* Unused */
static CAP *latest;		/* CAP entry to use */

static void stupid(ptr, c)
void (*ptr) ();
unsigned char c;
{
	ptr(c);
}

int tgetent(buf, name)
unsigned char *buf, *name;
{
	latest = getcap(name, 9600, stupid, NULL);
	if (latest)
		return 1;
	else
		return -1;
}

int tgetflag(name)
unsigned char *name;
{
	return getflag(latest, name);
}

int tgetnum(name)
unsigned char *name;
{
	return getnum(latest, name);
}

unsigned char *tgetstr(name)
unsigned char *name;
{
	return jgetstr(latest, name);
}

static int latestx, latesty;

unsigned char *tgoto(str, x, y)
unsigned char *str;
int x, y;
{
	latestx = x;
	latesty = y;
	return str;
}

void tputs(str, l, out)
unsigned char *str;
int l;
void (*out) ();
{
	latest->outptr = (void *) out;
	if (latest->baud != ospeed) {
		latest->baud = ospeed;
		latest->div = 100000 / ospeed;
	}
	texec(latest, str, l, latesty, latestx);
}
#endif
@


1.33
log
@portability fix
@
text
@d12 2
d17 1
d145 1
a145 1
CAP *my_getcap(unsigned char *name, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
d158 1
a199 1
	vsrm(namebuf);
d226 1
a226 1
	idxname = vsncpy(idxname, sLEN(idxname), sc(".idx"));
a242 1
	vsrm(idxname);
d246 1
a246 1
	if (sLEN(cap->tbuf) == ti)
d250 1
a250 1
	x = sLEN(cap->tbuf);
d262 1
a262 1
		sLen(cap->tbuf) = x + 1;
a344 3
	varm(npbuf);
	vsrm(name);

d433 1
a433 1
	vsrm(cap->tbuf);
d725 1
a725 1
	latest = my_getcap(name, 9600, stupid, NULL);
@


1.32
log
@UC -> USTR
@
text
@a20 4
#ifdef HAVE_TERMCAP_H
#include <termcap.h>
#endif

@


1.31
log
@more fixes
@
text
@d350 1
a350 1
	cap->pad = jgetstr(cap, UC "pc");
@


1.30
log
@change US to UC
@
text
@d146 1
a146 1
CAP *getcap(unsigned char *name, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
d730 1
a730 1
	latest = getcap(name, 9600, stupid, NULL);
@


1.29
log
@fix warnings
@
text
@d350 1
a350 1
	cap->pad = jgetstr(cap, US "pc");
@


1.28
log
@compiler warns
@
text
@d8 2
a11 3
/* JOE defines "US" which is a global variable in curses.h, so curses has to
   come before types.h */

a14 7

#endif

#include "types.h"

#ifdef TERMINFO

@


1.27
log
@gettext()
@
text
@a7 2
#include "types.h"

d10 2
a11 1
/* Fixes for itanium */
d17 6
d29 4
@


1.26
log
@change order of term.h and curses.h in termcap.c
@
text
@d219 1
a219 1
		fprintf(stderr, "Couldn't load termcap entry.  Using ansi default\n");
d240 1
a240 1
			fprintf(stderr, "%s is out of date\n", idxname);
@


1.25
log
@Massive check-in: rearrange header files, fix -Wall warnings.
@
text
@d14 5
a23 4
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif

@


1.24
log
@fixed for itenium
@
text
@a7 1
#include "config.h"
a9 14
#include <stdio.h>

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

d15 1
a24 6
#include "blocks.h"
#include "termcap.h"
#include "utils.h"
#include "va.h"
#include "vs.h"

d130 1
a130 1
				sscanf((char *)(buf + x), "%x", &z);
d405 7
a411 2
	if (cap->abuf)
		return (unsigned char *)tgetstr((char *)name, (char **)&cap->abufp);
d444 1
a444 1
static unsigned char escape(unsigned char **s)
d546 1
a546 1
			switch (x = a[0], c = escape(&s)) {
d554 1
a554 1
					x += escape(&s);
d641 2
a642 2
				if (a[0] > escape(&s))
					a[0] += escape(&s);
d644 1
a644 1
					escape(&s);
d651 1
a651 1
			cap->out(cap->outptr, escape(&s));
@


1.23
log
@fix gcc-4.0.0 warnings
@
text
@d12 1
d16 1
d20 1
d24 1
d26 3
d30 5
d36 1
@


1.22
log
@*** empty log message ***
@
text
@d139 1
a139 1
			} else if (!strcmp(buf + x, name))
d310 1
a310 1
			found = strcmp(qq, cap->sort[z].name);
d378 1
a378 1
		found = strcmp(name, cap->sort[z].name);
@


1.21
log
@Fix highlighter when there are utf-8 characters in file.

No longer depend on wctype.h (working towards not depending on
iconv()).
@
text
@a312 1
				break;
a314 1
				break;
d360 5
@


1.20
log
@	Added -notite global option: when set, prevents screen from
	being restored on exit.

	Added -usetabs global option: when set, uses tabs for cursor
	position update (which was the default before).  Now we don't
	use tabs by default.

        Completed change to 'unsigned char *' and elimination of
        MAXINT.  What a mess.  No warnings with gcc -pedantic.

	Fix UTF-8 bugs where cursor was not correct on scrolled screen.
@
text
@a22 1
#include <term.h>
@


1.19
log
@change 0 to NULL where we're talking about pointers
@
text
@d34 1
a34 1
char *joeterm = NULL;
d38 1
a38 1
char defentry[] = "\
d52 1
a52 1
static int match(char *s, char *name)
d71 1
a71 1
static char *lfind(char *s, int pos, FILE *fd, char *name)
d124 1
a124 1
static long findidx(FILE *file, char *name)
d126 1
a126 1
	char buf[80];
d129 1
a129 1
	while (fgets(buf, 80, file)) {
d138 1
a138 1
				sscanf(buf + x, "%x", &z);
d152 1
a152 1
CAP *getcap(char *name, unsigned int baud, void (*out) (char *, char), void *outptr)
d158 1
a158 1
	char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
d161 1
a161 1
	if (!name && !(name = joeterm) && !(name = getenv("TERM")))
d169 1
a169 1
	cap->abuf = (char *) joe_malloc(4096);
d171 1
a171 1
	if (tgetent(cap->tbuf, name) == 1)
d184 1
a184 1
	tp = getenv("TERMCAP");
d191 1
a191 1
		if ((tp = getenv("TERMPATH")))
d194 1
a194 1
			if ((tp = getenv("HOME"))) {
d234 1
a234 1
	f1 = fopen(npbuf[y], "r");
d238 1
a238 1
	f = fopen(idxname, "r");
d358 1
a358 1
	cap->pad = jgetstr(cap, "pc");
d366 1
a366 1
static struct sortentry *findcap(CAP *cap, char *name)
d387 1
a387 1
CAP *setcap(CAP *cap, unsigned int baud, void (*out) (char *, char), void *outptr)
d396 1
a396 1
int getflag(CAP *cap, char *name)
d400 1
a400 1
		return tgetflag(name);
d405 1
a405 1
char *jgetstr(CAP *cap, char *name)
d411 1
a411 1
		return tgetstr(name, &cap->abufp);
d420 1
a420 1
int getnum(CAP *cap, char *name)
d426 1
a426 1
		return tgetnum(name);
d430 1
a430 1
		return atoi(s->value);
d444 1
a444 1
static char escape(char **s)
d446 1
a446 1
	char c = *(*s)++;
d500 1
a500 1
void texec(CAP *cap, char *s, int l, int a0, int a1, int a2, int a3)
d513 1
a513 1
		char *a;
d516 2
a517 2
		a = tgoto(s, a1, a0);
		tputs(a, l, outout);
d672 1
a672 1
static void cst(char *ptr, char c)
d677 1
a677 1
int tcost(CAP *cap, char *s, int l, int a0, int a1, int a2, int a3)
d679 1
a679 1
	void (*out) (char *, char) = cap->out;
d690 2
a691 2
static char *ssp;
static void cpl(char *ptr, char c)
d696 1
a696 1
char *tcompile(CAP *cap, char *s, int a0, int a1, int a2, int a3)
d698 1
a698 1
	void (*out) (char *, char) = cap->out;
d715 1
a715 1
char PC, *UP, *BC;		/* Unused */
d720 1
a720 1
char c;
d726 1
a726 1
char *buf, *name;
d736 1
a736 1
char *name;
d742 1
a742 1
char *name;
d747 2
a748 2
char *tgetstr(name)
char *name;
d755 2
a756 2
char *tgoto(str, x, y)
char *str;
d765 1
a765 1
char *str;
@


1.18
log
@change "expr, expr" to "expr; expr" where appropriate (take 2)
@
text
@d34 1
a34 1
char *joeterm = 0;
d162 1
a162 1
		return 0;
d165 2
a166 2
	cap->abuf = 0;
	cap->sort = 0;
d175 1
a175 1
		cap->abuf = 0;
d198 1
a198 1
				namebuf = 0;
d325 1
a325 1
					cap->sort[z].value = 0;
d341 1
a341 1
			cap->sort[y].value = 0;
d384 1
a384 1
	return 0;
d417 1
a417 1
		return 0;
d702 1
a702 1
		return 0;
@


1.17
log
@kill some warnings when compiled with -Wall
@
text
@d770 4
a773 2
	if (latest->baud != ospeed)
		latest->baud = ospeed, latest->div = 100000 / ospeed;
@


1.16
log
@strcmp() can return values other than -1/0/+1
@
text
@d21 5
a34 5

#ifdef TERMINFO
extern char *tgoto(char *, int, int);
extern char *tgetstr(char *, char **);
#endif
@


1.15
log
@change "expr, expr" to "expr; expr" where appropriate
@
text
@d308 2
d311 2
a312 2
			switch (strcmp(qq, cap->sort[z].name)) {
			case 1:
d315 1
a315 1
			case -1:
d318 1
a318 1
			case 0:
@


1.14
log
@strcmp() can return values other than -1/0/+1
@
text
@d99 6
a104 3
		else if (c == '\r') ;
		else
			s = vsset(s, x, c), ++x;
d112 6
a117 3
		else if (c == '\r') ;
		else
			s = vsset(s, x, c), ++x;
d194 4
a197 3
			if ((tp = getenv("HOME")))
				namebuf = vsncpy(NULL, 0, sz(tp)), namebuf = vsadd(namebuf, '/');
			else
d449 4
a452 2
		else
			return (*s)++, 127;
d530 4
a533 2
	if (*s == '.')
		++s, tenth += *s++ - '0';
d536 4
a539 2
	if (*s == '*')
		++s, tenth *= l;
d546 4
a549 2
				if (x >= 96)
					cap->out(cap->outptr, x / 96), x %= 96;
d565 4
a568 2
				while (x >= 100)
					++c, x -= 100;
d571 4
a574 2
				while (x >= 10)
					++c, x -= 10;
d647 4
a650 2
		} else
			--s, cap->out(cap->outptr, escape(&s));
d656 4
a659 2
				for (s = cap->pad; *s; ++s)
					cap->out(cap->outptr, *s), tenth -= cap->div;
d661 4
a664 2
			while (tenth >= cap->div)
				cap->out(cap->outptr, 0), tenth -= cap->div;
@


1.13
log
@change (m|re|c)alloc() and free() into joe_(m|re|c)alloc() and joe_free()
(preparation for further error checking)
@
text
@d360 1
d367 2
a368 2
		switch (strcmp(name, cap->sort[z].name)) {
		case 1:
d370 1
a370 2
			break;
		case -1:
d372 1
a372 2
			break;
		case 0:
a373 1
		}
d393 1
a393 1
	return findcap(cap, name) != 0;
@


1.12
log
@change indentation of cases in the switch() statement
@
text
@d24 1
d157 1
a157 1
	cap = (CAP *) malloc(sizeof(CAP));
d163 1
a163 1
	cap->abuf = (char *) malloc(4096);
d168 1
a168 1
		free(cap->abuf);
d174 1
a174 1
	cap->sort = (struct sortentry *) malloc(sizeof(struct sortentry) * (sortsiz = 64));
d215 2
a216 2
 free(cap->sort);
 free(cap);
d325 1
a325 1
			cap->sort = (struct sortentry *) realloc(cap->sort, (sortsiz += 32) * sizeof(struct sortentry));
d431 1
a431 1
		free(cap->abuf);
d433 2
a434 2
		free(cap->sort);
	free(cap);
@


1.11
log
@change indentation of do {} while() cycles
@
text
@d302 1
a302 1
				case 1:
d305 1
a305 1
				case -1:
d308 1
a308 1
				case 0:
d366 1
a366 1
			case 1:
d369 1
a369 1
			case -1:
d372 1
a372 1
			case 0:
d447 8
a454 8
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
d461 2
a462 2
			case 'e':
			case 'E':
d464 2
a465 2
			case 'n':
			case 'l':
d467 1
a467 1
			case 'r':
d469 1
a469 1
			case 't':
d471 1
a471 1
			case 'b':
d473 1
a473 1
			case 'f':
d475 1
a475 1
			case 's':
d477 1
a477 1
			default:
d531 1
a531 1
		if (c == '%' && *s)
d533 1
a533 1
				case 'C':
d536 1
a536 1
				case '+':
d539 1
a539 1
				case '.':
d543 1
a543 1
				case 'd':
d546 1
a546 1
				case '2':
d549 1
a549 1
				case '3':
d561 1
a561 1
				case 'r':
d565 1
a565 1
				case 'i':
d569 1
a569 1
				case 'n':
d573 1
a573 1
				case 'm':
d577 1
a577 1
				case 'f':
d580 1
a580 1
				case 'b':
d583 1
a583 1
				case 'a':
d588 1
a588 1
					case '+':
d591 1
a591 1
					case '-':
d594 1
a594 1
					case '*':
d597 1
a597 1
					case '/':
d600 1
a600 1
					case '%':
d603 1
a603 1
					case 'l':
d606 1
a606 1
					case 's':
d609 1
a609 1
					default:
d614 1
a614 1
				case 'D':
d617 1
a617 1
				case 'B':
d620 1
a620 1
				case '>':
d625 1
a625 1
				default:
d628 1
@


1.10
log
@include only headers which are needed
@
text
@d64 1
a64 2
	}
	while (s[-1] == '|');
d78 1
a78 1
		do
d80 1
a80 1
		while (!(c == -1 || c == '\n'));
d136 1
a136 2
		}
		while (c && c != '\n');
d253 3
a255 3
		while (x && cap->tbuf[--x] != ':') ;
	}
	while (x && (!cap->tbuf[x + 1] || cap->tbuf[x + 1] == ':'));
@


1.9
log
@put struct definitions and other goodies into types.h
@
text
@d12 1
d14 2
d17 2
a18 1
#include <string.h>
d20 1
d23 2
a25 3
#include "va.h"
#include "queue.h"
#include "termcap.h"
@


1.8
log
@put correct prototype to the output routine in the CAP structure (and setcap()/getcap())
@
text
@d2 8
a9 5
	TERMCAP/TERMINFO database interface
	Copyright (C) 1992 Joseph H. Allen

	This file is part of JOE (Joe's Own Editor)
*/
a16 1
#include "config.h"
@


1.7
log
@use mfwrd() and mbkwd() only as internal functions to mmove()
@
text
@d141 1
a141 1
CAP *getcap(char *name, unsigned int baud, void (*out) (/* ??? */), void *outptr)
d375 1
a375 1
CAP *setcap(CAP *cap, unsigned int baud, void (*out) (/* ??? */), void *outptr)
d641 1
a641 1
static void cst(void)
d648 1
a648 1
	void (*out) () = cap->out;
d667 1
a667 1
	void (*out) () = cap->out;
@


1.6
log
@version 2.9.7-pre3
@
text
@d306 1
a306 1
					mfwrd(cap->sort + z, cap->sort + z + 1, (cap->sortlen-- - (z + 1)) * sizeof(struct sortentry));
d321 1
a321 1
		mbkwd(cap->sort + y + 1, cap->sort + y, (cap->sortlen++ - y) * sizeof(struct sortentry));
@


1.5
log
@take the CVS repository to version 2.9.7-pre2
@
text
@d25 2
a26 2
extern char *tgoto();
extern char *tgetstr();
d45 1
a45 2
static int match(s, name)
char *s, *name;
d65 1
a65 4
static char *lfind(s, pos, fd, name)
char *s, *name;
FILE *fd;
int pos;
d112 1
a112 3
static long findidx(file, name)
FILE *file;
char *name;
d141 1
a141 5
CAP *getcap(name, baud, out, outptr)
char *name;
unsigned baud;
void (*out) ();
void *outptr;
d352 1
a352 3
struct sortentry *findcap(cap, name)
CAP *cap;
char *name;
d375 1
a375 5
CAP *setcap(cap, baud, out, outptr)
CAP *cap;
unsigned baud;
void (*out) ();
void *outptr;
d384 1
a384 3
int getflag(cap, name)
CAP *cap;
char *name;
d393 1
a393 3
char *jgetstr(cap, name)
CAP *cap;
char *name;
d408 1
a408 3
int getnum(cap, name)
CAP *cap;
char *name;
d422 1
a422 2
void rmcap(cap)
CAP *cap;
d432 1
a432 2
static char escape(s)
char **s;
d480 1
a480 1
static int outout(c)
d486 1
a486 4
void texec(cap, s, l, a0, a1, a2, a3)
CAP *cap;
char *s;
int l, a0, a1, a2, a3;
d641 1
a641 1
static void cst()
d646 1
a646 4
int tcost(cap, s, l, a0, a1, a2, a3)
CAP *cap;
char *s;
int l, a0, a1, a2, a3;
d660 1
a660 3
static void cpl(ptr, c)
char *ptr;
char c;
d665 1
a665 4
char *tcompile(cap, s, a0, a1, a2, a3)
CAP *cap;
char *s;
int a0, a1, a2, a3;
@


1.4
log
@changed as of joe-2.9.6
@
text
@d25 2
a26 2
extern char *tgoto ();
extern char *tgetstr ();
d45 2
a46 3
static int
match (s, name)
     char *s, *name;
d50 10
a59 10
	do
	  {
		  int x;
		  for (x = 0; s[x] == name[x] && name[x] && s[x]; ++x);
		  if (name[x] == 0 && (s[x] == ':' || s[x] == '|'))
			  return 1;
		  while (s[x] != ':' && s[x] != '|' && s[x])
			  ++x;
		  s += x + 1;
	  }
d66 4
a69 5
static char *
lfind (s, pos, fd, name)
     char *s, *name;
     FILE *fd;
     int pos;
d72 1
d74 1
a74 1
		s = vsmk (1024);
d76 1
a76 1
	while (c = getc (fd), c == ' ' || c == '\t' || c == '#')
d78 1
a78 1
			c = getc (fd);
d81 21
a101 24
		return s = vstrunc (s, pos);
	ungetc (c, fd);
	s = vstrunc (s, x = pos);
	while (1)
	  {
		  c = getc (fd);
		  if (c == -1 || c == '\n')
			  if (x != pos && s[x - 1] == '\\')
			    {
				    --x;
				    if (!match (s + pos, name))
					    goto loop;
				    else
					    break;
			    }
			  else if (!match (s + pos, name))
				  goto loop;
			  else
				  return vstrunc (s, x);
		  else if (c == '\r');
		  else
			  s = vsset (s, x, c), ++x;
	  }
	while (c = getc (fd), c != -1)
d107 1
a107 1
		else if (c == '\r');
d109 2
a110 2
			s = vsset (s, x, c), ++x;
	s = vstrunc (s, x);
d116 3
a118 4
static long
findidx (file, name)
     FILE *file;
     char *name;
d122 20
a141 24
	while (fgets (buf, 80, file))
	  {
		  int x = 0, flg = 0, c, y, z;
		  do
		    {
			    for (y = x;
				 buf[y] && buf[y] != ' ' && buf[y] != '\n';
				 ++y);
			    c = buf[y];
			    buf[y] = 0;
			    if (c == '\n' || !c)
			      {
				      z = 0;
				      sscanf (buf + x, "%x", &z);
				      addr += z;
			      }
			    else if (!strcmp (buf + x, name))
				    flg = 1;
			    x = y + 1;
		    }
		  while (c && c != '\n');
		  if (flg)
			  return addr;
	  }
d147 5
a151 6
CAP *
getcap (name, baud, out, outptr)
     char *name;
     unsigned baud;
     void (*out) ();
     void *outptr;
d160 1
a160 1
	if (!name && !(name = joeterm) && !(name = getenv ("TERM")))
d162 2
a163 2
	cap = (CAP *) malloc (sizeof (CAP));
	cap->tbuf = vsmk (4096);
d168 1
a168 1
	cap->abuf = (char *) malloc (4096);
d170 6
a175 7
	if (tgetent (cap->tbuf, name) == 1)
		return setcap (cap, baud, out, outptr);
	else
	  {
		  free (cap->abuf);
		  cap->abuf = 0;
	  }
d178 3
a180 4
	name = vsncpy (NULL, 0, sz (name));
	cap->sort =
		(struct sortentry *) malloc (sizeof (struct sortentry) *
					     (sortsiz = 64));
d183 1
a183 1
	tp = getenv ("TERMCAP");
d186 16
a201 21
		namebuf = vsncpy (NULL, 0, sz (tp));
	else
	  {
		  if (tp)
			  cap->tbuf = vsncpy (sv (cap->tbuf), sz (tp));
		  if ((tp = getenv ("TERMPATH")))
			  namebuf = vsncpy (NULL, 0, sz (tp));
		  else
		    {
			    if ((tp = getenv ("HOME")))
				    namebuf = vsncpy (NULL, 0, sz (tp)),
					    namebuf = vsadd (namebuf, '/');
			    else
				    namebuf = 0;
			    namebuf = vsncpy (sv (namebuf), sc (".termcap "));
			    namebuf = vsncpy (sv (namebuf), sc (JOERC));
			    namebuf =
				    vsncpy (sv (namebuf),
					    sc ("termcap /etc/termcap"));
		    }
	  }
d203 2
a204 2
	npbuf = vawords (NULL, sv (namebuf), sc ("\t :"));
	vsrm (namebuf);
d209 1
a209 1
	if (match (cap->tbuf, name))
d212 1
a212 1
	cap->tbuf = vstrunc (cap->tbuf, 0);
d215 1
a215 2
	if (!npbuf[y])
	  {
d224 5
a228 6
		  fprintf (stderr,
			   "Couldn't load termcap entry.  Using ansi default\n");
		  ti = 0;
		  cap->tbuf = vsncpy (cap->tbuf, 0, sc (defentry));
		  goto checktc;
	  }
d230 3
a232 3
	idxname = vsncpy (NULL, 0, sz (npbuf[y]));
	idxname = vsncpy (idxname, sLEN (idxname), sc (".idx"));
	f1 = fopen (npbuf[y], "r");
d236 17
a252 17
	f = fopen (idxname, "r");
	if (f)
	  {
		  struct stat buf, buf1;
		  fstat (fileno (f), &buf);
		  fstat (fileno (f1), &buf1);
		  if (buf.st_mtime > buf1.st_mtime)
			  idx = findidx (f, name);
		  else
			  fprintf (stderr, "%s is out of date\n", idxname);
		  fclose (f);
	  }
	vsrm (idxname);
	fseek (f1, idx, 0);
	cap->tbuf = lfind (cap->tbuf, ti, f1, name);
	fclose (f1);
	if (sLEN (cap->tbuf) == ti)
d256 5
a260 6
	x = sLEN (cap->tbuf);
	do
	  {
		  cap->tbuf[x] = 0;
		  while (x && cap->tbuf[--x] != ':');
	  }
d263 10
a272 12
	if (cap->tbuf[x + 1] == 't' && cap->tbuf[x + 2] == 'c'
	    && cap->tbuf[x + 3] == '=')
	  {
		  name = vsncpy (NULL, 0, sz (cap->tbuf + x + 4));
		  cap->tbuf[x] = 0;
		  cap->tbuf[x + 1] = 0;
		  ti = x + 1;
		  sLen (cap->tbuf) = x + 1;
		  if (y)
			  --y;
		  goto nextfile;
	  }
d282 68
a349 84
	if (*pp)
	  {
		  int q;
		  *pp++ = 0;
		loop1:
		  if (pp[0] == ' ' || pp[0] == '\t')
			  goto loop;
		  for (q = 0;
		       pp[q] && pp[q] != '#' && pp[q] != '=' && pp[q] != '@@'
		       && pp[q] != ':'; ++q);
		  qq = pp;
		  c = pp[q];
		  pp[q] = 0;
		  if (c)
			  pp += q + 1;
		  else
			  pp += q;

		  x = 0;
		  y = cap->sortlen;
		  z = -1;
		  if (!y)
		    {
			    z = 0;
			    goto in;
		    }
		  while (z != (x + y) / 2)
		    {
			    z = (x + y) / 2;
			    switch (strcmp (qq, cap->sort[z].name))
			      {
			      case 1:
				      x = z;
				      break;
			      case -1:
				      y = z;
				      break;
			      case 0:
				      if (c == '@@')
					      mfwrd (cap->sort + z,
						     cap->sort + z + 1,
						     (cap->sortlen-- -
						      (z +
						       1)) *
						     sizeof (struct
							     sortentry));
				      else if (c && c != ':')
					      cap->sort[z].value = qq + q + 1;
				      else
					      cap->sort[z].value = 0;
				      if (c == ':')
					      goto loop1;
				      else
					      goto loop;
			      }
		    }
		in:
		  if (cap->sortlen == sortsiz)
			  cap->sort = (struct sortentry *) realloc (cap->sort,
								    (sortsiz
								     += 32) *
								    sizeof
								    (struct
								     sortentry));
		  mbkwd (cap->sort + y + 1, cap->sort + y,
			 (cap->sortlen++ - y) * sizeof (struct sortentry));
		  cap->sort[y].name = qq;
		  if (c && c != ':')
			  cap->sort[y].value = qq + q + 1;
		  else
			  cap->sort[y].value = 0;
		  if (c == ':')
			  goto loop1;
		  else
			  goto loop;
	  }

	if (ti)
	  {
		  for (--ti; ti; --ti)
			  if (!cap->tbuf[ti - 1])
				  break;
		  goto doline;
	  }
d351 2
a352 2
	varm (npbuf);
	vsrm (name);
d354 1
a354 1
	cap->pad = jgetstr (cap, "pc");
d359 1
a359 1
	return setcap (cap, baud, out, outptr);
d362 3
a364 4
struct sortentry *
findcap (cap, name)
     CAP *cap;
     char *name;
d367 1
d371 13
a383 15
	while (z != (x + y) / 2)
	  {
		  z = (x + y) / 2;
		  switch (strcmp (name, cap->sort[z].name))
		    {
		    case 1:
			    x = z;
			    break;
		    case -1:
			    y = z;
			    break;
		    case 0:
			    return cap->sort + z;
		    }
	  }
d387 5
a391 6
CAP *
setcap (cap, baud, out, outptr)
     CAP *cap;
     unsigned baud;
     void (*out) ();
     void *outptr;
d400 3
a402 4
int
getflag (cap, name)
     CAP *cap;
     char *name;
d406 1
a406 1
		return tgetflag (name);
d408 1
a408 1
	return findcap (cap, name) != 0;
d411 3
a413 4
char *
jgetstr (cap, name)
     CAP *cap;
     char *name;
d416 1
d419 1
a419 1
		return tgetstr (name, &cap->abufp);
d421 1
a421 1
	s = findcap (cap, name);
d428 3
a430 4
int
getnum (cap, name)
     CAP *cap;
     char *name;
d433 1
d436 1
a436 1
		return tgetnum (name);
d438 1
a438 1
	s = findcap (cap, name);
d440 1
a440 1
		return atoi (s->value);
d444 2
a445 3
void
rmcap (cap)
     CAP *cap;
d447 1
a447 1
	vsrm (cap->tbuf);
d449 1
a449 1
		free (cap->abuf);
d451 2
a452 2
		free (cap->sort);
	free (cap);
d455 2
a456 3
static char
escape (s)
     char **s;
d459 1
d466 34
a499 36
		switch (c = *((*s)++))
		  {
		  case '0':
		  case '1':
		  case '2':
		  case '3':
		  case '4':
		  case '5':
		  case '6':
		  case '7':
			  c -= '0';
			  if (**s >= '0' && **s <= '7')
				  c = (c << 3) + *((*s)++) - '0';
			  if (**s >= '0' && **s <= '7')
				  c = (c << 3) + *((*s)++) - '0';
			  return c;
		  case 'e':
		  case 'E':
			  return 27;
		  case 'n':
		  case 'l':
			  return 10;
		  case 'r':
			  return 13;
		  case 't':
			  return 9;
		  case 'b':
			  return 8;
		  case 'f':
			  return 12;
		  case 's':
			  return 32;
		  default:
			  return c;
		  }
	else
d504 1
a504 2
static int
outout (c)
d506 2
a507 1
	outcap->out (outcap->outptr, c);
d510 4
a513 5
void
texec (cap, s, l, a0, a1, a2, a3)
     CAP *cap;
     char *s;
     int l, a0, a1, a2, a3;
d525 8
a532 8
	if (cap->abuf)
	  {
		  char *a;
		  outcap = cap;
		  a = tgoto (s, a1, a0);
		  tputs (a, l, outout);
		  return;
	  }
d553 1
a553 1
	while (c = *s++)
d555 98
a652 103
			switch (x = a[0], c = escape (&s))
			  {
			  case 'C':
				  if (x >= 96)
					  cap->out (cap->outptr, x / 96), x %=
						  96;
			  case '+':
				  if (*s)
					  x += escape (&s);
			  case '.':
				  cap->out (cap->outptr, x);
				  ++a;
				  break;
			  case 'd':
				  if (x < 10)
					  goto one;
			  case '2':
				  if (x < 100)
					  goto two;
			  case '3':
				  c = '0';
				  while (x >= 100)
					  ++c, x -= 100;
				  cap->out (cap->outptr, c);
				two:c =
					  '0'; while (x >= 10)
					  ++c, x -= 10;
				  cap->out (cap->outptr, c);
				one:cap->
					  out (cap->outptr, '0' + x);
				  ++a;
				  break;
			  case 'r':
				  a[0] = a[1];
				  a[1] = x;
				  break;
			  case 'i':
				  ++a[0];
				  ++a[1];
				  break;
			  case 'n':
				  a[0] ^= 0140;
				  a[1] ^= 0140;
				  break;
			  case 'm':
				  a[0] ^= 0177;
				  a[1] ^= 0177;
				  break;
			  case 'f':
				  ++a;
				  break;
			  case 'b':
				  --a;
				  break;
			  case 'a':
				  x = s[2];
				  if (s[1] == 'p')
					  x = a[x - 0100];
				  switch (*s)
				    {
				    case '+':
					    a[0] += x;
					    break;
				    case '-':
					    a[0] -= x;
					    break;
				    case '*':
					    a[0] *= x;
					    break;
				    case '/':
					    a[0] /= x;
					    break;
				    case '%':
					    a[0] %= x;
					    break;
				    case 'l':
					    a[0] = vars[x];
					    break;
				    case 's':
					    vars[x] = a[0];
					    break;
				    default:
					    a[0] = x;
				    }
				  s += 3;
				  break;
			  case 'D':
				  a[0] = a[0] - 2 * (a[0] & 15);
				  break;
			  case 'B':
				  a[0] = 16 * (a[0] / 10) + a[0] % 10;
				  break;
			  case '>':
				  if (a[0] > escape (&s))
					  a[0] += escape (&s);
				  else
					  escape (&s);
			  default:
				  cap->out (cap->outptr, '%');
				  cap->out (cap->outptr, c);
			  }
		else
			--s, cap->out (cap->outptr, escape (&s));
d655 1
a655 1
	if (cap->dopadding)
d659 1
a659 2
					cap->out (cap->outptr, *s), tenth -=
						cap->div;
d662 2
a663 1
				cap->out (cap->outptr, 0), tenth -= cap->div;
d668 1
a668 2
static void
cst ()
d673 4
a676 5
int
tcost (cap, s, l, a0, a1, a2, a3)
     CAP *cap;
     char *s;
     int l, a0, a1, a2, a3;
d679 1
d684 1
a684 1
	texec (cap, s, l, a0, a1, a2, a3);
d690 5
a694 6
static void
cpl (ptr, c)
     char *ptr;
     char c;
{
	ssp = vsadd (ssp, c);
d697 4
a700 5
char *
tcompile (cap, s, a0, a1, a2, a3)
     CAP *cap;
     char *s;
     int a0, a1, a2, a3;
d704 1
d709 2
a710 2
	ssp = vsmk (10);
	texec (cap, s, 0, a0, a1, a2, a3);
d722 3
a724 4
static void
stupid (ptr, c)
     void (*ptr) ();
     char c;
d726 1
a726 1
	ptr (c);
d729 2
a730 3
int
tgetent (buf, name)
     char *buf, *name;
d732 1
a732 1
	latest = getcap (name, 9600, stupid, NULL);
d739 2
a740 3
int
tgetflag (name)
     char *name;
d742 1
a742 1
	return getflag (latest, name);
d745 2
a746 3
int
tgetnum (name)
     char *name;
d748 1
a748 1
	return getnum (latest, name);
d751 2
a752 3
char *
tgetstr (name)
     char *name;
d754 1
a754 1
	return jgetstr (latest, name);
d759 3
a761 4
char *
tgoto (str, x, y)
     char *str;
     int x, y;
d768 4
a771 5
void
tputs (str, l, out)
     char *str;
     int l;
     void (*out) ();
d776 1
a776 1
	texec (latest, str, l, latesty, latestx);
@


1.3
log
@changed as of joe-2.9.5
@
text
@d1 3
a3 2
/* TERMCAP/TERMINFO database interface
   Copyright (C) 1992 Joseph H. Allen
d5 2
a6 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d12 2
d21 2
a22 2
int dopadding=0;
char *joeterm=0;
d25 2
a26 2
extern char *tgoto();
extern char *tgetstr();
d31 1
a31 2
char defentry[]=
"\
d45 18
a62 14
static int match(s,name)
char *s, *name;
{
if(s[0]==0 || s[0]=='#') return 0;
do
 {
 int x;
 for(x=0;s[x]==name[x] && name[x] && s[x];++x);
 if(name[x]==0 && (s[x]==':' || s[x]=='|')) return 1;
 while(s[x]!=':' && s[x]!='|' && s[x]) ++x;
 s+=x+1;
 }
 while(s[-1]=='|');
return 0;
d67 49
a115 37
static char *lfind(s,pos,fd,name)
char *s, *name;
FILE *fd;
int pos;
{
int c,x;
if(!s) s=vsmk(1024);
loop:
while(c=getc(fd), c==' ' || c=='\t' || c=='#')
 do c=getc(fd); while(!(c== -1 || c=='\n'));
if(c== -1) return s=vstrunc(s,pos);
ungetc(c,fd);
s=vstrunc(s,x=pos);
while(1)
 {
 c=getc(fd);
 if(c== -1 || c=='\n')
  if(x!=pos && s[x-1]=='\\')
   {
   --x;
   if(!match(s+pos,name)) goto loop;
   else break;
   }
  else
   if(!match(s+pos,name)) goto loop;
   else return vstrunc(s,x);
 else if(c=='\r') ;
 else s=vsset(s,x,c), ++x;
 }
while(c=getc(fd), c!= -1)
 if(c=='\n')
  if(s[x-1]=='\\') --x;
  else break;
 else if(c=='\r') ;
 else s=vsset(s,x,c), ++x;
s=vstrunc(s,x);
return s;
d120 32
a151 25
static long findidx(file,name)
FILE *file;
char *name;
{
char buf[80];
long addr=0;
while(fgets(buf,80,file))
 {
 int x=0, flg=0, c, y, z;
 do
  {
  for(y=x;buf[y] && buf[y]!=' ' && buf[y]!='\n';++y);
  c=buf[y]; buf[y]=0;
  if(c=='\n' || !c)
   {
   z=0; sscanf(buf+x,"%x",&z);
   addr+=z;
   }
  else if(!strcmp(buf+x,name)) flg=1;
  x=y+1;
  }
  while(c && c!='\n');
 if(flg) return addr;
 }
return 0;
d156 20
a175 18
CAP *getcap(name,baud,out,outptr)
char *name;
unsigned baud;
void (*out)();
void *outptr;
{
CAP *cap;
FILE *f, *f1;
long idx;
int x,y,c,z,ti;
char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
int sortsiz;

if(!name && !(name=joeterm) && !(name=getenv("TERM"))) return 0;
cap=(CAP *)malloc(sizeof(CAP));
cap->tbuf=vsmk(4096);
cap->abuf=0;
cap->sort=0;
d178 9
a186 9
cap->abuf=(char *)malloc(4096);
cap->abufp=cap->abuf;
if(tgetent(cap->tbuf,name)==1)
 return setcap(cap,baud,out,outptr);
else
 {
 free(cap->abuf);
 cap->abuf=0;
 }
d189 45
a233 36
name=vsncpy(NULL,0,sz(name));
cap->sort=(struct sortentry *)malloc(sizeof(struct sortentry)*(sortsiz=64));
cap->sortlen=0;

tp=getenv("TERMCAP");

if(tp && tp[0]=='/') namebuf=vsncpy(NULL,0,sz(tp));
else
 {
 if(tp) cap->tbuf=vsncpy(sv(cap->tbuf),sz(tp));
 if((tp=getenv("TERMPATH"))) namebuf=vsncpy(NULL,0,sz(tp));
 else
  {
  if((tp=getenv("HOME")))
   namebuf=vsncpy(NULL,0,sz(tp)),
   namebuf=vsadd(namebuf,'/');
  else
   namebuf=0;
  namebuf=vsncpy(sv(namebuf),sc(".termcap "));
  namebuf=vsncpy(sv(namebuf),sc(JOERC));
  namebuf=vsncpy(sv(namebuf),sc("termcap /etc/termcap"));
  }
 }

npbuf=vawords(NULL,sv(namebuf),sc("\t :"));
vsrm(namebuf);

y=0; ti=0;

if(match(cap->tbuf,name)) goto checktc;

cap->tbuf=vstrunc(cap->tbuf,0);

nextfile:
if(!npbuf[y])
 {
d242 53
a294 46
 fprintf(stderr,"Couldn't load termcap entry.  Using ansi default\n");
 ti=0;
 cap->tbuf=vsncpy(cap->tbuf,0,sc(defentry));
 goto checktc;
 }
idx=0;
idxname=vsncpy(NULL,0,sz(npbuf[y]));
idxname=vsncpy(idxname,sLEN(idxname),sc(".idx"));
f1=fopen(npbuf[y],"r");
++y;
if(!f1) goto nextfile;
f=fopen(idxname,"r");
if(f)
 {
 struct stat buf, buf1;
 fstat(fileno(f),&buf);
 fstat(fileno(f1),&buf1);
 if(buf.st_mtime>buf1.st_mtime) idx=findidx(f,name);
 else fprintf(stderr,"%s is out of date\n",idxname);
 fclose(f);
 }
vsrm(idxname);
fseek(f1,idx,0);
cap->tbuf=lfind(cap->tbuf,ti,f1,name);
fclose(f1);
if(sLEN(cap->tbuf)==ti) goto nextfile;

checktc:
x=sLEN(cap->tbuf);
do
 {
 cap->tbuf[x]=0;
 while(x && cap->tbuf[--x]!=':');
 }
 while(x && (!cap->tbuf[x+1] || cap->tbuf[x+1]==':'));

if(cap->tbuf[x+1]=='t' && cap->tbuf[x+2]=='c' && cap->tbuf[x+3]=='=')
 {
 name=vsncpy(NULL,0,sz(cap->tbuf+x+4));
 cap->tbuf[x]=0;
 cap->tbuf[x+1]=0;
 ti=x+1;
 sLen(cap->tbuf)=x+1;
 if(y) --y;
 goto nextfile;
 }
d296 2
a297 2
doline:
pp=cap->tbuf+ti;
d301 144
a444 97
loop:
while(*pp && *pp!=':') ++pp;
if(*pp)
 {
 int q;
 *pp++=0;
 loop1:
 if(pp[0]==' ' || pp[0]=='\t') goto loop;
 for(q=0;pp[q] && pp[q]!='#' && pp[q]!='=' && pp[q]!='@@' && pp[q]!=':';++q);
 qq=pp;
 c=pp[q]; pp[q]=0;
 if(c) pp+=q+1;
 else pp+=q;

 x=0; y=cap->sortlen; z= -1;
 if(!y) { z=0; goto in; }
 while(z!=(x+y)/2)
  {
  z=(x+y)/2;
  switch(strcmp(qq,cap->sort[z].name))
   {
  case  1: x=z; break;
  case -1: y=z; break;
  case  0:
   if(c=='@@')
    mfwrd(cap->sort+z,cap->sort+z+1,
          (cap->sortlen---(z+1))*sizeof(struct sortentry));
   else
    if(c && c!=':') cap->sort[z].value=qq+q+1;
    else cap->sort[z].value=0;
   if(c==':') goto loop1;
   else goto loop;
   }
  }
 in:
 if(cap->sortlen==sortsiz)
  cap->sort=(struct sortentry *)realloc(cap->sort,
                                        (sortsiz+=32)*sizeof(struct sortentry));
 mbkwd(cap->sort+y+1,cap->sort+y,
       (cap->sortlen++-y)*sizeof(struct sortentry));
 cap->sort[y].name=qq;
 if(c && c!=':') cap->sort[y].value=qq+q+1;
 else cap->sort[y].value=0;
 if(c==':') goto loop1;
 else goto loop;
 }

if(ti)
 {
 for(--ti;ti;--ti) if(!cap->tbuf[ti-1]) break;
 goto doline;
 }

varm(npbuf);
vsrm(name);

cap->pad=jgetstr(cap,"pc");
if(dopadding) cap->dopadding=1;
else cap->dopadding=0;
return setcap(cap,baud,out,outptr);
}

struct sortentry *findcap(cap,name)
CAP *cap;
char *name;
{
int x,y,z;
x=0; y=cap->sortlen; z= -1;
while(z!=(x+y)/2)
 {
 z=(x+y)/2;
 switch(strcmp(name,cap->sort[z].name))
  {
 case  1: x=z; break;
 case -1: y=z; break;
 case  0: return cap->sort+z;
  }
 }
return 0;
}

CAP *setcap(cap,baud,out,outptr)
CAP *cap;
unsigned baud;
void (*out)();
void *outptr;
{
cap->baud=baud;
cap->div=100000/baud;
cap->out=out;
cap->outptr=outptr;
return cap;
}

int getflag(cap,name)
CAP *cap;
char *name;
d447 2
a448 1
if(cap->abuf) return tgetflag(name);
d450 1
a450 1
return findcap(cap,name)!=0;
d453 4
a456 3
char *jgetstr(cap,name)
CAP *cap;
char *name;
d458 1
a458 1
struct sortentry *s;
d460 2
a461 1
if(cap->abuf) return tgetstr(name,&cap->abufp);
d463 5
a467 3
s=findcap(cap,name);
if(s) return s->value;
else return 0;
d470 4
a473 3
int getnum(cap,name)
CAP *cap;
char *name;
d475 1
a475 1
struct sortentry *s;
d477 2
a478 1
if(cap->abuf) return tgetnum(name);
d480 66
a545 41
s=findcap(cap,name);
if(s && s->value) return atoi(s->value);
return -1;
}

void rmcap(cap)
CAP *cap;
{
vsrm(cap->tbuf);
if(cap->abuf) free(cap->abuf);
if(cap->sort) free(cap->sort);
free(cap);
}

static char escape(s)
char **s;
{
char c= *(*s)++;
if(c=='^' && **s)
 if(**s!='?') return 037&*(*s)++;
 else return (*s)++, 127;
else if(c=='\\' && **s)
 switch(c= *((*s)++))
  {
 case '0': case '1': case '2': case'3': case '4': case '5': case '6': case '7':
           c-='0';
           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
           return c;
 case 'e':
 case 'E': return 27;
 case 'n':
 case 'l': return 10;
 case 'r': return 13;
 case 't': return 9;
 case 'b': return 8;
 case 'f': return 12;
 case 's': return 32;
 default: return c;
  }
else return c;
d549 16
a564 14
static int outout(c)
 {
 outcap->out(outcap->outptr,c);
 }

void texec(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
int c, tenth=0, x;
int args[4];
int vars[128];
int *a=args;
d567 2
a568 1
if(!s) return;
d571 8
a578 8
if(cap->abuf)
 {
 char *a;
 outcap=cap;
 a=tgoto(s,a1,a0);
 tputs(a,l,outout);
 return;
 }
d582 4
a585 1
args[0]=a0; args[1]=a1; args[2]=a2; args[3]=a3;
d588 5
a592 3
while(*s>='0' && *s<='9') tenth=tenth*10+*s++-'0';
tenth*=10;
if(*s=='.') ++s, tenth+= *s++-'0';
d595 2
a596 1
if(*s=='*') ++s, tenth*=l;
d599 105
a703 39
while(c= *s++)
 if(c=='%' && *s)
  switch(x=a[0], c= escape(&s))
   {
  case 'C': if(x>=96) cap->out(cap->outptr,x/96), x%=96;
  case '+': if(*s) x+= escape(&s);
  case '.': cap->out(cap->outptr,x); ++a; break;
  case 'd': if(x<10) goto one;
  case '2': if(x<100) goto two;
  case '3': c='0'; while(x>=100) ++c, x-=100; cap->out(cap->outptr,c);
       two: c='0'; while(x>=10) ++c, x-=10; cap->out(cap->outptr,c);
       one: cap->out(cap->outptr,'0'+x); ++a; break;
  case 'r': a[0]=a[1]; a[1]=x; break;
  case 'i': ++a[0]; ++a[1]; break;
  case 'n': a[0]^=0140; a[1]^=0140; break;
  case 'm': a[0]^=0177; a[1]^=0177; break;
  case 'f': ++a; break;
  case 'b': --a; break;
  case 'a': x=s[2];
            if(s[1]=='p') x=a[x-0100];
            switch(*s)
             {
             case '+': a[0]+=x; break;
             case '-': a[0]-=x; break;
             case '*': a[0]*=x; break;
             case '/': a[0]/=x; break;
             case '%': a[0]%=x; break;
             case 'l': a[0]=vars[x]; break;
             case 's': vars[x]=a[0]; break;
             default:  a[0]=x;
             }
            s+=3;
            break;
  case 'D': a[0]=a[0]-2*(a[0]&15); break;
  case 'B': a[0]=16*(a[0]/10)+a[0]%10; break;
  case '>': if(a[0]>escape(&s)) a[0]+=escape(&s); else escape(&s);
   default: cap->out(cap->outptr,'%'); cap->out(cap->outptr,c);
   }
 else --s, cap->out(cap->outptr,escape(&s));
d706 9
a714 6
if(cap->dopadding)
 if(cap->pad)
  while(tenth>=cap->div)
   for(s=cap->pad;*s;++s) cap->out(cap->outptr,*s), tenth-=cap->div;
 else
  while(tenth>=cap->div) cap->out(cap->outptr,0), tenth-=cap->div;
d719 2
a720 1
static void cst()
d722 1
a722 1
++total;
d725 14
a738 12
int tcost(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
void (*out)()=cap->out;
if(!s) return 10000;
total=0;
cap->out=cst;
texec(cap,s,l,a0,a1,a2,a3);
cap->out=out;
return total;
d742 25
a766 20
static void cpl(ptr,c)
char *ptr;
char c;
{
ssp=vsadd(ssp,c);
}

char *tcompile(cap,s,a0,a1,a2,a3)
CAP *cap;
char *s;
int a0,a1,a2,a3;
{
void (*out)()=cap->out;
int div=cap->div;
if(!s) return 0;
cap->out=cpl; cap->div=10000;
ssp=vsmk(10);
texec(cap,s,0,a0,a1,a2,a3);
cap->out=out; cap->div=div;
return ssp;
d771 1
a771 1
short ospeed;		/* Output speed */
d773 1
a773 1
static CAP *latest;	/* CAP entry to use */
d775 4
a778 3
static void stupid(ptr,c)
void (*ptr)();
char c;
d780 1
a780 1
ptr(c);
d783 3
a785 2
int tgetent(buf,name)
char *buf, *name;
d787 5
a791 3
latest=getcap(name,9600,stupid,NULL);
if(latest) return 1;
else return -1;
d794 3
a796 2
int tgetflag(name)
char *name;
d798 1
a798 1
return getflag(latest,name);
d801 3
a803 2
int tgetnum(name)
char *name;
d805 1
a805 1
return getnum(latest,name);
d808 3
a810 2
char *tgetstr(name)
char *name;
d812 1
a812 1
return jgetstr(latest,name);
d817 20
a836 16
char *tgoto(str,x,y)
char *str;
int x,y;
{
latestx=x; latesty=y;
return str;
}

void tputs(str,l,out)
char *str;
int l;
void (*out)();
{
latest->outptr=(void *)out;
if(latest->baud!=ospeed) latest->baud=ospeed, latest->div=100000/ospeed;
texec(latest,str,l,latesty,latestx);
@


1.2
log
@changed as of joe-2.9.2
@
text
@a26 1
#include "zstr.h"
@


1.1
log
@Initial revision
@
text
@d22 1
d133 1
a133 1
  else if(!zcmp(buf+x,name)) flg=1;
d290 1
a290 1
  switch(zcmp(qq,cap->sort[z].name))
d342 1
a342 1
 switch(zcmp(name,cap->sort[z].name))
@


1.1.1.1
log
@First import of joe sources to cvs (as of joe-2.9)
@
text
@@
